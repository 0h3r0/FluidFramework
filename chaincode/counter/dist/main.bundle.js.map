{"version":3,"sources":["webpack://chaincode/counter/webpack/universalModuleDefinition","webpack://chaincode/counter/webpack/bootstrap","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/mergeTree.js","webpack://chaincode/counter/./node_modules/@prague/container-definitions/dist/index.js","webpack://chaincode/counter/./node_modules/assert/assert.js","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/ops.js","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/properties.js","webpack://chaincode/counter/./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/index.js","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/collections.js","webpack://chaincode/counter/./node_modules/events/events.js","webpack://chaincode/counter/./node_modules/uuid/v4.js","webpack://chaincode/counter/./node_modules/lodash/_root.js","webpack://chaincode/counter/./node_modules/buffer/index.js","webpack://chaincode/counter/./node_modules/debug/src/browser.js","webpack://chaincode/counter/./node_modules/lodash/_getNative.js","webpack://chaincode/counter/./node_modules/@prague/sequence/lib/sequence.js","webpack://chaincode/counter/./node_modules/lodash/isObject.js","webpack://chaincode/counter/./node_modules/lodash/isObjectLike.js","webpack://chaincode/counter/./node_modules/@prague/map/lib/map.js","webpack://chaincode/counter/(webpack)/buildin/global.js","webpack://chaincode/counter/./node_modules/lodash/_ListCache.js","webpack://chaincode/counter/./node_modules/lodash/_assocIndexOf.js","webpack://chaincode/counter/./node_modules/lodash/_baseGetTag.js","webpack://chaincode/counter/./node_modules/lodash/_nativeCreate.js","webpack://chaincode/counter/./node_modules/lodash/_getMapData.js","webpack://chaincode/counter/./node_modules/lodash/_copyObject.js","webpack://chaincode/counter/./node_modules/sha.js/sha1.js","webpack://chaincode/counter/./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/index.js","webpack://chaincode/counter/./node_modules/@prague/sequence/lib/sharedString.js","webpack://chaincode/counter/./node_modules/@prague/sequence/lib/extension.js","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/snapshot.js","webpack://chaincode/counter/./node_modules/process/browser.js","webpack://chaincode/counter/./node_modules/lodash/cloneDeep.js","webpack://chaincode/counter/./node_modules/lodash/_Map.js","webpack://chaincode/counter/./node_modules/lodash/_Symbol.js","webpack://chaincode/counter/./node_modules/lodash/keys.js","webpack://chaincode/counter/./node_modules/lodash/isArray.js","webpack://chaincode/counter/(webpack)/buildin/module.js","webpack://chaincode/counter/./node_modules/lodash/_baseUnary.js","webpack://chaincode/counter/./node_modules/lodash/_nodeUtil.js","webpack://chaincode/counter/./node_modules/lodash/_isPrototype.js","webpack://chaincode/counter/./node_modules/lodash/_getSymbols.js","webpack://chaincode/counter/./node_modules/lodash/_getTag.js","webpack://chaincode/counter/./node_modules/lodash/_cloneArrayBuffer.js","webpack://chaincode/counter/./node_modules/@prague/map/lib/extension.js","webpack://chaincode/counter/./node_modules/@prague/map/lib/debug.js","webpack://chaincode/counter/./node_modules/@prague/stream/lib/stream.js","webpack://chaincode/counter/./node_modules/@prague/cell/lib/cell.js","webpack://chaincode/counter/./node_modules/inherits/inherits_browser.js","webpack://chaincode/counter/./node_modules/double-ended-queue/js/deque.js","webpack://chaincode/counter/./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/valueType.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/blobs.js","webpack://chaincode/counter/./node_modules/safe-buffer/index.js","webpack://chaincode/counter/./node_modules/lodash/eq.js","webpack://chaincode/counter/./node_modules/lodash/isFunction.js","webpack://chaincode/counter/./node_modules/lodash/_freeGlobal.js","webpack://chaincode/counter/./node_modules/lodash/_toSource.js","webpack://chaincode/counter/./node_modules/lodash/_assignValue.js","webpack://chaincode/counter/./node_modules/lodash/_baseAssignValue.js","webpack://chaincode/counter/./node_modules/lodash/_arrayLikeKeys.js","webpack://chaincode/counter/./node_modules/lodash/isBuffer.js","webpack://chaincode/counter/./node_modules/lodash/isLength.js","webpack://chaincode/counter/./node_modules/lodash/_overArg.js","webpack://chaincode/counter/./node_modules/lodash/isArrayLike.js","webpack://chaincode/counter/./node_modules/lodash/keysIn.js","webpack://chaincode/counter/./node_modules/lodash/stubArray.js","webpack://chaincode/counter/./node_modules/lodash/_getSymbolsIn.js","webpack://chaincode/counter/./node_modules/lodash/_arrayPush.js","webpack://chaincode/counter/./node_modules/lodash/_getPrototype.js","webpack://chaincode/counter/./node_modules/lodash/_baseGetAllKeys.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/debug.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/blobs.js","webpack://chaincode/counter/./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/valueType.js","webpack://chaincode/counter/./node_modules/@prague/map/lib/view.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/index.js","webpack://chaincode/counter/./node_modules/@prague/component/dist/index.js","webpack://chaincode/counter/./node_modules/@prague/sequence/lib/intervalCollection.js","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/segmentGroupCollection.js","webpack://chaincode/counter/./node_modules/@prague/sequence/lib/sequenceDeltaEvent.js","webpack://chaincode/counter/./node_modules/@prague/stream/lib/extension.js","webpack://chaincode/counter/./node_modules/@prague/cell/lib/extension.js","webpack://chaincode/counter/./node_modules/@prague/cell/lib/debug.js","webpack://chaincode/counter/./node_modules/@prague/stream/lib/interfaces.js","webpack://chaincode/counter/./node_modules/@prague/stream/lib/snapshot.js","webpack://chaincode/counter/./node_modules/uuid/lib/rng-browser.js","webpack://chaincode/counter/./node_modules/uuid/lib/bytesToUuid.js","webpack://chaincode/counter/./node_modules/debug/src/common.js","webpack://chaincode/counter/./node_modules/ms/index.js","webpack://chaincode/counter/./node_modules/base64-js/index.js","webpack://chaincode/counter/./node_modules/ieee754/index.js","webpack://chaincode/counter/./node_modules/buffer/node_modules/isarray/index.js","webpack://chaincode/counter/./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/sharedObject.js","webpack://chaincode/counter/./node_modules/@prague/container-definitions/dist/blobs.js","webpack://chaincode/counter/./node_modules/@prague/container-definitions/dist/chaincode.js","webpack://chaincode/counter/./node_modules/@prague/container-definitions/dist/clients.js","webpack://chaincode/counter/./node_modules/@prague/container-definitions/dist/protocol.js","webpack://chaincode/counter/./node_modules/@prague/container-definitions/dist/storage.js","webpack://chaincode/counter/./node_modules/util/util.js","webpack://chaincode/counter/./node_modules/util/support/isBufferBrowser.js","webpack://chaincode/counter/./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/debug.js","webpack://chaincode/counter/./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/extension.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/runtime.js","webpack://chaincode/counter/./node_modules/sha.js/hash.js","webpack://chaincode/counter/./node_modules/lodash/_baseClone.js","webpack://chaincode/counter/./node_modules/lodash/_Stack.js","webpack://chaincode/counter/./node_modules/lodash/_listCacheClear.js","webpack://chaincode/counter/./node_modules/lodash/_listCacheDelete.js","webpack://chaincode/counter/./node_modules/lodash/_listCacheGet.js","webpack://chaincode/counter/./node_modules/lodash/_listCacheHas.js","webpack://chaincode/counter/./node_modules/lodash/_listCacheSet.js","webpack://chaincode/counter/./node_modules/lodash/_stackClear.js","webpack://chaincode/counter/./node_modules/lodash/_stackDelete.js","webpack://chaincode/counter/./node_modules/lodash/_stackGet.js","webpack://chaincode/counter/./node_modules/lodash/_stackHas.js","webpack://chaincode/counter/./node_modules/lodash/_stackSet.js","webpack://chaincode/counter/./node_modules/lodash/_baseIsNative.js","webpack://chaincode/counter/./node_modules/lodash/_getRawTag.js","webpack://chaincode/counter/./node_modules/lodash/_objectToString.js","webpack://chaincode/counter/./node_modules/lodash/_isMasked.js","webpack://chaincode/counter/./node_modules/lodash/_coreJsData.js","webpack://chaincode/counter/./node_modules/lodash/_getValue.js","webpack://chaincode/counter/./node_modules/lodash/_MapCache.js","webpack://chaincode/counter/./node_modules/lodash/_mapCacheClear.js","webpack://chaincode/counter/./node_modules/lodash/_Hash.js","webpack://chaincode/counter/./node_modules/lodash/_hashClear.js","webpack://chaincode/counter/./node_modules/lodash/_hashDelete.js","webpack://chaincode/counter/./node_modules/lodash/_hashGet.js","webpack://chaincode/counter/./node_modules/lodash/_hashHas.js","webpack://chaincode/counter/./node_modules/lodash/_hashSet.js","webpack://chaincode/counter/./node_modules/lodash/_mapCacheDelete.js","webpack://chaincode/counter/./node_modules/lodash/_isKeyable.js","webpack://chaincode/counter/./node_modules/lodash/_mapCacheGet.js","webpack://chaincode/counter/./node_modules/lodash/_mapCacheHas.js","webpack://chaincode/counter/./node_modules/lodash/_mapCacheSet.js","webpack://chaincode/counter/./node_modules/lodash/_arrayEach.js","webpack://chaincode/counter/./node_modules/lodash/_defineProperty.js","webpack://chaincode/counter/./node_modules/lodash/_baseAssign.js","webpack://chaincode/counter/./node_modules/lodash/_baseTimes.js","webpack://chaincode/counter/./node_modules/lodash/isArguments.js","webpack://chaincode/counter/./node_modules/lodash/_baseIsArguments.js","webpack://chaincode/counter/./node_modules/lodash/stubFalse.js","webpack://chaincode/counter/./node_modules/lodash/_isIndex.js","webpack://chaincode/counter/./node_modules/lodash/isTypedArray.js","webpack://chaincode/counter/./node_modules/lodash/_baseIsTypedArray.js","webpack://chaincode/counter/./node_modules/lodash/_baseKeys.js","webpack://chaincode/counter/./node_modules/lodash/_nativeKeys.js","webpack://chaincode/counter/./node_modules/lodash/_baseAssignIn.js","webpack://chaincode/counter/./node_modules/lodash/_baseKeysIn.js","webpack://chaincode/counter/./node_modules/lodash/_nativeKeysIn.js","webpack://chaincode/counter/./node_modules/lodash/_cloneBuffer.js","webpack://chaincode/counter/./node_modules/lodash/_copyArray.js","webpack://chaincode/counter/./node_modules/lodash/_copySymbols.js","webpack://chaincode/counter/./node_modules/lodash/_arrayFilter.js","webpack://chaincode/counter/./node_modules/lodash/_copySymbolsIn.js","webpack://chaincode/counter/./node_modules/lodash/_getAllKeys.js","webpack://chaincode/counter/./node_modules/lodash/_getAllKeysIn.js","webpack://chaincode/counter/./node_modules/lodash/_DataView.js","webpack://chaincode/counter/./node_modules/lodash/_Promise.js","webpack://chaincode/counter/./node_modules/lodash/_Set.js","webpack://chaincode/counter/./node_modules/lodash/_WeakMap.js","webpack://chaincode/counter/./node_modules/lodash/_initCloneArray.js","webpack://chaincode/counter/./node_modules/lodash/_initCloneByTag.js","webpack://chaincode/counter/./node_modules/lodash/_Uint8Array.js","webpack://chaincode/counter/./node_modules/lodash/_cloneDataView.js","webpack://chaincode/counter/./node_modules/lodash/_cloneRegExp.js","webpack://chaincode/counter/./node_modules/lodash/_cloneSymbol.js","webpack://chaincode/counter/./node_modules/lodash/_cloneTypedArray.js","webpack://chaincode/counter/./node_modules/lodash/_initCloneObject.js","webpack://chaincode/counter/./node_modules/lodash/_baseCreate.js","webpack://chaincode/counter/./node_modules/lodash/isMap.js","webpack://chaincode/counter/./node_modules/lodash/_baseIsMap.js","webpack://chaincode/counter/./node_modules/lodash/isSet.js","webpack://chaincode/counter/./node_modules/lodash/_baseIsSet.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/componentRuntime.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/componentStorageService.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/leaderElection.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/taskAnalyzer.js","webpack://chaincode/counter/./node_modules/@prague/runtime/dist/webPlatform.js","webpack://chaincode/counter/./node_modules/@prague/component/dist/componentHost.js","webpack://chaincode/counter/./node_modules/@prague/component/dist/channelDeltaConnection.js","webpack://chaincode/counter/./node_modules/@prague/component/dist/channelStorageService.js","webpack://chaincode/counter/./node_modules/@prague/component/dist/localChannelStorageService.js","webpack://chaincode/counter/./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/sharedObject.js","webpack://chaincode/counter/./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/debug.js","webpack://chaincode/counter/./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/extension.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/batchManager.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/heap.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/promises.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/rangeTracker.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/rateLimitter.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/safeParser.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/utils.js","webpack://chaincode/counter/./node_modules/@prague/component/node_modules/@prague/utils/lib/index.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/batchManager.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/heap.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/promises.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rangeTracker.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rateLimitter.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/safeParser.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/utils.js","webpack://chaincode/counter/./node_modules/@prague/runtime/node_modules/@prague/utils/lib/index.js","webpack://chaincode/counter/./node_modules/@prague/map/lib/set.js","webpack://chaincode/counter/./node_modules/@prague/map/lib/counter.js","webpack://chaincode/counter/./node_modules/@prague/app-component/lib/debug.js","webpack://chaincode/counter/./node_modules/@prague/app-component/lib/component.js","webpack://chaincode/counter/./node_modules/@prague/app-component/lib/document.js","webpack://chaincode/counter/./src/index.js","webpack://chaincode/counter/./node_modules/@prague/sequence/node_modules/@prague/utils/lib/promises.js","webpack://chaincode/counter/./node_modules/@prague/merge-tree/lib/client.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","process","__webpack_exports__","LocalReference","SegmentType","ordinalToArray","SubSequence","runToSeg","reservedRangeLabelsKey","Marker","TextSegment","UniversalSequenceNumber","UnassignedSequenceNumber","LocalClientId","NonCollabClient","compareStrings","clock","elapsedMicroseconds","internedSpaces","RegisterCollection","MergeTree","_collections__WEBPACK_IMPORTED_MODULE_0__","_ops__WEBPACK_IMPORTED_MODULE_1__","_properties__WEBPACK_IMPORTED_MODULE_2__","assert__WEBPACK_IMPORTED_MODULE_3__","_segmentGroupCollection__WEBPACK_IMPORTED_MODULE_4__","[object Object]","segment","offset","refType","Simple","this","b","compare","ordinal","mergeTree","refSeq","clientId","getOffset","refHasTileLabels","refHasRangeLabels","label","refHasTileLabel","refHasRangeLabel","refGetTileLabels","refGetRangeLabels","newProps","op","properties","MergeNode","addTile","tile","tiles","tileLabel","getTileLabels","addTileIfNotPresent","undefined","applyStackDelta","currentStackMap","deltaStackMap","deltaStack","empty","currentStack","delta","items","applyRangeReference","stack","NestBegin","push","top","pop","ord","a","len","length","charCodeAt","MaxNodesInBlock","MergeBlock","childCount","super","children","Array","child","index","localOrdinal","ordinalWidth","prevOrd","String","fromCharCode","traceOrdinals","console","log","updateOrdinal","parent","setOrdinal","HierMergeBlock","rightmostTiles","leftmostTiles","rangeStacks","node","updateRangeInfo","refPos","isLeaf","localNetLength","getType","marker","markerId","getId","mapIdToSegment","Tile","NestEnd","getRangeLabels","textSegment","localRefs","hierRefCount","lref","block","addNodeReferences","indentCount","strbuf","item","toString","BaseSegment","seq","segmentGroups","hasRangeLabels","hasTileLabels","k","j","pos","leafSegment","aRefs","bRefs","localRef","removedClientId","removedSeq","jseg","props","obj","addSerializedProps","bProps","MaxRun","cachedLength","remainingItems","slice","addProperties","segmentCopy","splitLocalRefs","start","end","clonedItems","cloneInto","Run","matchProperties","branchId","getBranchId","rseg","adj","concat","Error","remnantItems","segSpec","seg","reservedTileLabelsKey","reservedMarkerIdKey","reservedMarkerSimpleTypeKey","refLabel","make","simpleTypeName","hasProperty","bbuf","lbuf","id","labels","rangeKind","pbuf","JSON","stringify","text","tseg","remainingText","substring","Text","charAt","TextSegmentGranularity","remnantString","from","to","removalsByBranch","fromRemovalInfo","removedClientOverlap","copyTo","incrementalGatherText","state","traceGatherText","collabWindow","collabwindow","context","IncrementalExecOp","Go","IncrementalMapState","actions","childIndex","TreeMaintenanceSequenceNumber","CollaborationWindow","collaborating","minSeq","currentSeq","localMinSeq","globalMinSeq","latestLEQ","best","lo","hi","mid","Math","floor","compareNumbers","localeCompare","PartialSequenceLengths","minLength","segmentCount","partialLengths","clientSeqNumbers","cliSeqs","comparePartialLengths","aList","bList","aLen","aPartial","bPartial","seglen","overlapRemoveClients","glc","buf","partial","branchToString","downstreamPartialLengths","traceTraversal","getBranchPartialLength","pLen","seqIndex","cliLatestindex","cliLatest","cliSeq","precedingCliIndex","cliLatestLEQ","segmentWindow","copyDown","mindex","seqCount","remainingCount","cliPartials","cli","partialLength","addClientSeqNumber","map","oc","data","segBranchId","updateBranch","localBranchId","seqSeglen","segCount","removalInfo","getRemovalInfo","branchPartialLengths","partialLengthsForBranch","leqPartial","addSeq","seqPartialLen","penultPartialLen","leqIndex","options","zamboni","combinedPartialLengths","getOverlapClients","overlapClientids","bst","put","insertSegment","removeClientOverlap","segmentLen","seqPartials","seqPartialsLen","indexFirstGTE","overlapRemoveClientIds","ovlapClientNode","accumulateRemoveClientOverlap","seqLTE","prevLen","addClientSeqNumberFromPartial","recur","partialLengthsTopBranch","combineBranch","prevPartial","addNext","bProp","aProp","fromLeaves","childPartials","childBlock","combine","childPartialsLen","indices","childPartialsCounts","earliestPartialLength","outerIndexOfEarliest","cpLen","hrtime","Date","now","round","indentStrings","clientCollections","segments","clientCollection","segs","LRUSegmentComparer","min","maxSeq","getLongClientId","applyLeafRangeMarker","searchInfo","rangeLabel","rangeLabels","hasRangeLabel","stacks","recordRangeLeaf","segpos","rangeShift","recordTileStart","hasTileLabel","tileShift","posPrecedesTile","minListenerComparer","minRequired","Number","MIN_VALUE","windowTime","packTime","ordTime","maxOrdTime","blockUpdateMarkers","idToSegment","clientIdToBranchId","minSeqPending","gatherSegment","accumSegments","clone","gatherText","accumText","beginTags","endTags","parallelArrays","tags","initTags","remTags","tag","tagsInProgress","indexOf","accumTag","initTag","reverse","remTag","remdex","splice","placeholder","parallelMarkerLabel","parallelMarkers","parallelText","splitLeafSegment","segmentChanges","next","splitAt","blockUpdateActions","initBlockUpdateActions","initialTextNode","makeBlock","assignChild","blockClone","bBlock","segmentClone","nodeUpdateLengthNewStructure","nodeUpdateOrdinals","liveSegmentGroup","transactionSegmentGroup","pendingSegments","enqueue","segCap","buildMergeBlock","nodes","nodeCount","ceil","blocks","nodeIndex","addNode","hierBlock","localClientId","segmentsToScour","add","holdNodes","prevSegment","childNode","createBrid","traceZRemove","canAppend","traceAppend","append","scourNode","totalNodeCount","halfCount","baseCount","extraCount","packedBlocks","readCount","packedBlock","packedNodeIndex","nodeToPack","underflow","pack","blockUpdatePathLengths","clockStart","measureWindowTime","segmentToScour","peek","zamboniSegmentsMaxCount","childrenCopy","newChildCount","packClockStart","nodeGetStats","stats","maxHeight","leafCount","removedLeafCount","liveCount","histo","height","childStats","rootStats","fromSeq","toSeq","toClientId","tardisPositionFromClient","fromClientId","getLength","segoff","getContainingSegment","ret","rangeStart","rangeEnd","ranges","mapRange","leaf","segStart","segEnd","nodeLength","tardisRangeFromClient","blockLength","prevParent","totalOffset","target","searchChunkSize","chunk","result","getText","match","initialState","incrementalBlockMap","accum","runSeg","searchBlock","leafSeg","getPartialLength","setMinSeq","onMinGE","minSeqListeners","count","zamboniSegments","getSegment","startPos","search","shift","undoInfo","backwardSearch","toPosition","clientData","pre","contains","post","backwardSearchBlock","splitNode","newRoot","verboseOps","pendingSegmentGroup","dequeue","nodesToUpdate","overwrite","pendingSegment","diagOverlappingRemove","segmentGroup","relativePos","refseq","getSegmentFromId","before","segData","traverse","opArgs","ensureIntervalBoundary","ordinalIntegrity","updateRoot","mergeTreeDeltaCallback","mergeTreeClientId","operation","insert","blockInsert","behaviors","markerModifiedHandler","markerPos","posFromRelativePos","newSegment","segIsLocal","checkSegmentIsLocal","diagInsertTie","insertingWalk","replaceCurrent","locSegment","addToPendingList","addToLRUSet","saveIfLocal","candidateSegment","continuePredicate","rightExcursion","Base","leafAction","go","startNode","matchedStart","nodeMapReverse","nodeMap","segType","newNode","fromSplit","found","segInfo","breakTie","segmentBranchId","structureChange","blockUpdateLength","theUnfinishedNode","split","nodeOrdinalIntegrity","olen","measureOrdinalTime","elapsed","combiningOp","annotatedSegments","removedSegments","savedLocalRefs","brid","addOverlappingClient","afterSeg","segSavedRefs","SlideOnRemove","addLocalRef","removeInfo","nodeRemoveRange","highestBlockRemovingChildren","remBlock","startIndex","endIndex","removeRange","deleteCount","deleteStart","copyStart","copyCount","blockUpdate","removeLocalRef","newStructure","incrementalUpdate","update","nodeToString","hierToString","stateStack","traceIncrTraversal","childState","skipLeftShift","__export","global","x","y","isBuffer","Buffer","_isBuffer","util","hasOwn","pSlice","functionsHaveNames","pToString","isView","arrbuf","ArrayBuffer","DataView","buffer","assert","ok","regex","getName","func","isFunction","truncate","inspect","something","rawname","fail","actual","expected","message","operator","stackStartFunction","AssertionError","_deepEqual","strict","memos","isDate","getTime","isRegExp","source","multiline","lastIndex","ignoreCase","Float32Array","Float64Array","Uint8Array","actualIndex","actualVisitedObjects","isPrimitive","getPrototypeOf","aIsArgs","isArguments","bIsArgs","ka","objectKeys","kb","sort","objEquiv","expectedException","test","e","isPrototypeOf","_throws","shouldThrow","TypeError","error","_tryBlock","userProvidedMessage","isUnexpectedException","isError","self","generatedMessage","captureStackTrace","err","out","fn_name","idx","next_line","inherits","equal","notEqual","deepEqual","deepStrictEqual","notDeepEqual","notDeepStrictEqual","strictEqual","notStrictEqual","throws","doesNotThrow","ifError","keys","ReferenceType","IntervalType","combiningInfo","currentValue","newValue","defaultValue","minValue","cv","extend","base","extension","v","oldProps","createMap","extendIfUndefined","Stack","ListMakeHead","Heap","RedBlackTree","IntervalTree","_mergeTree__WEBPACK_IMPORTED_MODULE_0__","val","ListRemoveEntry","entry","isHead","prev","ListMakeEntry","List","fn","rev","head","insertEntryBefore","comp","L","fixdown","fixup","tmp","compareKeys","aug","color","size","init","nodeSize","nodeGet","cmp","left","right","matcher","results","nodeGather","continueSubtree","matchNode","conflict","remove","nodePut","kd","isRed","rotateLeft","rotateRight","flipColors","updateLocal","makeNode","isEmpty","nodeRemoveMin","moveRedLeft","balance","nodeRemoveMax","moveRedRight","nodeRemove","subtreeMin","nodeMin","nodeHeight","max","nodeFloor","rightFloor","nodeCeil","leftCeil","nodeMax","leftChild","rightChild","oppositeColor","action","keyList","showStructure","infix","walk","nodeWalk","cmpStart","cmpEnd","intervalComparer","intervals","diag","timePut","putTime","putCount","toFixed","rbConflict","currentKey","minmax","gather","overlaps","cont","union","EventEmitter","_events","_maxListeners","arg","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","emit","type","er","handler","args","listeners","arguments","apply","addListener","listener","newListener","warned","trace","on","once","fired","g","removeListener","list","position","removeAllListeners","listenerCount","evlistener","emitter","rng","bytesToUuid","rnds","random","ii","freeGlobal","freeSelf","Function","base64","ieee754","isArray","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","encodingOrOffset","allocUnsafe","array","byteOffset","byteLength","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","write","fromString","checked","copy","fromObject","assertSize","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","swap","bidirectionalIndexOf","dir","arrayIndexOf","lastIndexOf","arr","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","hexWrite","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","utf16leToBytes","base64Slice","fromByteArray","utf8Slice","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","foo","subarray","typedArraySupport","poolSize","_augment","species","configurable","fill","allocUnsafeSlow","swap16","swap32","swap64","hexSlice","asciiSlice","latin1Slice","utf16leSlice","equals","join","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","trim","replace","stringtrim","base64clean","src","dst","_typeof","iterator","constructor","_console","formatArgs","useColors","namespace","humanize","diff","lastC","save","namespaces","storage","setItem","removeItem","load","getItem","env","DEBUG","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","firebug","exception","table","RegExp","$1","localStorage","localstorage","colors","formatters","baseIsNative","getValue","SegmentSequence","SharedObjectSequence","SharedNumberSequence","_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__","_prague_map__WEBPACK_IMPORTED_MODULE_1__","_prague_map__WEBPACK_IMPORTED_MODULE_2__","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_3__","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_4__","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_5__","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_6__","_prague_utils__WEBPACK_IMPORTED_MODULE_7__","assert__WEBPACK_IMPORTED_MODULE_8__","uuid_v4__WEBPACK_IMPORTED_MODULE_9__","_extension__WEBPACK_IMPORTED_MODULE_10__","_intervalCollection__WEBPACK_IMPORTED_MODULE_11__","_sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_12__","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","rejected","done","then","cloneDeep","extensionType","services","isLoaded","collabStarted","pendingMinSequenceNumber","loadedDeferred","messagesSinceMSNChange","client","event","deltaArgs","loaded","promise","removeMessage","pos1","pos2","removeSegmentLocal","submitIfAttached","register","getCurrentSeq","getClientId","longClientId","insertMessage","pasteLocal","groupOp","localTransaction","annotateMessage","annotateSegmentLocal","getPropertiesAtPosition","getRangeExtentsOfPosition","lmseq","updateLocalMinSeq","Transient","addLocalReference","intervalCollections","has","Name","orderedSegments","NACKedSegmentGroup","opList","prevSeg","clear","segmentToOps","ops","minimumSequenceNumber","headerOrigin","header","initialize","runtime","createChannel","Type","catch","transformedMessages","transform","deltaManager","commitGlobalMin","snap","extractSync","mtSnap","entries","File","path","Blob","contents","processMessage","sequenceNumber","updateMinSeq","startCollaboration","pending","updateCollaboration","sendNACKed","isLocal","submitLocalMessage","applyMsg","notifyMinSeqListeners","originalMessage","referenceSequenceNumber","shared","originBranch","processChunk","segmentsFromSpecs","segmentTexts","reloadFromSegments","documentId","rawMessages","all","loadChunk","appendSegment","messages","parse","origin","initializeIntervalCollections","EmptyChunk","chunkSequenceNumber","loadHeader","loadBody","loadFinished","ev","intervalCollection","attached","attach","getCollabWindow","SharedSequence","isNumeric","isNumberSequence","insertSegmentLocal","getItemCount","getItems","segSpecs","SharedMap","_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__","_prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__","_debug__WEBPACK_IMPORTED_MODULE_2__","_extension__WEBPACK_IMPORTED_MODULE_3__","_view__WEBPACK_IMPORTED_MODULE_4__","snapshotFileName","contentPath","ContentObjectStorage","valueTypes","Map","serializeFilter","valueType","messageHandler","pendingKeys","pendingClearClientSequenceNumber","setMessageHandlers","initializeView","view","values","callbackFn","forEach","wait","delete","tree","serialize","sha","contentSnapshot","snapshotContent","Directory","Tree","clientSequenceNumber","submitMapMessage","getOpHandler","valueTypeMessageHandler","prepare","local","submit","filter","onDisconnectContent","mapMessages","contentMessages","isMapMessage","onConnectContent","populate","contentStorage","loadContent","initializeContent","processMinSequenceNumberChangedContent","Operation","prepareContent","handled","processContent","attachAll","attachContent","defaultPrepare","clearCore","clearExceptPendingKeys","submitMapClearMessage","needProcessKeyOperations","deleteCore","submitMapKeyMessage","prepareSetCore","setCore","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","eq","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","nativeCreate","getNative","isKeyable","__data__","assignValue","baseAssignValue","customizer","isNew","Hash","K","W","Sha1","_w","rotl5","num","rotl30","ft","_a","_b","_c","_d","_e","_update","M","_hash","H","sharedString_SharedString","sequence","extension_SharedStringExtension","insertText","lib_mergeTree","insertMarker","texts","ptext","textsToSegments","relativePos1","insertMarkerLocal","insertTextLocal","startGroupOperation","endGroupOperation","nestStart","nestEnd","checkNest","id1","id2","tardisRange","range","annotateRange","callback","relativePos2","annotateMarkerNotifyConsensus","annotateMarker","preceding","findTile","extension_SharedObjectSequenceExtension","extension_SharedNumberSequenceExtension","sharedString","initializeLocal","sharedSeq","Snapshot","_mergeTree__WEBPACK_IMPORTED_MODULE_1__","filename","onCompletion","allSegments","allLengths","approxSequenceLength","sequenceLength","pseg","chunkStartSegmentIndex","chunkSegmentCount","chunkLengthChars","totalLengthChars","segmentsTotalLength","totalSegmentCount","chunk1","getSeqLengthSegs","segmentLengths","chunk2","segLengths","toJSONObject","chunkAsString","SnapChunkMaxSize","SegmentLengthSize","SnapshotHeaderSize","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","runClearTimeout","Item","noop","nextTick","title","browser","argv","version","versions","off","prependListener","prependOnceListener","binding","cwd","chdir","umask","baseClone","CLONE_DEEP_FLAG","CLONE_SYMBOLS_FLAG","arrayLikeKeys","baseKeys","isArrayLike","webpackPolyfill","deprecate","paths","freeExports","nodeType","freeModule","freeProcess","nodeUtil","types","require","objectProto","Ctor","arrayFilter","stubArray","propertyIsEnumerable","nativeGetSymbols","getOwnPropertySymbols","getSymbols","symbol","Set","WeakMap","baseGetTag","toSource","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ctorString","arrayBuffer","registerDefaultValueType","MapExtension","_map__WEBPACK_IMPORTED_MODULE_0__","defaultValueTypes","registerValueTypes","registerValueType","debug","debug__WEBPACK_IMPORTED_MODULE_0__","Stream","_extension__WEBPACK_IMPORTED_MODULE_2__","_snapshot__WEBPACK_IMPORTED_MODULE_3__","emptySnapshot","layers","layerIndex","inkSnapshot","Clone","Cell","CellValueType","operationValue","Shared","Plain","content","rawContent","getChannel","ctor","superCtor","super_","writable","TempCtor","Deque","capacity","_capacity","getCapacity","_length","_front","toArray","front","argsLength","_checkCapacity","unshift","peekBack","peekFront","valueOf","removeFront","removeBack","insertFront","insertBack","_resizeTo","oldCapacity","srcIndex","dstIndex","arrayMove","ValueType","gitHashFile","flatten","readAndParse","buildHierarchy","sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__","file","filePrefix","digest","blobMap","flattenCore","treeEntries","treeEntry","subPath","blob","url","subTreeEntries","encoded","decoded","flatTree","lookup","blobs","commits","trees","entryPathDir","entryPathBase","newTree","copyProps","SafeBuffer","other","asyncTag","funcTag","genTag","proxyTag","funcToString","objValue","baseTimes","isIndex","isTypedArray","inherited","isArr","isArg","isBuff","isType","skipIndexes","stubFalse","MAX_SAFE_INTEGER","isLength","baseKeysIn","arrayPush","getPrototype","getSymbolsIn","overArg","keysFunc","symbolsFunc","registerDebug","MapView","ValueOpEmitter","params","localValuesP","localValueP","filledValue","localValues","localValue","getValueType","spill","localType","prepareOperationValue","successfullyRemoved","serialized","spilledValue","filteredValue","temp","remote","translatedValue","hasValueType","distributedObject","store","SharedStringIntervalCollectionValueType","SharedIntervalCollectionValueType","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_1__","_prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__","events__WEBPACK_IMPORTED_MODULE_4__","Interval","auxProps","serializedInterval","intervalType","startResult","SharedStringInterval","startPosition","checkMergeTree","checkOverlaps","bstart","bend","astart","aend","createPositionReference","baseSegment","createSharedStringInterval","beginRefType","RangeBegin","endRefType","RangeEnd","Nest","startLref","endLref","pairedRef","rangeProp","LocalIntervalCollection","helpers","intervalTree","endIntervalTree","compareEnds","conflictResolver","endConflictResolver","ival","endPosition","transientInterval","rbNode","interval","createInterval","compareSharedStringIntervalEnds","SharedStringIntervalCollectionFactory","raw","SharedIntervalCollection","serializeInternal","_factory","_ops","prepareAddInternal","addInternal","compareIntervalEnds","SharedIntervalCollectionFactory","collection","SharedIntervalCollectionView","savedSerializedIntervals","attachingP","localCollection","addInterval","onDeserialize","onPrepareDeserialize","attachDeserializerCore","findOverlappingIntervals","previousInterval","nextInterval","preparedIntervalsP","preparedIntervalP","preparedIntervals","preparedInterval","requiresClient","serializedIntervals","attachDeserializer","prepareAdd","SegmentGroupCollection","sg","SequenceDeltaEvent","mergeTreeClient","deltaOperation","sortedRanges","Lazy","pStart","pEnd","lastRange","pClientId","pRanges","nextStart","nextLength","nextType","currentPosition","valueGenerator","pEvaluated","evaluated","pValue","StreamExtension","_stream__WEBPACK_IMPORTED_MODULE_0__","stream","CellExtension","_cell__WEBPACK_IMPORTED_MODULE_0__","cell","ActionType","getActionType","Clear","stylusDown","StylusDown","stylusUp","StylusUp","stylusMove","StylusMove","snapshot_Snapshot","snapshot","operations","applyOperation","processClearAction","processStylusUpAction","processStylusDownAction","processStylusMoveAction","addOperationToLayer","layer","layerId","getRandomValues","crypto","msCrypto","rnds8","byteToHex","bth","selectColor","hash","createDebug","abs","prevTime","enabled","_len","_key","curr","ms","coerce","format","formatter","destroy","instances","delimiter","default","disable","enable","names","skips","instance","h","w","plural","msAbs","isPlural","exec","parseFloat","long","fmtLong","fmtShort","b64","lens","getLens","validLen","placeHoldersLen","Arr","_byteLength","curByte","revLookup","uint8","extraBytes","parts","len2","encodeChunk","output","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","LN2","container_definitions_1","events_1","debug_1","valueType_1","SharedObject","__sharedObject__","_state","ConnectionState","Disconnected","pendingOps","loadCore","objectStorage","attachDeltaHandler","initializeLocalCore","attachCore","attachChannel","Connected","deltaConnection","minSequenceNumberChanged","processMinSequenceNumberChanged","setConnectionState","prepareCore","onDisconnect","Connecting","onConnect","MessageType","processCore","getFileBlobType","mimeType","Browser","Robot","FileMode","TreeEntry","formatRegExp","f","isString","objects","_","isNull","msg","noDeprecation","throwDeprecation","traceDeprecation","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","isBoolean","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","styles","recurseTimes","primitive","simple","isNumber","formatPrimitive","visibleKeys","arrayToHash","getOwnPropertyNames","formatError","braces","toUTCString","formatProperty","formatArray","reduce","cur","numLinesEst","reduceToSingleString","desc","getOwnPropertyDescriptor","line","ar","re","pad","debuglog","NODE_DEBUG","toUpperCase","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","number","boolean","null","date","regexp","isNullOrUndefined","isSymbol","months","prop","time","getHours","getMinutes","getSeconds","getDate","getMonth","Registry","extensions","extensionsMap","utils_1","componentRuntime_1","componentStorageService_1","leaderElection_1","taskAnalyzer_1","Runtime","registry","tasks","components","componentsDeferred","closed","pendingAttach","lastMinSequenceNumber","snapshotTreesP","baseSnapshot","moduleSha","commit","getVersions","moduleTree","getSnapshotTree","snapshotTree","componentsP","componentId","componentP","loadComponent","connectionState","tenantId","parentBranch","existing","blobManager","branch","submitFn","snapshotFn","closeFn","connected","extraBlobs","runtimeStorage","ComponentStorageService","details","ComponentRuntime","LoadFromSnapshot","pkg","deferred","Deferred","component","requestHandler","request","status","tagMessage","lastVersion","channelEntries","channelCommitsP","channelId","channelSnapshot","channelCommitP","updateBaseSha","channelCommits","gitModules","channelCommit","Commit","repoUrl","requestSnapshot","verifyNotClosed","Attach","changeConnectionState","prepareOperation","prepareAttach","processOperation","processAttach","updateMinSequenceNumber","postProcessAttach","quorum","startLeaderElection","envelope","address","innerContents","transformed","metadata","timestamp","traces","attachMessage","flattened","clientType","initLeaderElection","leaderElector","LeaderElector","getQuorum","runTaskAnalyzer","proposeLeadership","getLeaderCandidate","getMembers","getLeader","helpTasks","analyzeTasks","robot","localHelpMessage","remoteHelpMessage","RemoteHelp","blockSize","finalSize","_block","_finalSize","_blockSize","enc","assigned","remainder","rem","bits","lowBits","highBits","arrayEach","baseAssign","baseAssignIn","cloneBuffer","copyArray","copySymbols","copySymbolsIn","getAllKeys","getAllKeysIn","initCloneArray","initCloneByTag","initCloneObject","isMap","isSet","CLONE_FLAT_FLAG","argsTag","objectTag","cloneableTags","bitmask","isDeep","isFlat","isFull","isFunc","stacked","subValue","keysIn","stackClear","stackDelete","stackGet","stackHas","stackSet","assocIndexOf","MapCache","LARGE_ARRAY_SIZE","pairs","isMasked","reIsHostCtor","funcProto","reIsNative","nativeObjectToString","isOwn","unmasked","uid","coreJsData","maskSrcKey","IE_PROTO","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","hashClear","hashDelete","hashGet","hashHas","hashSet","HASH_UNDEFINED","getMapData","iteratee","copyObject","baseIsArguments","isObjectLike","reIsUint","baseIsTypedArray","baseUnary","nodeIsTypedArray","typedArrayTags","isPrototype","nativeKeys","nativeKeysIn","isProto","predicate","resIndex","baseGetAllKeys","input","cloneArrayBuffer","cloneDataView","cloneRegExp","cloneSymbol","cloneTypedArray","boolTag","dateTag","mapTag","numberTag","regexpTag","setTag","stringTag","symbolTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","dataView","reFlags","symbolProto","symbolValueOf","typedArray","baseCreate","objectCreate","proto","baseIsMap","nodeIsMap","baseIsSet","nodeIsSet","hostRuntime","chaincode","baseSha","getPackage","instantiateComponent","channels","createAndAttachComponent","getComponent","getBlobMetadata","msn","componentAttributes","platform","storageService","repositoryUrl","getContent","parents","ref","createBlob","getRawUrl","QuorumKey","attachQuorumListeners","propose","leader","proposal","isRobot","runnerClientId","clients","handledTasks","unhandledTasks","task","runnerClient","permission","browserClients","DefinitionGuide","counter","dts","setInterval","WebPlatform","div","definitions","WebPlatformFactory","channelDeltaConnection_1","channelStorageService_1","localChannelStorageService_1","ServicePlatform","qi","ComponentHost","componentRuntime","channelsDeferred","reserve","loadSnapshotsP","loadSnapshotChannel","_platform","queryInterface","channel","getModule","connection","getObjectServices","Save","BlobUploaded","getBlob","snapshotInternal","prepareOp","processOp","objectId","objectAttributes","submitMessage","objectDetails","channelState","LocalChannelStorageService","ChannelDeltaConnection","submitEnvelope","loadChannel","channelAttributes","channelDetails","minSequenceNumber","ChannelStorageService","flattenedTree","flattenTree","getShaForPath","readSync","readSyncInternal","MaxBatchSize","BatchManager","pendingWork","work","pendingTimer","startWork","batch","NumberComparer","isGreaterThanParent","rej","assertNotRejected","rangeTracker_RangeTracker","primary","primaryHead","lastPrimary","secondaryHead","lastSecondary","secondary","closestRange","RateLimitter","windowMSec","requestMap","approvedList","currentTime","safelyParseJSON","json","isSystemType","dist","Integrate","ClientJoin","ClientLeave","Fork","DistributedSetFactory","DistributedSet","onAdd","onDelete","internalSet","submitEvent","DistributedSetValueType","CounterFactory","Counter","_value","onIncrement","CounterValueType","increment","component_awaiter","typeToFactorySym","component_ComponentPlatform","events","component_LegacyChaincode","component_Component","_host","_root","ensureOpened","dbgName","host","rootMapId","lib_extension","opened","typeToFactory","accept","runtimeId","encodeURIComponent","runtime_dist","Load","ctorFn","registerRequestHandler","close","document_Document","mapExtension","sharedStringExtension","sequence_lib_extension","streamExtension","stream_lib_extension","cellExtension","objectSequenceExtension","numberSequenceExtension","v4","src_Clicker","instantiateRuntime","span","createElement","textContent","btn","addEventListener","appendChild","maybeDiv","render","async","Client","_collections__WEBPACK_IMPORTED_MODULE_2__","initText","accumTime","localTime","localOps","accumWindowTime","maxWindowTime","accumWindow","accumOps","noVerboseRemoteAnnote","measureOps","clientNameToIds","shortClientIdMap","shortClientBranchIdMap","shortClientUserInfoMap","registerCollection","localSequenceNumber","opMarkersModified","pendingConsensus","getUserInfo","markerModified","q","checkQ","undoSegments","redoSegments","cherryPickedUndo","pct","curPct","undoSingleSequenceNumber","undoSeg","addLongClientId","getShortClientId","shortClientId","markerType","userId","insertOp","removeOp","toSequenceNumber","tardisPosition","transformOp","registerId","cloneSegments","insertTextRemote","insertMarkerRemote","clid","beginMarker","endMarker","beginPos","endPos","sequencedMessage","getOrAddShortClientId","removeSegmentRemote","insertItemsRemote","pasteRemote","annotateSegmentRemote","memberOp","applyOp","resetModifiedMarkers","operationMessage","ackPendingSegment","updateConsensusProperty","coreApplyMsg","msgCount","consensusInfo","addMinSeqListener","consensusCallback","segWindow","getLocalSequenceNumber","markRangeRemoved","insertTextMarkerRelative","markerDef","updateGlobalMinSeq","propertiesAtPosition","getTextAndMarkers","oldClientId","oldData"],"mappings":"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","file":"main.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"main\"] = factory();\n\telse\n\t\troot[\"main\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 185);\n","import * as Collections from \"./collections\";\nimport * as ops from \"./ops\";\nimport * as Properties from \"./properties\";\nimport * as assert from \"assert\";\nimport { SegmentGroupCollection } from \"./segmentGroupCollection\";\nexport class LocalReference {\n    constructor(segment, offset = 0, refType = ops.ReferenceType.Simple) {\n        this.segment = segment;\n        this.offset = offset;\n        this.refType = refType;\n    }\n    min(b) {\n        if (this.compare(b) < 0) {\n            return this;\n        }\n        else {\n            return b;\n        }\n    }\n    max(b) {\n        if (this.compare(b) > 0) {\n            return this;\n        }\n        else {\n            return b;\n        }\n    }\n    compare(b) {\n        if (this.segment === b.segment) {\n            return this.offset - b.offset;\n        }\n        else {\n            if (this.segment.ordinal < b.segment.ordinal) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        }\n    }\n    toPosition(mergeTree, refSeq, clientId) {\n        if (this.segment) {\n            return this.offset + mergeTree.getOffset(this.segment, refSeq, clientId);\n        }\n        else {\n            return -1;\n        }\n    }\n    hasTileLabels() {\n        return refHasTileLabels(this);\n    }\n    hasRangeLabels() {\n        return refHasRangeLabels(this);\n    }\n    hasTileLabel(label) {\n        return refHasTileLabel(this, label);\n    }\n    hasRangeLabel(label) {\n        return refHasRangeLabel(this, label);\n    }\n    getTileLabels() {\n        return refGetTileLabels(this);\n    }\n    getRangeLabels() {\n        return refGetRangeLabels(this);\n    }\n    isLeaf() {\n        return false;\n    }\n    addProperties(newProps, op) {\n        this.properties = Properties.addProperties(this.properties, newProps, op);\n    }\n    getSegment() {\n        return this.segment;\n    }\n    getOffset() {\n        return this.offset;\n    }\n    getProperties() {\n        return this.properties;\n    }\n}\nexport var SegmentType;\n(function (SegmentType) {\n    SegmentType[SegmentType[\"Base\"] = 0] = \"Base\";\n    SegmentType[SegmentType[\"Text\"] = 1] = \"Text\";\n    SegmentType[SegmentType[\"Marker\"] = 2] = \"Marker\";\n    SegmentType[SegmentType[\"External\"] = 3] = \"External\";\n    SegmentType[SegmentType[\"Custom\"] = 4] = \"Custom\";\n    SegmentType[SegmentType[\"Run\"] = 5] = \"Run\";\n})(SegmentType || (SegmentType = {}));\nexport class MergeNode {\n    isLeaf() {\n        return false;\n    }\n}\nfunction addTile(tile, tiles) {\n    for (let tileLabel of tile.getTileLabels()) {\n        tiles[tileLabel] = tile;\n    }\n}\nfunction addTileIfNotPresent(tile, tiles) {\n    for (let tileLabel of tile.getTileLabels()) {\n        if (tiles[tileLabel] === undefined) {\n            tiles[tileLabel] = tile;\n        }\n    }\n}\nfunction applyStackDelta(currentStackMap, deltaStackMap) {\n    for (let label in deltaStackMap) {\n        let deltaStack = deltaStackMap[label];\n        if (!deltaStack.empty()) {\n            let currentStack = currentStackMap[label];\n            if (currentStack === undefined) {\n                currentStack = new Collections.Stack();\n                currentStackMap[label] = currentStack;\n            }\n            for (let delta of deltaStack.items) {\n                applyRangeReference(currentStack, delta);\n            }\n        }\n    }\n}\nfunction applyRangeReference(stack, delta) {\n    if (delta.refType & ops.ReferenceType.NestBegin) {\n        stack.push(delta);\n        return true;\n    }\n    else {\n        // assume delta is end reference\n        let top = stack.top();\n        // TODO: match end with begin\n        if (top && (top.refType & ops.ReferenceType.NestBegin)) {\n            stack.pop();\n        }\n        else {\n            stack.push(delta);\n        }\n        return false;\n    }\n}\nfunction addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {\n    function updateRangeInfo(label, refPos) {\n        let stack = rangeStacks[label];\n        if (stack === undefined) {\n            stack = new Collections.Stack();\n            rangeStacks[label] = stack;\n        }\n        applyRangeReference(stack, refPos);\n    }\n    if (node.isLeaf()) {\n        let segment = node;\n        if (mergeTree.localNetLength(segment) > 0) {\n            if (segment.getType() == SegmentType.Marker) {\n                let marker = node;\n                let markerId = marker.getId();\n                // also in insertMarker but need for reload segs case\n                // can add option for this only from reload segs\n                if (markerId) {\n                    mergeTree.mapIdToSegment(markerId, marker);\n                }\n                if (marker.refType & ops.ReferenceType.Tile) {\n                    addTile(marker, rightmostTiles);\n                    addTileIfNotPresent(marker, leftmostTiles);\n                }\n                if (marker.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n                    for (let label of marker.getRangeLabels()) {\n                        updateRangeInfo(label, marker);\n                    }\n                }\n            }\n            else {\n                // TODO: generalize to other segment types\n                let textSegment = node;\n                if (textSegment.localRefs && (textSegment.hierRefCount !== undefined) &&\n                    (textSegment.hierRefCount > 0)) {\n                    for (let lref of textSegment.localRefs) {\n                        if (lref.refType & ops.ReferenceType.Tile) {\n                            addTile(lref, rightmostTiles);\n                            addTileIfNotPresent(lref, leftmostTiles);\n                        }\n                        if (lref.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n                            for (let label of lref.getRangeLabels()) {\n                                updateRangeInfo(label, lref);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else {\n        let block = node;\n        applyStackDelta(rangeStacks, block.rangeStacks);\n        Properties.extend(rightmostTiles, block.rightmostTiles);\n        Properties.extendIfUndefined(leftmostTiles, block.leftmostTiles);\n    }\n}\nexport function ordinalToArray(ord) {\n    let a = [];\n    if (ord) {\n        for (let i = 0, len = ord.length; i < len; i++) {\n            a.push(ord.charCodeAt(i));\n        }\n    }\n    return a;\n}\nexport const MaxNodesInBlock = 8;\nexport class MergeBlock extends MergeNode {\n    constructor(childCount) {\n        super();\n        this.childCount = childCount;\n        this.children = new Array(MaxNodesInBlock);\n    }\n    hierBlock() {\n        return undefined;\n    }\n    setOrdinal(child, index) {\n        let childCount = this.childCount;\n        if (childCount === 8) {\n            childCount = 7;\n        }\n        assert((childCount >= 1) && (childCount <= 7));\n        let localOrdinal;\n        let ordinalWidth = 1 << (MaxNodesInBlock - (childCount + 1));\n        if (index === 0) {\n            localOrdinal = ordinalWidth - 1;\n        }\n        else {\n            let prevOrd = this.children[index - 1].ordinal;\n            let prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);\n            localOrdinal = prevOrdCode + ordinalWidth;\n        }\n        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);\n        if (MergeBlock.traceOrdinals) {\n            console.log(`so: prnt chld prev ${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${(index > 0) ? ordinalToArray(this.children[index - 1].ordinal) : \"NA\"}`);\n        }\n        assert(child.ordinal.length === (this.ordinal.length + 1));\n        if (index > 0) {\n            assert(child.ordinal > this.children[index - 1].ordinal);\n            //console.log(`${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${ordinalToArray(this.children[index - 1].ordinal)}`);\n            //    console.log(`ord width ${ordinalWidth}`);\n        }\n    }\n    assignChild(child, index, updateOrdinal = true) {\n        child.parent = this;\n        child.index = index;\n        if (updateOrdinal) {\n            this.setOrdinal(child, index);\n        }\n        this.children[index] = child;\n    }\n}\nMergeBlock.traceOrdinals = false;\nclass HierMergeBlock extends MergeBlock {\n    constructor(childCount) {\n        super(childCount);\n        this.rightmostTiles = Properties.createMap();\n        this.leftmostTiles = Properties.createMap();\n        this.rangeStacks = Properties.createMap();\n    }\n    addNodeReferences(mergeTree, node) {\n        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);\n    }\n    hierBlock() {\n        return this;\n    }\n    hierToString(indentCount) {\n        let strbuf = \"\";\n        for (let key in this.rangeStacks) {\n            let stack = this.rangeStacks[key];\n            strbuf += internedSpaces(indentCount);\n            strbuf += `${key}: `;\n            for (let item of stack.items) {\n                strbuf += `${item.toString()} `;\n            }\n            strbuf += \"\\n\";\n        }\n        return strbuf;\n    }\n}\nfunction nodeTotalLength(mergeTree, node) {\n    if (!node.isLeaf()) {\n        return node.cachedLength;\n    }\n    else {\n        return mergeTree.localNetLength(node);\n    }\n}\nexport class BaseSegment extends MergeNode {\n    constructor(seq, clientId) {\n        super();\n        this.seq = seq;\n        this.clientId = clientId;\n        this.segmentGroups = new SegmentGroupCollection(this);\n    }\n    addLocalRef(lref) {\n        if ((this.hierRefCount === undefined) || (this.hierRefCount === 0)) {\n            if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n                this.hierRefCount = 1;\n            }\n        }\n        if (!this.localRefs) {\n            this.localRefs = [lref];\n        }\n        else {\n            let i = 0, len = this.localRefs.length;\n            for (; i < len; i++) {\n                if (this.localRefs[i].offset > lref.offset) {\n                    break;\n                }\n            }\n            if (i < len) {\n                for (let k = len; k > i; k--) {\n                    this.localRefs[k] = this.localRefs[k - 1];\n                }\n                this.localRefs[i] = lref;\n            }\n            else {\n                this.localRefs.push(lref);\n            }\n        }\n    }\n    removeLocalRef(lref) {\n        if (this.localRefs) {\n            for (let i = 0, len = this.localRefs.length; i < len; i++) {\n                if (lref === this.localRefs[i]) {\n                    for (let j = i; j < (len - 1); j++) {\n                        this.localRefs[j] = this.localRefs[j + 1];\n                    }\n                    this.localRefs.length--;\n                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {\n                        this.hierRefCount--;\n                    }\n                    return lref;\n                }\n            }\n        }\n    }\n    splitLocalRefs(pos, leafSegment) {\n        let aRefs = [];\n        let bRefs = [];\n        for (let localRef of this.localRefs) {\n            if (localRef.offset < pos) {\n                aRefs.push(localRef);\n            }\n            else {\n                localRef.segment = leafSegment;\n                localRef.offset -= pos;\n                bRefs.push(localRef);\n            }\n        }\n        this.localRefs = aRefs;\n        leafSegment.localRefs = bRefs;\n    }\n    addProperties(newProps, op, seq) {\n        this.properties = Properties.addProperties(this.properties, newProps, op, seq);\n    }\n    hasProperty(key) {\n        return this.properties && (this.properties[key] !== undefined);\n    }\n    isLeaf() {\n        return true;\n    }\n    cloneInto(b) {\n        b.clientId = this.clientId;\n        // TODO: deep clone properties\n        b.properties = Properties.extend(Properties.createMap(), this.properties);\n        b.removedClientId = this.removedClientId;\n        // TODO: copy removed client overlap and branch removal info\n        b.removedSeq = this.removedSeq;\n        b.seq = this.seq;\n    }\n    canAppend(segment, mergeTree) {\n        return false;\n    }\n    addSerializedProps(jseg) {\n        if (this.properties) {\n            jseg.props = this.properties;\n        }\n    }\n    toJSONObject() {\n        let obj = Properties.createMap();\n        this.addSerializedProps(obj);\n        return obj;\n    }\n    // TODO: use function in properties.ts\n    matchProperties(b) {\n        if (this.properties) {\n            if (!b.properties) {\n                return false;\n            }\n            else {\n                let bProps = b.properties;\n                // for now, straightforward; later use hashing\n                for (let key in this.properties) {\n                    if (bProps[key] === undefined) {\n                        return false;\n                    }\n                    else if (bProps[key] !== this.properties[key]) {\n                        return false;\n                    }\n                }\n                for (let key in bProps) {\n                    if (this.properties[key] === undefined) {\n                        return false;\n                    }\n                }\n            }\n        }\n        else {\n            if (b.properties) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst MaxRun = 128;\nexport class SubSequence extends BaseSegment {\n    constructor(items, seq, clientId) {\n        super(seq, clientId);\n        this.items = items;\n        this.cachedLength = items.length;\n    }\n    toJSONObject() {\n        const obj = { items: this.items };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    splitAt(pos) {\n        if (pos > 0) {\n            const remainingItems = this.items.slice(pos);\n            this.items = this.items.slice(0, pos);\n            this.cachedLength = this.items.length;\n            const leafSegment = new SubSequence(remainingItems, this.seq, this.clientId);\n            if (this.properties) {\n                leafSegment.addProperties(Properties.extend(Properties.createMap(), this.properties));\n            }\n            segmentCopy(this, leafSegment);\n            if (this.localRefs) {\n                this.splitLocalRefs(pos, leafSegment);\n            }\n            return leafSegment;\n        }\n    }\n    clone(start = 0, end) {\n        let clonedItems = this.items;\n        if (end === undefined) {\n            clonedItems = clonedItems.slice(start);\n        }\n        else {\n            clonedItems = clonedItems.slice(start, end);\n        }\n        const b = new SubSequence(clonedItems, this.seq, this.clientId);\n        this.cloneInto(b);\n        return b;\n    }\n    getType() {\n        return SegmentType.Run;\n    }\n    canAppend(segment, mergeTree) {\n        if (!this.removedSeq) {\n            if (segment.getType() === SegmentType.Run) {\n                if (this.matchProperties(segment)) {\n                    const branchId = mergeTree.getBranchId(this.clientId);\n                    const segBranchId = mergeTree.getBranchId(segment.clientId);\n                    if ((segBranchId === branchId) && (mergeTree.localNetLength(segment) > 0)) {\n                        return ((this.cachedLength <= MaxRun) ||\n                            (segment.cachedLength <= MaxRun));\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    toString() {\n        return this.items.toString();\n    }\n    append(segment) {\n        if (segment.getType() === SegmentType.Run) {\n            const rseg = segment;\n            if (segment.localRefs) {\n                const adj = this.cachedLength;\n                for (const localRef of segment.localRefs) {\n                    localRef.offset += adj;\n                    localRef.segment = this;\n                }\n            }\n            this.items = this.items.concat(rseg.items);\n            this.cachedLength = this.items.length;\n            return this;\n        }\n        else {\n            throw new Error(\"can only append another run segment\");\n        }\n    }\n    // TODO: retain removed items for undo\n    // returns true if entire run removed\n    removeRange(start, end) {\n        let remnantItems = [];\n        const len = this.items.length;\n        if (start > 0) {\n            remnantItems = remnantItems.concat(this.items.slice(0, start));\n        }\n        if (end < len) {\n            remnantItems = remnantItems.concat(this.items.slice(end));\n        }\n        this.items = remnantItems;\n        this.cachedLength = this.items.length;\n        return (this.items.length === 0);\n    }\n}\nexport function runToSeg(segSpec) {\n    const seg = new SubSequence(segSpec.items, UniversalSequenceNumber, LocalClientId);\n    if (segSpec.props) {\n        seg.addProperties(segSpec.props);\n    }\n    return seg;\n}\n/**\n * A non-shared placeholder for external content.\n */\nexport class ExternalSegment extends BaseSegment {\n    constructor(placeholderSeq, sequenceLength, sequenceIndex) {\n        super();\n        this.placeholderSeq = placeholderSeq;\n        this.sequenceLength = sequenceLength;\n        this.sequenceIndex = sequenceIndex;\n    }\n    toJSONObject() {\n        let obj = { sequenceIndex: this.sequenceIndex, sequenceLength: this.sequenceLength };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    mergeTreeInsert(mergeTree, pos, refSeq, clientId, seq, opArgs) {\n        mergeTree.insert(pos, refSeq, clientId, seq, this, (block, pos, refSeq, clientId, seq, eseg) => mergeTree.blockInsert(block, pos, refSeq, clientId, seq, eseg), opArgs);\n    }\n    clone() {\n        throw new Error('clone not implemented');\n    }\n    append(segment) {\n        throw new Error('Can not append to external segment');\n    }\n    getType() {\n        return SegmentType.External;\n    }\n    removeRange(start, end) {\n        throw new Error('Method not implemented.');\n    }\n    splitAt(pos) {\n        throw new Error('Method not implemented.');\n    }\n}\nexport let reservedTileLabelsKey = \"referenceTileLabels\";\nexport let reservedRangeLabelsKey = \"referenceRangeLabels\";\nexport let reservedMarkerIdKey = \"markerId\";\nexport let reservedMarkerSimpleTypeKey = \"markerSimpleType\";\nfunction refHasTileLabels(refPos) {\n    return (refPos.refType & ops.ReferenceType.Tile) &&\n        refPos.properties && refPos.properties[reservedTileLabelsKey];\n}\nfunction refHasRangeLabels(refPos) {\n    return (refPos.refType & (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) &&\n        refPos.properties && refPos.properties[reservedRangeLabelsKey];\n}\nfunction refHasTileLabel(refPos, label) {\n    if (refPos.hasTileLabels()) {\n        for (let refLabel of refPos.properties[reservedTileLabelsKey]) {\n            if (label === refLabel) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction refHasRangeLabel(refPos, label) {\n    if (refPos.hasRangeLabels()) {\n        for (let refLabel of refPos.properties[reservedRangeLabelsKey]) {\n            if (label === refLabel) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction refGetTileLabels(refPos) {\n    if (refPos.hasTileLabels()) {\n        return refPos.properties[reservedTileLabelsKey];\n    }\n    else {\n        return [];\n    }\n}\nfunction refGetRangeLabels(refPos) {\n    if (refPos.hasRangeLabels()) {\n        return refPos.properties[reservedRangeLabelsKey];\n    }\n    else {\n        return [];\n    }\n}\nexport class Marker extends BaseSegment {\n    constructor(refType, seq, clientId) {\n        super(seq, clientId);\n        this.refType = refType;\n        this.cachedLength = 1;\n    }\n    static make(refType, props, seq, clientId) {\n        let marker = new Marker(refType, seq, clientId);\n        if (props) {\n            marker.addProperties(props);\n        }\n        return marker;\n    }\n    toJSONObject() {\n        let obj = { marker: { refType: this.refType } };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    clone() {\n        let b = Marker.make(this.refType, this.properties, this.seq, this.clientId);\n        this.cloneInto(b);\n        return b;\n    }\n    getSegment() {\n        return this;\n    }\n    getOffset() {\n        return 0;\n    }\n    hasSimpleType(simpleTypeName) {\n        return this.hasProperty(reservedMarkerSimpleTypeKey) &&\n            this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;\n    }\n    getProperties() {\n        return this.properties;\n    }\n    getId() {\n        if (this.properties && this.properties[reservedMarkerIdKey]) {\n            return this.properties[reservedMarkerIdKey];\n        }\n    }\n    hasTileLabels() {\n        return refHasTileLabels(this);\n    }\n    hasRangeLabels() {\n        return refHasRangeLabels(this);\n    }\n    hasTileLabel(label) {\n        return refHasTileLabel(this, label);\n    }\n    hasRangeLabel(label) {\n        return refHasRangeLabel(this, label);\n    }\n    getTileLabels() {\n        return refGetTileLabels(this);\n    }\n    getRangeLabels() {\n        return refGetRangeLabels(this);\n    }\n    toString() {\n        let bbuf = \"\";\n        if (this.refType & ops.ReferenceType.Tile) {\n            bbuf += \"Tile\";\n        }\n        if (this.refType & ops.ReferenceType.NestBegin) {\n            if (bbuf.length > 0) {\n                bbuf += \"; \";\n            }\n            bbuf += \"RangeBegin\";\n        }\n        if (this.refType & ops.ReferenceType.NestEnd) {\n            if (bbuf.length > 0) {\n                bbuf += \"; \";\n            }\n            bbuf += \"RangeEnd\";\n        }\n        let lbuf = \"\";\n        let id = this.getId();\n        if (id) {\n            bbuf += ` (${id}) `;\n        }\n        if (this.hasTileLabels()) {\n            lbuf += \"tile -- \";\n            let labels = this.properties[reservedTileLabelsKey];\n            for (let i = 0, len = labels.length; i < len; i++) {\n                let tileLabel = labels[i];\n                if (i > 0) {\n                    lbuf += \"; \";\n                }\n                lbuf += tileLabel;\n            }\n        }\n        if (this.hasRangeLabels()) {\n            let rangeKind = \"begin\";\n            if (this.refType & ops.ReferenceType.NestEnd) {\n                rangeKind = \"end\";\n            }\n            if (this.hasTileLabels()) {\n                lbuf += \" \";\n            }\n            lbuf += `range ${rangeKind} -- `;\n            let labels = this.properties[reservedRangeLabelsKey];\n            for (let i = 0, len = labels.length; i < len; i++) {\n                let rangeLabel = labels[i];\n                if (i > 0) {\n                    lbuf += \"; \";\n                }\n                lbuf += rangeLabel;\n            }\n        }\n        let pbuf = \"\";\n        if (this.properties) {\n            pbuf += JSON.stringify(this.properties);\n        }\n        return `M ${bbuf}: ${lbuf} ${pbuf}`;\n    }\n    getType() {\n        return SegmentType.Marker;\n    }\n    removeRange(start, end) {\n        console.log(\"remove range called on marker\");\n        return false;\n    }\n    splitAt(pos) {\n        return undefined;\n    }\n    canAppend(segment) {\n        return false;\n    }\n    append(segment) {\n        return undefined;\n    }\n}\nexport class TextSegment extends BaseSegment {\n    constructor(text, seq, clientId) {\n        super(seq, clientId);\n        this.text = text;\n        this.cachedLength = text.length;\n    }\n    static make(text, props, seq, clientId) {\n        let tseg = new TextSegment(text, seq, clientId);\n        if (props) {\n            tseg.addProperties(props);\n        }\n        return tseg;\n    }\n    toJSONObject() {\n        let obj = { text: this.text };\n        super.addSerializedProps(obj);\n        return obj;\n    }\n    splitAt(pos) {\n        if (pos > 0) {\n            let remainingText = this.text.substring(pos);\n            this.text = this.text.substring(0, pos);\n            this.cachedLength = this.text.length;\n            let leafSegment = new TextSegment(remainingText, this.seq, this.clientId);\n            if (this.properties) {\n                leafSegment.addProperties(Properties.extend(Properties.createMap(), this.properties));\n            }\n            segmentCopy(this, leafSegment);\n            if (this.localRefs) {\n                this.splitLocalRefs(pos, leafSegment);\n            }\n            return leafSegment;\n        }\n    }\n    clone(start = 0, end) {\n        let text = this.text;\n        if (end === undefined) {\n            text = text.substring(start);\n        }\n        else {\n            text = text.substring(start, end);\n        }\n        let b = TextSegment.make(text, this.properties, this.seq, this.clientId);\n        this.cloneInto(b);\n        return b;\n    }\n    getType() {\n        return SegmentType.Text;\n    }\n    canAppend(segment, mergeTree) {\n        if ((!this.removedSeq) && (this.text.charAt(this.text.length - 1) != '\\n')) {\n            if (segment.getType() === SegmentType.Text) {\n                if (this.matchProperties(segment)) {\n                    let branchId = mergeTree.getBranchId(this.clientId);\n                    let segBranchId = mergeTree.getBranchId(segment.clientId);\n                    if ((segBranchId === branchId) && (mergeTree.localNetLength(segment) > 0)) {\n                        return ((this.cachedLength <= MergeTree.TextSegmentGranularity) ||\n                            (segment.cachedLength <= MergeTree.TextSegmentGranularity));\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    toString() {\n        return this.text;\n    }\n    append(segment) {\n        if (segment.getType() === SegmentType.Text) {\n            if (segment.localRefs) {\n                let adj = this.text.length;\n                for (let localRef of segment.localRefs) {\n                    localRef.offset += adj;\n                    localRef.segment = this;\n                }\n            }\n            this.text += segment.text;\n            this.cachedLength = this.text.length;\n            return this;\n        }\n        else {\n            throw new Error(\"can only append text segment\");\n        }\n    }\n    // TODO: retain removed text for undo\n    // returns true if entire string removed\n    removeRange(start, end) {\n        let remnantString = \"\";\n        let len = this.text.length;\n        if (start > 0) {\n            remnantString += this.text.substring(0, start);\n        }\n        if (end < len) {\n            remnantString += this.text.substring(end);\n        }\n        this.text = remnantString;\n        this.cachedLength = remnantString.length;\n        return (remnantString.length == 0);\n    }\n}\nexport function segmentCopy(from, to) {\n    to.parent = from.parent;\n    to.removedClientId = from.removedClientId;\n    to.removedSeq = from.removedSeq;\n    if (from.removalsByBranch) {\n        to.removalsByBranch = [];\n        for (let i = 0, len = from.removalsByBranch.length; i < len; i++) {\n            let fromRemovalInfo = from.removalsByBranch[i];\n            if (fromRemovalInfo) {\n                to.removalsByBranch[i] = {\n                    removedClientId: fromRemovalInfo.removedClientId,\n                    removedSeq: fromRemovalInfo.removedSeq,\n                    removedClientOverlap: fromRemovalInfo.removedClientOverlap,\n                };\n            }\n        }\n    }\n    to.seq = from.seq;\n    to.clientId = from.clientId;\n    to.removedClientOverlap = from.removedClientOverlap;\n    from.segmentGroups.copyTo(to);\n}\nfunction incrementalGatherText(segment, state) {\n    if (segment.getType() == SegmentType.Text) {\n        let textSegment = segment;\n        if (MergeTree.traceGatherText) {\n            console.log(`@cli ${this.collabWindow ? this.collabwindow.clientId : -1} gather seg seq ${textSegment.seq} rseq ${textSegment.removedSeq} text ${textSegment.text}`);\n        }\n        if ((state.start <= 0) && (state.end >= textSegment.text.length)) {\n            state.context.text += textSegment.text;\n        }\n        else {\n            if (state.end >= textSegment.text.length) {\n                state.context.text += textSegment.text.substring(state.start);\n            }\n            else {\n                state.context.text += textSegment.text.substring(state.start, state.end);\n            }\n        }\n    }\n    state.op = IncrementalExecOp.Go;\n}\nexport var IncrementalExecOp;\n(function (IncrementalExecOp) {\n    IncrementalExecOp[IncrementalExecOp[\"Go\"] = 0] = \"Go\";\n    IncrementalExecOp[IncrementalExecOp[\"Stop\"] = 1] = \"Stop\";\n    IncrementalExecOp[IncrementalExecOp[\"Yield\"] = 2] = \"Yield\";\n})(IncrementalExecOp || (IncrementalExecOp = {}));\nexport class IncrementalMapState {\n    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {\n        this.block = block;\n        this.actions = actions;\n        this.pos = pos;\n        this.refSeq = refSeq;\n        this.clientId = clientId;\n        this.context = context;\n        this.start = start;\n        this.end = end;\n        this.childIndex = childIndex;\n        this.op = IncrementalExecOp.Go;\n    }\n}\n/**\n * Sequence numbers for shared segments start at 1 or greater.  Every segment marked\n * with sequence number zero will be counted as part of the requested string.\n */\nexport const UniversalSequenceNumber = 0;\nexport const UnassignedSequenceNumber = -1;\nexport const TreeMaintenanceSequenceNumber = -2;\nexport const LocalClientId = -1;\nexport const NonCollabClient = -2;\nexport class CollaborationWindow {\n    constructor() {\n        this.clientId = LocalClientId;\n        this.collaborating = false;\n        // lowest-numbered segment in window; no client can reference a state before this one\n        this.minSeq = 0;\n        // highest-numbered segment in window and current\n        // reference segment for this client\n        this.currentSeq = 0;\n    }\n    loadFrom(a) {\n        this.clientId = a.clientId;\n        this.collaborating = a.collaborating;\n        this.localMinSeq = a.localMinSeq;\n        this.globalMinSeq = a.globalMinSeq;\n        this.minSeq = a.minSeq;\n        this.currentSeq = a.currentSeq;\n    }\n}\n/**\n * Returns the partial length whose sequence number is\n * the greatest sequence number within a that is\n * less than or equal to key.\n * @param {PartialLength[]} a array of partial segment lengths\n * @param {number} key sequence number\n */\nfunction latestLEQ(a, key) {\n    let best = -1;\n    let lo = 0;\n    let hi = a.length - 1;\n    while (lo <= hi) {\n        let mid = lo + Math.floor((hi - lo) / 2);\n        if (a[mid].seq <= key) {\n            if ((best < 0) || (a[best].seq < a[mid].seq)) {\n                best = mid;\n            }\n            lo = mid + 1;\n        }\n        else {\n            hi = mid - 1;\n        }\n    }\n    return best;\n}\nexport function compareNumbers(a, b) {\n    return a - b;\n}\nexport function compareStrings(a, b) {\n    return a.localeCompare(b);\n}\n/**\n * Keep track of partial sums of segment lengths for all sequence numbers\n * in the current collaboration window (if any).  Only used during active\n * collaboration.\n */\nexport class PartialSequenceLengths {\n    constructor(minSeq) {\n        this.minSeq = minSeq;\n        this.minLength = 0;\n        this.segmentCount = 0;\n        this.partialLengths = [];\n        this.clientSeqNumbers = [];\n    }\n    cliLatestLEQ(clientId, refSeq) {\n        let cliSeqs = this.clientSeqNumbers[clientId];\n        if (cliSeqs) {\n            return latestLEQ(cliSeqs, refSeq);\n        }\n        else {\n            return -1;\n        }\n    }\n    cliLatest(clientId) {\n        let cliSeqs = this.clientSeqNumbers[clientId];\n        if (cliSeqs && (cliSeqs.length > 0)) {\n            return cliSeqs.length - 1;\n        }\n        else {\n            return -1;\n        }\n    }\n    compare(b) {\n        function comparePartialLengths(aList, bList) {\n            let aLen = aList.length;\n            let bLen = bList.length;\n            if (aLen != bLen) {\n                return false;\n            }\n            for (let i = 0; i < aLen; i++) {\n                let aPartial = aList[i];\n                let bPartial = bList[i];\n                if ((aPartial.seq != bPartial.seq) || (aPartial.clientId != bPartial.clientId) ||\n                    (aPartial.seglen != bPartial.seglen) || (aPartial.len != bPartial.len) ||\n                    (aPartial.overlapRemoveClients && (!bPartial.overlapRemoveClients))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (!comparePartialLengths(this.partialLengths, b.partialLengths)) {\n            return false;\n        }\n        for (let clientId in this.clientSeqNumbers) {\n            if (!b.clientSeqNumbers[clientId]) {\n                return false;\n            }\n            else if (!comparePartialLengths(this.clientSeqNumbers[clientId], b.clientSeqNumbers[clientId])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    branchToString(glc, branchId = 0) {\n        let buf = \"\";\n        for (let partial of this.partialLengths) {\n            buf += `(${partial.seq},${partial.len}) `;\n        }\n        for (let clientId in this.clientSeqNumbers) {\n            if (this.clientSeqNumbers[clientId].length > 0) {\n                buf += `Client `;\n                if (glc) {\n                    buf += `${glc(+clientId)}`;\n                }\n                else {\n                    buf += `${clientId}`;\n                }\n                buf += '[';\n                for (let partial of this.clientSeqNumbers[clientId]) {\n                    buf += `(${partial.seq},${partial.len})`;\n                }\n                buf += ']';\n            }\n        }\n        buf = `Br ${branchId}, min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};` + buf;\n        return buf;\n    }\n    toString(glc, indentCount = 0) {\n        let buf = this.branchToString(glc);\n        if (this.downstreamPartialLengths) {\n            for (let i = 0, len = this.downstreamPartialLengths.length; i < len; i++) {\n                buf += \"\\n\";\n                buf += internedSpaces(indentCount);\n                buf += this.downstreamPartialLengths[i].branchToString(glc, i + 1);\n            }\n        }\n        return buf;\n    }\n    getPartialLength(mergeTree, refSeq, clientId) {\n        let branchId = mergeTree.getBranchId(clientId);\n        if (MergeTree.traceTraversal) {\n            console.log(`plen branch ${branchId}`);\n        }\n        if (branchId > 0) {\n            return this.downstreamPartialLengths[branchId - 1].getBranchPartialLength(refSeq, clientId);\n        }\n        else {\n            return this.getBranchPartialLength(refSeq, clientId);\n        }\n    }\n    getBranchPartialLength(refSeq, clientId) {\n        let pLen = this.minLength;\n        let seqIndex = latestLEQ(this.partialLengths, refSeq);\n        let cliLatestindex = this.cliLatest(clientId);\n        let cliSeq = this.clientSeqNumbers[clientId];\n        if (seqIndex >= 0) {\n            pLen += this.partialLengths[seqIndex].len;\n            if (cliLatestindex >= 0) {\n                let cliLatest = cliSeq[cliLatestindex];\n                if (cliLatest.seq > refSeq) {\n                    pLen += cliLatest.len;\n                    let precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);\n                    if (precedingCliIndex >= 0) {\n                        pLen -= cliSeq[precedingCliIndex].len;\n                    }\n                }\n            }\n        }\n        else {\n            if (cliLatestindex >= 0) {\n                let cliLatest = cliSeq[cliLatestindex];\n                pLen += cliLatest.len;\n            }\n        }\n        return pLen;\n    }\n    // clear away partial sums for sequence numbers earlier than the current window\n    zamboni(segmentWindow) {\n        function copyDown(partialLengths) {\n            let mindex = latestLEQ(partialLengths, segmentWindow.minSeq);\n            let minLength = 0;\n            //console.log(`mindex ${mindex}`);\n            if (mindex >= 0) {\n                minLength = partialLengths[mindex].len;\n                let seqCount = partialLengths.length;\n                if (mindex <= (seqCount - 1)) {\n                    // still some entries remaining\n                    let remainingCount = (seqCount - mindex) - 1;\n                    //copy down\n                    for (let i = 0; i < remainingCount; i++) {\n                        partialLengths[i] = partialLengths[i + mindex + 1];\n                        partialLengths[i].len -= minLength;\n                    }\n                    partialLengths.length = remainingCount;\n                }\n            }\n            return minLength;\n        }\n        this.minLength += copyDown(this.partialLengths);\n        for (let clientId in this.clientSeqNumbers) {\n            let cliPartials = this.clientSeqNumbers[clientId];\n            if (cliPartials) {\n                copyDown(cliPartials);\n            }\n        }\n    }\n    addClientSeqNumber(clientId, seq, seglen) {\n        if (this.clientSeqNumbers[clientId] === undefined) {\n            this.clientSeqNumbers[clientId] = [];\n        }\n        let cli = this.clientSeqNumbers[clientId];\n        let pLen = seglen;\n        if (cli.length > 0) {\n            pLen += cli[cli.length - 1].len;\n        }\n        cli.push({ seq: seq, len: pLen, seglen: seglen });\n    }\n    // assumes sequence number already coalesced\n    addClientSeqNumberFromPartial(partialLength) {\n        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);\n        if (partialLength.overlapRemoveClients) {\n            partialLength.overlapRemoveClients.map((oc) => {\n                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);\n                return true;\n            });\n        }\n    }\n    update(mergeTree, block, seq, clientId, collabWindow) {\n        let segBranchId = mergeTree.getBranchId(clientId);\n        // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);\n        if (segBranchId == 0) {\n            this.updateBranch(mergeTree, 0, block, seq, clientId, collabWindow);\n        }\n        if (mergeTree.localBranchId > 0) {\n            for (let i = 0; i < mergeTree.localBranchId; i++) {\n                let branchId = i + 1;\n                if (segBranchId <= branchId) {\n                    this.downstreamPartialLengths[i].updateBranch(mergeTree, branchId, block, seq, clientId, collabWindow);\n                }\n            }\n        }\n    }\n    // assume: seq is latest sequence number; no structural change to sub-tree, but a segment\n    // with sequence number seq has been added within the sub-tree\n    // TODO: assert client id matches\n    updateBranch(mergeTree, branchId, node, seq, clientId, collabWindow) {\n        let seqSeglen = 0;\n        let segCount = 0;\n        // compute length for seq across children\n        for (let i = 0; i < node.childCount; i++) {\n            let child = node.children[i];\n            if (!child.isLeaf()) {\n                let childBlock = child;\n                let branchPartialLengths = childBlock.partialLengths.partialLengthsForBranch(branchId);\n                let partialLengths = branchPartialLengths.partialLengths;\n                let seqIndex = latestLEQ(partialLengths, seq);\n                if (seqIndex >= 0) {\n                    let leqPartial = partialLengths[seqIndex];\n                    if (leqPartial.seq == seq) {\n                        seqSeglen += leqPartial.seglen;\n                    }\n                }\n                segCount += branchPartialLengths.segmentCount;\n            }\n            else {\n                let segment = child;\n                let segBranchId = mergeTree.getBranchId(segment.clientId);\n                let removalInfo = mergeTree.getRemovalInfo(branchId, segBranchId, segment);\n                if (segment.seq == seq) {\n                    if (removalInfo.removedSeq !== seq) {\n                        seqSeglen += segment.cachedLength;\n                    }\n                }\n                else {\n                    if (removalInfo.removedSeq === seq) {\n                        seqSeglen -= segment.cachedLength;\n                    }\n                }\n                segCount++;\n            }\n        }\n        this.segmentCount = segCount;\n        function addSeq(partialLengths, seq, clientId) {\n            let seqPartialLen;\n            let penultPartialLen;\n            let leqIndex = latestLEQ(partialLengths, seq);\n            if (leqIndex >= 0) {\n                let pLen = partialLengths[leqIndex];\n                if (pLen.seq == seq) {\n                    seqPartialLen = pLen;\n                    leqIndex = latestLEQ(partialLengths, seq - 1);\n                    if (leqIndex >= 0) {\n                        penultPartialLen = partialLengths[leqIndex];\n                    }\n                }\n                else {\n                    penultPartialLen = pLen;\n                }\n            }\n            if (seqPartialLen === undefined) {\n                seqPartialLen = {\n                    seq: seq,\n                    seglen: seqSeglen,\n                    clientId: clientId\n                };\n                partialLengths.push(seqPartialLen);\n            }\n            else {\n                seqPartialLen.seglen = seqSeglen;\n                // assert client id matches\n            }\n            if (penultPartialLen !== undefined) {\n                seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;\n            }\n            else {\n                seqPartialLen.len = seqPartialLen.seglen;\n            }\n        }\n        addSeq(this.partialLengths, seq, clientId);\n        if (this.clientSeqNumbers[clientId] === undefined) {\n            this.clientSeqNumbers[clientId] = [];\n        }\n        addSeq(this.clientSeqNumbers[clientId], seq);\n        //    console.log(this.toString());\n        if (PartialSequenceLengths.options.zamboni) {\n            this.zamboni(collabWindow);\n        }\n        //   console.log('ZZZ');\n        //   console.log(this.toString());\n    }\n    static fromLeaves(mergeTree, branchId, combinedPartialLengths, block, collabWindow) {\n        combinedPartialLengths.minLength = 0;\n        combinedPartialLengths.segmentCount = block.childCount;\n        function getOverlapClients(overlapClientids, seglen) {\n            let bst = new Collections.RedBlackTree(compareNumbers);\n            for (let clientId of overlapClientids) {\n                bst.put(clientId, { clientId: clientId, seglen: seglen });\n            }\n            return bst;\n        }\n        function accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {\n            if (partialLength.overlapRemoveClients) {\n                for (let clientId of overlapRemoveClientIds) {\n                    let ovlapClientNode = partialLength.overlapRemoveClients.get(clientId);\n                    if (!ovlapClientNode) {\n                        partialLength.overlapRemoveClients.put(clientId, { clientId: clientId, seglen: seglen });\n                    }\n                    else {\n                        ovlapClientNode.data.seglen += seglen;\n                    }\n                }\n            }\n            else {\n                partialLength.overlapRemoveClients = getOverlapClients(overlapRemoveClientIds, seglen);\n            }\n        }\n        function insertSegment(segment, removedSeq = false, removalInfo = undefined) {\n            let seq = segment.seq;\n            let segmentLen = segment.cachedLength;\n            let clientId = segment.clientId;\n            let removeClientOverlap;\n            if (removedSeq) {\n                seq = removalInfo.removedSeq;\n                segmentLen = -segmentLen;\n                clientId = removalInfo.removedClientId;\n                if (removalInfo.removedClientOverlap) {\n                    removeClientOverlap = removalInfo.removedClientOverlap;\n                }\n            }\n            let seqPartials = combinedPartialLengths.partialLengths;\n            let seqPartialsLen = seqPartials.length;\n            // find the first entry with sequence number greater or equal to seq\n            let indexFirstGTE = 0;\n            for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {\n                if (seqPartials[indexFirstGTE].seq >= seq) {\n                    break;\n                }\n            }\n            if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq == seq)) {\n                seqPartials[indexFirstGTE].seglen += segmentLen;\n                if (removeClientOverlap) {\n                    accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);\n                }\n            }\n            else {\n                let pLen;\n                if (removeClientOverlap) {\n                    let overlapClients = getOverlapClients(removeClientOverlap, segmentLen);\n                    pLen = { seq: seq, clientId: clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };\n                }\n                else {\n                    pLen = { seq: seq, clientId: clientId, len: 0, seglen: segmentLen };\n                }\n                if (indexFirstGTE < seqPartialsLen) {\n                    // shift entries with greater sequence numbers\n                    // TODO: investigate performance improvement using BST\n                    for (let k = seqPartialsLen; k > indexFirstGTE; k--) {\n                        seqPartials[k] = seqPartials[k - 1];\n                    }\n                    seqPartials[indexFirstGTE] = pLen;\n                }\n                else {\n                    seqPartials.push(pLen);\n                }\n            }\n        }\n        function seqLTE(seq, minSeq) {\n            return (seq != UnassignedSequenceNumber) && (seq <= minSeq);\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            let child = block.children[i];\n            if (child.isLeaf()) {\n                // leaf segment\n                let segment = child;\n                let segBranchId = mergeTree.getBranchId(segment.clientId);\n                // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);\n                if (segBranchId <= branchId) {\n                    if (seqLTE(segment.seq, collabWindow.minSeq)) {\n                        combinedPartialLengths.minLength += segment.cachedLength;\n                    }\n                    else {\n                        if (segment.seq != UnassignedSequenceNumber) {\n                            insertSegment(segment);\n                        }\n                    }\n                    let removalInfo = mergeTree.getRemovalInfo(branchId, segBranchId, segment);\n                    if (seqLTE(removalInfo.removedSeq, collabWindow.minSeq)) {\n                        combinedPartialLengths.minLength -= segment.cachedLength;\n                    }\n                    else {\n                        if ((removalInfo.removedSeq !== undefined) &&\n                            (removalInfo.removedSeq != UnassignedSequenceNumber)) {\n                            insertSegment(segment, true, removalInfo);\n                        }\n                    }\n                }\n            }\n        }\n        // post-process correctly-ordered partials computing sums and creating\n        // lists for each present client id\n        let seqPartials = combinedPartialLengths.partialLengths;\n        let seqPartialsLen = seqPartials.length;\n        let prevLen = 0;\n        for (let i = 0; i < seqPartialsLen; i++) {\n            seqPartials[i].len = prevLen + seqPartials[i].seglen;\n            prevLen = seqPartials[i].len;\n            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);\n        }\n    }\n    static combine(mergeTree, block, collabWindow, recur = false) {\n        let partialLengthsTopBranch = PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, 0, recur);\n        if (mergeTree.localBranchId > 0) {\n            partialLengthsTopBranch.downstreamPartialLengths = [];\n            for (let i = 0; i < mergeTree.localBranchId; i++) {\n                partialLengthsTopBranch.downstreamPartialLengths[i] =\n                    PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, i + 1, recur);\n            }\n        }\n        return partialLengthsTopBranch;\n    }\n    partialLengthsForBranch(branchId) {\n        if (branchId > 0) {\n            return this.downstreamPartialLengths[branchId - 1];\n        }\n        else {\n            return this;\n        }\n    }\n    /**\n     * Combine the partial lengths of block's children\n     * @param {IMergeBlock} block an interior node; it is assumed that each interior node child of this block\n     * has its partials up to date\n     * @param {CollaborationWindow} collabWindow segment window fo the segment tree containing textSegmentBlock\n     */\n    static combineBranch(mergeTree, block, collabWindow, branchId, recur = false) {\n        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n        PartialSequenceLengths.fromLeaves(mergeTree, branchId, combinedPartialLengths, block, collabWindow);\n        let prevPartial;\n        function combineOverlapClients(a, b) {\n            if (a.overlapRemoveClients) {\n                if (b.overlapRemoveClients) {\n                    b.overlapRemoveClients.map((bProp) => {\n                        let aProp = a.overlapRemoveClients.get(bProp.key);\n                        if (aProp) {\n                            aProp.data.seglen += bProp.data.seglen;\n                        }\n                        else {\n                            a.overlapRemoveClients.put(bProp.data.clientId, bProp.data);\n                        }\n                        return true;\n                    });\n                }\n            }\n            else {\n                a.overlapRemoveClients = b.overlapRemoveClients;\n            }\n        }\n        function addNext(partialLength) {\n            let seq = partialLength.seq;\n            let pLen = 0;\n            if (prevPartial) {\n                if (prevPartial.seq == partialLength.seq) {\n                    prevPartial.seglen += partialLength.seglen;\n                    prevPartial.len += partialLength.seglen;\n                    combineOverlapClients(prevPartial, partialLength);\n                    return;\n                }\n                else {\n                    pLen = prevPartial.len;\n                    // previous sequence number is finished\n                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n                }\n            }\n            prevPartial = {\n                seq: seq,\n                clientId: partialLength.clientId,\n                len: pLen + partialLength.seglen,\n                seglen: partialLength.seglen,\n                overlapRemoveClients: partialLength.overlapRemoveClients\n            };\n            combinedPartialLengths.partialLengths.push(prevPartial);\n        }\n        let childPartials = [];\n        for (let i = 0; i < block.childCount; i++) {\n            let child = block.children[i];\n            if (!child.isLeaf()) {\n                let childBlock = child;\n                if (recur) {\n                    childBlock.partialLengths = PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);\n                }\n                childPartials.push(childBlock.partialLengths.partialLengthsForBranch(branchId));\n            }\n        }\n        let childPartialsLen = childPartials.length;\n        if (childPartialsLen != 0) {\n            // some children are interior nodes\n            if (combinedPartialLengths.partialLengths.length > 0) {\n                // some children were leaves; add combined partials from these segments\n                childPartials.push(combinedPartialLengths);\n                childPartialsLen++;\n                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);\n            }\n            let indices = new Array(childPartialsLen);\n            let childPartialsCounts = new Array(childPartialsLen);\n            for (let i = 0; i < childPartialsLen; i++) {\n                indices[i] = 0;\n                childPartialsCounts[i] = childPartials[i].partialLengths.length;\n                combinedPartialLengths.minLength += childPartials[i].minLength;\n                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;\n            }\n            let outerIndexOfEarliest = 0;\n            let earliestPartialLength;\n            while (outerIndexOfEarliest >= 0) {\n                outerIndexOfEarliest = -1;\n                for (let k = 0; k < childPartialsLen; k++) {\n                    // find next earliest sequence number\n                    if (indices[k] < childPartialsCounts[k]) {\n                        let cpLen = childPartials[k].partialLengths[indices[k]];\n                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {\n                            outerIndexOfEarliest = k;\n                            earliestPartialLength = cpLen;\n                        }\n                    }\n                }\n                if (outerIndexOfEarliest >= 0) {\n                    addNext(earliestPartialLength);\n                    indices[outerIndexOfEarliest]++;\n                }\n            }\n            // add client entry for last partial, if any\n            if (prevPartial) {\n                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);\n            }\n        }\n        // TODO: incremental zamboni during build\n        //console.log(combinedPartialLengths.toString());\n        //console.log(`ZZZ...(min ${segmentWindow.minSeq})`);\n        if (PartialSequenceLengths.options.zamboni) {\n            combinedPartialLengths.zamboni(collabWindow);\n        }\n        //console.log(combinedPartialLengths.toString());\n        return combinedPartialLengths;\n    }\n}\nPartialSequenceLengths.options = {\n    zamboni: true\n};\nexport function clock() {\n    if (process.hrtime) {\n        return process.hrtime();\n    }\n    else {\n        return Date.now();\n    }\n}\nexport function elapsedMicroseconds(start) {\n    if (process.hrtime) {\n        let end = process.hrtime(start);\n        let duration = Math.round((end[0] * 1000000) + (end[1] / 1000));\n        return duration;\n    }\n    else {\n        return 1000 * (Date.now() - start);\n    }\n}\n/**\n * Used for in-memory testing.  This will queue a reference string for each client message.\n */\nexport const useCheckQ = false;\nlet indentStrings = [\"\", \" \", \"  \"];\nexport function internedSpaces(n) {\n    if (indentStrings[n] === undefined) {\n        indentStrings[n] = \"\";\n        for (let i = 0; i < n; i++) {\n            indentStrings[n] += \" \";\n        }\n    }\n    return indentStrings[n];\n}\nexport class RegisterCollection {\n    constructor() {\n        this.clientCollections = Properties.createMap();\n        // TODO: snapshot\n    }\n    set(clientId, id, segments) {\n        if (!this.clientCollections[clientId]) {\n            this.clientCollections[clientId] = Properties.createMap();\n        }\n        this.clientCollections[clientId][id] = segments;\n    }\n    get(clientId, id) {\n        let clientCollection = this.clientCollections[clientId];\n        if (clientCollection) {\n            return clientCollection[id];\n        }\n    }\n    getLength(clientId, id) {\n        let segs = this.get(clientId, id);\n        let len = 0;\n        if (segs) {\n            for (let seg of segs) {\n                len += seg.cachedLength;\n            }\n        }\n        return len;\n    }\n    removeClient(clientId) {\n        this.clientCollections[clientId] = undefined;\n    }\n}\nexport var clientSeqComparer = {\n    min: { refSeq: -1, clientId: \"\" },\n    compare: (a, b) => a.refSeq - b.refSeq\n};\nvar LRUSegmentComparer = {\n    min: { maxSeq: -2 },\n    compare: (a, b) => a.maxSeq - b.maxSeq\n};\nfunction glc(mergeTree, id) {\n    if (mergeTree.getLongClientId) {\n        return mergeTree.getLongClientId(id);\n    }\n    else {\n        return id.toString();\n    }\n}\nfunction applyLeafRangeMarker(marker, searchInfo) {\n    for (let rangeLabel of searchInfo.rangeLabels) {\n        if (marker.hasRangeLabel(rangeLabel)) {\n            let currentStack = searchInfo.stacks[rangeLabel];\n            if (currentStack === undefined) {\n                currentStack = new Collections.Stack();\n                searchInfo.stacks[rangeLabel] = currentStack;\n            }\n            applyRangeReference(currentStack, marker);\n        }\n    }\n}\nfunction recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n    if (segment.getType() === SegmentType.Marker) {\n        let marker = segment;\n        if (marker.refType &\n            (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n            applyLeafRangeMarker(marker, searchInfo);\n        }\n    }\n    return false;\n}\nfunction rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n    if (node.isLeaf()) {\n        let seg = node;\n        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && (seg.getType() === SegmentType.Marker)) {\n            let marker = seg;\n            if (marker.refType &\n                (ops.ReferenceType.NestBegin | ops.ReferenceType.NestEnd)) {\n                applyLeafRangeMarker(marker, searchInfo);\n            }\n        }\n    }\n    else {\n        let block = node;\n        applyStackDelta(searchInfo.stacks, block.rangeStacks);\n    }\n    return true;\n}\nfunction recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {\n    if (segment.getType() === SegmentType.Marker) {\n        let marker = segment;\n        if (marker.hasTileLabel(searchInfo.tileLabel)) {\n            searchInfo.tile = marker;\n        }\n    }\n    return false;\n}\nfunction tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {\n    if (node.isLeaf()) {\n        let seg = node;\n        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && (seg.getType() === SegmentType.Marker)) {\n            let marker = seg;\n            if (marker.hasTileLabel(searchInfo.tileLabel)) {\n                searchInfo.tile = marker;\n            }\n        }\n    }\n    else {\n        let block = node;\n        let marker;\n        if (searchInfo.posPrecedesTile) {\n            marker = block.rightmostTiles[searchInfo.tileLabel];\n        }\n        else {\n            marker = block.leftmostTiles[searchInfo.tileLabel];\n        }\n        if (marker !== undefined) {\n            searchInfo.tile = marker;\n        }\n    }\n    return true;\n}\nlet minListenerComparer = {\n    min: { minRequired: Number.MIN_VALUE },\n    compare: (a, b) => a.minRequired - b.minRequired,\n};\n// represents a sequence of text segments\nexport class MergeTree {\n    // TODO: make and use interface describing options\n    constructor(text, options) {\n        this.text = text;\n        this.options = options;\n        this.windowTime = 0;\n        this.packTime = 0;\n        this.ordTime = 0;\n        this.maxOrdTime = 0;\n        this.blockUpdateMarkers = false;\n        this.collabWindow = new CollaborationWindow();\n        // TODO: change this to ES6 map; add remove on segment remove\n        // for now assume only markers have ids and so point directly at the Segment\n        // if we need to have pointers to non-markers, we can change to point at local refs\n        this.idToSegment = Properties.createMap();\n        this.clientIdToBranchId = [];\n        this.localBranchId = 0;\n        this.minSeqPending = false;\n        this.gatherSegment = (segment, pos, refSeq, clientId, start, end, accumSegments) => {\n            if (start < 0) {\n                start = 0;\n            }\n            if (end > segment.cachedLength) {\n                end = segment.cachedLength;\n            }\n            if (segment.getType() === SegmentType.Text) {\n                let textSegment = segment;\n                accumSegments.segments.push(textSegment.clone(start, end));\n            }\n            else {\n                let marker = segment;\n                accumSegments.segments.push(marker.clone());\n            }\n            return true;\n        };\n        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {\n            if (segment.getType() == SegmentType.Text) {\n                let textSegment = segment;\n                if (MergeTree.traceGatherText) {\n                    console.log(`@cli ${this.getLongClientId(this.collabWindow.clientId)} gather seg seq ${textSegment.seq} rseq ${textSegment.removedSeq} text ${textSegment.text}`);\n                }\n                let beginTags = \"\";\n                let endTags = \"\";\n                if (accumText.parallelArrays) {\n                    // TODO: let clients pass in function to get tag\n                    let tags = [];\n                    let initTags = [];\n                    if (textSegment.properties && (textSegment.properties[\"font-weight\"])) {\n                        tags.push(\"b\");\n                    }\n                    if (textSegment.properties && (textSegment.properties[\"text-decoration\"])) {\n                        tags.push(\"u\");\n                    }\n                    let remTags = [];\n                    if (tags.length > 0) {\n                        for (let tag of tags) {\n                            if (accumText.tagsInProgress.indexOf(tag) < 0) {\n                                beginTags += `<${tag}>`;\n                                initTags.push(tag);\n                            }\n                        }\n                        for (let accumTag of accumText.tagsInProgress) {\n                            if (tags.indexOf(accumTag) < 0) {\n                                endTags += `</${accumTag}>`;\n                                remTags.push(accumTag);\n                            }\n                        }\n                        for (let initTag of initTags.reverse()) {\n                            accumText.tagsInProgress.push(initTag);\n                        }\n                    }\n                    else {\n                        for (let accumTag of accumText.tagsInProgress) {\n                            endTags += `</${accumTag}>`;\n                            remTags.push(accumTag);\n                        }\n                    }\n                    for (let remTag of remTags) {\n                        let remdex = accumText.tagsInProgress.indexOf(remTag);\n                        if (remdex >= 0) {\n                            accumText.tagsInProgress.splice(remdex, 1);\n                        }\n                    }\n                }\n                accumText.textSegment.text += endTags;\n                accumText.textSegment.text += beginTags;\n                if ((start <= 0) && (end >= textSegment.text.length)) {\n                    accumText.textSegment.text += textSegment.text;\n                }\n                else {\n                    if (start < 0) {\n                        start = 0;\n                    }\n                    if (end >= textSegment.text.length) {\n                        accumText.textSegment.text += textSegment.text.substring(start);\n                    }\n                    else {\n                        accumText.textSegment.text += textSegment.text.substring(start, end);\n                    }\n                }\n            }\n            else {\n                if (accumText.placeholder && (accumText.placeholder.length > 0)) {\n                    if (accumText.placeholder === \"*\") {\n                        let marker = segment;\n                        accumText.textSegment.text += `\\n${marker.toString()}`;\n                    }\n                    else {\n                        for (let i = 0; i < segment.cachedLength; i++) {\n                            accumText.textSegment.text += accumText.placeholder;\n                        }\n                    }\n                }\n                else if (accumText.parallelArrays) {\n                    let marker = segment;\n                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {\n                        accumText.parallelMarkers.push(marker);\n                        accumText.parallelText.push(accumText.textSegment.text);\n                        accumText.textSegment.text = \"\";\n                    }\n                }\n            }\n            return true;\n        };\n        this.splitLeafSegment = (segment, pos) => {\n            let segmentChanges = {};\n            if (pos > 0) {\n                segmentChanges.next = segment.splitAt(pos);\n            }\n            return segmentChanges;\n        };\n        this.blockUpdateActions = MergeTree.initBlockUpdateActions;\n        if (options) {\n            if (options.blockUpdateMarkers) {\n                this.blockUpdateMarkers = options.blockUpdateMarkers;\n            }\n            if (options.localMinSeq !== undefined) {\n                this.collabWindow.localMinSeq = options.localMinSeq;\n            }\n        }\n        this.root = this.initialTextNode(this.text);\n    }\n    makeBlock(childCount) {\n        let block;\n        if (this.blockUpdateMarkers) {\n            block = new HierMergeBlock(childCount);\n        }\n        else {\n            block = new MergeBlock(childCount);\n        }\n        block.ordinal = \"\";\n        return block;\n    }\n    initialTextNode(text) {\n        let block = this.makeBlock(1);\n        block.ordinal = \"\";\n        block.assignChild(new TextSegment(text, UniversalSequenceNumber, LocalClientId), 0);\n        block.cachedLength = text.length;\n        return block;\n    }\n    clone() {\n        let options = {\n            blockUpdateMarkers: this.blockUpdateMarkers,\n            localMinSeq: this.collabWindow.localMinSeq\n        };\n        let b = new MergeTree(\"\", options);\n        // for now assume that b will not collaborate\n        b.root = b.blockClone(this.root);\n    }\n    blockClone(block, segments) {\n        let bBlock = this.makeBlock(block.childCount);\n        for (let i = 0; i < block.childCount; i++) {\n            let child = block.children[i];\n            if (child.isLeaf()) {\n                let segment = this.segmentClone(child);\n                bBlock.assignChild(segment, i);\n                if (segments) {\n                    segments.push(segment);\n                }\n            }\n            else {\n                bBlock.assignChild(this.blockClone(child, segments), i);\n            }\n        }\n        this.nodeUpdateLengthNewStructure(bBlock);\n        this.nodeUpdateOrdinals(bBlock);\n        return bBlock;\n    }\n    segmentClone(segment) {\n        let b = segment.clone();\n        return b;\n    }\n    startGroupOperation(liveSegmentGroup) {\n        // TODO: assert undefined\n        if (this.collabWindow.collaborating) {\n            if (liveSegmentGroup) {\n                this.transactionSegmentGroup = liveSegmentGroup;\n            }\n            else {\n                this.transactionSegmentGroup = { segments: [] };\n                this.pendingSegments.enqueue(this.transactionSegmentGroup);\n            }\n            return this.transactionSegmentGroup;\n        }\n    }\n    endGroupOperation() {\n        if (this.collabWindow.collaborating) {\n            this.transactionSegmentGroup = undefined;\n        }\n    }\n    localNetLength(segment) {\n        let segBranchId = this.getBranchId(segment.clientId);\n        let removalInfo = segment;\n        if (this.localBranchId > segBranchId) {\n            removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, segment);\n        }\n        if (removalInfo.removedSeq !== undefined) {\n            return 0;\n        }\n        else {\n            return segment.cachedLength;\n        }\n    }\n    getBranchId(clientId) {\n        if ((this.clientIdToBranchId.length > clientId) && (clientId >= 0)) {\n            return this.clientIdToBranchId[clientId];\n        }\n        else if (clientId === LocalClientId) {\n            return 0;\n        }\n        else {\n            return this.localBranchId;\n        }\n    }\n    // TODO: remove id when segment removed\n    mapIdToSegment(id, segment) {\n        this.idToSegment[id] = segment;\n    }\n    addNode(block, node) {\n        let index = block.childCount++;\n        block.assignChild(node, index, false);\n        return index;\n    }\n    reloadFromSegments(segments) {\n        let segCap = MaxNodesInBlock - 1;\n        const measureReloadTime = false;\n        let buildMergeBlock = (nodes) => {\n            const nodeCount = Math.ceil(nodes.length / segCap);\n            const blocks = [];\n            let nodeIndex = 0;\n            for (let i = 0; i < nodeCount; i++) {\n                let len = 0;\n                blocks[i] = this.makeBlock(0);\n                for (let j = 0; j < segCap; j++) {\n                    if (nodeIndex < nodes.length) {\n                        let childIndex = this.addNode(blocks[i], nodes[nodeIndex]);\n                        len += nodes[nodeIndex].cachedLength;\n                        if (this.blockUpdateMarkers) {\n                            let hierBlock = blocks[i].hierBlock();\n                            hierBlock.addNodeReferences(this, nodes[nodeIndex]);\n                        }\n                        if (this.blockUpdateActions) {\n                            this.blockUpdateActions.child(blocks[i], childIndex);\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                    nodeIndex++;\n                }\n                blocks[i].cachedLength = len;\n            }\n            if (blocks.length == 1) {\n                return blocks[0];\n            }\n            else {\n                return buildMergeBlock(blocks);\n            }\n        };\n        let clockStart;\n        if (measureReloadTime) {\n            clockStart = clock();\n        }\n        if (segments.length > 0) {\n            this.root = this.makeBlock(1);\n            let block = buildMergeBlock(segments);\n            this.root.assignChild(block, 0, false);\n            if (this.blockUpdateMarkers) {\n                let hierRoot = this.root.hierBlock();\n                hierRoot.addNodeReferences(this, block);\n            }\n            if (this.blockUpdateActions) {\n                this.blockUpdateActions.child(this.root, 0);\n            }\n            this.nodeUpdateOrdinals(this.root);\n            this.root.cachedLength = block.cachedLength;\n        }\n        else {\n            this.root = this.makeBlock(0);\n            this.root.cachedLength = 0;\n        }\n        this.root.index = 0;\n        if (measureReloadTime) {\n            console.log(`reload time ${elapsedMicroseconds(clockStart)}`);\n        }\n    }\n    // for now assume min starts at zero\n    startCollaboration(localClientId, minSeq, branchId) {\n        this.collabWindow.clientId = localClientId;\n        this.collabWindow.minSeq = minSeq;\n        this.collabWindow.collaborating = true;\n        this.collabWindow.currentSeq = minSeq;\n        this.localBranchId = branchId;\n        this.segmentsToScour = new Collections.Heap([], LRUSegmentComparer);\n        this.pendingSegments = Collections.ListMakeHead();\n        let measureFullCollab = false;\n        let clockStart;\n        if (measureFullCollab) {\n            clockStart = clock();\n        }\n        this.nodeUpdateLengthNewStructure(this.root, true);\n        if (measureFullCollab) {\n            console.log(`update partial lengths at start ${elapsedMicroseconds(clockStart)}`);\n        }\n    }\n    addToLRUSet(segment, seq) {\n        this.segmentsToScour.add({ segment: segment, maxSeq: seq });\n    }\n    underflow(node) {\n        return node.childCount < (MaxNodesInBlock / 2);\n    }\n    scourNode(node, holdNodes) {\n        let prevSegment;\n        for (let k = 0; k < node.childCount; k++) {\n            let childNode = node.children[k];\n            if (childNode.isLeaf()) {\n                let segment = childNode;\n                if ((segment.removedSeq !== undefined) && (segment.removedSeq !== UnassignedSequenceNumber)) {\n                    let createBrid = this.getBranchId(segment.clientId);\n                    let removeBrid = this.getBranchId(segment.removedClientId);\n                    if ((removeBrid != createBrid) || (segment.removedSeq > this.collabWindow.minSeq)) {\n                        holdNodes.push(segment);\n                    }\n                    else {\n                        if (MergeTree.traceZRemove) {\n                            console.log(`${this.getLongClientId(this.collabWindow.clientId)}: Zremove ${segment.text}; cli ${this.getLongClientId(segment.clientId)}`);\n                        }\n                        segment.parent = undefined;\n                    }\n                    prevSegment = undefined;\n                }\n                else {\n                    if ((segment.seq <= this.collabWindow.minSeq) &&\n                        segment.segmentGroups.empty && (segment.seq != UnassignedSequenceNumber)) {\n                        if (prevSegment && prevSegment.canAppend(segment, this)) {\n                            if (MergeTree.traceAppend) {\n                                console.log(`${this.getLongClientId(this.collabWindow.clientId)}: append ${prevSegment.text} + ${segment.text}; cli ${this.getLongClientId(prevSegment.clientId)} + cli ${this.getLongClientId(segment.clientId)}`);\n                            }\n                            prevSegment.append(segment);\n                            segment.parent = undefined;\n                        }\n                        else {\n                            holdNodes.push(segment);\n                            if (this.localNetLength(segment) > 0) {\n                                prevSegment = segment;\n                            }\n                            else {\n                                prevSegment = undefined;\n                            }\n                        }\n                    }\n                    else {\n                        holdNodes.push(segment);\n                        prevSegment = undefined;\n                    }\n                }\n            }\n            else {\n                holdNodes.push(childNode);\n                prevSegment = undefined;\n            }\n        }\n    }\n    // interior node with all node children\n    pack(block) {\n        let parent = block.parent;\n        let children = parent.children;\n        let childIndex;\n        let childBlock;\n        let holdNodes = [];\n        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n            // debug assert not isLeaf()\n            childBlock = children[childIndex];\n            this.scourNode(childBlock, holdNodes);\n            // will replace this block with a packed block\n            childBlock.parent = undefined;\n        }\n        let totalNodeCount = holdNodes.length;\n        let halfCount = MaxNodesInBlock / 2;\n        let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));\n        if (childCount < 1) {\n            childCount = 1;\n        }\n        let baseCount = Math.floor(totalNodeCount / childCount);\n        let extraCount = totalNodeCount % childCount;\n        let packedBlocks = new Array(MaxNodesInBlock);\n        let readCount = 0;\n        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {\n            let nodeCount = baseCount;\n            if (extraCount > 0) {\n                nodeCount++;\n                extraCount--;\n            }\n            let packedBlock = this.makeBlock(nodeCount);\n            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {\n                let nodeToPack = holdNodes[readCount++];\n                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);\n            }\n            packedBlock.parent = parent;\n            packedBlocks[nodeIndex] = packedBlock;\n            this.nodeUpdateLengthNewStructure(packedBlock);\n        }\n        if (readCount != totalNodeCount) {\n            console.log(`total count ${totalNodeCount} readCount ${readCount}`);\n        }\n        parent.children = packedBlocks;\n        for (let j = 0; j < childCount; j++) {\n            parent.assignChild(packedBlocks[j], j, false);\n        }\n        parent.childCount = childCount;\n        if (this.underflow(parent) && (parent.parent)) {\n            this.pack(parent);\n        }\n        else {\n            this.nodeUpdateOrdinals(parent);\n            this.blockUpdatePathLengths(parent, UnassignedSequenceNumber, -1, true);\n        }\n    }\n    zamboniSegments() {\n        //console.log(`scour line ${segmentsToScour.count()}`);\n        let clockStart;\n        if (MergeTree.options.measureWindowTime) {\n            clockStart = clock();\n        }\n        let segmentToScour = this.segmentsToScour.peek();\n        if (segmentToScour && (segmentToScour.maxSeq <= this.collabWindow.minSeq)) {\n            for (let i = 0; i < MergeTree.zamboniSegmentsMaxCount; i++) {\n                segmentToScour = this.segmentsToScour.get();\n                if (segmentToScour && segmentToScour.segment.parent &&\n                    (segmentToScour.maxSeq <= this.collabWindow.minSeq)) {\n                    let block = segmentToScour.segment.parent;\n                    let childrenCopy = [];\n                    //                console.log(`scouring from ${segmentToScour.segment.seq}`);\n                    this.scourNode(block, childrenCopy);\n                    let newChildCount = childrenCopy.length;\n                    if (newChildCount < block.childCount) {\n                        block.childCount = newChildCount;\n                        block.children = childrenCopy;\n                        for (let j = 0; j < newChildCount; j++) {\n                            block.assignChild(childrenCopy[j], j, false);\n                        }\n                        if (this.underflow(block) && block.parent) {\n                            //nodeUpdatePathLengths(node, UnassignedSequenceNumber, -1, true);\n                            let packClockStart;\n                            if (MergeTree.options.measureWindowTime) {\n                                packClockStart = clock();\n                            }\n                            this.pack(block);\n                            if (MergeTree.options.measureWindowTime) {\n                                this.packTime += elapsedMicroseconds(packClockStart);\n                            }\n                        }\n                        else {\n                            this.nodeUpdateOrdinals(block);\n                            this.blockUpdatePathLengths(block, UnassignedSequenceNumber, -1, true);\n                        }\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        if (MergeTree.options.measureWindowTime) {\n            this.windowTime += elapsedMicroseconds(clockStart);\n        }\n    }\n    getCollabWindow() {\n        return this.collabWindow;\n    }\n    getStats() {\n        let nodeGetStats = (block) => {\n            let stats = { maxHeight: 0, nodeCount: 0, leafCount: 0, removedLeafCount: 0, liveCount: 0, histo: [] };\n            for (let k = 0; k < MaxNodesInBlock; k++) {\n                stats.histo[k] = 0;\n            }\n            for (let i = 0; i < block.childCount; i++) {\n                let child = block.children[i];\n                let height = 1;\n                if (!child.isLeaf()) {\n                    let childStats = nodeGetStats(child);\n                    height = 1 + childStats.maxHeight;\n                    stats.nodeCount += childStats.nodeCount;\n                    stats.leafCount += childStats.leafCount;\n                    stats.removedLeafCount += childStats.removedLeafCount;\n                    stats.liveCount += childStats.liveCount;\n                    for (let i = 0; i < MaxNodesInBlock; i++) {\n                        stats.histo[i] += childStats.histo[i];\n                    }\n                }\n                else {\n                    stats.leafCount++;\n                    let segment = child;\n                    if (segment.removedSeq !== undefined) {\n                        stats.removedLeafCount++;\n                    }\n                }\n                if (height > stats.maxHeight) {\n                    stats.maxHeight = height;\n                }\n            }\n            stats.histo[block.childCount]++;\n            stats.nodeCount++;\n            stats.liveCount += block.childCount;\n            return stats;\n        };\n        let rootStats = nodeGetStats(this.root);\n        if (MergeTree.options.measureWindowTime) {\n            rootStats.windowTime = this.windowTime;\n            rootStats.packTime = this.packTime;\n            rootStats.ordTime = this.ordTime;\n            rootStats.maxOrdTime = this.maxOrdTime;\n        }\n        return rootStats;\n    }\n    tardisPosition(pos, fromSeq, toSeq, toClientId = NonCollabClient) {\n        return this.tardisPositionFromClient(pos, fromSeq, toSeq, NonCollabClient, toClientId);\n    }\n    tardisPositionFromClient(pos, fromSeq, toSeq, fromClientId, toClientId = NonCollabClient) {\n        if (((fromSeq < toSeq) || (toClientId === this.collabWindow.clientId)) && pos < this.getLength(fromSeq, fromClientId)) {\n            if ((toSeq <= this.collabWindow.currentSeq) && (fromSeq >= this.collabWindow.minSeq)) {\n                let segoff = this.getContainingSegment(pos, fromSeq, fromClientId);\n                let toPos = this.getOffset(segoff.segment, toSeq, toClientId);\n                let ret = toPos + segoff.offset;\n                assert(ret !== undefined);\n                return ret;\n            }\n            assert(false);\n        }\n        else {\n            return pos;\n        }\n    }\n    tardisRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, fromClientId, toClientId = NonCollabClient) {\n        let ranges = [];\n        let recordRange = (segment, pos, refSeq, clientId, segStart, segEnd) => {\n            if (this.nodeLength(segment, toSeq, toClientId) > 0) {\n                let offset = this.getOffset(segment, toSeq, toClientId);\n                if (segStart < 0) {\n                    segStart = 0;\n                }\n                if (segEnd > segment.cachedLength) {\n                    segEnd = segment.cachedLength;\n                }\n                ranges.push({ start: offset + segStart, end: offset + segEnd });\n            }\n            return true;\n        };\n        this.mapRange({ leaf: recordRange }, fromSeq, fromClientId, undefined, rangeStart, rangeEnd);\n        return ranges;\n    }\n    tardisRange(rangeStart, rangeEnd, fromSeq, toSeq, toClientId = NonCollabClient) {\n        return this.tardisRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, NonCollabClient, toClientId);\n    }\n    getLength(refSeq, clientId) {\n        return this.blockLength(this.root, refSeq, clientId);\n    }\n    getOffset(node, refSeq, clientId) {\n        let totalOffset = 0;\n        let parent = node.parent;\n        let prevParent;\n        while (parent) {\n            let children = parent.children;\n            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {\n                let child = children[childIndex];\n                if ((prevParent && (child == prevParent)) || (child == node)) {\n                    break;\n                }\n                totalOffset += this.nodeLength(child, refSeq, clientId);\n            }\n            prevParent = parent;\n            parent = parent.parent;\n        }\n        return totalOffset;\n    }\n    searchFromPos(pos, target) {\n        let start = pos;\n        let end = pos + MergeTree.searchChunkSize;\n        let chunk = \"\";\n        let found = false;\n        while (!found) {\n            if (end > this.root.cachedLength) {\n                end = this.root.cachedLength;\n            }\n            chunk += this.getText(UniversalSequenceNumber, this.collabWindow.clientId, \"\", start, end);\n            let result = chunk.match(target);\n            if (result !== null) {\n                return { text: result[0], pos: result.index };\n            }\n            start += MergeTree.searchChunkSize;\n            if (start >= this.root.cachedLength) {\n                break;\n            }\n            end += MergeTree.searchChunkSize;\n        }\n    }\n    incrementalGetText(refSeq, clientId, start, end) {\n        if (start === undefined) {\n            start = 0;\n        }\n        if (end === undefined) {\n            end = this.blockLength(this.root, refSeq, clientId);\n        }\n        let context = new TextSegment(\"\");\n        let stack = new Collections.Stack();\n        let initialState = new IncrementalMapState(this.root, { leaf: incrementalGatherText }, 0, refSeq, clientId, context, start, end, 0);\n        stack.push(initialState);\n        while (!stack.empty()) {\n            this.incrementalBlockMap(stack);\n        }\n        return context.text;\n    }\n    getTextAndMarkers(refSeq, clientId, label, start, end) {\n        if (start === undefined) {\n            start = 0;\n        }\n        if (end === undefined) {\n            end = this.blockLength(this.root, refSeq, clientId);\n        }\n        let accum = {\n            textSegment: new TextSegment(\"\"), parallelMarkerLabel: label, parallelArrays: true, parallelMarkers: [], parallelText: [],\n            tagsInProgress: []\n        };\n        if (MergeTree.traceGatherText) {\n            console.log(`get text on cli ${glc(this, this.collabWindow.clientId)} ref cli ${glc(this, clientId)} refSeq ${refSeq}`);\n        }\n        this.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, start, end);\n        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };\n    }\n    cloneSegments(refSeq, clientId, start = 0, end) {\n        if (end === undefined) {\n            end = this.blockLength(this.root, refSeq, clientId);\n        }\n        let accum = {\n            segments: []\n        };\n        this.mapRange({ leaf: this.gatherSegment }, refSeq, clientId, accum, start, end);\n        return accum.segments;\n    }\n    getItems(refSeq, clientId, start, end) {\n        let accum = [];\n        function gatherItems(segment, pos, refSeq, clientId, start, end) {\n            if (segment.getType() === SegmentType.Run) {\n                const runSeg = segment;\n                for (const item of runSeg.items) {\n                    accum.push(item);\n                }\n                return true;\n            }\n        }\n        this.mapRange({ leaf: gatherItems }, refSeq, clientId, accum, start, end);\n        return accum;\n    }\n    getText(refSeq, clientId, placeholder = \"\", start, end) {\n        if (start === undefined) {\n            start = 0;\n        }\n        if (end === undefined) {\n            end = this.blockLength(this.root, refSeq, clientId);\n        }\n        let accum = { textSegment: new TextSegment(\"\"), placeholder };\n        if (MergeTree.traceGatherText) {\n            console.log(`get text on cli ${glc(this, this.collabWindow.clientId)} ref cli ${glc(this, clientId)} refSeq ${refSeq}`);\n        }\n        this.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, start, end);\n        return accum.textSegment.text;\n    }\n    getContainingSegment(pos, refSeq, clientId) {\n        let segment;\n        let offset;\n        let leaf = (leafSeg, segpos, refSeq, clientId, start) => {\n            segment = leafSeg;\n            offset = start;\n            return false;\n        };\n        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf });\n        return { segment, offset };\n    }\n    blockLength(node, refSeq, clientId) {\n        if ((this.collabWindow.collaborating) && (clientId != this.collabWindow.clientId)) {\n            return node.partialLengths.getPartialLength(this, refSeq, clientId);\n        }\n        else {\n            return node.cachedLength;\n        }\n    }\n    getRemovalInfo(branchId, segBranchId, segment) {\n        if (branchId > segBranchId) {\n            let index = (branchId - segBranchId) - 1;\n            if (!segment.removalsByBranch) {\n                segment.removalsByBranch = [];\n            }\n            if (!segment.removalsByBranch[index]) {\n                segment.removalsByBranch[index] = {};\n            }\n            return segment.removalsByBranch[index];\n        }\n        else {\n            return segment;\n        }\n    }\n    nodeLength(node, refSeq, clientId) {\n        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId == clientId)) {\n            // local client sees all segments, even when collaborating\n            if (!node.isLeaf()) {\n                return node.cachedLength;\n            }\n            else {\n                return this.localNetLength(node);\n            }\n        }\n        else {\n            // sequence number within window\n            let branchId = this.getBranchId(clientId);\n            if (!node.isLeaf()) {\n                return node.partialLengths.getPartialLength(this, refSeq, clientId);\n            }\n            else {\n                let segment = node;\n                let segBranchId = this.getBranchId(segment.clientId);\n                if ((segBranchId <= branchId) && ((segment.clientId === clientId) ||\n                    ((segment.seq != UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {\n                    let removalInfo = segment;\n                    if (branchId > segBranchId) {\n                        removalInfo = this.getRemovalInfo(branchId, segBranchId, segment);\n                    }\n                    // segment happened by reference sequence number or segment from requesting client\n                    if (removalInfo.removedSeq !== undefined) {\n                        if ((removalInfo.removedClientId === clientId) ||\n                            (removalInfo.removedClientOverlap && (removalInfo.removedClientOverlap.indexOf(clientId) >= 0)) ||\n                            ((removalInfo.removedSeq != UnassignedSequenceNumber) && (removalInfo.removedSeq <= refSeq))) {\n                            return 0;\n                        }\n                        else {\n                            return segment.cachedLength;\n                        }\n                    }\n                    else {\n                        return segment.cachedLength;\n                    }\n                }\n                else {\n                    // segment invisible to client at reference sequence number/branch id/client id of op\n                    return 0;\n                }\n            }\n        }\n    }\n    updateLocalMinSeq(localMinSeq) {\n        this.collabWindow.localMinSeq = localMinSeq;\n        this.setMinSeq(Math.min(this.collabWindow.globalMinSeq, localMinSeq));\n    }\n    addMinSeqListener(minRequired, onMinGE) {\n        if (!this.minSeqListeners) {\n            this.minSeqListeners = new Collections.Heap([], minListenerComparer);\n        }\n        this.minSeqListeners.add({ minRequired, onMinGE });\n    }\n    notifyMinSeqListeners() {\n        this.minSeqPending = false;\n        while ((this.minSeqListeners.count() > 0) &&\n            (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {\n            let minListener = this.minSeqListeners.get();\n            minListener.onMinGE(this.collabWindow.minSeq);\n        }\n    }\n    setMinSeq(minSeq) {\n        if (minSeq > this.collabWindow.minSeq) {\n            this.collabWindow.minSeq = minSeq;\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n            if (this.minSeqListeners && this.minSeqListeners.count()) {\n                this.minSeqPending = true;\n            }\n        }\n    }\n    commitGlobalMin() {\n        if (this.collabWindow.globalMinSeq !== undefined) {\n            this.collabWindow.localMinSeq = this.collabWindow.globalMinSeq;\n            this.setMinSeq(this.collabWindow.globalMinSeq);\n        }\n    }\n    updateGlobalMinSeq(globalMinSeq) {\n        if (this.collabWindow.localMinSeq === undefined) {\n            this.setMinSeq(globalMinSeq);\n        }\n        else {\n            this.collabWindow.globalMinSeq = globalMinSeq;\n            this.setMinSeq(Math.min(globalMinSeq, this.collabWindow.localMinSeq));\n        }\n    }\n    referencePositionToLocalPosition(refPos, refSeq = UniversalSequenceNumber, clientId = this.collabWindow.clientId) {\n        let seg = refPos.getSegment();\n        let offset = refPos.getOffset();\n        return offset + this.getOffset(seg, refSeq, clientId);\n    }\n    getStackContext(startPos, clientId, rangeLabels) {\n        let searchInfo = {\n            mergeTree: this,\n            stacks: Properties.createMap(),\n            rangeLabels\n        };\n        this.search(startPos, UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);\n        return searchInfo.stacks;\n    }\n    // TODO: with annotation op change value\n    cherryPickedUndo(undoInfo) {\n        let segment = undoInfo.seg;\n        // no branches\n        if (segment.removedSeq !== undefined) {\n            segment.removedSeq = undefined;\n            segment.removedClientId = undefined;\n        }\n        else {\n            if (undoInfo.op === 1 /* REMOVE */) {\n                segment.removedSeq = undoInfo.seq;\n            }\n            else {\n                segment.removedSeq = UnassignedSequenceNumber;\n            }\n            segment.removedClientId = this.collabWindow.clientId;\n        }\n        this.blockUpdatePathLengths(segment.parent, UnassignedSequenceNumber, -1, true);\n    }\n    // TODO: filter function\n    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {\n        let searchInfo = {\n            mergeTree: this,\n            posPrecedesTile,\n            tileLabel,\n        };\n        if (posPrecedesTile) {\n            this.search(startPos, UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);\n        }\n        else {\n            this.backwardSearch(startPos, UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);\n        }\n        if (searchInfo.tile) {\n            let pos;\n            if (searchInfo.tile.isLeaf()) {\n                let marker = searchInfo.tile;\n                pos = this.getOffset(marker, UniversalSequenceNumber, clientId);\n            }\n            else {\n                let localRef = searchInfo.tile;\n                pos = localRef.toPosition(this, UniversalSequenceNumber, clientId);\n            }\n            return { tile: searchInfo.tile, pos };\n        }\n    }\n    search(pos, refSeq, clientId, actions, clientData) {\n        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);\n    }\n    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {\n        let children = block.children;\n        if (actions && actions.pre) {\n            actions.pre(block, segpos, refSeq, clientId, undefined, undefined, clientData);\n        }\n        let contains = actions && actions.contains;\n        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n            let child = children[childIndex];\n            let len = this.nodeLength(child, refSeq, clientId);\n            if (((!contains) && (pos < len)) || (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {\n                // found entry containing pos\n                if (!child.isLeaf()) {\n                    return this.searchBlock(child, pos, segpos, refSeq, clientId, actions, clientData);\n                }\n                else {\n                    if (actions && actions.leaf) {\n                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n                    }\n                    return child;\n                }\n            }\n            else {\n                if (actions && actions.shift) {\n                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n                }\n                pos -= len;\n                segpos += len;\n            }\n        }\n        if (actions && actions.post) {\n            actions.post(block, segpos, refSeq, clientId, undefined, undefined, clientData);\n        }\n    }\n    backwardSearch(pos, refSeq, clientId, actions, clientData) {\n        return this.backwardSearchBlock(this.root, pos, this.getLength(refSeq, clientId), refSeq, clientId, actions, clientData);\n    }\n    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {\n        let children = block.children;\n        if (actions && actions.pre) {\n            actions.pre(block, segEnd, refSeq, clientId, undefined, undefined, clientData);\n        }\n        let contains = actions && actions.contains;\n        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n            let child = children[childIndex];\n            let len = this.nodeLength(child, refSeq, clientId);\n            let segpos = segEnd - len;\n            if (((!contains) && (pos >= segpos)) ||\n                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {\n                // found entry containing pos\n                if (!child.isLeaf()) {\n                    return this.backwardSearchBlock(child, pos, segEnd, refSeq, clientId, actions, clientData);\n                }\n                else {\n                    if (actions && actions.leaf) {\n                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);\n                    }\n                    return child;\n                }\n            }\n            else {\n                if (actions && actions.shift) {\n                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);\n                }\n                segEnd = segpos;\n            }\n        }\n        if (actions && actions.post) {\n            actions.post(block, segEnd, refSeq, clientId, undefined, undefined, clientData);\n        }\n    }\n    updateRoot(splitNode, refSeq, clientId, seq) {\n        if (splitNode !== undefined) {\n            let newRoot = this.makeBlock(2);\n            newRoot.index = 0;\n            newRoot.ordinal = \"\";\n            newRoot.assignChild(this.root, 0, false);\n            newRoot.assignChild(splitNode, 1, false);\n            this.root = newRoot;\n            this.nodeUpdateOrdinals(this.root);\n            this.nodeUpdateLengthNewStructure(this.root);\n        }\n    }\n    /**\n     * Assign sequence number to existing segment; update partial lengths to reflect the change\n     * @param seq sequence number given by server to pending segment\n     */\n    ackPendingSegment(seq, verboseOps = false) {\n        let pendingSegmentGroup = this.pendingSegments.dequeue();\n        let nodesToUpdate = [];\n        let clientId;\n        let overwrite = false;\n        if (pendingSegmentGroup !== undefined) {\n            if (verboseOps) {\n                console.log(`segment group has ${pendingSegmentGroup.segments.length} segments`);\n            }\n            pendingSegmentGroup.segments.map((pendingSegment) => {\n                if (pendingSegment.seq === UnassignedSequenceNumber) {\n                    pendingSegment.seq = seq;\n                }\n                else {\n                    let segBranchId = this.getBranchId(pendingSegment.clientId);\n                    let removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, pendingSegment);\n                    if (removalInfo.removedSeq !== undefined) {\n                        if (removalInfo.removedSeq != UnassignedSequenceNumber) {\n                            overwrite = true;\n                            if (MergeTree.diagOverlappingRemove) {\n                                console.log(`grump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)} from ${pendingSegment.removedSeq} text ${pendingSegment.toString()}`);\n                            }\n                        }\n                        else {\n                            removalInfo.removedSeq = seq;\n                        }\n                    }\n                }\n                const segmentGroup = pendingSegment.segmentGroups.dequeue();\n                assert.equal(segmentGroup, pendingSegmentGroup);\n                clientId = this.collabWindow.clientId;\n                if (nodesToUpdate.indexOf(pendingSegment.parent) < 0) {\n                    nodesToUpdate.push(pendingSegment.parent);\n                }\n            });\n            for (let node of nodesToUpdate) {\n                this.blockUpdatePathLengths(node, seq, clientId, overwrite);\n                //nodeUpdatePathLengths(node, seq, clientId, true);\n            }\n        }\n    }\n    addToPendingList(segment, segmentGroup) {\n        if (segmentGroup === undefined) {\n            if (this.transactionSegmentGroup) {\n                segmentGroup = this.transactionSegmentGroup;\n            }\n            else {\n                segmentGroup = { segments: [] };\n                this.pendingSegments.enqueue(segmentGroup);\n            }\n        }\n        // TODO: share this group with UNDO\n        segment.segmentGroups.enqueue(segmentGroup);\n        return segmentGroup;\n    }\n    // TODO: error checking\n    getSegmentFromId(id) {\n        return this.idToSegment[id];\n    }\n    /**\n     * Given a position specified relative to a marker id, lookup the marker\n     * and convert the position to a character position.\n     * @param relativePos Id of marker (may be indirect) and whether position is before or after marker.\n     * @param refseq The reference sequence number at which to compute the position.\n     * @param clientId The client id with which to compute the position.\n     */\n    posFromRelativePos(relativePos, refseq = UniversalSequenceNumber, clientId = this.collabWindow.clientId) {\n        let pos = -1;\n        let marker;\n        if (relativePos.id) {\n            marker = this.getSegmentFromId(relativePos.id);\n        }\n        if (marker) {\n            pos = this.getOffset(marker, refseq, clientId);\n            if (!relativePos.before) {\n                pos += marker.cachedLength;\n                if (relativePos.offset !== undefined) {\n                    pos += relativePos.offset;\n                }\n            }\n            else {\n                if (relativePos.offset !== undefined) {\n                    pos -= relativePos.offset;\n                }\n            }\n        }\n        return pos;\n    }\n    insert(pos, refSeq, clientId, seq, segData, traverse, opArgs) {\n        this.ensureIntervalBoundary(pos, refSeq, clientId);\n        if (MergeTree.traceOrdinals) {\n            this.ordinalIntegrity();\n        }\n        //traceTraversal = true;\n        let splitNode = traverse(this.root, pos, refSeq, clientId, seq, segData);\n        //traceTraversal = false;\n        this.updateRoot(splitNode, refSeq, clientId, seq);\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                mergeTreeClientId: clientId,\n                operation: 0 /* INSERT */,\n                mergeTree: this,\n                segments: [segData]\n            });\n        }\n    }\n    insertSegment(pos, refSeq, clientId, seq, segment, opArgs) {\n        // const tt = MergeTree.traceTraversal;\n        // MergeTree.traceTraversal = true;\n        this.insert(pos, refSeq, clientId, seq, segment, (block, pos, refSeq, clientId, seq, seg) => this.blockInsert(block, pos, refSeq, clientId, seq, seg), opArgs);\n        // MergeTree.traceTraversal = tt;\n    }\n    insertMarker(pos, refSeq, clientId, seq, behaviors, props, opArgs) {\n        let marker = Marker.make(behaviors, props, seq, clientId);\n        let markerId = marker.getId();\n        if (markerId) {\n            this.mapIdToSegment(markerId, marker);\n        }\n        this.insert(pos, refSeq, clientId, seq, marker, (block, pos, refSeq, clientId, seq, marker) => this.blockInsert(block, pos, refSeq, clientId, seq, marker), opArgs);\n        // report segment if client interested\n        if (this.markerModifiedHandler && (seq !== UnassignedSequenceNumber)) {\n            this.markerModifiedHandler(marker);\n        }\n        return marker;\n    }\n    insertTextMarkerRelative(markerPos, refSeq, clientId, seq, text, props, opArgs) {\n        let pos = this.posFromRelativePos(markerPos, refSeq, clientId);\n        if (pos >= 0) {\n            let newSegment = TextSegment.make(text, props, seq, clientId);\n            // MergeTree.traceTraversal = true;\n            this.insert(pos, refSeq, clientId, seq, newSegment, (block, pos, refSeq, clientId, seq, segment) => this.blockInsert(this.root, pos, refSeq, clientId, seq, segment), opArgs);\n            MergeTree.traceTraversal = false;\n            if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&\n                (seq != UnassignedSequenceNumber)) {\n                this.zamboniSegments();\n            }\n        }\n    }\n    insertText(pos, refSeq, clientId, seq, text, props, opArgs) {\n        let newSegment = TextSegment.make(text, props, seq, clientId);\n        // MergeTree.traceTraversal = true;\n        this.insert(pos, refSeq, clientId, seq, newSegment, (block, pos, refSeq, clientId, seq, segment) => this.blockInsert(this.root, pos, refSeq, clientId, seq, segment), opArgs);\n        MergeTree.traceTraversal = false;\n        if (MergeTree.traceOrdinals) {\n            this.ordinalIntegrity();\n        }\n        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&\n            (seq != UnassignedSequenceNumber)) {\n            this.zamboniSegments();\n        }\n    }\n    blockInsert(block, pos, refSeq, clientId, seq, newSegment) {\n        let segIsLocal = false;\n        let checkSegmentIsLocal = (segment, pos, refSeq, clientId) => {\n            if (segment.seq == UnassignedSequenceNumber) {\n                if (MergeTree.diagInsertTie) {\n                    console.log(`@cli ${glc(this, this.collabWindow.clientId)}: promoting continue due to seq ${segment.seq} text ${segment.toString()} ref ${refSeq}`);\n                }\n                segIsLocal = true;\n            }\n            // only need to look at first segment that follows finished node\n            return false;\n        };\n        let continueFrom = (node) => {\n            segIsLocal = false;\n            this.rightExcursion(node, checkSegmentIsLocal);\n            if (MergeTree.diagInsertTie && segIsLocal && (newSegment.getType() === SegmentType.Text)) {\n                let text = newSegment.toString();\n                console.log(`@cli ${glc(this, this.collabWindow.clientId)}: attempting continue with seq ${seq} text ${text} ref ${refSeq}`);\n            }\n            return segIsLocal;\n        };\n        let onLeaf = (segment, pos, context) => {\n            let saveIfLocal = (locSegment) => {\n                // save segment so can assign sequence number when acked by server\n                if (this.collabWindow.collaborating) {\n                    if ((locSegment.seq == UnassignedSequenceNumber) &&\n                        (clientId == this.collabWindow.clientId)) {\n                        this.addToPendingList(locSegment);\n                    }\n                    else if ((locSegment.seq >= this.collabWindow.minSeq) &&\n                        MergeTree.options.zamboniSegments) {\n                        this.addToLRUSet(locSegment, locSegment.seq);\n                    }\n                }\n            };\n            let segmentChanges = {};\n            if (segment) {\n                // insert before segment\n                segmentChanges.replaceCurrent = newSegment;\n                segmentChanges.next = segment;\n            }\n            else {\n                segmentChanges.next = newSegment;\n            }\n            saveIfLocal(newSegment);\n            return segmentChanges;\n        };\n        return this.insertingWalk(block, pos, refSeq, clientId, seq, newSegment.getType(), { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });\n    }\n    ensureIntervalBoundary(pos, refSeq, clientId) {\n        let splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, TreeMaintenanceSequenceNumber, SegmentType.Base, { leaf: this.splitLeafSegment });\n        this.updateRoot(splitNode, refSeq, clientId, TreeMaintenanceSequenceNumber);\n    }\n    // assume called only when pos == len\n    breakTie(pos, len, seq, node, refSeq, clientId, candidateSegment) {\n        if (node.isLeaf()) {\n            let segment = node;\n            // TODO: marker/marker tie break & alternate tie break rules\n            if (pos == 0) {\n                return segment.seq !== UnassignedSequenceNumber;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return true;\n        }\n    }\n    // visit segments starting from node's right siblings, then up to node's parent\n    leftExcursion(node, leafAction) {\n        let actions = { leaf: leafAction };\n        let go = true;\n        let startNode = node;\n        let parent = startNode.parent;\n        while (parent) {\n            let children = parent.children;\n            let childIndex;\n            let node;\n            let matchedStart = false;\n            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {\n                node = children[childIndex];\n                if (matchedStart) {\n                    if (!node.isLeaf()) {\n                        let childBlock = node;\n                        go = this.nodeMapReverse(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);\n                    }\n                    else {\n                        go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0);\n                    }\n                    if (!go) {\n                        return;\n                    }\n                }\n                else {\n                    matchedStart = (startNode === node);\n                }\n            }\n            startNode = parent;\n            parent = parent.parent;\n        }\n    }\n    // visit segments starting from node's right siblings, then up to node's parent\n    rightExcursion(node, leafAction) {\n        let actions = { leaf: leafAction };\n        let go = true;\n        let startNode = node;\n        let parent = startNode.parent;\n        while (parent) {\n            let children = parent.children;\n            let childIndex;\n            let node;\n            let matchedStart = false;\n            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {\n                node = children[childIndex];\n                if (matchedStart) {\n                    if (!node.isLeaf()) {\n                        let childBlock = node;\n                        go = this.nodeMap(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);\n                    }\n                    else {\n                        go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0);\n                    }\n                    if (!go) {\n                        return;\n                    }\n                }\n                else {\n                    matchedStart = (startNode === node);\n                }\n            }\n            startNode = parent;\n            parent = parent.parent;\n        }\n    }\n    insertingWalk(block, pos, refSeq, clientId, seq, segType, context) {\n        let children = block.children;\n        let childIndex;\n        let child;\n        let newNode;\n        let fromSplit;\n        let found = false;\n        for (childIndex = 0; childIndex < block.childCount; childIndex++) {\n            child = children[childIndex];\n            let len = this.nodeLength(child, refSeq, clientId);\n            if (MergeTree.traceTraversal) {\n                let segInfo;\n                if ((!child.isLeaf()) && this.collabWindow.collaborating) {\n                    segInfo = `minLength: ${child.partialLengths.minLength}`;\n                }\n                else {\n                    let segment = child;\n                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: ${segment.toString()}`;\n                    if (segment.removedSeq !== undefined) {\n                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;\n                    }\n                }\n                console.log(`@tcli: ${glc(this, this.collabWindow.clientId)} len: ${len} pos: ${pos} ` + segInfo);\n            }\n            if ((pos < len) || ((pos == len) && this.breakTie(pos, len, seq, child, refSeq, clientId, context.candidateSegment))) {\n                // found entry containing pos\n                found = true;\n                if (!child.isLeaf()) {\n                    let childBlock = child;\n                    //internal node\n                    let splitNode = this.insertingWalk(childBlock, pos, refSeq, clientId, seq, segType, context);\n                    if (splitNode === undefined) {\n                        if (context.structureChange) {\n                            this.nodeUpdateLengthNewStructure(block);\n                        }\n                        else {\n                            this.blockUpdateLength(block, seq, clientId);\n                        }\n                        return undefined;\n                    }\n                    else if (splitNode == MergeTree.theUnfinishedNode) {\n                        if (MergeTree.traceTraversal) {\n                            console.log(`@cli ${glc(this, this.collabWindow.clientId)} unfinished bus pos ${pos} len ${len}`);\n                        }\n                        pos -= len; // act as if shifted segment\n                        continue;\n                    }\n                    else {\n                        newNode = splitNode;\n                        fromSplit = splitNode;\n                        childIndex++; // insert after\n                    }\n                }\n                else {\n                    if (MergeTree.traceTraversal) {\n                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action`);\n                    }\n                    const segment = child;\n                    const branchId = this.getBranchId(clientId);\n                    const segmentBranchId = this.getBranchId(segment.clientId);\n                    const removalInfo = this.getRemovalInfo(branchId, segmentBranchId, segment);\n                    if (removalInfo && removalInfo.removedSeq) {\n                        continue;\n                    }\n                    let segmentChanges = context.leaf(segment, pos, context);\n                    if (segmentChanges.replaceCurrent) {\n                        if (MergeTree.traceOrdinals) {\n                            console.log(`assign from leaf with block ord ${ordinalToArray(block.ordinal)}`);\n                        }\n                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);\n                        segmentChanges.replaceCurrent.ordinal = child.ordinal;\n                    }\n                    if (segmentChanges.next) {\n                        newNode = segmentChanges.next;\n                        childIndex++; // insert after\n                    }\n                    else {\n                        // no change\n                        if (context.structureChange) {\n                            this.nodeUpdateLengthNewStructure(block);\n                        }\n                        return undefined;\n                    }\n                }\n                break;\n            }\n            else {\n                pos -= len;\n            }\n        }\n        if (MergeTree.traceTraversal) {\n            if ((!found) && (pos > 0)) {\n                console.log(`inserting walk fell through pos ${pos} len: ${this.blockLength(this.root, refSeq, clientId)}`);\n            }\n        }\n        if (!newNode) {\n            if (pos == 0) {\n                if ((seq != UnassignedSequenceNumber) && context.continuePredicate &&\n                    context.continuePredicate(block)) {\n                    return MergeTree.theUnfinishedNode;\n                }\n                else {\n                    if (MergeTree.traceTraversal) {\n                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action pos 0`);\n                    }\n                    let segmentChanges = context.leaf(undefined, pos, context);\n                    newNode = segmentChanges.next;\n                    // assert segmentChanges.replaceCurrent === undefined\n                }\n            }\n        }\n        if (newNode) {\n            for (let i = block.childCount; i > childIndex; i--) {\n                block.children[i] = block.children[i - 1];\n                block.children[i].index = i;\n            }\n            block.assignChild(newNode, childIndex, false);\n            block.childCount++;\n            block.setOrdinal(newNode, childIndex);\n            if (block.childCount < MaxNodesInBlock) {\n                if (fromSplit) {\n                    if (MergeTree.traceOrdinals) {\n                        console.log(`split ord ${ordinalToArray(fromSplit.ordinal)}`);\n                    }\n                    this.nodeUpdateOrdinals(fromSplit);\n                }\n                if (context.structureChange) {\n                    this.nodeUpdateLengthNewStructure(block);\n                }\n                else {\n                    this.blockUpdateLength(block, seq, clientId);\n                }\n                return undefined;\n            }\n            else {\n                // don't update ordinals because higher block will do it\n                return this.split(block);\n            }\n        }\n        else {\n            return undefined;\n        }\n    }\n    split(node) {\n        let halfCount = MaxNodesInBlock / 2;\n        let newNode = this.makeBlock(halfCount);\n        node.childCount = halfCount;\n        // update ordinals to reflect lowered child count\n        this.nodeUpdateOrdinals(node);\n        for (let i = 0; i < halfCount; i++) {\n            newNode.assignChild(node.children[halfCount + i], i, false);\n            node.children[halfCount + i] = undefined;\n        }\n        this.nodeUpdateLengthNewStructure(node);\n        this.nodeUpdateLengthNewStructure(newNode);\n        return newNode;\n    }\n    ordinalIntegrity() {\n        console.log(\"chk ordnls\");\n        this.nodeOrdinalIntegrity(this.root);\n    }\n    nodeOrdinalIntegrity(block) {\n        let olen = block.ordinal.length;\n        for (let i = 0; i < block.childCount; i++) {\n            if (block.children[i].ordinal) {\n                if (olen !== (block.children[i].ordinal.length - 1)) {\n                    console.log(\"node integrity issue\");\n                }\n                if (i > 0) {\n                    if (block.children[i].ordinal <= block.children[i - 1].ordinal) {\n                        console.log(\"node sib integrity issue\");\n                        console.log(`??: prnt chld prev ${ordinalToArray(block.ordinal)} ${ordinalToArray(block.children[i].ordinal)} ${(i > 0) ? ordinalToArray(block.children[i - 1].ordinal) : \"NA\"}`);\n                    }\n                }\n                if (!block.children[i].isLeaf()) {\n                    this.nodeOrdinalIntegrity(block.children[i]);\n                }\n            }\n            else {\n                console.log(`node child ordinal not set ${i}`);\n                console.log(`??: prnt ${ordinalToArray(block.ordinal)}`);\n            }\n        }\n    }\n    nodeUpdateOrdinals(block) {\n        if (MergeTree.traceOrdinals) {\n            console.log(`update ordinals for children of node with ordinal ${ordinalToArray(block.ordinal)}`);\n        }\n        let clockStart;\n        if (MergeTree.options.measureOrdinalTime) {\n            clockStart = clock();\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            let child = block.children[i];\n            block.setOrdinal(child, i);\n            if (!child.isLeaf()) {\n                this.nodeUpdateOrdinals(child);\n            }\n        }\n        if (MergeTree.options.measureOrdinalTime) {\n            let elapsed = elapsedMicroseconds(clockStart);\n            if (elapsed > this.maxOrdTime) {\n                this.maxOrdTime = elapsed;\n            }\n            this.ordTime += elapsed;\n        }\n    }\n    addOverlappingClient(removalInfo, clientId) {\n        if (!removalInfo.removedClientOverlap) {\n            removalInfo.removedClientOverlap = [];\n        }\n        if (MergeTree.diagOverlappingRemove) {\n            console.log(`added cli ${glc(this, clientId)} to rseq: ${removalInfo.removedSeq}`);\n        }\n        removalInfo.removedClientOverlap.push(clientId);\n    }\n    annotateRange(props, start, end, refSeq, clientId, seq, combiningOp, opArgs) {\n        this.ensureIntervalBoundary(start, refSeq, clientId);\n        this.ensureIntervalBoundary(end, refSeq, clientId);\n        const annotatedSegments = [];\n        let annotateSegment = (segment) => {\n            let segType = segment.getType();\n            if ((segType == SegmentType.Marker) || (segType == SegmentType.Text)) {\n                annotatedSegments.push(segment);\n                segment.addProperties(props, combiningOp, seq);\n                if (this.markerModifiedHandler && (segType === SegmentType.Marker) && (seq !== UnassignedSequenceNumber)) {\n                    this.markerModifiedHandler(segment);\n                }\n            }\n            return true;\n        };\n        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                mergeTreeClientId: clientId,\n                operation: 2 /* ANNOTATE */,\n                mergeTree: this,\n                segments: annotatedSegments\n            });\n        }\n    }\n    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {\n        this.ensureIntervalBoundary(start, refSeq, clientId);\n        this.ensureIntervalBoundary(end, refSeq, clientId);\n        let segmentGroup;\n        const removedSegments = [];\n        let savedLocalRefs = [];\n        let markRemoved = (segment, pos, start, end) => {\n            let branchId = this.getBranchId(clientId);\n            let segBranchId = this.getBranchId(segment.clientId);\n            for (let brid = branchId; brid <= this.localBranchId; brid++) {\n                let removalInfo = this.getRemovalInfo(brid, segBranchId, segment);\n                if (removalInfo.removedSeq != undefined) {\n                    if (MergeTree.diagOverlappingRemove) {\n                        console.log(`yump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)}: overlaps deleted segment ${removalInfo.removedSeq} text '${segment.toString()}'`);\n                    }\n                    overwrite = true;\n                    if (removalInfo.removedSeq === UnassignedSequenceNumber) {\n                        // will only happen on local branch (brid === this.localBranchId)\n                        // replace because comes later\n                        removalInfo.removedClientId = clientId;\n                        removalInfo.removedSeq = seq;\n                    }\n                    else {\n                        // do not replace earlier sequence number for remove\n                        this.addOverlappingClient(removalInfo, clientId);\n                    }\n                }\n                else {\n                    removalInfo.removedClientId = clientId;\n                    removalInfo.removedSeq = seq;\n                    removedSegments.push(segment);\n                    if (segment.localRefs && (brid === this.localBranchId)) {\n                        savedLocalRefs.push(segment.localRefs);\n                        segment.localRefs = undefined;\n                    }\n                }\n            }\n            // save segment so can assign removed sequence number when acked by server\n            if (this.collabWindow.collaborating) {\n                // report segment if client interested\n                if (this.markerModifiedHandler && (segment.getType() === SegmentType.Marker) && (seq !== UnassignedSequenceNumber)) {\n                    this.markerModifiedHandler(segment);\n                }\n                // use removal information\n                let removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, segment);\n                if ((removalInfo.removedSeq === UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {\n                    segmentGroup = this.addToPendingList(segment, segmentGroup);\n                }\n                else {\n                    if (MergeTree.options.zamboniSegments) {\n                        this.addToLRUSet(segment, seq);\n                    }\n                }\n                //console.log(`saved local removed seg with text: ${textSegment.text}`);\n            }\n            return true;\n        };\n        let afterMarkRemoved = (node, pos, start, end) => {\n            if (overwrite) {\n                this.nodeUpdateLengthNewStructure(node);\n            }\n            else {\n                this.blockUpdateLength(node, seq, clientId);\n            }\n            return true;\n        };\n        // MergeTree.traceTraversal = true;\n        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);\n        if (savedLocalRefs.length > 0) {\n            let afterSeg;\n            for (let segSavedRefs of savedLocalRefs) {\n                for (let localRef of segSavedRefs) {\n                    if (localRef.refType && (localRef.refType & ops.ReferenceType.SlideOnRemove)) {\n                        if (!afterSeg) {\n                            let afterSegOff = this.getContainingSegment(start, refSeq, clientId);\n                            afterSeg = afterSegOff.segment;\n                        }\n                        if (afterSeg) {\n                            localRef.segment = afterSeg;\n                            localRef.offset = 0;\n                            afterSeg.addLocalRef(localRef);\n                        }\n                    }\n                }\n            }\n            if (afterSeg) {\n                this.blockUpdatePathLengths(afterSeg.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n            }\n        }\n        if (this.mergeTreeDeltaCallback) {\n            this.mergeTreeDeltaCallback(opArgs, {\n                mergeTreeClientId: clientId,\n                operation: 1 /* REMOVE */,\n                mergeTree: this,\n                segments: removedSegments\n            });\n        }\n        if (this.collabWindow.collaborating && (seq != UnassignedSequenceNumber)) {\n            if (MergeTree.options.zamboniSegments) {\n                this.zamboniSegments();\n            }\n        }\n        // MergeTree.traceTraversal = false;\n    }\n    // This method is deprecated should not be used. It modifies existing segments.\n    removeRange(start, end, refSeq, clientId) {\n        let removeInfo = {};\n        this.nodeRemoveRange(this.root, start, end, refSeq, clientId, removeInfo);\n        if (removeInfo.highestBlockRemovingChildren) {\n            let remBlock = removeInfo.highestBlockRemovingChildren;\n            this.nodeUpdateOrdinals(remBlock);\n        }\n    }\n    nodeRemoveRange(block, start, end, refSeq, clientId, removeInfo) {\n        let children = block.children;\n        let startIndex;\n        if (start < 0) {\n            startIndex = -1;\n        }\n        let endIndex = block.childCount;\n        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n            let child = children[childIndex];\n            let len = this.nodeLength(child, refSeq, clientId);\n            if ((start >= 0) && (start < len)) {\n                startIndex = childIndex;\n                if (!child.isLeaf()) {\n                    this.nodeRemoveRange(child, start, end, refSeq, clientId, removeInfo);\n                }\n                else {\n                    let segment = child;\n                    if (segment.removeRange(start, end)) {\n                        startIndex--;\n                    }\n                }\n            }\n            // REVIEW: run this clause even if above clause runs\n            if (end < len) {\n                endIndex = childIndex;\n                if (end > 0) {\n                    if (endIndex > startIndex) {\n                        if (!child.isLeaf()) {\n                            this.nodeRemoveRange(child, start, end, refSeq, clientId, removeInfo);\n                        }\n                        else {\n                            let segment = child;\n                            if (segment.removeRange(0, end)) {\n                                endIndex++;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n            start -= len;\n            end -= len;\n        }\n        let deleteCount = (endIndex - startIndex) - 1;\n        let deleteStart = startIndex + 1;\n        if (deleteCount > 0) {\n            // delete nodes in middle of range\n            let copyStart = deleteStart + deleteCount;\n            let copyCount = block.childCount - copyStart;\n            for (let j = 0; j < copyCount; j++) {\n                block.assignChild(children[copyStart + j], deleteStart + j, false);\n            }\n            block.childCount -= deleteCount;\n            if (removeInfo.highestBlockRemovingChildren && removeInfo.highestBlockRemovingChildren.parent &&\n                (removeInfo.highestBlockRemovingChildren.parent === block.parent)) {\n                removeInfo.highestBlockRemovingChildren = block.parent;\n            }\n            else {\n                removeInfo.highestBlockRemovingChildren = block;\n            }\n        }\n        this.nodeUpdateLengthNewStructure(block);\n    }\n    nodeUpdateLengthNewStructure(node, recur = false) {\n        this.blockUpdate(node);\n        if (this.collabWindow.collaborating) {\n            node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow, recur);\n        }\n    }\n    removeLocalReference(segment, lref) {\n        let removedRef = segment.removeLocalRef(lref);\n        if (removedRef) {\n            this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n        }\n    }\n    addLocalReference(lref) {\n        let segment = lref.segment;\n        segment.addLocalRef(lref);\n        this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);\n    }\n    blockUpdate(block) {\n        let len = 0;\n        let hierBlock;\n        if (this.blockUpdateMarkers) {\n            hierBlock = block.hierBlock();\n            hierBlock.rightmostTiles = Properties.createMap();\n            hierBlock.leftmostTiles = Properties.createMap();\n            hierBlock.rangeStacks = {};\n        }\n        for (let i = 0; i < block.childCount; i++) {\n            let child = block.children[i];\n            len += nodeTotalLength(this, child);\n            if (this.blockUpdateMarkers) {\n                hierBlock.addNodeReferences(this, child);\n            }\n            if (this.blockUpdateActions) {\n                this.blockUpdateActions.child(block, i);\n            }\n        }\n        block.cachedLength = len;\n    }\n    blockUpdatePathLengths(block, seq, clientId, newStructure = false) {\n        while (block !== undefined) {\n            if (newStructure) {\n                this.nodeUpdateLengthNewStructure(block);\n            }\n            else {\n                this.blockUpdateLength(block, seq, clientId);\n            }\n            block = block.parent;\n        }\n    }\n    blockUpdateLength(node, seq, clientId) {\n        this.blockUpdate(node);\n        if (this.collabWindow.collaborating && (seq != UnassignedSequenceNumber) && (seq != TreeMaintenanceSequenceNumber)) {\n            if (node.partialLengths !== undefined) {\n                if (MergeTree.options.incrementalUpdate) {\n                    node.partialLengths.update(this, node, seq, clientId, this.collabWindow);\n                }\n                else {\n                    node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);\n                }\n            }\n            else {\n                node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);\n            }\n        }\n    }\n    map(actions, refSeq, clientId, accum) {\n        // TODO: optimize to avoid comparisons\n        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);\n    }\n    mapRange(actions, refSeq, clientId, accum, start, end) {\n        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);\n    }\n    rangeToString(start, end) {\n        let strbuf = \"\";\n        for (let childIndex = 0; childIndex < this.root.childCount; childIndex++) {\n            let child = this.root.children[childIndex];\n            if (!child.isLeaf()) {\n                let block = child;\n                let len = this.blockLength(block, UniversalSequenceNumber, this.collabWindow.clientId);\n                if ((start <= len) && (end > 0)) {\n                    strbuf += this.nodeToString(block, strbuf, 0);\n                }\n                start -= len;\n                end -= len;\n            }\n        }\n        return strbuf;\n    }\n    nodeToString(block, strbuf, indentCount = 0) {\n        strbuf += internedSpaces(indentCount);\n        strbuf += `Node (len ${block.cachedLength}) p len (${block.parent ? block.parent.cachedLength : 0}) ord ${ordinalToArray(block.ordinal)} with ${block.childCount} segs:\\n`;\n        if (this.blockUpdateMarkers) {\n            strbuf += internedSpaces(indentCount);\n            strbuf += block.hierToString(indentCount);\n        }\n        if (this.collabWindow.collaborating) {\n            strbuf += internedSpaces(indentCount);\n            strbuf += block.partialLengths.toString((id) => glc(this, id), indentCount) + '\\n';\n        }\n        let children = block.children;\n        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {\n            let child = children[childIndex];\n            if (!child.isLeaf()) {\n                strbuf = this.nodeToString(child, strbuf, indentCount + 4);\n            }\n            else {\n                let segment = child;\n                strbuf += internedSpaces(indentCount + 4);\n                strbuf += `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} ord: ${ordinalToArray(segment.ordinal)}`;\n                let segBranchId = this.getBranchId(segment.clientId);\n                let branchId = this.localBranchId;\n                let removalInfo = this.getRemovalInfo(branchId, segBranchId, segment);\n                if (removalInfo.removedSeq !== undefined) {\n                    strbuf += ` rcli: ${glc(this, removalInfo.removedClientId)} rseq: ${removalInfo.removedSeq}`;\n                }\n                strbuf += \"\\n\";\n                strbuf += internedSpaces(indentCount + 4);\n                strbuf += segment.toString();\n                strbuf += \"\\n\";\n            }\n        }\n        return strbuf;\n    }\n    toString() {\n        return this.nodeToString(this.root, \"\", 0);\n    }\n    incrementalBlockMap(stateStack) {\n        while (!stateStack.empty()) {\n            let state = stateStack.top();\n            if (state.op != IncrementalExecOp.Go) {\n                return;\n            }\n            if (state.childIndex == 0) {\n                if (state.start === undefined) {\n                    state.start = 0;\n                }\n                if (state.end === undefined) {\n                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);\n                }\n                if (state.actions.pre) {\n                    state.actions.pre(state);\n                }\n            }\n            if ((state.op == IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {\n                let child = state.block.children[state.childIndex];\n                let len = this.nodeLength(child, state.refSeq, state.clientId);\n                if (MergeTree.traceIncrTraversal) {\n                    if (child.isLeaf()) {\n                        console.log(`considering (r ${state.refSeq} c ${glc(this, state.clientId)}) seg with text ${child.text} len ${len} seq ${child.seq} rseq ${child.removedSeq} cli ${glc(this, child.clientId)}`);\n                    }\n                }\n                if ((len > 0) && (state.start < len) && (state.end > 0)) {\n                    if (!child.isLeaf()) {\n                        let childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);\n                        stateStack.push(childState);\n                    }\n                    else {\n                        if (MergeTree.traceIncrTraversal) {\n                            console.log(`action on seg with text ${child.text}`);\n                        }\n                        state.actions.leaf(child, state);\n                    }\n                }\n                state.pos += len;\n                state.start -= len;\n                state.end -= len;\n                state.childIndex++;\n            }\n            else {\n                if (state.childIndex == state.block.childCount) {\n                    if ((state.op == IncrementalExecOp.Go) && state.actions.post) {\n                        state.actions.post(state);\n                    }\n                    stateStack.pop();\n                }\n            }\n        }\n    }\n    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {\n        if (start === undefined) {\n            start = 0;\n        }\n        if (end === undefined) {\n            end = this.blockLength(node, refSeq, clientId);\n        }\n        let go = true;\n        if (actions.pre) {\n            go = actions.pre(node, pos, refSeq, clientId, start, end, accum);\n            if (!go) {\n                // cancel this node but not entire traversal\n                return true;\n            }\n        }\n        let children = node.children;\n        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {\n            let child = children[childIndex];\n            let len = this.nodeLength(child, refSeq, clientId);\n            if (MergeTree.traceTraversal) {\n                let segInfo;\n                if ((!child.isLeaf()) && this.collabWindow.collaborating) {\n                    segInfo = `minLength: ${child.partialLengths.minLength}`;\n                }\n                else {\n                    let segment = child;\n                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: '${segment.toString()}'`;\n                    if (segment.removedSeq !== undefined) {\n                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;\n                    }\n                }\n                console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map len: ${len} start: ${start} end: ${end} ` + segInfo);\n            }\n            let isLeaf = child.isLeaf();\n            if (go && (end > 0) && (len > 0) && (start < len)) {\n                // found entry containing pos\n                if (!isLeaf) {\n                    if (go) {\n                        go = this.nodeMap(child, actions, pos, refSeq, clientId, accum, start, end);\n                    }\n                }\n                else {\n                    if (MergeTree.traceTraversal) {\n                        console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map leaf action`);\n                    }\n                    go = actions.leaf(child, pos, refSeq, clientId, start, end, accum);\n                }\n            }\n            if (!go) {\n                break;\n            }\n            if (actions.shift) {\n                actions.shift(child, pos, refSeq, clientId, start, end, accum);\n            }\n            pos += len;\n            start -= len;\n            end -= len;\n        }\n        if (go && actions.post) {\n            go = actions.post(node, pos, refSeq, clientId, start, end, accum);\n        }\n        return go;\n    }\n    // straight call every segment; goes until leaf action returns false\n    nodeMapReverse(block, actions, pos, refSeq, clientId, accum) {\n        let go = true;\n        let children = block.children;\n        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {\n            let child = children[childIndex];\n            let isLeaf = child.isLeaf();\n            if (go) {\n                // found entry containing pos\n                if (!isLeaf) {\n                    if (go) {\n                        go = this.nodeMapReverse(child, actions, pos, refSeq, clientId, accum);\n                    }\n                }\n                else {\n                    go = actions.leaf(child, pos, refSeq, clientId, 0, 0, accum);\n                }\n            }\n            if (!go) {\n                break;\n            }\n        }\n        return go;\n    }\n}\n// must be an even number\nMergeTree.TextSegmentGranularity = 128;\nMergeTree.zamboniSegmentsMaxCount = 2;\nMergeTree.options = {\n    incrementalUpdate: true,\n    zamboniSegments: true,\n    measureWindowTime: true,\n    measureOrdinalTime: true,\n};\nMergeTree.searchChunkSize = 256;\nMergeTree.traceAppend = false;\nMergeTree.traceZRemove = false;\nMergeTree.traceOrdinals = false;\nMergeTree.traceGatherText = false;\nMergeTree.diagInsertTie = false;\nMergeTree.skipLeftShift = true;\nMergeTree.diagOverlappingRemove = false;\nMergeTree.traceTraversal = false;\nMergeTree.traceIncrTraversal = false;\nMergeTree.theUnfinishedNode = { childCount: -1 };\n//# sourceMappingURL=mergeTree.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./blobs\"));\n__export(require(\"./chaincode\"));\n__export(require(\"./clients\"));\n__export(require(\"./protocol\"));\n__export(require(\"./storage\"));\n//# sourceMappingURL=index.js.map","'use strict';\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n","// tslint:disable:no-bitwise\n// tslint:disable:ban-types\nexport var ReferenceType;\n(function (ReferenceType) {\n    ReferenceType[ReferenceType[\"Simple\"] = 0] = \"Simple\";\n    ReferenceType[ReferenceType[\"Tile\"] = 1] = \"Tile\";\n    ReferenceType[ReferenceType[\"NestBegin\"] = 2] = \"NestBegin\";\n    ReferenceType[ReferenceType[\"NestEnd\"] = 4] = \"NestEnd\";\n    ReferenceType[ReferenceType[\"RangeBegin\"] = 16] = \"RangeBegin\";\n    ReferenceType[ReferenceType[\"RangeEnd\"] = 32] = \"RangeEnd\";\n    ReferenceType[ReferenceType[\"SlideOnRemove\"] = 64] = \"SlideOnRemove\";\n    ReferenceType[ReferenceType[\"Transient\"] = 256] = \"Transient\";\n})(ReferenceType || (ReferenceType = {}));\nexport var IntervalType;\n(function (IntervalType) {\n    IntervalType[IntervalType[\"Simple\"] = 0] = \"Simple\";\n    IntervalType[IntervalType[\"Nest\"] = 1] = \"Nest\";\n    IntervalType[IntervalType[\"SlideOnRemove\"] = 2] = \"SlideOnRemove\";\n    IntervalType[IntervalType[\"Transient\"] = 4] = \"Transient\";\n})(IntervalType || (IntervalType = {}));\n//# sourceMappingURL=ops.js.map","export function combine(combiningInfo, currentValue, newValue, seq) {\n    if (currentValue === undefined) {\n        currentValue = combiningInfo.defaultValue;\n    }\n    // fixed set of operations for now\n    switch (combiningInfo.name) {\n        case \"incr\":\n            currentValue += newValue;\n            if (combiningInfo.minValue) {\n                if (currentValue < combiningInfo.minValue) {\n                    currentValue = combiningInfo.minValue;\n                }\n            }\n            break;\n        case \"consensus\":\n            if (currentValue === undefined) {\n                currentValue = {\n                    value: newValue,\n                    seq\n                };\n            }\n            else {\n                let cv = currentValue;\n                if (cv.seq === -1) {\n                    cv.seq = seq;\n                }\n            }\n            break;\n    }\n    return currentValue;\n}\nexport function matchProperties(a, b) {\n    if (a) {\n        if (!b) {\n            return false;\n        }\n        else {\n            // for now, straightforward; later use hashing\n            for (let key in a) {\n                if (b[key] === undefined) {\n                    return false;\n                }\n                else if (b[key] !== a[key]) {\n                    return false;\n                }\n            }\n            for (let key in b) {\n                if (a[key] === undefined) {\n                    return false;\n                }\n            }\n        }\n    }\n    else {\n        if (b) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function extend(base, extension, combiningOp, seq) {\n    if (extension !== undefined) {\n        if ((typeof extension !== \"object\")) {\n            console.log(`oh my ${extension}`);\n        }\n        for (let key in extension) {\n            let v = extension[key];\n            if (v === null) {\n                delete base[key];\n            }\n            else {\n                if (combiningOp && (combiningOp.name !== \"rewrite\")) {\n                    base[key] = combine(combiningOp, base[key], v, seq);\n                }\n                else {\n                    base[key] = v;\n                }\n            }\n        }\n    }\n    return base;\n}\nexport function addProperties(oldProps, newProps, op, seq) {\n    if ((!oldProps) || (op && (op.name === \"rewrite\"))) {\n        oldProps = createMap();\n    }\n    extend(oldProps, newProps, op, seq);\n    return oldProps;\n}\nexport function extendIfUndefined(base, extension) {\n    if (extension !== undefined) {\n        if ((typeof extension !== \"object\")) {\n            console.log(`oh my ${extension}`);\n        }\n        for (let key in extension) {\n            if (base[key] === undefined) {\n                base[key] = extension[key];\n            }\n        }\n    }\n    return base;\n}\n/** Create a MapLike with good performance. */\nexport function createMap() {\n    const map = Object.create(null); // tslint:disable-line:no-null-keyword\n    // Using 'delete' on an object causes V8 to put the object in dictionary mode.\n    // This disables creation of hidden classes, which are expensive when an object is\n    // constantly changing shape.\n    map[\"__\"] = undefined;\n    delete map[\"__\"];\n    return map;\n}\n//# sourceMappingURL=properties.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./sharedObject\"));\n__export(require(\"./extension\"));\n__export(require(\"./valueType\"));\n//# sourceMappingURL=index.js.map","// tslint:disable\nimport * as MergeTree from \"./mergeTree\";\nexport class Stack {\n    constructor() {\n        this.items = [];\n    }\n    push(val) {\n        this.items.push(val);\n    }\n    empty() {\n        return this.items.length == 0;\n    }\n    top() {\n        return this.items[this.items.length - 1];\n    }\n    pop() {\n        return this.items.pop();\n    }\n}\nexport function ListRemoveEntry(entry) {\n    if (entry === undefined) {\n        return undefined;\n    }\n    else if (entry.isHead) {\n        return undefined;\n    }\n    else {\n        entry.next.prev = entry.prev;\n        entry.prev.next = entry.next;\n    }\n    return (entry);\n}\nexport function ListMakeEntry(data) {\n    var entry = new List(false, data);\n    entry.prev = entry;\n    entry.next = entry;\n    return entry;\n}\nexport function ListMakeHead() {\n    var entry = new List(true, undefined);\n    entry.prev = entry;\n    entry.next = entry;\n    return entry;\n}\nexport class List {\n    constructor(isHead, data) {\n        this.isHead = isHead;\n        this.data = data;\n    }\n    clear() {\n        if (this.isHead) {\n            this.prev = this;\n            this.next = this;\n        }\n    }\n    add(data) {\n        var entry = ListMakeEntry(data);\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return (entry);\n    }\n    dequeue() {\n        if (!this.empty()) {\n            let removedEntry = ListRemoveEntry(this.next);\n            return removedEntry.data;\n        }\n    }\n    enqueue(data) {\n        return this.add(data);\n    }\n    walk(fn) {\n        for (var entry = this.next; !(entry.isHead); entry = entry.next) {\n            fn(entry.data, entry);\n        }\n    }\n    some(fn, rev) {\n        for (var entry = this; !(entry.isHead); entry = rev ? entry.prev : entry.next) {\n            if (fn(entry.data, entry)) {\n                return (entry.data);\n            }\n        }\n    }\n    count() {\n        var entry;\n        var i;\n        entry = this.next;\n        for (i = 0; !(entry.isHead); i++) {\n            entry = entry.next;\n        }\n        return (i);\n    }\n    first() {\n        if (!this.empty()) {\n            return (this.next.data);\n        }\n    }\n    last() {\n        if (!this.empty()) {\n            return (this.prev.data);\n        }\n    }\n    empty() {\n        return (this.next == this);\n    }\n    pushEntry(entry) {\n        entry.isHead = false;\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n    }\n    push(data) {\n        var entry = ListMakeEntry(data);\n        entry.data = data;\n        entry.isHead = false;\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n    }\n    popEntry(head) {\n        if (this.next.isHead)\n            return (undefined);\n        else\n            return (ListRemoveEntry(this.next));\n    }\n    insertEntry(entry) {\n        entry.isHead = false;\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return entry;\n    }\n    insertAfter(data) {\n        var entry = ListMakeEntry(data);\n        entry.next = this.next;\n        entry.prev = this;\n        this.next = entry;\n        entry.next.prev = entry;\n        return (entry);\n    }\n    insertBefore(data) {\n        var entry = ListMakeEntry(data);\n        return this.insertEntryBefore(entry);\n    }\n    insertEntryBefore(entry) {\n        this.prev.next = entry;\n        entry.next = this;\n        entry.prev = this.prev;\n        this.prev = entry;\n        return (entry);\n    }\n}\nexport var numberComparer = {\n    min: Number.MIN_VALUE,\n    compare: (a, b) => a - b,\n};\nexport class Heap {\n    constructor(a, comp) {\n        this.comp = comp;\n        this.L = [comp.min];\n        for (var i = 0, len = a.length; i < len; i++) {\n            this.add(a[i]);\n        }\n    }\n    count() {\n        return this.L.length - 1;\n    }\n    peek() {\n        return this.L[1];\n    }\n    get() {\n        var x = this.L[1];\n        this.L[1] = this.L[this.count()];\n        this.L.pop();\n        this.fixdown(1);\n        return x;\n    }\n    add(x) {\n        this.L.push(x);\n        this.fixup(this.count());\n    }\n    fixup(k) {\n        while (k > 1 && (this.comp.compare(this.L[k >> 1], this.L[k]) > 0)) {\n            var tmp = this.L[k >> 1];\n            this.L[k >> 1] = this.L[k];\n            this.L[k] = tmp;\n            k = k >> 1;\n        }\n    }\n    fixdown(k) {\n        while ((k << 1) <= (this.count())) {\n            var j = k << 1;\n            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {\n                j++;\n            }\n            if (this.comp.compare(this.L[k], this.L[j]) <= 0) {\n                break;\n            }\n            var tmp = this.L[k];\n            this.L[k] = this.L[j];\n            this.L[j] = tmp;\n            k = j;\n        }\n    }\n}\n// for testing\nexport function LinearDictionary(compareKeys) {\n    let a = [];\n    function compareProps(a, b) {\n        return compareKeys(a.key, b.key);\n    }\n    function diag() {\n        console.log(`size is ${a.length}`);\n    }\n    function mapRange(action, accum, start, end) {\n        if (start === undefined) {\n            start = min().key;\n        }\n        if (end === undefined) {\n            end = max().key;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (compareKeys(start, a[i].key) <= 0) {\n                let ecmp = compareKeys(end, a[i].key);\n                if (ecmp < 0) {\n                    break;\n                }\n                if (!action(a[i], accum)) {\n                    break;\n                }\n            }\n        }\n    }\n    function map(action, accum) {\n        mapRange(action, accum);\n    }\n    function min() {\n        if (a.length > 0) {\n            return a[0];\n        }\n    }\n    function max() {\n        if (a.length > 0) {\n            return a[a.length - 1];\n        }\n    }\n    function get(key) {\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i].key == key) {\n                return a[i];\n            }\n        }\n    }\n    function put(key, data) {\n        if (key !== undefined) {\n            if (data === undefined) {\n                remove(key);\n            }\n            else {\n                a.push({ key: key, data: data });\n                a.sort(compareProps); // go to insertion sort if too slow\n            }\n        }\n    }\n    function remove(key) {\n        if (key !== undefined) {\n            for (let i = 0, len = a.length; i < len; i++) {\n                if (a[i].key == key) {\n                    a[i] = a[len - 1];\n                    a.length--;\n                    a.sort(compareProps);\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        min: min,\n        max: max,\n        map: map,\n        mapRange: mapRange,\n        remove: remove,\n        get: get,\n        put: put,\n        diag: diag\n    };\n}\nexport class RedBlackTree {\n    constructor(compareKeys, aug) {\n        this.compareKeys = compareKeys;\n        this.aug = aug;\n    }\n    makeNode(key, data, color, size) {\n        let node = { key: key, data: data, color: color, size: size };\n        if (this.aug && this.aug.init) {\n            this.aug.init(node);\n        }\n        return node;\n    }\n    isRed(node) {\n        return node && (node.color == 0 /* RED */);\n    }\n    nodeSize(node) {\n        return node ? node.size : 0;\n    }\n    size() {\n        return this.nodeSize(this.root);\n    }\n    isEmpty() {\n        return !this.root;\n    }\n    get(key) {\n        if (key !== undefined) {\n            return this.nodeGet(this.root, key);\n        }\n    }\n    nodeGet(node, key) {\n        while (node) {\n            let cmp = this.compareKeys(key, node.key);\n            if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n            else {\n                return node;\n            }\n        }\n    }\n    contains(key) {\n        return this.get(key);\n    }\n    gather(key, matcher) {\n        let results = [];\n        if (key !== undefined) {\n            this.nodeGather(this.root, results, key, matcher);\n        }\n        return results;\n    }\n    nodeGather(node, results, key, matcher) {\n        if (node) {\n            if (matcher.continueSubtree(node.left, key)) {\n                this.nodeGather(node.left, results, key, matcher);\n            }\n            if (matcher.matchNode(node, key)) {\n                results.push(node);\n            }\n            if (matcher.continueSubtree(node.right, key)) {\n                this.nodeGather(node.right, results, key, matcher);\n            }\n        }\n    }\n    put(key, data, conflict) {\n        if (key !== undefined) {\n            if (data === undefined) {\n                this.remove(key);\n            }\n            else {\n                this.root = this.nodePut(this.root, key, data, conflict);\n                this.root.color = 1 /* BLACK */;\n            }\n        }\n    }\n    nodePut(node, key, data, conflict) {\n        if (!node) {\n            return this.makeNode(key, data, 0 /* RED */, 1);\n        }\n        else {\n            let cmp = this.compareKeys(key, node.key);\n            if (cmp < 0) {\n                node.left = this.nodePut(node.left, key, data, conflict);\n            }\n            else if (cmp > 0) {\n                node.right = this.nodePut(node.right, key, data, conflict);\n            }\n            else {\n                if (conflict) {\n                    const kd = conflict(key, node.key, data, node.data);\n                    if (kd.key) {\n                        node.key = kd.key;\n                    }\n                    if (kd.data) {\n                        node.data = kd.data;\n                    }\n                    else {\n                        node.data = data;\n                    }\n                }\n                else {\n                    node.data = data;\n                }\n            }\n            if (this.isRed(node.right) && (!this.isRed(node.left))) {\n                node = this.rotateLeft(node);\n            }\n            if (this.isRed(node.left) && this.isRed(node.left.left)) {\n                node = this.rotateRight(node);\n            }\n            if (this.isRed(node.left) && this.isRed(node.right)) {\n                this.flipColors(node);\n            }\n            node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n            if (this.aug) {\n                this.updateLocal(node);\n            }\n            return node;\n        }\n    }\n    updateLocal(node) {\n        if (this.aug) {\n            if (this.isRed(node.left)) {\n                this.aug.update(node.left);\n            }\n            if (this.isRed(node.right)) {\n                this.aug.update(node.right);\n            }\n            this.aug.update(node);\n        }\n    }\n    removeMin() {\n        if (!this.isEmpty()) {\n            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n                this.root.color = 0 /* RED */;\n            }\n            this.root = this.nodeRemoveMin(this.root);\n            if (!this.isEmpty()) {\n                this.root.color = 1 /* BLACK */;\n            }\n        }\n        // TODO: error on empty\n    }\n    nodeRemoveMin(node) {\n        if (node.left) {\n            if ((!this.isRed(node.left)) && (!this.isRed(node.left.left))) {\n                node = this.moveRedLeft(node);\n            }\n            node.left = this.nodeRemoveMin(node.left);\n            return this.balance(node);\n        }\n    }\n    removeMax() {\n        if (this.isEmpty()) {\n            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n                this.root.color = 0 /* RED */;\n            }\n            this.root = this.nodeRemoveMax(this.root);\n            if (!this.isEmpty()) {\n                this.root.color = 1 /* BLACK */;\n            }\n        }\n        // TODO: error on empty\n    }\n    nodeRemoveMax(node) {\n        if (this.isRed(node.left)) {\n            node = this.rotateRight(node);\n        }\n        if (!node.right) {\n            return undefined;\n        }\n        if ((!this.isRed(node.right)) && (!this.isRed(node.right.left))) {\n            node = this.moveRedRight(node);\n        }\n        node.right = this.nodeRemoveMax(node.right);\n        return this.balance(node);\n    }\n    remove(key) {\n        if (key !== undefined) {\n            if (!this.contains(key)) {\n                return;\n            }\n            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {\n                this.root.color = 0 /* RED */;\n            }\n            this.root = this.nodeRemove(this.root, key);\n        }\n        // TODO: error on undefined key\n    }\n    nodeRemove(node, key) {\n        if (this.compareKeys(key, node.key) < 0) {\n            if ((!this.isRed(node.left)) && (!this.isRed(node.left.left))) {\n                node = this.moveRedLeft(node);\n            }\n            node.left = this.nodeRemove(node.left, key);\n        }\n        else {\n            if (this.isRed(node.left)) {\n                node = this.rotateRight(node);\n            }\n            if ((this.compareKeys(key, node.key) == 0) && (!node.right)) {\n                return undefined;\n            }\n            if ((!this.isRed(node.right)) && (!this.isRed(node.right.left))) {\n                node = this.moveRedRight(node);\n            }\n            if (this.compareKeys(key, node.key) == 0) {\n                let subtreeMin = this.nodeMin(node.right);\n                node.key = subtreeMin.key;\n                node.data = subtreeMin.data;\n                node.right = this.nodeRemoveMin(node.right);\n            }\n            else {\n                node.right = this.nodeRemove(node.right, key);\n            }\n        }\n        return this.balance(node);\n    }\n    height() {\n        return this.nodeHeight(this.root);\n    }\n    nodeHeight(node) {\n        if (node === undefined) {\n            return -1;\n        }\n        else {\n            return 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));\n        }\n    }\n    floor(key) {\n        if (!this.isEmpty()) {\n            return this.nodeFloor(this.root, key);\n        }\n    }\n    nodeFloor(node, key) {\n        if (node) {\n            let cmp = this.compareKeys(key, node.key);\n            if (cmp == 0) {\n                return node;\n            }\n            else if (cmp < 0) {\n                return this.nodeFloor(node.left, key);\n            }\n            else {\n                let rightFloor = this.nodeFloor(node.right, key);\n                if (rightFloor) {\n                    return rightFloor;\n                }\n                else {\n                    return node;\n                }\n            }\n        }\n    }\n    ceil(key) {\n        if (!this.isEmpty()) {\n            return this.nodeCeil(this.root, key);\n        }\n    }\n    nodeCeil(node, key) {\n        if (node) {\n            let cmp = this.compareKeys(key, node.key);\n            if (cmp == 0) {\n                return node;\n            }\n            else if (cmp > 0) {\n                return this.nodeCeil(node.right, key);\n            }\n            else {\n                let leftCeil = this.nodeCeil(node.left, key);\n                if (leftCeil) {\n                    return leftCeil;\n                }\n                else {\n                    return node;\n                }\n            }\n        }\n    }\n    min() {\n        if (!this.isEmpty()) {\n            return this.nodeMin(this.root);\n        }\n        // TODO: error on empty\n    }\n    nodeMin(node) {\n        if (!node.left) {\n            return node;\n        }\n        else {\n            return this.nodeMin(node.left);\n        }\n    }\n    max() {\n        if (!this.isEmpty()) {\n            return this.nodeMax(this.root);\n        }\n        // TODO: error on empty\n    }\n    nodeMax(node) {\n        if (!node.right) {\n            return node;\n        }\n        else {\n            return this.nodeMax(node.right);\n        }\n    }\n    rotateRight(node) {\n        let leftChild = node.left;\n        node.left = leftChild.right;\n        leftChild.right = node;\n        leftChild.color = leftChild.right.color;\n        leftChild.right.color = 0 /* RED */;\n        leftChild.size = node.size;\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.updateLocal(node);\n            this.updateLocal(leftChild);\n        }\n        return leftChild;\n    }\n    rotateLeft(node) {\n        let rightChild = node.right;\n        node.right = rightChild.left;\n        rightChild.left = node;\n        rightChild.color = rightChild.left.color;\n        rightChild.left.color = 0 /* RED */;\n        rightChild.size = node.size;\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.updateLocal(node);\n            this.updateLocal(rightChild);\n        }\n        return rightChild;\n    }\n    oppositeColor(c) {\n        return (c == 1 /* BLACK */) ? 0 /* RED */ : 1 /* BLACK */;\n    }\n    flipColors(node) {\n        node.color = this.oppositeColor(node.color);\n        node.left.color = this.oppositeColor(node.left.color);\n        node.right.color = this.oppositeColor(node.right.color);\n    }\n    moveRedLeft(node) {\n        this.flipColors(node);\n        if (this.isRed(node.right.left)) {\n            node.right = this.rotateRight(node.right);\n            node = this.rotateLeft(node);\n            this.flipColors(node);\n        }\n        return node;\n    }\n    moveRedRight(node) {\n        this.flipColors(node);\n        if (this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n            this.flipColors(node);\n        }\n        return node;\n    }\n    balance(node) {\n        if (this.isRed(node.right)) {\n            node = this.rotateLeft(node);\n        }\n        if (this.isRed(node.left) && this.isRed(node.left.left)) {\n            node = this.rotateRight(node);\n        }\n        if (this.isRed(node.left) && (this.isRed(node.right))) {\n            this.flipColors(node);\n        }\n        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;\n        if (this.aug) {\n            this.aug.update(node);\n        }\n        return node;\n    }\n    mapRange(action, accum, start, end) {\n        this.nodeMap(this.root, action, start, end);\n    }\n    map(action, accum) {\n        // TODO: optimize to avoid comparisons\n        this.nodeMap(this.root, action, accum);\n    }\n    keys() {\n        let keyList = [];\n        let actions = {\n            showStructure: true,\n            infix: (node) => {\n                keyList.push(node.key);\n                return true;\n            }\n        };\n        this.walk(actions);\n        return keyList;\n    }\n    /**\n     * Depth-first traversal with custom action; if action returns\n     * false, traversal is halted.\n     * @param action action to apply to each node\n     */\n    walk(actions) {\n        this.nodeWalk(this.root, actions);\n    }\n    nodeWalk(node, actions) {\n        let go = true;\n        if (node) {\n            if (actions.pre) {\n                if (actions.showStructure || (node.color === 1 /* BLACK */)) {\n                    go = actions.pre(node);\n                }\n            }\n            if (node.left) {\n                go = this.nodeWalk(node.left, actions);\n            }\n            if (go && actions.infix) {\n                if (actions.showStructure || (node.color === 1 /* BLACK */)) {\n                    go = actions.infix(node);\n                }\n            }\n            if (go) {\n                go = this.nodeWalk(node.right, actions);\n            }\n            if (go && actions.post) {\n                if (actions.showStructure || (node.color === 1 /* BLACK */)) {\n                    go = actions.post(node);\n                }\n            }\n        }\n        return go;\n    }\n    nodeMap(node, action, accum, start, end) {\n        if (!node) {\n            return true;\n        }\n        if (start === undefined) {\n            start = this.nodeMin(node).key;\n        }\n        if (end === undefined) {\n            end = this.nodeMax(node).key;\n        }\n        let cmpStart = this.compareKeys(start, node.key);\n        let cmpEnd = this.compareKeys(end, node.key);\n        let go = true;\n        if (cmpStart < 0) {\n            go = this.nodeMap(node.left, action, accum, start, end);\n        }\n        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {\n            // REVIEW: test for black node here\n            go = action(node, accum);\n        }\n        if (go && (cmpEnd > 0)) {\n            go = this.nodeMap(node.right, action, accum, start, end);\n        }\n        return go;\n    }\n    diag() {\n        console.log(`Height is ${this.height()}`);\n    }\n}\n/**\n * Union of two ranges; assumes for both ranges start <= end.\n * @param a A range\n * @param b A range\n */\nexport function integerRangeUnion(a, b) {\n    return {\n        start: Math.min(a.start, b.start),\n        end: Math.max(a.end, b.end)\n    };\n}\nexport function integerRangeOverlaps(a, b) {\n    return (a.start < b.end) && (a.end > b.start);\n}\nexport function integerRangeComparer(a, b) {\n    if (a.start === b.start) {\n        return a.end - b.end;\n    }\n    else {\n        return a.start - b.start;\n    }\n}\nexport function integerRangeCopy(r) {\n    return { start: r.start, end: r.end };\n}\nexport function integerRangeToString(range) {\n    return `[${range.start},${range.end})`;\n}\n// TODO: handle duplicate keys\nexport class IntegerRangeTree {\n    constructor() {\n        this.ranges = new RedBlackTree(integerRangeComparer, this);\n        this.diag = false;\n    }\n    remove(r) {\n        this.ranges.remove(r);\n    }\n    put(r) {\n        this.ranges.put(r, { minmax: integerRangeCopy(r) });\n    }\n    toString() {\n        return this.nodeToString(this.ranges.root);\n    }\n    nodeToString(node) {\n        let buf = \"\";\n        let indentAmt = 0;\n        let actions = {\n            pre: (node) => {\n                let red = \"\";\n                if (node.color === 0 /* RED */) {\n                    red = \"R \";\n                }\n                buf += MergeTree.internedSpaces(indentAmt);\n                buf += `${red}key: ${integerRangeToString(node.key)} minmax: ${integerRangeToString(node.data.minmax)}\\n`;\n                indentAmt += 2;\n                return true;\n            },\n            post: (node) => {\n                indentAmt -= 2;\n                return true;\n            },\n            showStructure: true\n        };\n        this.ranges.nodeWalk(node, actions);\n        return buf;\n    }\n    matchPos(pos) {\n        return this.match({ start: pos, end: pos + 1 });\n    }\n    match(r) {\n        return this.ranges.gather(r, this);\n    }\n    matchNode(node, key) {\n        return node && integerRangeOverlaps(node.key, key);\n    }\n    continueSubtree(node, key) {\n        let cont = node && integerRangeOverlaps(node.data.minmax, key);\n        if (this.diag && (!cont)) {\n            if (node) {\n                console.log(`skipping subtree of size ${node.size} key ${integerRangeToString(key)}`);\n                console.log(this.nodeToString(node));\n            }\n        }\n        return cont;\n    }\n    update(node) {\n        if (node.left && node.right) {\n            node.data.minmax = integerRangeUnion(node.key, integerRangeUnion(node.left.data.minmax, node.right.data.minmax));\n        }\n        else {\n            if (node.left) {\n                node.data.minmax = integerRangeUnion(node.key, node.left.data.minmax);\n            }\n            else if (node.right) {\n                node.data.minmax = integerRangeUnion(node.key, node.right.data.minmax);\n            }\n            else {\n                node.data.minmax = integerRangeCopy(node.key);\n            }\n        }\n    }\n}\nexport function intervalComparer(a, b) {\n    return a.compare(b);\n}\nexport class IntervalTree {\n    constructor() {\n        this.intervals = new RedBlackTree(intervalComparer, this);\n        this.diag = false;\n        this.timePut = false;\n        this.putTime = 0;\n        this.putCount = 0;\n    }\n    printTiming() {\n        console.log(`put total = ${this.putTime} avg=${(this.putTime / this.putCount).toFixed(2)}`);\n    }\n    remove(x) {\n        this.intervals.remove(x);\n    }\n    put(x, conflict) {\n        let rbConflict;\n        if (conflict) {\n            rbConflict = (key, currentKey) => {\n                const ival = conflict(key, currentKey);\n                return {\n                    key: ival,\n                };\n            };\n        }\n        if (this.timePut) {\n            let clockStart = MergeTree.clock();\n            this.intervals.put(x, { minmax: x.clone() }, rbConflict);\n            this.putTime += MergeTree.elapsedMicroseconds(clockStart);\n            this.putCount++;\n        }\n        else {\n            this.intervals.put(x, { minmax: x.clone() }, rbConflict);\n        }\n    }\n    map(fn) {\n        let actions = {\n            infix: (node) => {\n                fn(node.key);\n                return true;\n            },\n            showStructure: true,\n        };\n        this.intervals.walk(actions);\n    }\n    // TODO: toString()\n    match(x) {\n        return this.intervals.gather(x, this);\n    }\n    matchNode(node, key) {\n        return node && node.key.overlaps(key);\n    }\n    continueSubtree(node, key) {\n        let cont = node && node.data.minmax.overlaps(key);\n        if (this.diag && (!cont)) {\n            if (node) {\n                console.log(`skipping subtree of size ${node.size} key ${key.toString()}`);\n                // console.log(this.nodeToString(node));\n            }\n        }\n        return cont;\n    }\n    update(node) {\n        if (node.left && node.right) {\n            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));\n        }\n        else {\n            if (node.left) {\n                node.data.minmax = node.key.union(node.left.data.minmax);\n            }\n            else if (node.right) {\n                node.data.minmax = node.key.union(node.right.data.minmax);\n            }\n            else {\n                node.data.minmax = node.key.clone();\n            }\n        }\n    }\n}\nexport class TST {\n    constructor() {\n        this.n = 0;\n    }\n    size() {\n        return this.n;\n    }\n    contains(key) {\n        return this.get(key);\n    }\n    get(key) {\n        let x = this.nodeGet(this.root, key, 0);\n        if (x === undefined) {\n            return undefined;\n        }\n        return x.val;\n    }\n    nodeGet(x, key, d) {\n        if (x === undefined) {\n            return undefined;\n        }\n        let c = key.charAt(d);\n        if (c < x.c) {\n            return this.nodeGet(x.left, key, d);\n        }\n        else if (c > x.c) {\n            return this.nodeGet(x.right, key, d);\n        }\n        else if (d < (key.length - 1)) {\n            return this.nodeGet(x.mid, key, d + 1);\n        }\n        else\n            return x;\n    }\n    put(key, val) {\n        if (!this.contains(key)) {\n            this.n++;\n        }\n        this.root = this.nodePut(this.root, key, val, 0);\n        // console.log(`put ${key}`);\n    }\n    nodePut(x, key, val, d) {\n        let c = key.charAt(d);\n        if (x === undefined) {\n            x = { c };\n        }\n        if (c < x.c) {\n            x.left = this.nodePut(x.left, key, val, d);\n        }\n        else if (c > x.c) {\n            x.right = this.nodePut(x.right, key, val, d);\n        }\n        else if (d < (key.length - 1)) {\n            x.mid = this.nodePut(x.mid, key, val, d + 1);\n        }\n        else {\n            x.val = val;\n        }\n        return x;\n    }\n    neighbors(text, distance = 2) {\n        let q = [];\n        this.nodeProximity(this.root, { text: \"\" }, 0, text, distance, q);\n        q = q.filter(value => (value.text.length > 0));\n        return q;\n    }\n    keysWithPrefix(text) {\n        let q = [];\n        let x = this.nodeGet(this.root, text, 0);\n        if (x === undefined) {\n            return q;\n        }\n        if (x.val !== undefined) {\n            q.push(text);\n        }\n        this.collect(x.mid, { text }, q);\n        return q;\n    }\n    collect(x, prefix, q) {\n        if (x === undefined) {\n            return;\n        }\n        this.collect(x.left, prefix, q);\n        if (x.val !== undefined) {\n            q.push(prefix.text + x.c);\n        }\n        this.collect(x.mid, { text: prefix.text + x.c }, q);\n        this.collect(x.right, prefix, q);\n    }\n    pairsWithPrefix(text) {\n        let q = [];\n        let x = this.nodeGet(this.root, text, 0);\n        if (x === undefined) {\n            return q;\n        }\n        if (x.val !== undefined) {\n            q.push({ key: text, val: x.val });\n        }\n        this.collectPairs(x.mid, { text }, q);\n        return q;\n    }\n    collectPairs(x, prefix, q) {\n        if (x === undefined) {\n            return;\n        }\n        this.collectPairs(x.left, prefix, q);\n        if (x.val !== undefined) {\n            q.push({ key: prefix.text + x.c, val: x.val });\n        }\n        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);\n        this.collectPairs(x.right, prefix, q);\n    }\n    patternCollect(x, prefix, d, pattern, q) {\n        if (x === undefined) {\n            return;\n        }\n        let c = pattern.charAt(d);\n        if ((c === '.') || (c < x.c)) {\n            this.patternCollect(x.left, prefix, d, pattern, q);\n        }\n        else if ((c === '.') || (c === x.c)) {\n            if ((d === (pattern.length - 1)) && (x.val !== undefined)) {\n                q.push(prefix.text + x.c);\n            }\n            else if (d < (pattern.length - 1)) {\n                this.patternCollect(x.mid, { text: prefix.text + x.c }, d + 1, pattern, q);\n            }\n        }\n        if ((c === '.') || (c > x.c)) {\n            this.patternCollect(x.right, prefix, d, pattern, q);\n        }\n    }\n    nodeProximity(x, prefix, d, pattern, distance, q) {\n        if ((x === undefined) || (distance < 0)) {\n            return;\n        }\n        let c = pattern.charAt(d);\n        if ((distance > 0) || (c < x.c)) {\n            this.nodeProximity(x.left, prefix, d, pattern, distance, q);\n        }\n        if (x.val !== undefined) {\n            let remD = distance - (pattern.length - d);\n            if (remD >= 0) {\n                let invD = distance;\n                if (c !== x.c) {\n                    invD--;\n                }\n                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });\n            }\n        }\n        let recurD = (d < (pattern.length - 1)) ? d + 1 : d;\n        if (c === x.c) {\n            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);\n        }\n        else {\n            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);\n        }\n        if ((distance > 0) || (c > x.c)) {\n            this.nodeProximity(x.right, prefix, d, pattern, distance, q);\n        }\n    }\n    match(pattern) {\n        let q = [];\n        this.patternCollect(this.root, { text: \"\" }, 0, pattern, q);\n        return q;\n    }\n}\n//# sourceMappingURL=collections.js.map","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = require('./common')(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// tslint:disable:whitespace align no-bitwise\nimport { FileMode, TreeEntry, } from \"@prague/container-definitions\";\nimport { MapExtension, SharedMap, } from \"@prague/map\";\nimport * as MergeTree from \"@prague/merge-tree\";\nimport { Deferred } from \"@prague/utils\";\nimport * as assert from \"assert\";\n// tslint:disable-next-line:no-submodule-imports no-var-requires no-require-imports\nconst cloneDeep = require(\"lodash/cloneDeep\");\n// tslint:disable-next-line:no-submodule-imports\nimport * as uuid from \"uuid/v4\";\nimport { SharedNumberSequenceExtension, SharedObjectSequenceExtension, } from \"./extension\";\nimport { SharedStringIntervalCollectionValueType, } from \"./intervalCollection\";\nimport { SequenceDeltaEvent } from \"./sequenceDeltaEvent\";\nexport class SegmentSequence extends SharedMap {\n    constructor(document, id, extensionType, services) {\n        super(id, document, extensionType);\n        this.id = id;\n        this.isLoaded = false;\n        this.collabStarted = false;\n        this.pendingMinSequenceNumber = 0;\n        // Deferred that triggers once the object is loaded\n        this.loadedDeferred = new Deferred();\n        this.messagesSinceMSNChange = new Array();\n        /* tslint:disable:no-unsafe-any */\n        this.client = new MergeTree.Client(\"\", document.options);\n        super.on(\"newListener\", (event) => {\n            switch (event) {\n                case \"sequenceDelta\":\n                    if (!this.client.mergeTree.mergeTreeDeltaCallback) {\n                        this.client.mergeTree.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {\n                            this.emit(\"sequenceDelta\", this, new SequenceDeltaEvent(opArgs, this.client, deltaArgs));\n                        };\n                    }\n                    break;\n                default:\n            }\n        });\n        super.on(\"removeListener\", (event) => {\n            switch (event) {\n                case \"sequenceDelta\":\n                    if (super.listenerCount(event) === 0) {\n                        this.client.mergeTree.mergeTreeDeltaCallback = undefined;\n                    }\n                    break;\n                default:\n            }\n        });\n    }\n    get loaded() {\n        return this.loadedDeferred.promise;\n    }\n    // tslint:disable-next-line:no-unnecessary-override\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    removeRange(start, end) {\n        const removeMessage = {\n            pos1: start,\n            pos2: end,\n            type: 1 /* REMOVE */,\n        };\n        this.client.removeSegmentLocal(start, end, { op: removeMessage });\n        this.submitIfAttached(removeMessage);\n    }\n    cut(register, start, end) {\n        const removeMessage = {\n            pos1: start,\n            pos2: end,\n            register,\n            type: 1 /* REMOVE */,\n        };\n        this.client.copy(start, end, register, this.client.getCurrentSeq(), this.client.getClientId(), this.client.longClientId);\n        this.client.removeSegmentLocal(start, end, { op: removeMessage });\n        this.submitIfAttached(removeMessage);\n    }\n    paste(register, pos) {\n        const insertMessage = {\n            pos1: pos,\n            register,\n            type: 0 /* INSERT */,\n        };\n        // tslint:disable-next-line:no-parameter-reassignment\n        pos = this.client.pasteLocal(register, pos, { op: insertMessage });\n        this.submitIfAttached(insertMessage);\n        return pos;\n    }\n    copy(register, start, end) {\n        const insertMessage = {\n            pos1: start,\n            pos2: end,\n            register,\n            type: 0 /* INSERT */,\n        };\n        this.client.copy(start, end, register, this.client.getCurrentSeq(), this.client.getClientId(), this.client.longClientId);\n        this.submitIfAttached(insertMessage);\n    }\n    groupOperation(groupOp) {\n        const segmentGroup = this.client.localTransaction(groupOp);\n        this.submitIfAttached(groupOp);\n        return segmentGroup;\n    }\n    annotateRange(props, start, end, op) {\n        const annotateMessage = {\n            pos1: start,\n            pos2: end,\n            props,\n            type: 2 /* ANNOTATE */,\n        };\n        if (op) {\n            annotateMessage.combiningOp = op;\n        }\n        this.client.annotateSegmentLocal(props, start, end, op, { op: annotateMessage });\n        this.submitIfAttached(annotateMessage);\n    }\n    getPropertiesAtPosition(pos) {\n        return this.client.getPropertiesAtPosition(pos);\n    }\n    getRangeExtentsOfPosition(pos) {\n        return this.client.getRangeExtentsOfPosition(pos);\n    }\n    setLocalMinSeq(lmseq) {\n        this.client.mergeTree.updateLocalMinSeq(lmseq);\n    }\n    createPositionReference(pos, refType, refSeq = this.client.getCurrentSeq(), clientId = this.client.getClientId()) {\n        const segoff = this.client.mergeTree.getContainingSegment(pos, refSeq, this.client.getClientId());\n        if (segoff && segoff.segment) {\n            const lref = new MergeTree.LocalReference(segoff.segment, segoff.offset, refType);\n            if (refType !== MergeTree.ReferenceType.Transient) {\n                this.client.mergeTree.addLocalReference(lref);\n            }\n            return lref;\n        }\n    }\n    localRefToPos(localRef) {\n        if (localRef.segment) {\n            return localRef.offset + this.client.mergeTree.getOffset(localRef.segment, this.client.getCurrentSeq(), this.client.getClientId());\n        }\n        else {\n            return -1;\n        }\n    }\n    getIntervalCollections() {\n        return this.intervalCollections;\n    }\n    // TODO: fix race condition on creation by putting type on every operation\n    getSharedIntervalCollection(label) {\n        if (!this.intervalCollections.has(label)) {\n            this.intervalCollections.set(label, undefined, SharedStringIntervalCollectionValueType.Name);\n        }\n        const sharedCollection = this.intervalCollections.get(label);\n        return sharedCollection;\n    }\n    sendNACKed() {\n        const orderedSegments = [];\n        while (!this.client.mergeTree.pendingSegments.empty()) {\n            const NACKedSegmentGroup = this.client.mergeTree.pendingSegments.dequeue();\n            for (const segment of NACKedSegmentGroup.segments) {\n                orderedSegments.push(segment);\n            }\n        }\n        orderedSegments.sort((a, b) => {\n            if (a === b) {\n                return 0;\n            }\n            else if (a.ordinal < b.ordinal) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        });\n        /* tslint:disable:no-object-literal-type-assertion */\n        const segmentGroup = {\n            segments: [],\n        };\n        const opList = [];\n        let prevSeg;\n        for (const segment of orderedSegments) {\n            if (prevSeg !== segment) {\n                segment.segmentGroups.clear();\n                segment.segmentGroups.enqueue(segmentGroup);\n                this.client.segmentToOps(segment, opList);\n                prevSeg = segment;\n            }\n        }\n        const groupOp = {\n            ops: opList,\n            type: 3 /* GROUP */,\n        };\n        if (groupOp.ops.length > 0) {\n            this.client.mergeTree.pendingSegments.enqueue(segmentGroup);\n            this.submitIfAttached(groupOp);\n        }\n    }\n    loadContent(minimumSequenceNumber, headerOrigin, storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const header = yield storage.read(\"header\");\n            return this.initialize(minimumSequenceNumber, header, true, headerOrigin, storage);\n        });\n    }\n    initializeContent() {\n        const intervalCollections = this.runtime.createChannel(uuid(), MapExtension.Type);\n        this.set(\"intervalCollections\", intervalCollections);\n        // TODO will want to update initialize to operate synchronously\n        this.initialize(0, null, false, this.id, null)\n            .catch((error) => {\n            console.error(\"initializeContent\", error);\n        });\n    }\n    snapshotContent() {\n        // debug(`Transforming up to ${this.deltaManager.minimumSequenceNumber}`);\n        const transformedMessages = [];\n        for (const message of this.messagesSinceMSNChange) {\n            transformedMessages.push(this.transform(message, this.runtime.deltaManager.minimumSequenceNumber));\n        }\n        this.client.mergeTree.commitGlobalMin();\n        const snap = new MergeTree.Snapshot(this.client.mergeTree);\n        snap.extractSync();\n        const mtSnap = snap.emit();\n        mtSnap.entries.push({\n            mode: FileMode.File,\n            path: \"tardis\",\n            type: TreeEntry[TreeEntry.Blob],\n            value: {\n                contents: JSON.stringify(transformedMessages),\n                encoding: \"utf-8\",\n            },\n        });\n        return mtSnap;\n    }\n    /* tslint:disable:promise-function-async */\n    prepareContent() {\n        return this.loadedDeferred.promise;\n    }\n    processContent(message) {\n        this.messagesSinceMSNChange.push(message);\n        this.processMessage(message);\n    }\n    processMinSequenceNumberChangedContent(value) {\n        let index = 0;\n        for (; index < this.messagesSinceMSNChange.length; index++) {\n            if (this.messagesSinceMSNChange[index].sequenceNumber > value) {\n                break;\n            }\n        }\n        if (index !== 0) {\n            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);\n        }\n        // Apply directly once loaded - otherwise track so we can update later\n        if (this.isLoaded) {\n            this.client.updateMinSeq(value);\n        }\n        else {\n            this.pendingMinSequenceNumber = value;\n        }\n    }\n    attachContent() {\n        this.client.startCollaboration(this.runtime.clientId, 0);\n        this.collabStarted = true;\n    }\n    onConnectContent(pending) {\n        // Update merge tree collaboration information with new client ID and then resend pending ops\n        if (this.collabStarted) {\n            this.client.updateCollaboration(this.runtime.clientId);\n        }\n        this.sendNACKed();\n        return;\n    }\n    readyContent() {\n        return this.loaded;\n    }\n    submitIfAttached(message) {\n        if (this.isLocal()) {\n            return;\n        }\n        this.submitLocalMessage(message);\n    }\n    processMessage(message) {\n        this.client.applyMsg(message);\n        if (this.client.mergeTree.minSeqPending) {\n            this.client.mergeTree.notifyMinSeqListeners();\n        }\n    }\n    transform(originalMessage, sequenceNumber) {\n        let message = originalMessage;\n        // Allow the distributed data types to perform custom transformations\n        if (message.referenceSequenceNumber < sequenceNumber) {\n            // Make a copy of original message since we will be modifying in place\n            message = cloneDeep(message);\n            message.contents = this.client.transform(message.contents, message.referenceSequenceNumber, sequenceNumber);\n            message.referenceSequenceNumber = sequenceNumber;\n        }\n        return message;\n    }\n    loadHeader(minimumSequenceNumber, header, shared, originBranch) {\n        if (!header) {\n            return;\n        }\n        const chunk = MergeTree.Snapshot.processChunk(header);\n        const segs = this.segmentsFromSpecs(chunk.segmentTexts);\n        this.client.mergeTree.reloadFromSegments(segs);\n        if (shared) {\n            // TODO currently only assumes two levels of branching\n            const branchId = originBranch === this.runtime.documentId ? 0 : 1;\n            this.collabStarted = true;\n            this.client.startCollaboration(this.runtime.clientId, minimumSequenceNumber, branchId);\n        }\n    }\n    loadBody(header, originBranch, services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If loading from a snapshot load in the body and tardis messages\n            if (header) {\n                const [chunk, rawMessages] = yield Promise.all([\n                    yield MergeTree.Snapshot.loadChunk(services, \"body\"),\n                    services.read(\"tardis\"),\n                ]);\n                for (const segSpec of chunk.segmentTexts) {\n                    this.appendSegment(segSpec);\n                }\n                const messages = JSON.parse(Buffer.from(rawMessages, \"base64\").toString());\n                if (originBranch !== this.runtime.documentId) {\n                    for (const message of messages) {\n                        // Append branch information when transforming for the case of messages stashed with the snapshot\n                        message.origin = {\n                            id: originBranch,\n                            minimumSequenceNumber: message.minimumSequenceNumber,\n                            sequenceNumber: message.sequenceNumber,\n                        };\n                    }\n                }\n                // Apply all pending messages\n                for (const message of messages) {\n                    this.processMessage(message);\n                }\n            }\n            // And initialize the interval collections\n            this.initializeIntervalCollections();\n        });\n    }\n    initialize(minimumSequenceNumber, header, shared, originBranch, services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!header) {\n                assert.equal(minimumSequenceNumber, MergeTree.Snapshot.EmptyChunk.chunkSequenceNumber);\n            }\n            this.loadHeader(minimumSequenceNumber, header, shared, originBranch);\n            this.loadBody(header, originBranch, services)\n                .then(() => {\n                this.loadFinished();\n            }, (error) => {\n                this.loadFinished(error);\n            });\n        });\n    }\n    initializeIntervalCollections() {\n        this.intervalCollections = this.get(\"intervalCollections\");\n        // Listen and initialize new SharedIntervalCollections\n        this.intervalCollections.on(\"valueChanged\", (ev) => {\n            const intervalCollection = this.intervalCollections.get(ev.key);\n            if (!intervalCollection.attached) {\n                intervalCollection.attach(this.client, ev.key);\n            }\n        });\n        // Initialize existing SharedIntervalCollections\n        for (const key of this.intervalCollections.keys()) {\n            const intervalCollection = this.intervalCollections.get(key);\n            intervalCollection.attach(this.client, key);\n        }\n    }\n    loadFinished(error) {\n        if (error) {\n            this.loadedDeferred.reject(error);\n        }\n        else {\n            this.isLoaded = true;\n            this.loadedDeferred.resolve();\n            // Update the MSN if larger than the set value\n            if (this.pendingMinSequenceNumber > this.client.mergeTree.getCollabWindow().minSeq) {\n                this.client.updateMinSeq(this.pendingMinSequenceNumber);\n            }\n        }\n    }\n}\nexport class SharedSequence extends SegmentSequence {\n    constructor(document, id, extensionType, services) {\n        super(document, id, extensionType, services);\n        this.id = id;\n        if (extensionType === SharedNumberSequenceExtension.Type) {\n            this.isNumeric = true;\n        }\n    }\n    appendSegment(segSpec) {\n        const mergeTree = this.client.mergeTree;\n        const pos = mergeTree.root.cachedLength;\n        mergeTree.insertSegment(pos, MergeTree.UniversalSequenceNumber, mergeTree.collabWindow.clientId, MergeTree.UniversalSequenceNumber, MergeTree.runToSeg(segSpec), undefined);\n    }\n    insert(pos, items, props) {\n        const insertMessage = {\n            items,\n            pos1: pos,\n            props,\n            type: 0 /* INSERT */,\n        };\n        if (this.isNumeric) {\n            insertMessage.isNumberSequence = true;\n        }\n        const segment = new MergeTree.SubSequence(items);\n        this.client.insertSegmentLocal(pos, segment, props, { op: insertMessage });\n        this.submitIfAttached(insertMessage);\n    }\n    remove(start, end) {\n        this.removeRange(start, end);\n    }\n    getItemCount() {\n        return this.client.mergeTree.getLength(this.client.getCurrentSeq(), this.client.getClientId());\n    }\n    // tslint:disable: no-parameter-reassignment\n    getItems(start, end) {\n        if (end === undefined) {\n            end = this.getItemCount();\n        }\n        return this.client.mergeTree.getItems(this.client.getCurrentSeq(), this.client.getClientId(), start, end);\n    }\n    segmentsFromSpecs(segSpecs) {\n        return segSpecs.map(MergeTree.runToSeg);\n    }\n}\nexport class SharedObjectSequence extends SharedSequence {\n    constructor(document, id, services) {\n        super(document, id, SharedObjectSequenceExtension.Type, services);\n        this.id = id;\n    }\n    getRange(start, end) {\n        return this.getItems(start, end);\n    }\n}\nexport class SharedNumberSequence extends SharedSequence {\n    constructor(document, id, services) {\n        super(document, id, SharedNumberSequenceExtension.Type, services);\n        this.id = id;\n    }\n    getRange(start, end) {\n        return this.getItems(start, end);\n    }\n}\n//# sourceMappingURL=sequence.js.map","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SharedObject } from \"@prague/api-definitions\";\nimport { FileMode, MessageType, TreeEntry, } from \"@prague/container-definitions\";\nimport { debug } from \"./debug\";\nimport { MapExtension } from \"./extension\";\nimport { MapView } from \"./view\";\nconst snapshotFileName = \"header\";\nconst contentPath = \"content\";\n/**\n * Copies all values from the provided SharedMap to the given Map\n */\nexport function copyMap(from, to) {\n    from.forEach((value, key) => {\n        /* tslint:disable:no-unsafe-any */\n        to.set(key, value);\n    });\n}\nclass ContentObjectStorage {\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /* tslint:disable:promise-function-async */\n    read(path) {\n        return this.storage.read(`content/${path}`);\n    }\n}\n/**\n * Implementation of a map shared object\n */\nexport class SharedMap extends SharedObject {\n    /**\n     * Constructs a new shared map. If the object is non-local an id and service interfaces will\n     * be provided\n     */\n    constructor(id, runtime, type = MapExtension.Type) {\n        super(id, runtime, type);\n        this.valueTypes = new Map();\n        this.serializeFilter = (key, value, valueType) => value;\n        this.messageHandler = new Map();\n        this.pendingKeys = new Map();\n        this.pendingClearClientSequenceNumber = -1;\n        this.setMessageHandlers();\n        this.initializeView();\n        this[Symbol.toStringTag] = this.view.data[Symbol.toStringTag];\n    }\n    internalView() {\n        return this.view;\n    }\n    keys() {\n        return this.view.keys();\n    }\n    // TODO: entries and values will have incorrect content until\n    // map contains plain values and meta-data is segregated into\n    // separate map\n    entries() {\n        return this.view.data.entries();\n    }\n    values() {\n        return this.view.data.values();\n    }\n    [Symbol.iterator]() {\n        return this.view.data[Symbol.iterator]();\n    }\n    get size() {\n        return this.view.data.size;\n    }\n    forEach(callbackFn) {\n        this.view.forEach(callbackFn);\n    }\n    /**\n     * Retrieves the value with the given key from the map.\n     */\n    get(key) {\n        return this.view.get(key);\n    }\n    wait(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.view.wait(key);\n        });\n    }\n    has(key) {\n        return this.view.has(key);\n    }\n    set(key, value, type) {\n        this.view.set(key, value, type);\n        return this;\n    }\n    delete(key) {\n        return this.view.delete(key);\n    }\n    clear() {\n        return this.view.clear();\n    }\n    snapshot() {\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: snapshotFileName,\n                    type: TreeEntry[TreeEntry.Blob],\n                    value: {\n                        contents: this.view.serialize(this.serializeFilter),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n            sha: null,\n        };\n        // Add the snapshot of the content to the tree\n        const contentSnapshot = this.snapshotContent();\n        if (contentSnapshot) {\n            tree.entries.push({\n                mode: FileMode.Directory,\n                path: contentPath,\n                type: TreeEntry[TreeEntry.Tree],\n                value: contentSnapshot,\n            });\n        }\n        return tree;\n    }\n    submitMapClearMessage(op) {\n        const clientSequenceNumber = this.submitMapMessage(op);\n        if (clientSequenceNumber !== -1) {\n            this.pendingClearClientSequenceNumber = clientSequenceNumber;\n        }\n    }\n    submitMapKeyMessage(op) {\n        const clientSequenceNumber = this.submitMapMessage(op);\n        if (clientSequenceNumber !== -1) {\n            this.pendingKeys.set(op.key, clientSequenceNumber);\n        }\n    }\n    submitMapMessage(op) {\n        // Local operations do not require any extra processing\n        if (this.isLocal()) {\n            return -1;\n        }\n        // Once we have performed the attach submit the local operation\n        return this.submitLocalMessage(op);\n    }\n    /**\n     * Registers a new value type on the map\n     */\n    registerValueType(type) {\n        this.valueTypes.set(type.name, type);\n        function getOpHandler(op) {\n            const handler = type.ops.get(op.value.type);\n            if (!handler) {\n                throw new Error(\"Unknown type message\");\n            }\n            return handler;\n        }\n        const valueTypeMessageHandler = {\n            prepare: (op, local, message) => __awaiter(this, void 0, void 0, function* () {\n                const handler = getOpHandler(op);\n                const value = this.view.get(op.key);\n                return handler.prepare(value, op.value.value, local, message);\n            }),\n            process: (op, context, local, message) => {\n                const handler = getOpHandler(op);\n                const value = this.view.get(op.key);\n                handler.process(value, op.value.value, context, local, message);\n                this.emit(\"valueChanged\", { key: op.key }, local, message);\n            },\n            submit: (op) => {\n                this.submitLocalMessage(op);\n            },\n        };\n        this.messageHandler.set(type.name, valueTypeMessageHandler);\n    }\n    hasValueType(type) {\n        return this.valueTypes.has(type);\n    }\n    getValueType(type) {\n        return this.valueTypes.get(type);\n    }\n    registerSerializeFilter(filter) {\n        this.serializeFilter = filter;\n    }\n    /* tslint:disable:no-unnecessary-override */\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    onDisconnect() {\n        debug(`Map ${this.id} is now disconnected`);\n        this.onDisconnectContent();\n    }\n    onConnect(pending) {\n        debug(`Map ${this.id} is now connected`);\n        // REVIEW: Does it matter that the map and content message get out of order?\n        // Filter the nonAck and pending messages into a map set and a content set.\n        const mapMessages = [];\n        const contentMessages = [];\n        for (const message of pending) {\n            if (this.isMapMessage(message)) {\n                mapMessages.push(message);\n            }\n            else {\n                contentMessages.push(message);\n            }\n        }\n        // Deal with the map messages - for the map it's always last one wins so we just resend\n        for (const message of mapMessages) {\n            const handler = this.messageHandler.get(message.type);\n            handler.submit(message);\n        }\n        // Allow content to catch up\n        this.onConnectContent(contentMessages);\n    }\n    loadCore(minimumSequenceNumber, headerOrigin, storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const header = yield storage.read(snapshotFileName);\n            const data = header ? JSON.parse(Buffer.from(header, \"base64\")\n                .toString(\"utf-8\")) : {};\n            yield this.view.populate(data);\n            const contentStorage = new ContentObjectStorage(storage);\n            yield this.loadContent(minimumSequenceNumber, headerOrigin, contentStorage);\n        });\n    }\n    initializeLocalCore() {\n        this.initializeContent();\n    }\n    processMinSequenceNumberChanged(value) {\n        this.processMinSequenceNumberChangedContent(value);\n    }\n    loadContent(minimumSequenceNumber, headerOrigin, services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return;\n        });\n    }\n    initializeContent() {\n        return;\n    }\n    prepareCore(message, local) {\n        if (message.type === MessageType.Operation) {\n            const op = message.contents;\n            if (this.messageHandler.has(op.type)) {\n                return this.messageHandler.get(op.type)\n                    .prepare(op, local, message);\n            }\n        }\n        return this.prepareContent(message, local);\n    }\n    processCore(message, local, context) {\n        let handled = false;\n        if (message.type === MessageType.Operation) {\n            const op = message.contents;\n            if (this.messageHandler.has(op.type)) {\n                this.messageHandler.get(op.type)\n                    .process(op, context, local, message);\n                handled = true;\n            }\n        }\n        if (!handled) {\n            this.processContent(message, local, context);\n        }\n    }\n    attachCore() {\n        this.view.attachAll();\n        this.attachContent();\n    }\n    // The following three methods enable derived classes to provide custom content that is stored\n    // with the map\n    attachContent() {\n        return;\n    }\n    prepareContent(message, local) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve();\n        });\n    }\n    /**\n     * Processes a content message\n     */\n    processContent(message, local, context) {\n        return;\n    }\n    /**\n     * Message sent to notify derived content of disconnection\n     */\n    onDisconnectContent() {\n        return;\n    }\n    /**\n     * Message sent upon reconnecting to the delta stream\n     */\n    onConnectContent(pending) {\n        for (const message of pending) {\n            this.submitLocalMessage(message);\n        }\n        return;\n    }\n    /**\n     * Snapshots the content\n     */\n    snapshotContent() {\n        return null;\n    }\n    /**\n     * Notifies the content that the minimum sequence number has changed\n     */\n    processMinSequenceNumberChangedContent(value) {\n        return;\n    }\n    needProcessKeyOperations(op, local, message) {\n        if (this.pendingClearClientSequenceNumber !== -1) {\n            // If I have a NACK clear, we can ignore all ops.\n            return false;\n        }\n        if ((this.pendingKeys.size !== 0 && this.pendingKeys.has(op.key))) {\n            // Found an NACK op, clear it from the map if the latest sequence number in the map match the message's\n            // and don't process the op.\n            if (local) {\n                const pendingKeyClientSequenceNumber = this.pendingKeys.get(op.key);\n                if (pendingKeyClientSequenceNumber === message.clientSequenceNumber) {\n                    this.pendingKeys.delete(op.key);\n                }\n            }\n            return false;\n        }\n        // If we don't have a NACK op on the key, we need to process the remote ops.\n        return !local;\n    }\n    initializeView() {\n        this.view = new MapView(this, this.runtime, this.id);\n    }\n    setMessageHandlers() {\n        const defaultPrepare = (op, local) => Promise.resolve();\n        // tslint:disable:no-backbone-get-set-outside-model\n        this.messageHandler.set(\"clear\", {\n            prepare: defaultPrepare,\n            process: (op, context, local, message) => {\n                if (local) {\n                    if (this.pendingClearClientSequenceNumber === message.clientSequenceNumber) {\n                        this.pendingClearClientSequenceNumber = -1;\n                    }\n                    return false;\n                }\n                if (this.pendingKeys.size !== 0) {\n                    this.view.clearExceptPendingKeys(this.pendingKeys);\n                    return;\n                }\n                this.view.clearCore(local, message);\n            },\n            submit: (op) => {\n                this.submitMapClearMessage(op);\n            },\n        });\n        this.messageHandler.set(\"delete\", {\n            prepare: defaultPrepare,\n            process: (op, context, local, message) => {\n                if (!this.needProcessKeyOperations(op, local, message)) {\n                    return;\n                }\n                return this.view.deleteCore(op.key, local, message);\n            },\n            submit: (op) => {\n                this.submitMapKeyMessage(op);\n            },\n        });\n        this.messageHandler.set(\"set\", {\n            prepare: (op, local) => {\n                return local ? Promise.resolve(null) : this.view.prepareSetCore(op.key, op.value);\n            },\n            process: (op, context, local, message) => {\n                if (!this.needProcessKeyOperations(op, local, message)) {\n                    return;\n                }\n                this.view.setCore(op.key, context, local, message);\n            },\n            submit: (op) => {\n                this.submitMapKeyMessage(op);\n            },\n        });\n    }\n    isMapMessage(message) {\n        const type = message.type;\n        return this.messageHandler.has(type);\n    }\n}\n//# sourceMappingURL=map.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = require('inherits')\nvar Hash = require('./hash')\nvar Buffer = require('safe-buffer').Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl1 (num) {\n  return (num << 1) | (num >>> 31)\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./sharedObject\"));\n__export(require(\"./extension\"));\n__export(require(\"./valueType\"));\n//# sourceMappingURL=index.js.map","// tslint:disable:whitespace align no-bitwise\nimport * as MergeTree from \"@prague/merge-tree\";\nimport { SharedStringExtension, } from \"./extension\";\nimport { SegmentSequence, } from \"./sequence\";\nfunction textsToSegments(texts) {\n    const segments = [];\n    for (const ptext of texts) {\n        let segment;\n        if (ptext.text !== undefined) {\n            segment = MergeTree.TextSegment.make(ptext.text, ptext.props, MergeTree.UniversalSequenceNumber, MergeTree.LocalClientId);\n        }\n        else {\n            // for now assume marker\n            segment = MergeTree.Marker.make(ptext.marker.refType, ptext.props, MergeTree.UniversalSequenceNumber, MergeTree.LocalClientId);\n        }\n        segments.push(segment);\n    }\n    return segments;\n}\nexport class SharedString extends SegmentSequence {\n    constructor(document, id, services) {\n        super(document, id, SharedStringExtension.Type, services);\n        this.id = id;\n    }\n    appendSegment(segSpec) {\n        const mergeTree = this.client.mergeTree;\n        const pos = mergeTree.root.cachedLength;\n        if (segSpec.text) {\n            mergeTree.insertText(pos, MergeTree.UniversalSequenceNumber, mergeTree.collabWindow.clientId, MergeTree.UniversalSequenceNumber, segSpec.text, segSpec.props, undefined);\n        }\n        else {\n            // assume marker for now\n            mergeTree.insertMarker(pos, MergeTree.UniversalSequenceNumber, mergeTree.collabWindow.clientId, MergeTree.UniversalSequenceNumber, segSpec.marker.refType, segSpec.props, undefined);\n        }\n    }\n    segmentsFromSpecs(segSpecs) {\n        return textsToSegments(segSpecs);\n    }\n    insertMarkerRelative(relativePos1, refType, props) {\n        const insertMessage = {\n            marker: { refType },\n            props,\n            relativePos1,\n            type: 0 /* INSERT */,\n        };\n        const pos = this.client.mergeTree.posFromRelativePos(relativePos1);\n        this.client.insertMarkerLocal(pos, refType, props, { op: insertMessage });\n        this.submitIfAttached(insertMessage);\n    }\n    insertMarker(pos, refType, props) {\n        const insertMessage = {\n            marker: { refType },\n            pos1: pos,\n            props,\n            type: 0 /* INSERT */,\n        };\n        this.client.insertMarkerLocal(pos, refType, props, { op: insertMessage });\n        this.submitIfAttached(insertMessage);\n    }\n    getText(start, end) {\n        return this.client.getText(start, end);\n    }\n    insertTextRelative(relativePos1, text, props) {\n        const insertMessage = {\n            props,\n            relativePos1,\n            text,\n            type: 0 /* INSERT */,\n        };\n        const pos = this.client.mergeTree.posFromRelativePos(relativePos1);\n        this.client.insertTextLocal(text, pos, props, { op: insertMessage });\n        this.submitIfAttached(insertMessage);\n    }\n    insertText(text, pos, props) {\n        const insertMessage = {\n            pos1: pos,\n            props,\n            text,\n            type: 0 /* INSERT */,\n        };\n        this.client.insertTextLocal(text, pos, props, { op: insertMessage });\n        this.submitIfAttached(insertMessage);\n    }\n    replaceText(text, start, end, props) {\n        const insertMessage = {\n            pos1: start,\n            pos2: end,\n            props,\n            text,\n            type: 0 /* INSERT */,\n        };\n        this.client.mergeTree.startGroupOperation();\n        this.client.removeSegmentLocal(start, end, { op: insertMessage });\n        this.client.insertTextLocal(text, start, props, { op: insertMessage });\n        this.client.mergeTree.endGroupOperation();\n        this.submitIfAttached(insertMessage);\n    }\n    removeNest(nestStart, nestEnd) {\n        const start = this.client.mergeTree.getOffset(nestStart, MergeTree.UniversalSequenceNumber, this.client.getClientId());\n        const end = nestEnd.cachedLength + this.client.mergeTree.getOffset(nestEnd, MergeTree.UniversalSequenceNumber, this.client.getClientId());\n        console.log(`removing nest ${nestStart.getId()} from [${start},${end})`);\n        const removeMessage = {\n            checkNest: { id1: nestStart.getId(), id2: nestEnd.getId() },\n            pos1: start,\n            pos2: end,\n            type: 1 /* REMOVE */,\n        };\n        this.client.removeSegmentLocal(start, end, { op: removeMessage });\n        this.submitIfAttached(removeMessage);\n    }\n    removeText(start, end) {\n        this.removeRange(start, end);\n    }\n    annotateRangeFromPast(props, start, end, fromSeq) {\n        const ranges = this.client.mergeTree.tardisRange(start, end, fromSeq, this.client.getCurrentSeq(), this.client.getClientId());\n        ranges.map((range) => {\n            this.annotateRange(props, range.start, range.end);\n        });\n    }\n    annotateMarkerNotifyConsensus(marker, props, callback) {\n        const id = marker.getId();\n        const annotateMessage = {\n            combiningOp: { name: \"consensus\" },\n            props,\n            relativePos1: { id, before: true },\n            relativePos2: { id },\n            type: 2 /* ANNOTATE */,\n        };\n        this.client.annotateMarkerNotifyConsensus(marker, props, callback, { op: annotateMessage });\n        this.submitIfAttached(annotateMessage);\n    }\n    annotateMarker(props, marker, op) {\n        const id = marker.getId();\n        const annotateMessage = {\n            props,\n            relativePos1: { id, before: true },\n            relativePos2: { id },\n            type: 2 /* ANNOTATE */,\n        };\n        if (op) {\n            annotateMessage.combiningOp = op;\n        }\n        this.client.annotateMarker(props, marker, op, { op: annotateMessage });\n        this.submitIfAttached(annotateMessage);\n    }\n    findTile(startPos, tileLabel, preceding = true) {\n        return this.client.findTile(startPos, tileLabel, preceding);\n    }\n}\n//# sourceMappingURL=sharedString.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SharedNumberSequence, SharedObjectSequence } from \"./sequence\";\nimport { SharedString } from \"./sharedString\";\nexport class SharedStringExtension {\n    constructor() {\n        this.type = SharedStringExtension.Type;\n    }\n    load(document, id, minimumSequenceNumber, services, headerOrigin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sharedString = new SharedString(document, id, services);\n            yield sharedString.load(minimumSequenceNumber, headerOrigin, services);\n            return sharedString;\n        });\n    }\n    create(document, id) {\n        const sharedString = new SharedString(document, id);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\n// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically\n// load code\nSharedStringExtension.Type = \"https://graph.microsoft.com/types/mergeTree\";\nexport class SharedObjectSequenceExtension {\n    constructor() {\n        this.type = SharedObjectSequenceExtension.Type;\n    }\n    load(document, id, minimumSequenceNumber, services, headerOrigin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sharedSeq = new SharedObjectSequence(document, id, services);\n            yield sharedSeq.load(minimumSequenceNumber, headerOrigin, services);\n            return sharedSeq;\n        });\n    }\n    create(document, id) {\n        const sharedString = new SharedObjectSequence(document, id);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\nSharedObjectSequenceExtension.Type = \"https://graph.microsoft.com/types/mergeTree/object-sequence\";\nexport class SharedNumberSequenceExtension {\n    constructor() {\n        this.type = SharedNumberSequenceExtension.Type;\n    }\n    load(document, id, minimumSequenceNumber, services, headerOrigin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sharedSeq = new SharedNumberSequence(document, id, services);\n            yield sharedSeq.load(minimumSequenceNumber, headerOrigin, services);\n            return sharedSeq;\n        });\n    }\n    create(document, id) {\n        const sharedString = new SharedNumberSequence(document, id);\n        sharedString.initializeLocal();\n        return sharedString;\n    }\n}\nSharedNumberSequenceExtension.Type = \"https://graph.microsoft.com/types/mergeTree/number-sequence\";\n//# sourceMappingURL=extension.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FileMode, TreeEntry } from \"@prague/container-definitions\";\nimport * as MergeTree from \"./mergeTree\";\nexport class Snapshot {\n    constructor(mergeTree, filename, onCompletion) {\n        this.mergeTree = mergeTree;\n        this.filename = filename;\n        this.onCompletion = onCompletion;\n    }\n    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {\n        let segs = [];\n        let sequenceLength = 0;\n        let segCount = 0;\n        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {\n            let pseg = allSegments[startIndex + segCount];\n            segCount++;\n            segs.push(pseg);\n            sequenceLength += allLengths[startIndex + segCount];\n        }\n        return {\n            chunkStartSegmentIndex: startIndex,\n            chunkSegmentCount: segCount,\n            chunkLengthChars: sequenceLength,\n            totalLengthChars: this.header.segmentsTotalLength,\n            totalSegmentCount: allSegments.length,\n            chunkSequenceNumber: this.header.seq,\n            segmentTexts: segs\n        };\n    }\n    emit() {\n        let chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, 10000);\n        let chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, chunk1.totalLengthChars, chunk1.chunkSegmentCount);\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: \"header\",\n                    type: TreeEntry[TreeEntry.Blob],\n                    value: {\n                        contents: JSON.stringify(chunk1),\n                        encoding: \"utf-8\",\n                    },\n                },\n                {\n                    mode: FileMode.File,\n                    path: \"body\",\n                    type: TreeEntry[TreeEntry.Blob],\n                    value: {\n                        contents: JSON.stringify(chunk2),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n            sha: null,\n        };\n        return tree;\n    }\n    extractSync() {\n        let collabWindow = this.mergeTree.getCollabWindow();\n        this.seq = collabWindow.minSeq;\n        this.header = {\n            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, MergeTree.NonCollabClient),\n            seq: this.mergeTree.collabWindow.minSeq,\n        };\n        let segs = [];\n        let segLengths = [];\n        let extractSegment = (segment, pos, refSeq, clientId, start, end) => {\n            if ((segment.seq != MergeTree.UnassignedSequenceNumber) && (segment.seq <= this.seq) &&\n                ((segment.removedSeq === undefined) || (segment.removedSeq == MergeTree.UnassignedSequenceNumber) ||\n                    (segment.removedSeq > this.seq))) {\n                segs.push(segment.toJSONObject());\n                segLengths.push(segment.cachedLength);\n            }\n            return true;\n        };\n        this.mergeTree.map({ leaf: extractSegment }, this.seq, MergeTree.NonCollabClient);\n        this.segments = segs;\n        this.segmentLengths = segLengths;\n        return segs;\n    }\n    static loadChunk(storage, path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let chunkAsString = yield storage.read(path);\n            return Snapshot.processChunk(chunkAsString);\n        });\n    }\n    static processChunk(chunk) {\n        return JSON.parse(Buffer.from(chunk, \"base64\").toString(\"utf-8\"));\n    }\n}\nSnapshot.SnapChunkMaxSize = 0x20000;\nSnapshot.SegmentLengthSize = 0x4;\nSnapshot.SnapshotHeaderSize = 0x14;\nSnapshot.EmptyChunk = {\n    chunkStartSegmentIndex: -1,\n    chunkSegmentCount: -1,\n    chunkLengthChars: -1,\n    totalLengthChars: -1,\n    totalSegmentCount: -1,\n    chunkSequenceNumber: 0,\n    segmentTexts: [],\n};\n//# sourceMappingURL=snapshot.js.map","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SharedMap } from \"./map\";\n// register default types\nconst defaultValueTypes = new Array();\nexport function registerDefaultValueType(type) {\n    defaultValueTypes.push(type);\n}\n/**\n * The extension that defines the map\n */\nexport class MapExtension {\n    constructor() {\n        this.type = MapExtension.Type;\n    }\n    load(runtime, id, minimumSequenceNumber, services, headerOrigin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const map = new SharedMap(id, runtime, MapExtension.Type);\n            this.registerValueTypes(map, defaultValueTypes);\n            yield map.load(minimumSequenceNumber, headerOrigin, services);\n            return map;\n        });\n    }\n    create(document, id) {\n        const map = new SharedMap(id, document, MapExtension.Type);\n        this.registerValueTypes(map, defaultValueTypes);\n        map.initializeLocal();\n        return map;\n    }\n    registerValueTypes(map, valueTypes) {\n        for (const type of valueTypes) {\n            map.registerValueType(type);\n        }\n    }\n}\nMapExtension.Type = \"https://graph.microsoft.com/types/map\";\n//# sourceMappingURL=extension.js.map","import * as registerDebug from \"debug\";\nexport const debug = registerDebug(\"prague:map\");\n//# sourceMappingURL=debug.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FileMode, MessageType, TreeEntry, } from \"@prague/container-definitions\";\nimport { SharedMap } from \"@prague/map\";\nimport { StreamExtension } from \"./extension\";\nimport { Snapshot } from \"./snapshot\";\nconst snapshotFileName = \"header\";\nconst emptySnapshot = { layers: [], layerIndex: {} };\nexport class Stream extends SharedMap {\n    constructor(runtime, id) {\n        super(id, runtime, StreamExtension.Type);\n    }\n    getLayers() {\n        return this.inkSnapshot.layers;\n    }\n    getLayer(key) {\n        return this.inkSnapshot.layers[this.inkSnapshot.layerIndex[key]];\n    }\n    submitOp(op) {\n        this.submitLocalMessage(op);\n        this.inkSnapshot.apply(op);\n    }\n    loadContent(minimumSequenceNumber, headerOrigin, storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const header = yield storage.read(snapshotFileName);\n            /* tslint:disable:no-unsafe-any */\n            const data = header\n                ? JSON.parse(Buffer.from(header, \"base64\")\n                    .toString(\"utf-8\"))\n                : emptySnapshot;\n            this.initialize(data);\n        });\n    }\n    initializeContent() {\n        this.initialize(emptySnapshot);\n    }\n    snapshotContent() {\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: snapshotFileName,\n                    type: TreeEntry[TreeEntry.Blob],\n                    value: {\n                        contents: JSON.stringify(this.inkSnapshot),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n            sha: null,\n        };\n        return tree;\n    }\n    processContent(message, local) {\n        if (message.type === MessageType.Operation && !local) {\n            this.inkSnapshot.apply(message.contents);\n        }\n    }\n    onConnectContent(pending) {\n        // Stream can resend messages under new client id\n        for (const message of pending) {\n            this.submitLocalMessage(message);\n        }\n        return;\n    }\n    initialize(data) {\n        this.inkSnapshot = Snapshot.Clone(data);\n    }\n}\n//# sourceMappingURL=stream.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SharedObject } from \"@prague/api-definitions\";\nimport { FileMode, MessageType, TreeEntry, } from \"@prague/container-definitions\";\nimport { debug } from \"./debug\";\nimport { CellExtension } from \"./extension\";\nexport var CellValueType;\n(function (CellValueType) {\n    // The value is another shared object\n    CellValueType[CellValueType[\"Shared\"] = 0] = \"Shared\";\n    // The value is a plain JavaScript object\n    CellValueType[CellValueType[\"Plain\"] = 1] = \"Plain\";\n})(CellValueType || (CellValueType = {}));\nconst snapshotFileName = \"header\";\n/**\n * Implementation of a cell shared object\n */\nexport class Cell extends SharedObject {\n    /**\n     * Constructs a new shared cell. If the object is non-local an id and service interfaces will\n     * be provided\n     */\n    constructor(id, runtime) {\n        super(id, runtime, CellExtension.Type);\n    }\n    /**\n     * Retrieves the value of the cell.\n     */\n    get() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.data;\n        });\n    }\n    /**\n     * Sets the value of the cell.\n     */\n    set(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let operationValue;\n            /* tslint:disable:no-unsafe-any */\n            if (value instanceof SharedObject) {\n                // Convert any local shared objects to our internal storage format\n                if (!this.isLocal()) {\n                    value.attach();\n                }\n                operationValue = {\n                    type: CellValueType[CellValueType.Shared],\n                    value: value.id,\n                };\n            }\n            else {\n                operationValue = {\n                    type: CellValueType[CellValueType.Plain],\n                    value,\n                };\n            }\n            const op = {\n                type: \"setCell\",\n                value: operationValue,\n            };\n            this.setCore(value);\n            this.submitIfAttached(op);\n        });\n    }\n    // Deletes the value from the cell.\n    delete() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const op = {\n                type: \"deleteCell\",\n            };\n            this.deleteCore();\n            this.submitIfAttached(op);\n        });\n    }\n    /**\n     * Returns whether cell is empty or not.\n     */\n    empty() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.data === undefined ? true : false;\n        });\n    }\n    snapshot() {\n        // Get a serializable form of data\n        let content;\n        if (this.data instanceof SharedObject) {\n            content = {\n                type: CellValueType[CellValueType.Shared],\n                value: this.data.id,\n            };\n        }\n        else {\n            content = {\n                type: CellValueType[CellValueType.Plain],\n                value: this.data,\n            };\n        }\n        // And then construct the tree for it\n        const tree = {\n            entries: [\n                {\n                    mode: FileMode.File,\n                    path: snapshotFileName,\n                    type: TreeEntry[TreeEntry.Blob],\n                    value: {\n                        contents: JSON.stringify(content),\n                        encoding: \"utf-8\",\n                    },\n                },\n            ],\n            sha: null,\n        };\n        return tree;\n    }\n    loadCore(minimumSequenceNumber, headerOrigin, storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const rawContent = yield storage.read(snapshotFileName);\n            // tslint:disable-next-line:strict-boolean-expressions\n            const content = rawContent\n                ? JSON.parse(Buffer.from(rawContent, \"base64\")\n                    .toString(\"utf-8\"))\n                : { type: CellValueType[CellValueType.Plain], value: undefined };\n            this.data = content.type === CellValueType[CellValueType.Shared]\n                ? yield this.runtime.getChannel(content.value)\n                : content.value;\n        });\n    }\n    initializeLocalCore() {\n        this.data = undefined;\n    }\n    attachCore() {\n        return;\n    }\n    onDisconnect() {\n        debug(`Cell ${this.id} is now disconnected`);\n    }\n    onConnect(pending) {\n        for (const message of pending) {\n            this.submitLocalMessage(message);\n        }\n        return;\n    }\n    prepareCore(message, local) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (message.type === MessageType.Operation && !local) {\n                const op = message.contents;\n                if (op.type === \"setCell\") {\n                    /* tslint:disable:no-return-await */\n                    return op.value.type === CellValueType[CellValueType.Shared]\n                        ? yield this.runtime.getChannel(op.value.value)\n                        : op.value.value;\n                }\n            }\n        });\n    }\n    processCore(message, local, context) {\n        if (message.type === MessageType.Operation && !local) {\n            const op = message.contents;\n            switch (op.type) {\n                case \"setCell\":\n                    this.setCore(context);\n                    break;\n                case \"deleteCell\":\n                    this.deleteCore();\n                    break;\n                default:\n                    throw new Error(\"Unknown operation\");\n            }\n        }\n    }\n    processMinSequenceNumberChanged(value) {\n        return;\n    }\n    submitIfAttached(message) {\n        if (this.isLocal()) {\n            return;\n        }\n        this.submitLocalMessage(message);\n    }\n    setCore(value) {\n        this.data = value;\n        this.emit(\"valueChanged\", value);\n    }\n    deleteCore() {\n        this.data = undefined;\n        this.emit(\"delete\");\n    }\n}\n//# sourceMappingURL=cell.js.map","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","/**\n * Copyright (c) 2013 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\"use strict\";\nfunction Deque(capacity) {\n    this._capacity = getCapacity(capacity);\n    this._length = 0;\n    this._front = 0;\n    if (isArray(capacity)) {\n        var len = capacity.length;\n        for (var i = 0; i < len; ++i) {\n            this[i] = capacity[i];\n        }\n        this._length = len;\n    }\n}\n\nDeque.prototype.toArray = function Deque$toArray() {\n    var len = this._length;\n    var ret = new Array(len);\n    var front = this._front;\n    var capacity = this._capacity;\n    for (var j = 0; j < len; ++j) {\n        ret[j] = this[(front + j) & (capacity - 1)];\n    }\n    return ret;\n};\n\nDeque.prototype.push = function Deque$push(item) {\n    var argsLength = arguments.length;\n    var length = this._length;\n    if (argsLength > 1) {\n        var capacity = this._capacity;\n        if (length + argsLength > capacity) {\n            for (var i = 0; i < argsLength; ++i) {\n                this._checkCapacity(length + 1);\n                var j = (this._front + length) & (this._capacity - 1);\n                this[j] = arguments[i];\n                length++;\n                this._length = length;\n            }\n            return length;\n        }\n        else {\n            var j = this._front;\n            for (var i = 0; i < argsLength; ++i) {\n                this[(j + length) & (capacity - 1)] = arguments[i];\n                j++;\n            }\n            this._length = length + argsLength;\n            return length + argsLength;\n        }\n\n    }\n\n    if (argsLength === 0) return length;\n\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = item;\n    this._length = length + 1;\n    return length + 1;\n};\n\nDeque.prototype.pop = function Deque$pop() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var i = (this._front + length - 1) & (this._capacity - 1);\n    var ret = this[i];\n    this[i] = void 0;\n    this._length = length - 1;\n    return ret;\n};\n\nDeque.prototype.shift = function Deque$shift() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var front = this._front;\n    var ret = this[front];\n    this[front] = void 0;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length = length - 1;\n    return ret;\n};\n\nDeque.prototype.unshift = function Deque$unshift(item) {\n    var length = this._length;\n    var argsLength = arguments.length;\n\n\n    if (argsLength > 1) {\n        var capacity = this._capacity;\n        if (length + argsLength > capacity) {\n            for (var i = argsLength - 1; i >= 0; i--) {\n                this._checkCapacity(length + 1);\n                var capacity = this._capacity;\n                var j = (((( this._front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n                this[j] = arguments[i];\n                length++;\n                this._length = length;\n                this._front = j;\n            }\n            return length;\n        }\n        else {\n            var front = this._front;\n            for (var i = argsLength - 1; i >= 0; i--) {\n                var j = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n                this[j] = arguments[i];\n                front = j;\n            }\n            this._front = front;\n            this._length = length + argsLength;\n            return length + argsLength;\n        }\n    }\n\n    if (argsLength === 0) return length;\n\n    this._checkCapacity(length + 1);\n    var capacity = this._capacity;\n    var i = (((( this._front - 1 ) &\n        ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = item;\n    this._length = length + 1;\n    this._front = i;\n    return length + 1;\n};\n\nDeque.prototype.peekBack = function Deque$peekBack() {\n    var length = this._length;\n    if (length === 0) {\n        return void 0;\n    }\n    var index = (this._front + length - 1) & (this._capacity - 1);\n    return this[index];\n};\n\nDeque.prototype.peekFront = function Deque$peekFront() {\n    if (this._length === 0) {\n        return void 0;\n    }\n    return this[this._front];\n};\n\nDeque.prototype.get = function Deque$get(index) {\n    var i = index;\n    if ((i !== (i | 0))) {\n        return void 0;\n    }\n    var len = this._length;\n    if (i < 0) {\n        i = i + len;\n    }\n    if (i < 0 || i >= len) {\n        return void 0;\n    }\n    return this[(this._front + i) & (this._capacity - 1)];\n};\n\nDeque.prototype.isEmpty = function Deque$isEmpty() {\n    return this._length === 0;\n};\n\nDeque.prototype.clear = function Deque$clear() {\n    var len = this._length;\n    var front = this._front;\n    var capacity = this._capacity;\n    for (var j = 0; j < len; ++j) {\n        this[(front + j) & (capacity - 1)] = void 0;\n    }\n    this._length = 0;\n    this._front = 0;\n};\n\nDeque.prototype.toString = function Deque$toString() {\n    return this.toArray().toString();\n};\n\nDeque.prototype.valueOf = Deque.prototype.toString;\nDeque.prototype.removeFront = Deque.prototype.shift;\nDeque.prototype.removeBack = Deque.prototype.pop;\nDeque.prototype.insertFront = Deque.prototype.unshift;\nDeque.prototype.insertBack = Deque.prototype.push;\nDeque.prototype.enqueue = Deque.prototype.push;\nDeque.prototype.dequeue = Deque.prototype.shift;\nDeque.prototype.toJSON = Deque.prototype.toArray;\n\nObject.defineProperty(Deque.prototype, \"length\", {\n    get: function() {\n        return this._length;\n    },\n    set: function() {\n        throw new RangeError(\"\");\n    }\n});\n\nDeque.prototype._checkCapacity = function Deque$_checkCapacity(size) {\n    if (this._capacity < size) {\n        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));\n    }\n};\n\nDeque.prototype._resizeTo = function Deque$_resizeTo(capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    if (front + length > oldCapacity) {\n        var moveItemsCount = (front + length) & (oldCapacity - 1);\n        arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n    }\n};\n\n\nvar isArray = Array.isArray;\n\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction pow2AtLeast(n) {\n    n = n >>> 0;\n    n = n - 1;\n    n = n | (n >> 1);\n    n = n | (n >> 2);\n    n = n | (n >> 4);\n    n = n | (n >> 8);\n    n = n | (n >> 16);\n    return n + 1;\n}\n\nfunction getCapacity(capacity) {\n    if (typeof capacity !== \"number\") {\n        if (isArray(capacity)) {\n            capacity = capacity.length;\n        }\n        else {\n            return 16;\n        }\n    }\n    return pow2AtLeast(\n        Math.min(\n            Math.max(16, capacity), 1073741824)\n    );\n}\n\nmodule.exports = Deque;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO this is probably too map specific - but is used to serailize objects in certain cases\nvar ValueType;\n(function (ValueType) {\n    // The value is a shared object\n    ValueType[ValueType[\"Shared\"] = 0] = \"Shared\";\n    // The value is a plain JavaScript object\n    ValueType[ValueType[\"Plain\"] = 1] = \"Plain\";\n    // The value is a counter\n    ValueType[ValueType[\"Counter\"] = 2] = \"Counter\";\n    // The value is a set\n    ValueType[ValueType[\"Set\"] = 3] = \"Set\";\n})(ValueType = exports.ValueType || (exports.ValueType = {}));\n//# sourceMappingURL=valueType.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FileMode, TreeEntry, } from \"@prague/container-definitions\";\n// tslint:disable-next-line:no-submodule-imports\nimport * as sha1 from \"sha.js/sha1\";\n/**\n * Create Hash (Github hashes the string with blob and size)\n * @param file The contents of the file in a buffer\n */\nexport function gitHashFile(file) {\n    const size = file.byteLength;\n    const filePrefix = \"blob \" + size.toString() + String.fromCharCode(0);\n    /* tslint:disable:no-unsafe-any */\n    const engine = new sha1();\n    return engine.update(filePrefix)\n        .update(file)\n        .digest(\"hex\");\n}\nexport function flatten(tree, blobMap) {\n    const entries = flattenCore(\"\", tree, blobMap);\n    return {\n        sha: null,\n        tree: entries,\n        url: null,\n    };\n}\nexport function readAndParse(storage, sha) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const encoded = yield storage.read(sha);\n        const decoded = Buffer\n            .from(encoded, \"base64\")\n            .toString();\n        return JSON.parse(decoded);\n    });\n}\nfunction flattenCore(path, treeEntries, blobMap) {\n    const entries = new Array();\n    for (const treeEntry of treeEntries) {\n        const subPath = `${path}${treeEntry.path}`;\n        if (treeEntry.type === TreeEntry[TreeEntry.Blob]) {\n            const blob = treeEntry.value;\n            const buffer = Buffer.from(blob.contents, blob.encoding);\n            const sha = gitHashFile(buffer);\n            blobMap.set(sha, buffer.toString(\"base64\"));\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha,\n                size: buffer.length,\n                type: \"blob\",\n                url: \"\",\n            };\n            entries.push(entry);\n        }\n        else {\n            const t = treeEntry.value;\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha: null,\n                size: -1,\n                type: \"tree\",\n                url: \"\",\n            };\n            entries.push(entry);\n            const subTreeEntries = flattenCore(subPath + \"/\", t.entries, blobMap);\n            entries.push(...subTreeEntries);\n        }\n    }\n    return entries;\n}\nexport function buildHierarchy(flatTree) {\n    if (!flatTree) {\n        return null;\n    }\n    const lookup = {};\n    const root = { sha: flatTree.sha, blobs: {}, commits: {}, trees: {} };\n    lookup[\"\"] = root;\n    for (const entry of flatTree.tree) {\n        const lastIndex = entry.path.lastIndexOf(\"/\");\n        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));\n        const entryPathBase = entry.path.slice(lastIndex + 1);\n        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents\n        const node = lookup[entryPathDir];\n        // Add in either the blob or tree\n        if (entry.type === \"tree\") {\n            const newTree = { sha: entry.sha, blobs: {}, commits: {}, trees: {} };\n            node.trees[entryPathBase] = newTree;\n            lookup[entry.path] = newTree;\n        }\n        else if (entry.type === \"blob\") {\n            node.blobs[entryPathBase] = entry.sha;\n        }\n        else if (entry.type === \"commit\") {\n            node.commits[entryPathBase] = entry.sha;\n        }\n    }\n    return root;\n}\n//# sourceMappingURL=blobs.js.map","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst registerDebug = require(\"debug\");\nexports.debug = registerDebug(\"prague:process-loader\");\n//# sourceMappingURL=debug.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FileMode, TreeEntry, } from \"@prague/container-definitions\";\n// tslint:disable-next-line:no-submodule-imports\nimport * as sha1 from \"sha.js/sha1\";\n/**\n * Create Hash (Github hashes the string with blob and size)\n * @param file The contents of the file in a buffer\n */\nexport function gitHashFile(file) {\n    const size = file.byteLength;\n    const filePrefix = \"blob \" + size.toString() + String.fromCharCode(0);\n    /* tslint:disable:no-unsafe-any */\n    const engine = new sha1();\n    return engine.update(filePrefix)\n        .update(file)\n        .digest(\"hex\");\n}\nexport function flatten(tree, blobMap) {\n    const entries = flattenCore(\"\", tree, blobMap);\n    return {\n        sha: null,\n        tree: entries,\n        url: null,\n    };\n}\nexport function readAndParse(storage, sha) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const encoded = yield storage.read(sha);\n        const decoded = Buffer\n            .from(encoded, \"base64\")\n            .toString();\n        return JSON.parse(decoded);\n    });\n}\nfunction flattenCore(path, treeEntries, blobMap) {\n    const entries = new Array();\n    for (const treeEntry of treeEntries) {\n        const subPath = `${path}${treeEntry.path}`;\n        if (treeEntry.type === TreeEntry[TreeEntry.Blob]) {\n            const blob = treeEntry.value;\n            const buffer = Buffer.from(blob.contents, blob.encoding);\n            const sha = gitHashFile(buffer);\n            blobMap.set(sha, buffer.toString(\"base64\"));\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha,\n                size: buffer.length,\n                type: \"blob\",\n                url: \"\",\n            };\n            entries.push(entry);\n        }\n        else {\n            const t = treeEntry.value;\n            const entry = {\n                mode: FileMode[treeEntry.mode],\n                path: subPath,\n                sha: null,\n                size: -1,\n                type: \"tree\",\n                url: \"\",\n            };\n            entries.push(entry);\n            const subTreeEntries = flattenCore(subPath + \"/\", t.entries, blobMap);\n            entries.push(...subTreeEntries);\n        }\n    }\n    return entries;\n}\nexport function buildHierarchy(flatTree) {\n    if (!flatTree) {\n        return null;\n    }\n    const lookup = {};\n    const root = { sha: flatTree.sha, blobs: {}, commits: {}, trees: {} };\n    lookup[\"\"] = root;\n    for (const entry of flatTree.tree) {\n        const lastIndex = entry.path.lastIndexOf(\"/\");\n        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));\n        const entryPathBase = entry.path.slice(lastIndex + 1);\n        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents\n        const node = lookup[entryPathDir];\n        // Add in either the blob or tree\n        if (entry.type === \"tree\") {\n            const newTree = { sha: entry.sha, blobs: {}, commits: {}, trees: {} };\n            node.trees[entryPathBase] = newTree;\n            lookup[entry.path] = newTree;\n        }\n        else if (entry.type === \"blob\") {\n            node.blobs[entryPathBase] = entry.sha;\n        }\n        else if (entry.type === \"commit\") {\n            node.commits[entryPathBase] = entry.sha;\n        }\n    }\n    return root;\n}\n//# sourceMappingURL=blobs.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO this is probably too map specific - but is used to serailize objects in certain cases\nvar ValueType;\n(function (ValueType) {\n    // The value is a shared object\n    ValueType[ValueType[\"Shared\"] = 0] = \"Shared\";\n    // The value is a plain JavaScript object\n    ValueType[ValueType[\"Plain\"] = 1] = \"Plain\";\n    // The value is a counter\n    ValueType[ValueType[\"Counter\"] = 2] = \"Counter\";\n    // The value is a set\n    ValueType[ValueType[\"Set\"] = 3] = \"Set\";\n})(ValueType = exports.ValueType || (exports.ValueType = {}));\n//# sourceMappingURL=valueType.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// tslint:disable:align\nimport { SharedObject, ValueType } from \"@prague/api-definitions\";\nclass ValueOpEmitter {\n    constructor(type, key, map) {\n        this.type = type;\n        this.key = key;\n        this.map = map;\n    }\n    emit(name, params) {\n        const op = {\n            key: this.key,\n            type: this.type,\n            value: {\n                type: name,\n                value: params,\n            },\n        };\n        this.map.submitMapMessage(op);\n        this.map.emit(\"valueChanged\", { key: this.key }, true, null);\n    }\n}\nexport class MapView {\n    constructor(map, runtime, id) {\n        this.map = map;\n        this.runtime = runtime;\n        this.data = new Map();\n    }\n    populate(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const localValuesP = new Array();\n            // tslint:disable-next-line:forin\n            for (const key in data) {\n                const value = data[key];\n                const localValueP = this.fill(key, value)\n                    .then((filledValue) => ({ key, value: filledValue }));\n                localValuesP.push(localValueP);\n            }\n            const localValues = yield Promise.all(localValuesP);\n            for (const localValue of localValues) {\n                this.data.set(localValue.key, localValue.value);\n            }\n        });\n    }\n    // TODO: fix to pass-through when meta-data moved to separate map\n    forEach(callbackFn) {\n        this.data.forEach((value, key, m) => {\n            callbackFn(value.localValue, key, m);\n        });\n    }\n    get(key) {\n        if (!this.data.has(key)) {\n            return undefined;\n        }\n        // Let's stash the *type* of the object on the key\n        const value = this.data.get(key);\n        return value.localValue;\n    }\n    getMap() {\n        return this.map;\n    }\n    wait(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Return immediately if the value already exists\n            if (this.has(key)) {\n                /* tslint:disable:no-unsafe-any */\n                /* tslint:disable:no-object-literal-type-assertion */\n                return this.get(key);\n            }\n            // Otherwise subscribe to changes\n            return new Promise((resolve, reject) => {\n                const callback = (value) => {\n                    if (key === value.key) {\n                        resolve(this.get(value.key));\n                        this.map.removeListener(\"valueChanged\", callback);\n                    }\n                };\n                this.map.on(\"valueChanged\", callback);\n            });\n        });\n    }\n    has(key) {\n        return this.data.has(key);\n    }\n    attachAll() {\n        for (const [, value] of this.data) {\n            if (value.localValue instanceof SharedObject) {\n                value.localValue.attach();\n            }\n        }\n    }\n    prepareOperationValue(key, value, type) {\n        let operationValue;\n        if (type) {\n            const valueType = this.map.getValueType(type);\n            if (!valueType) {\n                throw new Error(`Unknown type '${type}' specified`);\n            }\n            // set operationValue first with the raw value params prior to doing the load\n            operationValue = {\n                type,\n                value,\n            };\n            // tslint:disable-next-line:no-parameter-reassignment\n            value = valueType.factory.load(new ValueOpEmitter(type, key, this.map), value);\n        }\n        else {\n            const valueType = value instanceof SharedObject\n                ? ValueType[ValueType.Shared]\n                : ValueType[ValueType.Plain];\n            operationValue = this.spill({ localType: valueType, localValue: value });\n        }\n        return { operationValue, localValue: value };\n    }\n    set(key, value, type) {\n        const values = this.prepareOperationValue(key, value, type);\n        const op = {\n            key,\n            type: \"set\",\n            value: values.operationValue,\n        };\n        this.setCore(op.key, {\n            localType: values.operationValue.type,\n            localValue: values.localValue,\n        }, true, null);\n        this.map.submitMapKeyMessage(op);\n    }\n    delete(key) {\n        const op = {\n            key,\n            type: \"delete\",\n        };\n        const successfullyRemoved = this.deleteCore(op.key, true, null);\n        this.map.submitMapKeyMessage(op);\n        return successfullyRemoved;\n    }\n    keys() {\n        return this.data.keys();\n    }\n    clear() {\n        const op = {\n            type: \"clear\",\n        };\n        this.clearCore(true, null);\n        this.map.submitMapClearMessage(op);\n    }\n    /**\n     * Serializes the shared map to a JSON string\n     */\n    serialize(filter) {\n        const serialized = {};\n        this.data.forEach((value, key) => {\n            const spilledValue = this.spill(value);\n            const filteredValue = filter(key, spilledValue.value, spilledValue.type);\n            serialized[key] = { type: spilledValue.type, value: filteredValue };\n        });\n        return JSON.stringify(serialized);\n    }\n    setCore(key, value, local, op) {\n        this.data.set(key, value);\n        this.map.emit(\"valueChanged\", { key }, local, op);\n    }\n    prepareSetCore(key, value) {\n        return this.fill(key, value);\n    }\n    clearCore(local, op) {\n        this.data.clear();\n        this.map.emit(\"clear\", local, op);\n    }\n    deleteCore(key, local, op) {\n        const successfullyRemoved = this.data.delete(key);\n        this.map.emit(\"valueChanged\", { key }, local, op);\n        return successfullyRemoved;\n    }\n    clearExceptPendingKeys(pendingKeys) {\n        // Assuming the pendingKeys is small and the map is large\n        // we will get the value for the pendingKeys and clear the map\n        const temp = new Map();\n        pendingKeys.forEach((value, key, map) => {\n            temp.set(key, this.data.get(key));\n        });\n        this.data.clear();\n        temp.forEach((value, key, map) => {\n            this.data.set(key, value);\n        });\n    }\n    fill(key, remote) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let translatedValue;\n            if (remote.type === ValueType[ValueType.Shared]) {\n                const distributedObject = yield this.runtime.getChannel(remote.value);\n                translatedValue = distributedObject;\n            }\n            else if (remote.type === ValueType[ValueType.Plain]) {\n                translatedValue = remote.value;\n            }\n            else if (this.map.hasValueType(remote.type)) {\n                const valueType = this.map.getValueType(remote.type);\n                translatedValue = valueType.factory.load(new ValueOpEmitter(remote.type, key, this.map), remote.value);\n            }\n            else {\n                return Promise.reject(\"Unknown value type\");\n            }\n            return {\n                localType: remote.type,\n                localValue: translatedValue,\n            };\n        });\n    }\n    spill(local) {\n        if (local.localType === ValueType[ValueType.Shared]) {\n            const distributedObject = local.localValue;\n            // Attach the collab object to the document. If already attached the attach call will noop.\n            // This feels slightly out of place here since it has a side effect. But is part of spilling a document.\n            // Not sure if there is some kind of prep call to separate the op creation from things needed to make it\n            // (like attaching)\n            if (!this.map.isLocal()) {\n                distributedObject.attach();\n            }\n            return {\n                type: ValueType[ValueType.Shared],\n                value: distributedObject.id,\n            };\n        }\n        else if (this.map.hasValueType(local.localType)) {\n            const valueType = this.map.getValueType(local.localType);\n            return {\n                type: local.localType,\n                value: valueType.factory.store(local.localValue),\n            };\n        }\n        else {\n            return {\n                type: ValueType[ValueType.Plain],\n                value: local.localValue,\n            };\n        }\n    }\n}\nexport class DirectoryView extends MapView {\n    constructor(directory, runtime, id) {\n        super(directory, runtime, id);\n    }\n}\n//# sourceMappingURL=view.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./runtime\"));\n__export(require(\"./webPlatform\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./componentHost\"));\n//# sourceMappingURL=index.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as MergeTree from \"@prague/merge-tree\";\nimport { EventEmitter } from \"events\";\nexport class Interval {\n    constructor(start, end, props) {\n        this.start = start;\n        this.end = end;\n        if (props) {\n            this.addProperties(props);\n        }\n    }\n    getAdditionalPropertySets() {\n        return this.auxProps;\n    }\n    addPropertySet(props) {\n        if (this.auxProps === undefined) {\n            this.auxProps = [];\n        }\n        this.auxProps.push(props);\n    }\n    serialize(client) {\n        let seq = 0;\n        if (client) {\n            seq = client.getCurrentSeq();\n        }\n        /* tslint:disable:no-object-literal-type-assertion */\n        const serializedInterval = {\n            end: this.end,\n            intervalType: 0,\n            sequenceNumber: seq,\n            start: this.start,\n        };\n        if (this.properties) {\n            serializedInterval.properties = this.properties;\n        }\n        return serializedInterval;\n    }\n    clone() {\n        return new Interval(this.start, this.end, this.properties);\n    }\n    compare(b) {\n        const startResult = this.start - b.start;\n        if (startResult === 0) {\n            return (this.end - b.end);\n        }\n        else {\n            return startResult;\n        }\n    }\n    overlaps(b) {\n        const result = (this.start < b.end) &&\n            (this.end >= b.start);\n        return result;\n    }\n    union(b) {\n        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);\n    }\n    getProperties() {\n        return this.properties;\n    }\n    addProperties(newProps, op) {\n        this.properties = MergeTree.addProperties(this.properties, newProps, op);\n    }\n}\nexport class SharedStringInterval {\n    constructor(start, end, intervalType, props) {\n        this.start = start;\n        this.end = end;\n        this.intervalType = intervalType;\n        if (props) {\n            this.addProperties(props);\n        }\n    }\n    serialize(client) {\n        const startPosition = this.start.toPosition(client.mergeTree, client.getCurrentSeq(), client.getClientId());\n        const endPosition = this.end.toPosition(client.mergeTree, client.getCurrentSeq(), client.getClientId());\n        const serializedInterval = {\n            end: endPosition,\n            intervalType: this.intervalType,\n            sequenceNumber: client.getCurrentSeq(),\n            start: startPosition,\n        };\n        if (this.properties) {\n            serializedInterval.properties = this.properties;\n        }\n        return serializedInterval;\n    }\n    clone() {\n        return new SharedStringInterval(this.start, this.end, this.intervalType);\n    }\n    compare(b) {\n        const startResult = this.start.compare(b.start);\n        if (startResult === 0) {\n            return (this.end.compare(b.end));\n        }\n        else {\n            return startResult;\n        }\n    }\n    overlaps(b) {\n        const result = (this.start.compare(b.end) < 0) &&\n            (this.end.compare(b.start) >= 0);\n        if (this.checkMergeTree) {\n            this.checkOverlaps(b, result);\n        }\n        return result;\n    }\n    union(b) {\n        return new SharedStringInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);\n    }\n    addProperties(newProps, op) {\n        this.properties = MergeTree.addProperties(this.properties, newProps, op);\n    }\n    overlapsPos(mergeTree, bstart, bend) {\n        const startPos = this.start.toPosition(mergeTree, MergeTree.UniversalSequenceNumber, mergeTree.collabWindow.clientId);\n        const endPos = this.start.toPosition(mergeTree, MergeTree.UniversalSequenceNumber, mergeTree.collabWindow.clientId);\n        return (endPos > bstart) && (startPos < bend);\n    }\n    checkOverlaps(b, result) {\n        const astart = this.start.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);\n        const bstart = b.start.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);\n        const aend = this.end.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);\n        const bend = b.end.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);\n        const checkResult = ((astart < bend) && (bstart < aend));\n        if (checkResult !== result) {\n            // tslint:disable-next-line:max-line-length\n            console.log(`check mismatch: res ${result} ${this.start.segment === b.end.segment} ${b.start.segment === this.end.segment}`);\n            console.log(`as ${astart} ae ${aend} bs ${bstart} be ${bend}`);\n            console.log(`as ${MergeTree.ordinalToArray(this.start.segment.ordinal)}@${this.start.offset}`);\n            console.log(`ae ${MergeTree.ordinalToArray(this.end.segment.ordinal)}@${this.end.offset}`);\n            console.log(`bs ${MergeTree.ordinalToArray(b.start.segment.ordinal)}@${b.start.offset}`);\n            console.log(`be ${MergeTree.ordinalToArray(b.end.segment.ordinal)}@${b.end.offset}`);\n            console.log(this.checkMergeTree.nodeToString(b.start.segment.parent, \"\"));\n        }\n    }\n}\nfunction createPositionReference(client, pos, refType, refSeq = client.getCurrentSeq(), clientId = client.getClientId()) {\n    const segoff = client.mergeTree.getContainingSegment(pos, refSeq, client.getClientId());\n    if (segoff && segoff.segment) {\n        const baseSegment = segoff.segment;\n        const lref = new MergeTree.LocalReference(baseSegment, segoff.offset, refType);\n        if (refType !== MergeTree.ReferenceType.Transient) {\n            client.mergeTree.addLocalReference(lref);\n        }\n        return lref;\n    }\n}\nfunction createSharedStringInterval(label, start, end, client, intervalType) {\n    let beginRefType = MergeTree.ReferenceType.RangeBegin;\n    let endRefType = MergeTree.ReferenceType.RangeEnd;\n    if (intervalType === MergeTree.IntervalType.Nest) {\n        beginRefType = MergeTree.ReferenceType.NestBegin;\n        endRefType = MergeTree.ReferenceType.NestEnd;\n    }\n    else if (intervalType === MergeTree.IntervalType.Transient) {\n        beginRefType = MergeTree.ReferenceType.Transient;\n        endRefType = MergeTree.ReferenceType.Transient;\n    }\n    const startLref = createPositionReference(client, start, beginRefType);\n    const endLref = createPositionReference(client, end, endRefType);\n    if (startLref && endLref) {\n        startLref.pairedRef = endLref;\n        endLref.pairedRef = startLref;\n        const rangeProp = {\n            [MergeTree.reservedRangeLabelsKey]: [label],\n        };\n        startLref.addProperties(rangeProp);\n        endLref.addProperties(rangeProp);\n        const ival = new SharedStringInterval(startLref, endLref, intervalType, rangeProp);\n        // ival.checkMergeTree = sharedString.client.mergeTree;\n        return ival;\n    }\n    else {\n        return null;\n    }\n}\nexport function defaultIntervalConflictResolver(a, b) {\n    a.addPropertySet(b.properties);\n    return a;\n}\nexport function createIntervalIndex(conflict) {\n    const helpers = {\n        compareEnds: compareIntervalEnds,\n        create: createInterval,\n    };\n    const lc = new LocalIntervalCollection(undefined, \"\", helpers);\n    if (conflict) {\n        lc.addConflictResolver(conflict);\n    }\n    else {\n        lc.addConflictResolver(defaultIntervalConflictResolver);\n    }\n    return lc;\n}\nexport class LocalIntervalCollection {\n    constructor(client, label, helpers) {\n        this.client = client;\n        this.label = label;\n        this.helpers = helpers;\n        this.intervalTree = new MergeTree.IntervalTree();\n        this.endIntervalTree =\n            new MergeTree.RedBlackTree(helpers.compareEnds);\n    }\n    addConflictResolver(conflictResolver) {\n        this.conflictResolver = conflictResolver;\n        this.endConflictResolver =\n            (key, currentKey) => {\n                const ival = this.conflictResolver(key, currentKey);\n                return {\n                    data: ival,\n                    key: ival,\n                };\n            };\n    }\n    map(fn) {\n        this.intervalTree.map(fn);\n    }\n    findOverlappingIntervals(startPosition, endPosition) {\n        if (!this.intervalTree.intervals.isEmpty()) {\n            const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, MergeTree.IntervalType.Transient);\n            const overlappingIntervalNodes = this.intervalTree.match(transientInterval);\n            return overlappingIntervalNodes.map((node) => node.key);\n        }\n        else {\n            return [];\n        }\n    }\n    previousInterval(pos) {\n        const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, MergeTree.IntervalType.Transient);\n        const rbNode = this.endIntervalTree.floor(transientInterval);\n        if (rbNode) {\n            return rbNode.data;\n        }\n    }\n    nextInterval(pos) {\n        const transientInterval = this.helpers.create(\"transient\", pos, pos, this.client, MergeTree.IntervalType.Transient);\n        const rbNode = this.endIntervalTree.ceil(transientInterval);\n        if (rbNode) {\n            return rbNode.data;\n        }\n    }\n    removeInterval(startPosition, endPosition) {\n        const transientInterval = this.helpers.create(\"transient\", startPosition, endPosition, this.client, MergeTree.IntervalType.Transient);\n        this.intervalTree.remove(transientInterval);\n        this.endIntervalTree.remove(transientInterval);\n    }\n    createInterval(start, end, intervalType) {\n        return this.helpers.create(this.label, start, end, this.client, intervalType);\n    }\n    // TODO: remove interval, handle duplicate intervals\n    addInterval(start, end, intervalType, props) {\n        const interval = this.createInterval(start, end, intervalType);\n        if (interval) {\n            interval.addProperties(props);\n            if (this.label && (this.label.length > 0)) {\n                interval.properties[MergeTree.reservedRangeLabelsKey] = [this.label];\n            }\n            this.intervalTree.put(interval, this.conflictResolver);\n            this.endIntervalTree.put(interval, interval, this.endConflictResolver);\n        }\n        return interval;\n    }\n    serialize() {\n        const client = this.client;\n        const intervals = this.intervalTree.intervals.keys();\n        // tslint:disable-next-line\n        return intervals.map((interval) => interval.serialize(client));\n    }\n}\nfunction compareSharedStringIntervalEnds(a, b) {\n    return a.end.compare(b.end);\n}\nclass SharedStringIntervalCollectionFactory {\n    load(emitter, raw) {\n        const helpers = {\n            compareEnds: compareSharedStringIntervalEnds,\n            create: createSharedStringInterval,\n        };\n        return new SharedIntervalCollection(helpers, true, emitter, raw || []);\n    }\n    store(value) {\n        return value.serializeInternal();\n    }\n}\nexport class SharedStringIntervalCollectionValueType {\n    // tslint:enable:variable-name\n    constructor() {\n        this._factory = new SharedStringIntervalCollectionFactory();\n        this._ops = new Map([[\n                \"add\",\n                {\n                    /* tslint:disable:promise-function-async */\n                    prepare: (value, params, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        /* tslint:disable:no-unsafe-any */\n                        return value.prepareAddInternal(params, local, op);\n                    },\n                    process: (value, params, context, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        value.addInternal(params, context, local, op);\n                    },\n                },\n            ]]);\n    }\n    get name() {\n        return SharedStringIntervalCollectionValueType.Name;\n    }\n    get factory() {\n        return this._factory;\n    }\n    get ops() {\n        return this._ops;\n    }\n}\nSharedStringIntervalCollectionValueType.Name = \"sharedStringIntervalCollection\";\nfunction compareIntervalEnds(a, b) {\n    return a.end - b.end;\n}\nfunction createInterval(label, start, end, client) {\n    let rangeProp;\n    if (label && (label.length > 0)) {\n        rangeProp = {\n            [MergeTree.reservedRangeLabelsKey]: [label],\n        };\n    }\n    return new Interval(start, end, rangeProp);\n}\nclass SharedIntervalCollectionFactory {\n    load(emitter, raw) {\n        const helpers = {\n            compareEnds: compareIntervalEnds,\n            create: createInterval,\n        };\n        const collection = new SharedIntervalCollection(helpers, false, emitter, raw || []);\n        collection.attach(undefined, \"\");\n        return collection;\n    }\n    store(value) {\n        return value.serializeInternal();\n    }\n}\nexport class SharedIntervalCollectionValueType {\n    // tslint:enable:variable-name\n    constructor() {\n        this._factory = new SharedIntervalCollectionFactory();\n        this._ops = new Map([[\n                \"add\",\n                {\n                    prepare: (value, params, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        return value.prepareAddInternal(params, local, op);\n                    },\n                    process: (value, params, context, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        value.addInternal(params, context, local, op);\n                    },\n                },\n            ]]);\n    }\n    get name() {\n        return SharedIntervalCollectionValueType.Name;\n    }\n    get factory() {\n        return this._factory;\n    }\n    get ops() {\n        return this._ops;\n    }\n}\nSharedIntervalCollectionValueType.Name = \"sharedIntervalCollection\";\nexport class SharedIntervalCollectionView extends EventEmitter {\n    constructor(client, savedSerializedIntervals, label, helpers, emitter) {\n        super();\n        this.client = client;\n        this.emitter = emitter;\n        this.attachingP = Promise.resolve();\n        // Instantiate the local interval collection based on the saved intervals\n        this.localCollection = new LocalIntervalCollection(client, label, helpers);\n        if (savedSerializedIntervals) {\n            for (const serializedInterval of savedSerializedIntervals) {\n                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n            }\n        }\n    }\n    attachDeserializer(onDeserialize, onPrepareDeserialize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.attachingP = this.attachDeserializerCore(onDeserialize, onPrepareDeserialize);\n            return this.attachingP;\n        });\n    }\n    findOverlappingIntervals(startPosition, endPosition) {\n        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);\n    }\n    map(fn) {\n        this.localCollection.map(fn);\n    }\n    previousInterval(pos) {\n        return this.localCollection.previousInterval(pos);\n    }\n    nextInterval(pos) {\n        return this.localCollection.nextInterval(pos);\n    }\n    /* tslint:disable:no-unnecessary-override */\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    add(start, end, intervalType, props) {\n        let seq = 0;\n        if (this.client) {\n            seq = this.client.getCurrentSeq();\n        }\n        const serializedInterval = {\n            end,\n            intervalType,\n            properties: props,\n            sequenceNumber: seq,\n            start,\n        };\n        this.addInternal(serializedInterval, null, true, null);\n    }\n    // TODO: error cases\n    addInternal(serializedInterval, context, local, op) {\n        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);\n        if (interval) {\n            // Local ops get submitted to the server. Remote ops have the deserializer run.\n            if (local) {\n                this.emitter.emit(\"add\", serializedInterval);\n            }\n            else {\n                if (this.onDeserialize) {\n                    this.onDeserialize(interval, context);\n                }\n            }\n        }\n        this.emit(\"addInterval\", interval, local, op);\n        return this;\n    }\n    prepareAdd(interval, local, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.attachingP;\n            return this.onPrepareDeserialize ? this.onPrepareDeserialize(interval.properties) : null;\n        });\n    }\n    serializeInternal() {\n        return this.localCollection.serialize();\n    }\n    attachDeserializerCore(onDeserialize, onPrepareDeserialize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If no deserializer is specified can skip all processing work\n            if (!onDeserialize && !onPrepareDeserialize) {\n                return;\n            }\n            // Start by storing the callbacks so that any subsequent modifications make use of them\n            this.onDeserialize = onDeserialize;\n            this.onPrepareDeserialize = onPrepareDeserialize;\n            // Trigger the async prepare work across all values in the collection\n            const preparedIntervalsP = [];\n            this.localCollection.map((interval) => {\n                const preparedIntervalP = onPrepareDeserialize(interval.properties)\n                    .then((context) => ({ context, interval }));\n                preparedIntervalsP.push(preparedIntervalP);\n            });\n            const preparedIntervals = yield Promise.all(preparedIntervalsP);\n            for (const preparedInterval of preparedIntervals) {\n                this.onDeserialize(preparedInterval.interval, preparedInterval.context);\n            }\n        });\n    }\n}\nexport class SharedIntervalCollection {\n    constructor(helpers, requiresClient, emitter, serializedIntervals) {\n        this.helpers = helpers;\n        this.requiresClient = requiresClient;\n        this.emitter = emitter;\n        this.savedSerializedIntervals = serializedIntervals;\n    }\n    get attached() {\n        return !!this.view;\n    }\n    attach(client, label) {\n        if (this.view) {\n            throw new Error(\"Only supports one SharedString attach\");\n        }\n        if ((client === undefined) && (this.requiresClient)) {\n            throw new Error(\"Client required for this collection\");\n        }\n        this.view = new SharedIntervalCollectionView(client, this.savedSerializedIntervals, label, this.helpers, this.emitter);\n        this.savedSerializedIntervals = undefined;\n    }\n    add(startPosition, endPosition, intervalType, props) {\n        if (!this.view) {\n            return Promise.reject(\"attach must be called prior to adding intervals\");\n        }\n        this.view.add(startPosition, endPosition, intervalType, props);\n    }\n    getView(onDeserialize, onPrepareDeserialize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.view) {\n                return Promise.reject(\"attachSharedString must be called prior to retrieving the view\");\n            }\n            // Attach custom deserializers if specified\n            if (onDeserialize || onPrepareDeserialize) {\n                yield this.view.attachDeserializer(onDeserialize, onPrepareDeserialize);\n            }\n            return this.view;\n        });\n    }\n    prepareAddInternal(interval, local, message) {\n        if (!this.view) {\n            return Promise.reject(\"attachSharedString must be called\");\n        }\n        return this.view.prepareAdd(interval, local, message);\n    }\n    addInternal(serializedInterval, context, local, op) {\n        if (!this.view) {\n            throw new Error(\"attachSharedString must be called\");\n        }\n        return this.view.addInternal(serializedInterval, context, local, op);\n    }\n    serializeInternal() {\n        if (!this.view) {\n            throw new Error(\"attachSharedString must be called\");\n        }\n        return this.view.serializeInternal();\n    }\n}\n//# sourceMappingURL=intervalCollection.js.map","import { ListMakeHead } from \"./collections\";\nexport class SegmentGroupCollection {\n    constructor(segment) {\n        this.segment = segment;\n        this.segmentGroups = ListMakeHead();\n    }\n    get size() {\n        return this.segmentGroups.count();\n    }\n    get empty() {\n        return this.segmentGroups.empty();\n    }\n    enqueue(segmentGroup) {\n        this.segmentGroups.enqueue(segmentGroup);\n        segmentGroup.segments.push(this.segment);\n    }\n    dequeue() {\n        return this.segmentGroups.dequeue();\n    }\n    clear() {\n        this.segmentGroups.clear();\n    }\n    copyTo(segment) {\n        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));\n    }\n}\n//# sourceMappingURL=segmentGroupCollection.js.map","/**\n * The event object returned on sequenceDelta events.\n *\n * The properties of this object and it's sub-objects represent a point in time state\n * at the time the operation was applied. They will not take into any future modifications\n *  performed to the undlying sequence and merge tree.\n *\n * For group ops, each op will get it's own event, and the group op property will be set on the op args.\n *\n * Ops may get multiple events. For instance, as insert-replace will get a remove then an insert event.\n */\nexport class SequenceDeltaEvent {\n    constructor(opArgs, mergeTreeClient, deltaArgs) {\n        this.opArgs = opArgs;\n        this.mergeTreeClient = mergeTreeClient;\n        this.deltaArgs = deltaArgs;\n        this.isLocal =\n            this.deltaArgs.mergeTreeClientId ===\n                this.deltaArgs.mergeTree.collabWindow.clientId;\n        this.isEmpty = deltaArgs.segments.length === 0;\n        this.deltaOperation = deltaArgs.operation;\n        this.sortedRanges = new Lazy(() => this.deltaArgs.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : (a.ordinal > b.ordinal ? 1 : 0))\n            .map((segment) => new Lazy(() => {\n            const start = this.deltaArgs.mergeTree.getOffset(segment, this.deltaArgs.mergeTree.collabWindow.currentSeq, this.deltaArgs.mergeTree.collabWindow.clientId);\n            return {\n                segment,\n                start,\n            };\n        })));\n        this.pStart = new Lazy(() => {\n            if (this.isEmpty) {\n                return undefined;\n            }\n            return this.sortedRanges.value[0].value.start;\n        });\n        this.pEnd = new Lazy(() => {\n            if (this.isEmpty) {\n                return undefined;\n            }\n            const lastRange = this.sortedRanges.value[this.sortedRanges.value.length - 1].value;\n            return lastRange.start + lastRange.segment.cachedLength;\n        });\n        this.pClientId = new Lazy(() => this.mergeTreeClient.getLongClientId(this.deltaArgs.mergeTreeClientId));\n        this.pRanges = new Lazy(() => {\n            const ranges = [];\n            if (this.isEmpty) {\n                return ranges;\n            }\n            let segments;\n            let start;\n            let length;\n            let type;\n            for (const segment of this.sortedRanges.value) {\n                const nextStart = segment.value.start;\n                const nextLength = segment.value.segment.cachedLength;\n                const nextType = segment.value.segment.getType();\n                let currentPosition = start;\n                // for remove don't add the length, since getOffset won't include it\n                if (this.deltaArgs.operation !== 1 /* REMOVE */) {\n                    currentPosition += length;\n                }\n                if (type !== nextType || currentPosition !== nextStart) {\n                    // don't push if the first segment\n                    if (segments) {\n                        ranges.push({\n                            length,\n                            segments,\n                            start,\n                            type,\n                        });\n                    }\n                    segments = [segment.value.segment];\n                    start = nextStart;\n                    length = nextLength;\n                    type = nextType;\n                }\n                else {\n                    segments.push(segment.value.segment);\n                    length += nextLength;\n                }\n            }\n            ranges.push({\n                length,\n                segments,\n                start,\n                type,\n            });\n            return ranges;\n        });\n    }\n    get start() {\n        return this.pStart.value;\n    }\n    get end() {\n        return this.pEnd.value;\n    }\n    get clientId() {\n        return this.pClientId.value;\n    }\n    get ranges() {\n        return this.pRanges.value;\n    }\n}\nclass Lazy {\n    constructor(valueGenerator) {\n        this.valueGenerator = valueGenerator;\n        this.pEvaluated = false;\n    }\n    get evaluated() {\n        return this.pEvaluated;\n    }\n    get value() {\n        if (!this.pEvaluated) {\n            this.pEvaluated = true;\n            this.pValue = this.valueGenerator();\n        }\n        return this.pValue;\n    }\n}\n//# sourceMappingURL=sequenceDeltaEvent.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Stream } from \"./stream\";\nexport class StreamExtension {\n    constructor() {\n        this.type = StreamExtension.Type;\n    }\n    load(runtime, id, minimumSequenceNumber, services, headerOrigin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stream = new Stream(runtime, id);\n            yield stream.load(minimumSequenceNumber, headerOrigin, services);\n            return stream;\n        });\n    }\n    create(runtime, id) {\n        const stream = new Stream(runtime, id);\n        stream.initializeLocal();\n        return stream;\n    }\n}\nStreamExtension.Type = \"https://graph.microsoft.com/types/stream\";\n//# sourceMappingURL=extension.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Cell } from \"./cell\";\n/**\n * The extension that defines the map\n */\nexport class CellExtension {\n    constructor() {\n        this.type = CellExtension.Type;\n    }\n    load(document, id, minimumSequenceNumber, services, headerOrigin) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cell = new Cell(id, document);\n            yield cell.load(minimumSequenceNumber, headerOrigin, services);\n            return cell;\n        });\n    }\n    create(document, id) {\n        const cell = new Cell(id, document);\n        cell.initializeLocal();\n        return cell;\n    }\n}\nCellExtension.Type = \"https://graph.microsoft.com/types/cell\";\n//# sourceMappingURL=extension.js.map","import * as registerDebug from \"debug\";\nexport const debug = registerDebug(\"prague:cell\");\n//# sourceMappingURL=debug.js.map","// tslint:disable-next-line:no-submodule-imports\nimport * as uuid from \"uuid/v4\";\n/**\n * Fluent implementation of the IDelta interface to make creation the underlying operation easier.\n * Only one operation per delta is currently supported but it's expected this will expand to multiple in\n * the future\n */\nexport class Delta {\n    constructor(operations = []) {\n        this.operations = operations;\n    }\n    /**\n     * Composes two ink delta streams together - which is as simple as appending their operation\n     * logs\n     */\n    compose(delta) {\n        this.operations = this.operations.concat(delta.operations);\n    }\n    push(operation) {\n        this.operations.push(operation);\n    }\n    clear(time = new Date().getTime()) {\n        const clear = {};\n        this.operations.push({ clear, time });\n        return this;\n    }\n    stylusUp(point, pressure, id = uuid(), time = new Date().getTime()) {\n        const stylusUp = {\n            id,\n            point,\n            pressure,\n        };\n        this.operations.push({ stylusUp, time });\n        return this;\n    }\n    stylusDown(point, pressure, pen, layer = 0, id = uuid(), time = new Date().getTime()) {\n        const stylusDown = {\n            id,\n            layer,\n            pen,\n            point,\n            pressure,\n        };\n        this.operations.push({ stylusDown, time });\n        return this;\n    }\n    stylusMove(point, pressure, id = uuid(), time = new Date().getTime()) {\n        const stylusMove = {\n            id,\n            point,\n            pressure,\n        };\n        this.operations.push({ stylusMove, time });\n        return this;\n    }\n}\n/**\n * Retrieves the type of action contained within the operation\n */\nexport function getActionType(operation) {\n    if (operation.clear) {\n        return ActionType.Clear;\n    }\n    else if (operation.stylusDown) {\n        return ActionType.StylusDown;\n    }\n    else if (operation.stylusUp) {\n        return ActionType.StylusUp;\n    }\n    else if (operation.stylusMove) {\n        return ActionType.StylusMove;\n    }\n    else {\n        throw new Error(\"Unknown action\");\n    }\n}\n/**\n * Extracts the IStylusAction contained in the operation\n */\nexport function getStylusAction(operation) {\n    if (operation.stylusDown) {\n        return operation.stylusDown;\n    }\n    else if (operation.stylusUp) {\n        return operation.stylusUp;\n    }\n    else if (operation.stylusMove) {\n        return operation.stylusMove;\n    }\n    else {\n        throw new Error(\"Unknown action\");\n    }\n}\n/**\n * Helper function to retrieve the ID of the stylus operation\n */\nexport function getStylusId(operation) {\n    const type = getActionType(operation);\n    switch (type) {\n        case ActionType.StylusDown:\n            return operation.stylusDown.id;\n        case ActionType.StylusUp:\n            return operation.stylusUp.id;\n        case ActionType.StylusMove:\n            return operation.stylusMove.id;\n        default:\n            throw new Error(\"Non-stylus event\");\n    }\n}\nexport var ActionType;\n(function (ActionType) {\n    // Action of placing the stylus on the canvas\n    ActionType[ActionType[\"StylusDown\"] = 0] = \"StylusDown\";\n    // Action of picking the stylus up from the canvas\n    ActionType[ActionType[\"StylusUp\"] = 1] = \"StylusUp\";\n    // Stylus has moved on the canvas\n    ActionType[ActionType[\"StylusMove\"] = 2] = \"StylusMove\";\n    // Canvas has been cleared\n    ActionType[ActionType[\"Clear\"] = 3] = \"Clear\";\n})(ActionType || (ActionType = {}));\n//# sourceMappingURL=interfaces.js.map","import { ActionType, getActionType } from \"./interfaces\";\nexport class Snapshot {\n    constructor(layers = [], layerIndex = {}) {\n        this.layers = layers;\n        this.layerIndex = layerIndex;\n    }\n    static Clone(snapshot) {\n        return new Snapshot(snapshot.layers, snapshot.layerIndex);\n    }\n    apply(delta) {\n        for (const operation of delta.operations) {\n            this.applyOperation(operation);\n        }\n    }\n    applyOperation(operation) {\n        const actionType = getActionType(operation);\n        switch (actionType) {\n            case ActionType.Clear:\n                this.processClearAction(operation);\n                break;\n            case ActionType.StylusUp:\n                this.processStylusUpAction(operation);\n                break;\n            case ActionType.StylusDown:\n                this.processStylusDownAction(operation);\n                break;\n            case ActionType.StylusMove:\n                this.processStylusMoveAction(operation);\n                break;\n            default:\n                throw new Error(\"Unknown action type\");\n        }\n    }\n    processClearAction(operation) {\n        this.layers = [];\n        this.layerIndex = {};\n    }\n    processStylusUpAction(operation) {\n        // TODO - longer term on ink up - or possibly earlier - we can attempt to smooth the provided ink\n        this.addOperationToLayer(operation.stylusUp.id, operation);\n    }\n    processStylusDownAction(operation) {\n        const layer = {\n            id: operation.stylusDown.id,\n            operations: [],\n        };\n        // Push if we are isnerting at the end - otherwise splice to insert at the specified location\n        if (operation.stylusDown.layer === 0) {\n            this.layers.push(layer);\n        }\n        else {\n            this.layers.splice(this.layers.length - operation.stylusDown.layer, 0, layer);\n        }\n        // Create a reference to the specified layer\n        let layerIndex = this.layers.length - 1 - operation.stylusDown.layer;\n        this.layerIndex[layer.id] = layerIndex;\n        // And move any after it down by one\n        // tslint:disable-next-line:no-increment-decrement\n        for (layerIndex = layerIndex + 1; layerIndex < this.layers.length; layerIndex++) {\n            const layerId = this.layers[layerIndex].id;\n            this.layerIndex[layerId] = this.layerIndex[layerId] + 1;\n        }\n        // And save the stylus down\n        this.addOperationToLayer(operation.stylusDown.id, operation);\n    }\n    processStylusMoveAction(operation) {\n        this.addOperationToLayer(operation.stylusMove.id, operation);\n    }\n    addOperationToLayer(id, operation) {\n        // TODO: Why is this operation sometimes undefined?\n        if (this.layerIndex[id] !== undefined) {\n            const layerIndex = this.layerIndex[id];\n            if (this.layers[layerIndex].operations === undefined) {\n                this.layers[layerIndex].operations = [];\n            }\n            this.layers[layerIndex].operations.push(operation);\n        }\n    }\n}\n//# sourceMappingURL=snapshot.js.map","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","\"use strict\";\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = require('ms');\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\nconst assert = require(\"assert\");\nconst Deque = require(\"double-ended-queue\");\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"./debug\");\nconst valueType_1 = require(\"./valueType\");\nclass SharedObject extends events_1.EventEmitter {\n    constructor(id, runtime, type) {\n        super();\n        this.id = id;\n        this.runtime = runtime;\n        this.type = type;\n        // tslint:disable-next-line:variable-name\n        this.__sharedObject__ = true;\n        // tslint:disable-next-line:variable-name private fields exposed via getters\n        this._state = container_definitions_1.ConnectionState.Disconnected;\n        // Locally applied operations not yet ACK'd by the server\n        this.pendingOps = new Deque();\n    }\n    get state() {\n        return this._state;\n    }\n    toJSON() {\n        return {\n            type: valueType_1.ValueType[valueType_1.ValueType.Shared],\n            value: this.id,\n        };\n    }\n    /**\n     * A shared object, after construction, can either be loaded in the case that it is already part of\n     * a shared document. Or later attached if it is being newly added.\n     */\n    load(minimumSequenceNumber, headerOrigin, services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.services = services;\n            yield this.loadCore(minimumSequenceNumber, headerOrigin, services.objectStorage);\n            this.attachDeltaHandler();\n        });\n    }\n    /**\n     * Initializes the object as a local, non-shared object. This object can become shared after\n     * it is attached to the document.\n     */\n    initializeLocal() {\n        this.initializeLocalCore();\n    }\n    /**\n     * Attaches the given shared object to its containing document\n     */\n    attach() {\n        if (!this.isLocal()) {\n            return this;\n        }\n        // Allow derived classes to perform custom processing prior to attaching this object\n        this.attachCore();\n        // Notify the document of the attachment\n        this.services = this.runtime.attachChannel(this);\n        this.attachDeltaHandler();\n        return this;\n    }\n    /**\n     * Returns whether the given shared object is local\n     */\n    isLocal() {\n        return !this.services;\n    }\n    /* tslint:disable:no-unnecessary-override */\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    /**\n     * Processes a message by the local client\n     */\n    submitLocalMessage(content) {\n        assert(!this.isLocal());\n        // Send if we are connected - otherwise just add to the sent list\n        let clientSequenceNumber = -1;\n        if (this.state === container_definitions_1.ConnectionState.Connected) {\n            clientSequenceNumber = this.services.deltaConnection.submit(content);\n        }\n        else {\n            debug_1.debug(`${this.id} Not fully connected - adding to pending list`, content);\n            // Store the message for when it is ACKed and then submit to the server if connected\n        }\n        this.pendingOps.push({ clientSequenceNumber, content });\n        return clientSequenceNumber;\n    }\n    attachDeltaHandler() {\n        this.services.deltaConnection.attach({\n            minSequenceNumberChanged: (value) => {\n                this.processMinSequenceNumberChanged(value);\n            },\n            prepare: (message, local) => {\n                return this.prepare(message, local);\n            },\n            process: (message, local, context) => {\n                this.process(message, local, context);\n            },\n            setConnectionState: (state) => {\n                this.setConnectionState(state);\n            },\n        });\n        // Trigger initial state\n        this.setConnectionState(this.services.deltaConnection.state);\n    }\n    prepare(message, local) {\n        return this.prepareCore(message, local);\n    }\n    setConnectionState(state) {\n        // Should I change the state at the end? So that we *can't* send new stuff before we send old?\n        this._state = state;\n        switch (state) {\n            case container_definitions_1.ConnectionState.Disconnected:\n                // Things that are true now...\n                // - if we had a connection we can no longer send messages over it\n                // - if we had outbound messages some may or may not be ACK'd. Won't know until next message\n                //\n                // - nack could get a new msn - but might as well do it in the join?\n                this.onDisconnect();\n                break;\n            case container_definitions_1.ConnectionState.Connecting:\n                // Things that are now true...\n                // - we will begin to receive inbound messages\n                // - we know what our new client id is.\n                // - still not safe to send messages\n                // While connecting we are still ticking off the previous messages\n                debug_1.debug(`${this.id} is now connecting`);\n                break;\n            case container_definitions_1.ConnectionState.Connected:\n                // Extract all un-ack'd payload operation\n                const pendingOps = this.pendingOps.toArray().map((value) => value.content);\n                this.pendingOps.clear();\n                // And now we are fully connected\n                // - we have a client ID\n                // - we are caught up enough to attempt to send messages\n                this.onConnect(pendingOps);\n                break;\n            default:\n                assert.ok(false, `Unknown ConnectionState ${state}`);\n        }\n    }\n    /**\n     * Handles a message being received from the remote delta server\n     */\n    process(message, local, context) {\n        if (message.type === container_definitions_1.MessageType.Operation && local) {\n            // disconnected ops should never be processed. They should have been fully sent on connected\n            assert(this.pendingOps.length === 0 || this.pendingOps.peekFront().clientSequenceNumber !== -1, `process for disconnected op ${this.pendingOps.peekFront().clientSequenceNumber}`);\n            // One of our messages was sequenced. We can remove it from the local message list. Given these arrive\n            // in order we only need to check the beginning of the local list.\n            if (this.pendingOps.length > 0 &&\n                this.pendingOps.peekFront().clientSequenceNumber === message.clientSequenceNumber) {\n                this.pendingOps.shift();\n                if (this.pendingOps.length === 0) {\n                    this.emit(\"processed\");\n                }\n            }\n            else {\n                debug_1.debug(`Duplicate ack received ${message.clientSequenceNumber}`);\n            }\n        }\n        this.emit(\"pre-op\", message, local);\n        this.processCore(message, local, context);\n        this.emit(\"op\", message, local);\n    }\n}\nexports.SharedObject = SharedObject;\n//# sourceMappingURL=sharedObject.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getFileBlobType(mimeType) {\n    switch (mimeType) {\n        case \"image/jpeg\":\n        case \"image/png\":\n        case \"image/gif\":\n        case \"image/bmp\": {\n            return \"image\";\n        }\n        case \"video/mp4\": {\n            return \"video\";\n        }\n        case \"text/plain\": {\n            return \"text\";\n        }\n        default: {\n            return \"generic\";\n        }\n    }\n}\nexports.getFileBlobType = getFileBlobType;\n//# sourceMappingURL=blobs.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ConnectionState;\n(function (ConnectionState) {\n    /**\n     * The document is no longer connected to the delta server\n     */\n    ConnectionState[ConnectionState[\"Disconnected\"] = 0] = \"Disconnected\";\n    /**\n     * The document has an inbound connection but is still pending for outbound deltas\n     */\n    ConnectionState[ConnectionState[\"Connecting\"] = 1] = \"Connecting\";\n    /**\n     * The document is fully connected\n     */\n    ConnectionState[ConnectionState[\"Connected\"] = 2] = \"Connected\";\n})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));\n//# sourceMappingURL=chaincode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Browser = \"browser\";\nexports.Robot = \"robot\";\n//# sourceMappingURL=clients.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MessageType;\n(function (MessageType) {\n    // Empty operation message. Used to send an updated reference sequence number.\n    MessageType[\"NoOp\"] = \"noop\";\n    // System message sent to indicate a new client has joined the collaboration\n    MessageType[\"ClientJoin\"] = \"join\";\n    // System message sent to indicate a client has left the collaboration\n    MessageType[\"ClientLeave\"] = \"leave\";\n    // Proposes a new consensus value\n    MessageType[\"Propose\"] = \"propose\";\n    // Message used to reject a pending proposal\n    MessageType[\"Reject\"] = \"reject\";\n    // Blob uploaded\n    MessageType[\"BlobUploaded\"] = \"blobUploaded\";\n    // TODO the attach and operation names are partially historican. We may want to rename to align with changes\n    // coming from code loading.\n    // Creates a new channel and attaches chaincode to it\n    MessageType[\"Attach\"] = \"attach\";\n    // Channel operation.\n    MessageType[\"Operation\"] = \"op\";\n    // Chunked operation.\n    MessageType[\"ChunkedOp\"] = \"chunkedOp\";\n    // Forced snapshot\n    MessageType[\"Save\"] = \"saveOp\";\n    // System message to indicate the creation of a new fork\n    MessageType[\"Fork\"] = \"fork\";\n    // Message sent when forwarding a sequenced message to an upstream branch\n    MessageType[\"Integrate\"] = \"integrate\";\n    // Message to indicate the need of a remote agent for a document.\n    MessageType[\"RemoteHelp\"] = \"remoteHelp\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\n//# sourceMappingURL=protocol.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar FileMode;\n(function (FileMode) {\n    FileMode[\"File\"] = \"100644\";\n    FileMode[\"Executable\"] = \"100755\";\n    FileMode[\"Directory\"] = \"040000\";\n    FileMode[\"Commit\"] = \"160000\";\n    FileMode[\"Symlink\"] = \"120000\";\n})(FileMode = exports.FileMode || (exports.FileMode = {}));\n/**\n * Type of entries that can be stored in a tree\n */\nvar TreeEntry;\n(function (TreeEntry) {\n    TreeEntry[TreeEntry[\"Blob\"] = 0] = \"Blob\";\n    TreeEntry[TreeEntry[\"Commit\"] = 1] = \"Commit\";\n    TreeEntry[TreeEntry[\"Tree\"] = 2] = \"Tree\";\n})(TreeEntry = exports.TreeEntry || (exports.TreeEntry = {}));\n//# sourceMappingURL=storage.js.map","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst registerDebug = require(\"debug\");\nexports.debug = registerDebug(\"prague:api-definitions\");\n//# sourceMappingURL=debug.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class that contains a collection of collaboration extensions\n */\nclass Registry {\n    constructor() {\n        this.extensions = [];\n        this.extensionsMap = {};\n    }\n    /**\n     * Registers a new extension\n     * @param extension The extension to register\n     */\n    register(extension) {\n        this.extensions.push(extension);\n        this.extensionsMap[extension.type] = extension;\n    }\n    /**\n     * Retrieves the extension with the given id\n     * @param id ID for the extension to retrieve\n     */\n    getExtension(type) {\n        if (!(type in this.extensionsMap)) {\n            throw new Error(\"Extension not found\");\n        }\n        return this.extensionsMap[type];\n    }\n}\nexports.Registry = Registry;\n//# sourceMappingURL=extension.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\nconst utils_1 = require(\"@prague/utils\");\nconst assert = require(\"assert\");\nconst events_1 = require(\"events\");\nconst componentRuntime_1 = require(\"./componentRuntime\");\nconst componentStorageService_1 = require(\"./componentStorageService\");\nconst debug_1 = require(\"./debug\");\nconst leaderElection_1 = require(\"./leaderElection\");\nconst taskAnalyzer_1 = require(\"./taskAnalyzer\");\n// Context will define the component level mappings\nclass Runtime extends events_1.EventEmitter {\n    constructor(registry, context) {\n        super();\n        this.registry = registry;\n        this.context = context;\n        this.tasks = [];\n        // Components tracked by the Domain\n        this.components = new Map();\n        this.componentsDeferred = new Map();\n        this.closed = false;\n        this.pendingAttach = new Map();\n        this.lastMinSequenceNumber = context.minimumSequenceNumber;\n    }\n    static Load(registry, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runtime = new Runtime(registry, context);\n            const components = new Map();\n            const snapshotTreesP = Object.keys(context.baseSnapshot.commits).map((key) => __awaiter(this, void 0, void 0, function* () {\n                const moduleSha = context.baseSnapshot.commits[key];\n                const commit = (yield context.storage.getVersions(moduleSha, 1))[0];\n                const moduleTree = yield context.storage.getSnapshotTree(commit);\n                return { id: key, tree: moduleTree };\n            }));\n            const snapshotTree = yield Promise.all(snapshotTreesP);\n            for (const value of snapshotTree) {\n                components.set(value.id, value.tree);\n            }\n            const componentsP = new Array();\n            for (const [componentId, snapshot] of components) {\n                const componentP = runtime.loadComponent(componentId, snapshot, context.blobs);\n                componentsP.push(componentP);\n            }\n            yield Promise.all(componentsP);\n            return runtime;\n        });\n    }\n    get connectionState() {\n        return this.context.connectionState;\n    }\n    get tenantId() {\n        return this.context.tenantId;\n    }\n    get id() {\n        return this.context.id;\n    }\n    get parentBranch() {\n        return this.context.parentBranch;\n    }\n    get existing() {\n        return this.context.existing;\n    }\n    // tslint:disable-next-line:no-unsafe-any\n    get options() {\n        return this.context.options;\n    }\n    get clientId() {\n        return this.context.clientId;\n    }\n    get blobManager() {\n        return this.context.blobManager;\n    }\n    get deltaManager() {\n        return this.context.deltaManager;\n    }\n    get storage() {\n        return this.context.storage;\n    }\n    get branch() {\n        return this.context.branch;\n    }\n    get minimumSequenceNumber() {\n        return this.context.minimumSequenceNumber;\n    }\n    get submitFn() {\n        return this.context.submitFn;\n    }\n    get snapshotFn() {\n        return this.context.snapshotFn;\n    }\n    get closeFn() {\n        return this.context.closeFn;\n    }\n    get connected() {\n        return this.connectionState === container_definitions_1.ConnectionState.Connected;\n    }\n    loadComponent(id, snapshotTree, extraBlobs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Need to rip through snapshot and use that to populate extraBlobs\n            const runtimeStorage = new componentStorageService_1.ComponentStorageService(this.storage, extraBlobs);\n            const details = yield utils_1.readAndParse(this.storage, snapshotTree.blobs[\".component\"]);\n            const componentP = componentRuntime_1.ComponentRuntime.LoadFromSnapshot(this, id, details.pkg, runtimeStorage, snapshotTree);\n            const deferred = new utils_1.Deferred();\n            deferred.resolve(componentP);\n            this.componentsDeferred.set(id, deferred);\n            const component = yield componentP;\n            this.components.set(id, component);\n            yield component.start();\n        });\n    }\n    registerRequestHandler(handler) {\n        this.requestHandler = handler;\n    }\n    getPackage(name) {\n        return this.registry.get(name);\n    }\n    request(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.requestHandler) {\n                return { status: 404, mimeType: \"text/plain\", value: `${request.url} not found` };\n            }\n            else {\n                return this.requestHandler(request);\n            }\n        });\n    }\n    snapshot(tagMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Pull in the prior version and snapshot tree to store against\n            const lastVersion = yield this.storage.getVersions(this.id, 1);\n            const tree = lastVersion.length > 0\n                ? yield this.storage.getSnapshotTree(lastVersion[0])\n                : { blobs: {}, commits: {}, trees: {} };\n            // Iterate over each component and ask it to snapshot\n            const channelEntries = new Map();\n            this.components.forEach((component, key) => channelEntries.set(key, component.snapshot()));\n            // Use base tree to know previous component snapshot and then snapshot each component\n            const channelCommitsP = new Array();\n            for (const [channelId, channelSnapshot] of channelEntries) {\n                // If sha exists then previous commit is still valid\n                if (channelSnapshot.sha) {\n                    channelCommitsP.push(Promise.resolve({\n                        commit: tree.commits[channelId],\n                        id: channelId,\n                    }));\n                }\n                else {\n                    const parent = channelId in tree.commits ? [tree.commits[channelId]] : [];\n                    const channelCommitP = this.storage\n                        .write(channelSnapshot, parent, `${channelId} commit ${tagMessage}`, channelId)\n                        .then((commit) => {\n                        this.components.get(channelId).updateBaseSha(commit.tree.sha);\n                        return { id: channelId, commit: commit.sha };\n                    });\n                    channelCommitsP.push(channelCommitP);\n                }\n            }\n            const root = { entries: [], sha: null };\n            // Add in module references to the component snapshots\n            const channelCommits = yield Promise.all(channelCommitsP);\n            let gitModules = \"\";\n            for (const channelCommit of channelCommits) {\n                root.entries.push({\n                    mode: container_definitions_1.FileMode.Commit,\n                    path: channelCommit.id,\n                    type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Commit],\n                    value: channelCommit.commit,\n                });\n                const repoUrl = \"https://github.com/kurtb/praguedocs.git\"; // this.storageService.repositoryUrl\n                gitModules += `[submodule \"${channelCommit.id}\"]\\n\\tpath = ${channelCommit.id}\\n\\turl = ${repoUrl}\\n\\n`;\n            }\n            // Write the module lookup details\n            root.entries.push({\n                mode: container_definitions_1.FileMode.File,\n                path: \".gitmodules\",\n                type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob],\n                value: {\n                    contents: gitModules,\n                    encoding: \"utf-8\",\n                },\n            });\n            return root;\n        });\n    }\n    requestSnapshot(tagMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.context.requestSnapshot(tagMessage);\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            this.closed = true;\n        });\n    }\n    changeConnectionState(value, clientId) {\n        this.verifyNotClosed();\n        // Resend all pending attach messages prior to notifying clients\n        if (value === container_definitions_1.ConnectionState.Connected) {\n            for (const [, message] of this.pendingAttach) {\n                this.submit(container_definitions_1.MessageType.Attach, message);\n            }\n        }\n        for (const [, component] of this.components) {\n            component.changeConnectionState(value, clientId);\n        }\n        if (value === container_definitions_1.ConnectionState.Connected) {\n            this.emit(\"connected\", this.clientId);\n        }\n    }\n    prepare(message, local) {\n        switch (message.type) {\n            case container_definitions_1.MessageType.Operation:\n                return this.prepareOperation(message, local);\n            case container_definitions_1.MessageType.Attach:\n                return this.prepareAttach(message, local);\n            default:\n                return Promise.resolve();\n        }\n    }\n    process(message, local, context) {\n        switch (message.type) {\n            case container_definitions_1.MessageType.Operation:\n                this.processOperation(message, local, context);\n                break;\n            case container_definitions_1.MessageType.Attach:\n                this.processAttach(message, local, context);\n                break;\n            default:\n        }\n        this.emit(\"op\", message);\n        if (this.lastMinSequenceNumber !== message.minimumSequenceNumber) {\n            this.lastMinSequenceNumber = message.minimumSequenceNumber;\n            this.updateMinSequenceNumber(message.minimumSequenceNumber);\n        }\n    }\n    postProcess(message, local, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (message.type) {\n                case container_definitions_1.MessageType.Attach:\n                    return this.postProcessAttach(message, local, context);\n                default:\n            }\n        });\n    }\n    updateMinSequenceNumber(minimumSequenceNumber) {\n        for (const [, component] of this.components) {\n            component.updateMinSequenceNumber(minimumSequenceNumber);\n        }\n    }\n    getComponent(id, wait = true) {\n        this.verifyNotClosed();\n        if (!this.componentsDeferred.has(id)) {\n            if (!wait) {\n                return Promise.reject(`Process ${id} does not exist`);\n            }\n            // Add in a deferred that will resolve once the process ID arrives\n            this.componentsDeferred.set(id, new utils_1.Deferred());\n        }\n        return this.componentsDeferred.get(id).promise;\n    }\n    createAndAttachComponent(id, pkg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            const runtimeStorage = new componentStorageService_1.ComponentStorageService(this.storage, new Map());\n            const component = yield componentRuntime_1.ComponentRuntime.create(this, id, pkg, runtimeStorage);\n            // Generate the attach message\n            const message = {\n                id,\n                snapshot: null,\n                type: pkg,\n            };\n            this.pendingAttach.set(id, message);\n            this.submit(container_definitions_1.MessageType.Attach, message);\n            // Start the component\n            yield component.start();\n            // Store off the component\n            this.components.set(id, component);\n            // Resolve any pending requests for the component\n            if (this.componentsDeferred.has(id)) {\n                this.componentsDeferred.get(id).resolve(component);\n            }\n            else {\n                const deferred = new utils_1.Deferred();\n                deferred.resolve(component);\n                this.componentsDeferred.set(id, deferred);\n            }\n            return component;\n        });\n    }\n    getQuorum() {\n        return this.context.quorum;\n    }\n    error(error) {\n        this.context.error(error);\n    }\n    registerTasks(tasks, version) {\n        this.verifyNotClosed();\n        this.tasks = tasks;\n        this.version = version;\n        this.startLeaderElection();\n    }\n    submit(type, content) {\n        this.verifyNotClosed();\n        this.submitFn(type, content);\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n    prepareOperation(message, local) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const envelope = message.contents;\n            const component = this.components.get(envelope.address);\n            assert(component);\n            const innerContents = envelope.contents;\n            const transformed = {\n                clientId: message.clientId,\n                clientSequenceNumber: message.clientSequenceNumber,\n                contents: innerContents.content,\n                metadata: message.metadata,\n                minimumSequenceNumber: message.minimumSequenceNumber,\n                origin: message.origin,\n                referenceSequenceNumber: message.referenceSequenceNumber,\n                sequenceNumber: message.sequenceNumber,\n                timestamp: message.timestamp,\n                traces: message.traces,\n                type: innerContents.type,\n            };\n            return component.prepare(transformed, local);\n        });\n    }\n    processOperation(message, local, context) {\n        const envelope = message.contents;\n        const component = this.components.get(envelope.address);\n        assert(component);\n        const innerContents = envelope.contents;\n        const transformed = {\n            clientId: message.clientId,\n            clientSequenceNumber: message.clientSequenceNumber,\n            contents: innerContents.content,\n            metadata: message.metadata,\n            minimumSequenceNumber: message.minimumSequenceNumber,\n            origin: message.origin,\n            referenceSequenceNumber: message.referenceSequenceNumber,\n            sequenceNumber: message.sequenceNumber,\n            timestamp: message.timestamp,\n            traces: message.traces,\n            type: innerContents.type,\n        };\n        component.process(transformed, local, context);\n    }\n    prepareAttach(message, local) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            // the local object has already been attached\n            if (local) {\n                return;\n            }\n            const attachMessage = message.contents;\n            let snapshotTree = null;\n            if (attachMessage.snapshot) {\n                const flattened = utils_1.flatten(attachMessage.snapshot.entries, new Map());\n                snapshotTree = utils_1.buildHierarchy(flattened);\n            }\n            // create storage service that wraps the attach data\n            const runtimeStorage = new componentStorageService_1.ComponentStorageService(this.storage, new Map());\n            const component = yield componentRuntime_1.ComponentRuntime.LoadFromSnapshot(this, attachMessage.id, attachMessage.type, runtimeStorage, snapshotTree);\n            return component;\n        });\n    }\n    processAttach(message, local, context) {\n        this.verifyNotClosed();\n        debug_1.debug(\"processAttach\");\n    }\n    postProcessAttach(message, local, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const attachMessage = message.contents;\n            // If a non-local operation then go and create the object - otherwise mark it as officially attached.\n            if (local) {\n                assert(this.pendingAttach.has(attachMessage.id));\n                this.pendingAttach.delete(attachMessage.id);\n            }\n            else {\n                yield context.start();\n                this.components.set(attachMessage.id, context);\n                // Resolve pending gets and store off any new ones\n                if (this.componentsDeferred.has(attachMessage.id)) {\n                    this.componentsDeferred.get(attachMessage.id).resolve(context);\n                }\n                else {\n                    const deferred = new utils_1.Deferred();\n                    deferred.resolve(context);\n                    this.componentsDeferred.set(attachMessage.id, deferred);\n                }\n            }\n        });\n    }\n    startLeaderElection() {\n        if (this.deltaManager && this.deltaManager.clientType === container_definitions_1.Browser) {\n            if (this.connected) {\n                this.initLeaderElection();\n            }\n            else {\n                this.once(\"connected\", () => this.initLeaderElection());\n            }\n        }\n    }\n    initLeaderElection() {\n        this.leaderElector = new leaderElection_1.LeaderElector(this.getQuorum(), this.clientId);\n        this.leaderElector.on(\"newLeader\", (clientId) => {\n            debug_1.debug(`New leader elected: ${clientId}`);\n            this.runTaskAnalyzer();\n        });\n        this.leaderElector.on(\"leaderLeft\", (clientId) => {\n            debug_1.debug(`Leader ${clientId} left`);\n            this.proposeLeadership();\n        });\n        this.leaderElector.on(\"memberLeft\", (clientId) => {\n            debug_1.debug(`Member ${clientId} left`);\n            this.runTaskAnalyzer();\n        });\n        this.proposeLeadership();\n    }\n    proposeLeadership() {\n        if (taskAnalyzer_1.getLeaderCandidate(this.getQuorum().getMembers()) === this.clientId) {\n            this.leaderElector.proposeLeadership().then(() => {\n                debug_1.debug(`Proposal accepted`);\n            }, (err) => {\n                debug_1.debug(`Proposal rejected: ${err}`);\n            });\n        }\n    }\n    /**\n     * On a client joining/departure, decide whether this client is the new leader.\n     * If so, calculate if there are any unhandled tasks for browsers and remote agents.\n     * Emit local help message for this browser and submits a remote help message for agents.\n     */\n    runTaskAnalyzer() {\n        if (this.leaderElector.getLeader() === this.clientId) {\n            // Analyze the current state and ask for local and remote help seperately.\n            const helpTasks = taskAnalyzer_1.analyzeTasks(this.clientId, this.getQuorum().getMembers(), this.tasks);\n            if (helpTasks && (helpTasks.browser.length > 0 || helpTasks.robot.length > 0)) {\n                if (helpTasks.browser.length > 0) {\n                    const localHelpMessage = {\n                        tasks: helpTasks.browser,\n                        version: this.version,\n                    };\n                    console.log(`Requesting local help for ${helpTasks.browser}`);\n                    this.emit(\"localHelp\", localHelpMessage);\n                }\n                if (helpTasks.robot.length > 0) {\n                    const remoteHelpMessage = {\n                        tasks: helpTasks.robot,\n                        version: this.version,\n                    };\n                    console.log(`Requesting remote help for ${helpTasks.robot}`);\n                    this.submit(container_definitions_1.MessageType.RemoteHelp, remoteHelpMessage);\n                }\n            }\n        }\n    }\n}\nexports.Runtime = Runtime;\n//# sourceMappingURL=runtime.js.map","var Buffer = require('safe-buffer').Buffer\n\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = Buffer.alloc(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = Buffer.from(data, enc)\n  }\n\n  var block = this._block\n  var blockSize = this._blockSize\n  var length = data.length\n  var accum = this._len\n\n  for (var offset = 0; offset < length;) {\n    var assigned = accum % blockSize\n    var remainder = Math.min(length - offset, blockSize - assigned)\n\n    for (var i = 0; i < remainder; i++) {\n      block[assigned + i] = data[offset + i]\n    }\n\n    accum += remainder\n    offset += remainder\n\n    if ((accum % blockSize) === 0) {\n      this._update(block)\n    }\n  }\n\n  this._len += length\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  var rem = this._len % this._blockSize\n\n  this._block[rem] = 0x80\n\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n  this._block.fill(0, rem + 1)\n\n  if (rem >= this._finalSize) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  var bits = this._len * 8\n\n  // uint32\n  if (bits <= 0xffffffff) {\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\n\n  // uint64\n  } else {\n    var lowBits = (bits & 0xffffffff) >>> 0\n    var highBits = (bits - lowBits) / 0x100000000\n\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\n  }\n\n  this._update(this._block)\n  var hash = this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n\n    return result;\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\nconst events_1 = require(\"events\");\n// tslint:disable:no-unsafe-any\nclass ComponentRuntime extends events_1.EventEmitter {\n    constructor(hostRuntime, pkg, id, existing, chaincode, storage, baseSnapshot) {\n        super();\n        this.hostRuntime = hostRuntime;\n        this.pkg = pkg;\n        this.id = id;\n        this.existing = existing;\n        this.chaincode = chaincode;\n        this.storage = storage;\n        this.baseSnapshot = baseSnapshot;\n        this.closed = false;\n        // Tracks the base snapshot hash. If no ops effect this component then the sha value can be returned on a\n        // snapshot call\n        this.baseSha = null;\n        this.baseSha = baseSnapshot ? baseSnapshot.sha : null;\n    }\n    static create(hostRuntime, id, pkg, storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const factory = yield hostRuntime.getPackage(pkg);\n            const extension = yield factory.instantiateComponent();\n            const component = new ComponentRuntime(hostRuntime, pkg, id, false, extension, storage, null);\n            return component;\n        });\n    }\n    static LoadFromSnapshot(hostRuntime, id, pkg, storage, channels) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const factory = yield hostRuntime.getPackage(pkg);\n            const extension = yield factory.instantiateComponent();\n            const component = new ComponentRuntime(hostRuntime, pkg, id, true, extension, storage, channels);\n            return component;\n        });\n    }\n    get tenantId() {\n        return this.hostRuntime.tenantId;\n    }\n    get documentId() {\n        return this.hostRuntime.id;\n    }\n    get parentBranch() {\n        return this.hostRuntime.parentBranch;\n    }\n    get options() {\n        return this.hostRuntime.options;\n    }\n    get clientId() {\n        return this.hostRuntime.clientId;\n    }\n    get blobManager() {\n        return this.hostRuntime.blobManager;\n    }\n    get deltaManager() {\n        return this.hostRuntime.deltaManager;\n    }\n    get connected() {\n        return this.hostRuntime.connected;\n    }\n    get connectionState() {\n        return this.hostRuntime.connectionState;\n    }\n    get submitFn() {\n        return this.hostRuntime.submitFn;\n    }\n    get snapshotFn() {\n        return this.hostRuntime.snapshotFn;\n    }\n    get closeFn() {\n        return this.hostRuntime.closeFn;\n    }\n    get branch() {\n        return this.hostRuntime.branch;\n    }\n    createAndAttachComponent(id, pkg) {\n        return this.hostRuntime.createAndAttachComponent(id, pkg);\n    }\n    getComponent(id, wait) {\n        return this.hostRuntime.getComponent(id, wait);\n    }\n    changeConnectionState(value, clientId) {\n        this.verifyNotClosed();\n        this.handler.changeConnectionState(value, clientId);\n    }\n    // Called after a snapshot to update the base sha\n    updateBaseSha(sha) {\n        this.baseSha = sha;\n    }\n    prepare(message, local) {\n        this.verifyNotClosed();\n        return this.handler.prepare(message, local);\n    }\n    process(message, local, context) {\n        this.verifyNotClosed();\n        // component has been modified and will need to regenerate its snapshot\n        this.baseSha = null;\n        return this.handler.process(message, local, context);\n    }\n    getQuorum() {\n        this.verifyNotClosed();\n        return this.hostRuntime.getQuorum();\n    }\n    getBlobMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.blobManager.getBlobMetadata();\n        });\n    }\n    stop() {\n        this.verifyNotClosed();\n        this.closed = true;\n        return this.snapshot();\n    }\n    close() {\n        this.hostRuntime.closeFn();\n    }\n    updateMinSequenceNumber(msn) {\n        this.handler.updateMinSequenceNumber(msn);\n    }\n    snapshot() {\n        const componentAttributes = { pkg: this.pkg };\n        const snapshot = this.chaincode.snapshot();\n        snapshot.entries.push({\n            mode: container_definitions_1.FileMode.File,\n            path: \".component\",\n            type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob],\n            value: {\n                contents: JSON.stringify(componentAttributes),\n                encoding: \"utf-8\",\n            },\n        });\n        // base sha still being set means previous snapshot is still valid\n        if (this.baseSha) {\n            snapshot.sha = this.baseSha;\n        }\n        return snapshot;\n    }\n    request(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.handler.request(request);\n        });\n    }\n    submitMessage(type, content) {\n        return this.submit(type, content);\n    }\n    error(err) {\n        return;\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            this.handler = yield this.chaincode.run(this);\n        });\n    }\n    attach(platform) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.chaincode.attach(platform);\n        });\n    }\n    submit(type, content) {\n        this.verifyNotClosed();\n        const envelope = {\n            address: this.id,\n            contents: {\n                content,\n                type,\n            },\n        };\n        return this.hostRuntime.submitFn(container_definitions_1.MessageType.Operation, envelope);\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n}\nexports.ComponentRuntime = ComponentRuntime;\n//# sourceMappingURL=componentRuntime.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ComponentStorageService {\n    constructor(storageService, blobs) {\n        this.storageService = storageService;\n        this.blobs = blobs;\n    }\n    get repositoryUrl() {\n        return this.storageService.repositoryUrl;\n    }\n    // TODO Will a subcomponent ever need this? Or we can probably restrict the ref to itself\n    getSnapshotTree(version) {\n        return this.storageService.getSnapshotTree(version);\n    }\n    getVersions(sha, count) {\n        return this.storageService.getVersions(sha, count);\n    }\n    getContent(version, path) {\n        return this.storageService.getContent(version, path);\n    }\n    read(sha) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.blobs.has(sha)) {\n                return this.blobs.get(sha);\n            }\n            return this.storageService.read(sha);\n        });\n    }\n    // TODO the write as well potentially doesn't seem necessary\n    write(root, parents, message, ref) {\n        return this.storageService.write(root, parents, message, ref);\n    }\n    createBlob(file) {\n        return this.storageService.createBlob(file);\n    }\n    getRawUrl(sha) {\n        return this.storageService.getRawUrl(sha);\n    }\n}\nexports.ComponentStorageService = ComponentStorageService;\n//# sourceMappingURL=componentStorageService.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"./debug\");\nexports.QuorumKey = \"leader\";\nclass LeaderElector extends events_1.EventEmitter {\n    constructor(quorum, clientId) {\n        super();\n        this.quorum = quorum;\n        this.clientId = clientId;\n        this.attachQuorumListeners();\n    }\n    proposeLeadership() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.quorum.propose(exports.QuorumKey, this.clientId);\n        });\n    }\n    getLeader() {\n        return this.leader;\n    }\n    attachQuorumListeners() {\n        this.quorum.on(\"approveProposal\", (sequenceNumber, key, value) => {\n            if (key === exports.QuorumKey) {\n                this.leader = value;\n                this.emit(\"newLeader\", this.leader);\n            }\n        });\n        this.quorum.on(\"addProposal\", (proposal) => {\n            if (proposal.key === exports.QuorumKey) {\n                if (this.leader !== undefined) {\n                    proposal.reject();\n                }\n            }\n        });\n        this.quorum.on(\"removeMember\", (removedClientId) => {\n            if (this.leader === undefined || removedClientId === this.leader) {\n                this.leader = undefined;\n                this.emit(\"leaderLeft\", removedClientId);\n            }\n            else {\n                this.emit(\"memberLeft\", removedClientId);\n            }\n        });\n        this.quorum.on(\"rejectProposal\", (sequenceNumber, key, value) => {\n            // Use of 'any' in template literal should be as safe as (\"\" + value) coercion.\n            // tslint:disable-next-line:no-unsafe-any\n            debug_1.debug(`Proposal rejected @${sequenceNumber}. ${key}:${value}`);\n        });\n    }\n}\nexports.LeaderElector = LeaderElector;\n//# sourceMappingURL=leaderElection.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\n// For a given list of connected clients and tasks to run, this function calculates need for local & remote help.\n// Right now only one client (aka leader) is allowed to run tasks and ask for local and remote.\n// To become completely distributed, each client should take into account other client permissions\n// and calculate help list. Then each client will pick up work independently and only leader will\n// ask for help.\n// TODO: Make this run on all clients once services are hardened better.\nfunction analyzeTasks(runnerClientId, clients, tasks) {\n    const robotClients = [...clients].filter((client) => isRobot(client[1]));\n    const handledTasks = robotClients.map((robot) => robot[1].client.type);\n    const unhandledTasks = tasks.filter((task) => handledTasks.indexOf(task) === -1);\n    if (unhandledTasks.length > 0) {\n        const runnerClient = clients.get(runnerClientId);\n        /* tslint:disable:strict-boolean-expressions */\n        const permission = runnerClient.client && runnerClient.client.permission ? runnerClient.client.permission : [];\n        const allowedTasks = unhandledTasks.filter((task) => permission && permission.indexOf(task) !== -1);\n        const robotNeeded = unhandledTasks.filter((task) => permission && permission.indexOf(task) === -1);\n        return {\n            browser: allowedTasks,\n            robot: robotNeeded,\n        };\n    }\n}\nexports.analyzeTasks = analyzeTasks;\nfunction getLeaderCandidate(clients) {\n    const browserClients = [...clients].filter((client) => !isRobot(client[1]));\n    if (browserClients.length > 0) {\n        const candidate = browserClients.reduce((prev, curr) => {\n            return prev[1].sequenceNumber < curr[1].sequenceNumber ? prev : curr;\n        });\n        return candidate[0];\n    }\n}\nexports.getLeaderCandidate = getLeaderCandidate;\nfunction isRobot(client) {\n    return client.client && client.client.type && client.client.type !== container_definitions_1.Browser;\n}\n//# sourceMappingURL=taskAnalyzer.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nclass DefinitionGuide extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.counter = 0;\n        this.dts = \"\";\n        setInterval(() => {\n            let dts = \"declare class Facts {\\n\";\n            for (let i = 0; i < this.counter; i++) {\n                dts += `    static next${i}(): string;\\n`;\n            }\n            dts += \"}\";\n            this.dts = dts;\n            this.counter++;\n            this.emit(\"definitionsChanged\");\n        }, 5000);\n    }\n    getDefinition() {\n        return this.dts;\n    }\n}\nclass WebPlatform extends events_1.EventEmitter {\n    constructor(div) {\n        super();\n        this.div = div;\n        this.definitions = new DefinitionGuide();\n    }\n    queryInterface(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (id) {\n                case \"dom\":\n                    return document;\n                case \"div\":\n                    return this.div;\n                case \"dts\":\n                    return this.definitions;\n                default:\n                    return null;\n            }\n        });\n    }\n    // Temporary measure to indicate the UI changed\n    update() {\n        this.emit(\"update\");\n    }\n    detach() {\n        return;\n    }\n}\nexports.WebPlatform = WebPlatform;\nclass WebPlatformFactory {\n    constructor(div) {\n        this.div = div;\n    }\n    create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new WebPlatform(this.div);\n        });\n    }\n}\nexports.WebPlatformFactory = WebPlatformFactory;\n//# sourceMappingURL=webPlatform.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\nconst utils_1 = require(\"@prague/utils\");\nconst assert = require(\"assert\");\nconst events_1 = require(\"events\");\nconst channelDeltaConnection_1 = require(\"./channelDeltaConnection\");\nconst channelStorageService_1 = require(\"./channelStorageService\");\nconst localChannelStorageService_1 = require(\"./localChannelStorageService\");\nclass ServicePlatform extends events_1.EventEmitter {\n    constructor(services) {\n        super();\n        this.qi = new Map(services);\n    }\n    queryInterface(id) {\n        return this.qi.get(id) || Promise.reject(`queryInterface() failed - Unknown id '${id}'.`);\n    }\n    detach() {\n        return;\n    }\n}\n/**\n * Base component class\n */\nclass ComponentHost extends events_1.EventEmitter {\n    // tslint:enable-next-line:variable-name\n    constructor(componentRuntime, tenantId, documentId, id, parentBranch, existing, options, blobManager, deltaManager, quorum, chaincode, storageService, snapshotFn, closeFn) {\n        super();\n        this.componentRuntime = componentRuntime;\n        this.tenantId = tenantId;\n        this.documentId = documentId;\n        this.id = id;\n        this.parentBranch = parentBranch;\n        this.existing = existing;\n        this.options = options;\n        this.blobManager = blobManager;\n        this.deltaManager = deltaManager;\n        this.quorum = quorum;\n        this.chaincode = chaincode;\n        this.storageService = storageService;\n        this.snapshotFn = snapshotFn;\n        this.closeFn = closeFn;\n        this.channels = new Map();\n        this.channelsDeferred = new Map();\n        this.closed = false;\n        this.pendingAttach = new Map();\n    }\n    static LoadFromSnapshot(componentRuntime, chaincode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tree = componentRuntime.baseSnapshot;\n            const runtime = new ComponentHost(componentRuntime, componentRuntime.tenantId, componentRuntime.documentId, componentRuntime.id, componentRuntime.parentBranch, componentRuntime.existing, componentRuntime.options, componentRuntime.blobManager, componentRuntime.deltaManager, componentRuntime.getQuorum(), chaincode, componentRuntime.storage, componentRuntime.snapshotFn, componentRuntime.closeFn);\n            // Must always receive the component type inside of the attributes\n            if (tree && tree.trees) {\n                Object.keys(tree.trees).forEach((path) => {\n                    // Reserve space for the channel\n                    runtime.reserve(path);\n                });\n                /* tslint:disable:promise-function-async */\n                const loadSnapshotsP = Object.keys(tree.trees).map((path) => {\n                    return runtime.loadSnapshotChannel(path, tree.trees[path], componentRuntime.storage, componentRuntime.branch);\n                });\n                yield Promise.all(loadSnapshotsP);\n            }\n            // Start the runtime\n            yield runtime.start();\n            return runtime;\n        });\n    }\n    get connected() {\n        return this.componentRuntime.connected;\n    }\n    // Interface used to access the runtime code\n    get platform() {\n        return this._platform;\n    }\n    get clientId() {\n        return this.componentRuntime.clientId;\n    }\n    createAndAttachComponent(id, pkg) {\n        return this.componentRuntime.createAndAttachComponent(id, pkg);\n    }\n    getComponent(id, wait) {\n        return this.componentRuntime.getComponent(id, wait);\n    }\n    /**\n     * Opens the component with the given 'id'.  Once the component is retrieved, it is attached\n     * with the given list of services.\n     */\n    openComponent(id, wait, services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runtime = yield this.componentRuntime.getComponent(id, wait);\n            const platform = yield runtime.attach(new ServicePlatform(services));\n            return platform.queryInterface(\"component\");\n        });\n    }\n    request(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = request.url.substr(1);\n            const value = yield this.getChannel(id);\n            return { mimeType: \"prague/dataType\", status: 200, value };\n        });\n    }\n    getChannel(id) {\n        this.verifyNotClosed();\n        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist\n        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if\n        // it doesn't exist\n        if (!this.channelsDeferred.has(id)) {\n            this.channelsDeferred.set(id, new utils_1.Deferred());\n        }\n        return this.channelsDeferred.get(id).promise;\n    }\n    createChannel(id, type) {\n        this.verifyNotClosed();\n        const extension = this.chaincode.getModule(type);\n        const channel = extension.create(this, id);\n        this.channels.set(id, { baseSha: null, object: channel, connection: null, storage: null });\n        if (this.channelsDeferred.has(id)) {\n            this.channelsDeferred.get(id).resolve(channel);\n        }\n        else {\n            const deferred = new utils_1.Deferred();\n            deferred.resolve(channel);\n            this.channelsDeferred.set(id, deferred);\n        }\n        return channel;\n    }\n    attachChannel(channel) {\n        this.verifyNotClosed();\n        // Get the object snapshot and include it in the initial attach\n        const snapshot = channel.snapshot();\n        const message = {\n            id: channel.id,\n            snapshot,\n            type: channel.type,\n        };\n        this.pendingAttach.set(channel.id, message);\n        this.submit(container_definitions_1.MessageType.Attach, message);\n        // Store a reference to the object in our list of objects and then get the services\n        // used to attach it to the stream\n        const services = this.getObjectServices(channel.id, null, this.storageService);\n        const entry = this.channels.get(channel.id);\n        assert.equal(entry.object, channel);\n        entry.connection = services.deltaConnection;\n        entry.storage = services.objectStorage;\n        return services;\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            this._platform = yield this.chaincode.run(this, null);\n        });\n    }\n    changeConnectionState(value, clientId) {\n        this.verifyNotClosed();\n        // Resend all pending attach messages prior to notifying clients\n        if (value === container_definitions_1.ConnectionState.Connected) {\n            for (const [, message] of this.pendingAttach) {\n                this.submit(container_definitions_1.MessageType.Attach, message);\n            }\n        }\n        for (const [, object] of this.channels) {\n            if (object.connection) {\n                object.connection.setConnectionState(value);\n            }\n        }\n        if (value === container_definitions_1.ConnectionState.Connected) {\n            this.emit(\"connected\", clientId);\n        }\n    }\n    getQuorum() {\n        this.verifyNotClosed();\n        return this.quorum;\n    }\n    snapshot(message) {\n        this.verifyNotClosed();\n        return this.snapshotFn(message);\n    }\n    save(tag) {\n        this.verifyNotClosed();\n        this.submit(container_definitions_1.MessageType.Save, tag);\n    }\n    uploadBlob(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            const sha = utils_1.gitHashFile(file.content);\n            file.sha = sha;\n            file.url = this.storageService.getRawUrl(sha);\n            yield this.blobManager.createBlob(file);\n            this.submit(container_definitions_1.MessageType.BlobUploaded, yield this.blobManager.createBlob(file));\n            return file;\n        });\n    }\n    getBlob(sha) {\n        this.verifyNotClosed();\n        return this.blobManager.getBlob(sha);\n    }\n    getBlobMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.blobManager.getBlobMetadata();\n        });\n    }\n    stop() {\n        this.verifyNotClosed();\n        this.closed = true;\n        return this.snapshotInternal();\n    }\n    close() {\n        this.closeFn();\n    }\n    prepare(message, local) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (message.type) {\n                case container_definitions_1.MessageType.Attach:\n                    return this.prepareAttach(message, local);\n                case container_definitions_1.MessageType.Operation:\n                    return this.prepareOp(message, local);\n                default:\n                    return;\n            }\n        });\n    }\n    process(message, local, context) {\n        let target = null;\n        switch (message.type) {\n            case container_definitions_1.MessageType.Attach:\n                target = this.processAttach(message, local, context);\n                break;\n            case container_definitions_1.MessageType.Operation:\n                target = this.processOp(message, local, context);\n                break;\n            default:\n        }\n        this.emit(\"op\", message, target);\n    }\n    updateMinSequenceNumber(msn) {\n        for (const [, object] of this.channels) {\n            if (!object.object.isLocal()) {\n                object.connection.updateMinSequenceNumber(msn);\n            }\n        }\n    }\n    snapshotInternal() {\n        const entries = new Array();\n        this.updateMinSequenceNumber(this.deltaManager.minimumSequenceNumber);\n        // Craft the .attributes file for each distributed object\n        for (const [objectId, object] of this.channels) {\n            // If the object isn't local - and we have received the sequenced op creating the object (i.e. it has a\n            // base mapping) - then we go ahead and snapshot\n            if (!object.object.isLocal()) {\n                const snapshot = object.object.snapshot();\n                // Add in the object attributes to the returned tree\n                const objectAttributes = {\n                    type: object.object.type,\n                };\n                snapshot.entries.push({\n                    mode: container_definitions_1.FileMode.File,\n                    path: \".attributes\",\n                    type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob],\n                    value: {\n                        contents: JSON.stringify(objectAttributes),\n                        encoding: \"utf-8\",\n                    },\n                });\n                // If baseSha exists then the previous snapshot is still valid\n                if (object.baseSha) {\n                    snapshot.sha = object.baseSha;\n                }\n                // And then store the tree\n                entries.push({\n                    mode: container_definitions_1.FileMode.Directory,\n                    path: objectId,\n                    type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Tree],\n                    value: snapshot,\n                });\n            }\n        }\n        return entries;\n    }\n    submitMessage(type, content) {\n        this.submit(type, content);\n    }\n    submit(type, content) {\n        this.verifyNotClosed();\n        return this.componentRuntime.submitMessage(type, content);\n    }\n    reserve(id) {\n        if (!this.channelsDeferred.has(id)) {\n            this.channelsDeferred.set(id, new utils_1.Deferred());\n        }\n    }\n    prepareOp(message, local) {\n        this.verifyNotClosed();\n        const envelope = message.contents;\n        const objectDetails = this.channels.get(envelope.address);\n        assert(objectDetails);\n        const transformed = {\n            clientId: message.clientId,\n            clientSequenceNumber: message.clientSequenceNumber,\n            contents: envelope.contents,\n            metadata: message.metadata,\n            minimumSequenceNumber: message.minimumSequenceNumber,\n            origin: message.origin,\n            referenceSequenceNumber: message.referenceSequenceNumber,\n            sequenceNumber: message.sequenceNumber,\n            timestamp: message.timestamp,\n            traces: message.traces,\n            type: message.type,\n        };\n        return objectDetails.connection.prepare(transformed, local);\n    }\n    processOp(message, local, context) {\n        this.verifyNotClosed();\n        const envelope = message.contents;\n        const objectDetails = this.channels.get(envelope.address);\n        assert(objectDetails);\n        // Clear base sha since the channel is now dirty\n        objectDetails.baseSha = null;\n        const transformed = {\n            clientId: message.clientId,\n            clientSequenceNumber: message.clientSequenceNumber,\n            contents: envelope.contents,\n            metadata: message.metadata,\n            minimumSequenceNumber: message.minimumSequenceNumber,\n            origin: message.origin,\n            referenceSequenceNumber: message.referenceSequenceNumber,\n            sequenceNumber: message.sequenceNumber,\n            timestamp: message.timestamp,\n            traces: message.traces,\n            type: message.type,\n        };\n        objectDetails.connection.process(transformed, local, context);\n        return objectDetails.object;\n    }\n    processAttach(message, local, context) {\n        this.verifyNotClosed();\n        const attachMessage = message.contents;\n        // If a non-local operation then go and create the object - otherwise mark it as officially attached.\n        if (local) {\n            assert(this.pendingAttach.has(attachMessage.id));\n            this.pendingAttach.delete(attachMessage.id);\n        }\n        else {\n            const channelState = context;\n            this.channels.set(channelState.object.id, channelState);\n            if (this.channelsDeferred.has(channelState.object.id)) {\n                this.channelsDeferred.get(channelState.object.id).resolve(channelState.object);\n            }\n            else {\n                const deferred = new utils_1.Deferred();\n                deferred.resolve(channelState.object);\n                this.channelsDeferred.set(channelState.object.id, deferred);\n            }\n        }\n        return this.channels.get(attachMessage.id).object;\n    }\n    prepareAttach(message, local) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.verifyNotClosed();\n            if (local) {\n                return;\n            }\n            const attachMessage = message.contents;\n            // create storage service that wraps the attach data\n            const localStorage = new localChannelStorageService_1.LocalChannelStorageService(attachMessage.snapshot);\n            const connection = new channelDeltaConnection_1.ChannelDeltaConnection(attachMessage.id, this.componentRuntime.connectionState, (submitMessage) => {\n                const submitEnvelope = {\n                    address: attachMessage.id,\n                    contents: submitMessage,\n                };\n                return this.submit(container_definitions_1.MessageType.Operation, submitEnvelope);\n            });\n            const services = {\n                baseSha: null,\n                deltaConnection: connection,\n                objectStorage: localStorage,\n            };\n            const origin = message.origin ? message.origin.id : this.id;\n            const value = yield this.loadChannel(attachMessage.id, attachMessage.type, message.minimumSequenceNumber, services, origin);\n            return value;\n        });\n    }\n    loadSnapshotChannel(id, tree, storage, branch) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const channelAttributes = yield utils_1.readAndParse(storage, tree.blobs[\".attributes\"]);\n            const services = this.getObjectServices(id, tree, storage);\n            const channelDetails = yield this.loadChannel(id, channelAttributes.type, this.deltaManager.minimumSequenceNumber, services, branch);\n            assert(!this.channels.has(id));\n            this.channels.set(id, channelDetails);\n            this.channelsDeferred.get(id).resolve(channelDetails.object);\n        });\n    }\n    loadChannel(id, type, minSequenceNumber, services, originBranch) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Pass the transformedMessages - but the object really should be storing this\n            const extension = this.chaincode.getModule(type);\n            // TODO need to fix up the SN vs. MSN stuff here. If want to push messages to object also need\n            // to store the mappings from channel ID to doc ID.\n            const value = yield extension.load(this, id, minSequenceNumber, services, originBranch);\n            return {\n                baseSha: services.baseSha,\n                connection: services.deltaConnection,\n                object: value,\n                storage: services.objectStorage,\n            };\n        });\n    }\n    getObjectServices(id, tree, storage) {\n        const deltaConnection = new channelDeltaConnection_1.ChannelDeltaConnection(id, this.componentRuntime.connectionState, (message) => {\n            const envelope = { address: id, contents: message };\n            return this.submit(container_definitions_1.MessageType.Operation, envelope);\n        });\n        const objectStorage = new channelStorageService_1.ChannelStorageService(tree, storage);\n        return {\n            baseSha: tree ? tree.sha : null,\n            deltaConnection,\n            objectStorage,\n        };\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error(\"Runtime is closed\");\n        }\n    }\n}\nexports.ComponentHost = ComponentHost;\n//# sourceMappingURL=componentHost.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nclass ChannelDeltaConnection {\n    constructor(objectId, \n    // tslint:disable-next-line:variable-name\n    _state, submitFn) {\n        this.objectId = objectId;\n        this._state = _state;\n        this.submitFn = submitFn;\n    }\n    get state() {\n        return this._state;\n    }\n    attach(handler) {\n        /* tslint:disable:strict-boolean-expressions */\n        assert(!this.handler);\n        this.handler = handler;\n    }\n    setConnectionState(state) {\n        this._state = state;\n        this.handler.setConnectionState(state);\n    }\n    prepare(message, local) {\n        assert(this.handler);\n        return this.handler.prepare(message, local);\n    }\n    process(message, local, context) {\n        assert(this.handler);\n        this.handler.process(message, local, context);\n    }\n    updateMinSequenceNumber(value) {\n        assert(this.handler);\n        this.handler.minSequenceNumberChanged(value);\n    }\n    /**\n     * Send new messages to the server\n     */\n    submit(message) {\n        return this.submitFn(message);\n    }\n}\nexports.ChannelDeltaConnection = ChannelDeltaConnection;\n//# sourceMappingURL=channelDeltaConnection.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ChannelStorageService {\n    constructor(tree, storage) {\n        this.storage = storage;\n        this.flattenedTree = {};\n        // Create a map from paths to blobs\n        /* tslint:disable:strict-boolean-expressions */\n        if (tree) {\n            ChannelStorageService.flattenTree(\"\", tree, this.flattenedTree);\n        }\n    }\n    static flattenTree(base, tree, results) {\n        // tslint:disable-next-line:forin\n        for (const path in tree.trees) {\n            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);\n        }\n        // tslint:disable-next-line:forin\n        for (const blob in tree.blobs) {\n            results[`${base}${blob}`] = tree.blobs[blob];\n        }\n    }\n    /* tslint:disable:promise-function-async */\n    read(path) {\n        const sha = this.getShaForPath(path);\n        return this.storage.read(sha);\n    }\n    getShaForPath(path) {\n        return this.flattenedTree[path];\n    }\n}\nexports.ChannelStorageService = ChannelStorageService;\n//# sourceMappingURL=channelStorageService.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\nclass LocalChannelStorageService {\n    constructor(tree) {\n        this.tree = tree;\n    }\n    /* tslint:disable:promise-function-async */\n    read(path) {\n        const contents = this.readSync(path);\n        return contents !== undefined ? Promise.resolve(contents) : Promise.reject(\"Not found\");\n    }\n    /**\n     * Provides a synchronous access point to locally stored data\n     */\n    readSync(path) {\n        return this.readSyncInternal(path, this.tree);\n    }\n    readSyncInternal(path, tree) {\n        for (const entry of tree.entries) {\n            switch (entry.type) {\n                case container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob]:\n                    if (path === entry.path) {\n                        const blob = entry.value;\n                        return blob.encoding === \"utf-8\"\n                            ? new Buffer(blob.contents).toString(\"base64\")\n                            : blob.contents;\n                    }\n                    break;\n                case container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Tree]:\n                    if (path.indexOf(entry.path) === 0) {\n                        return this.readSyncInternal(path.substr(entry.path.length + 1), entry.value);\n                    }\n                    break;\n                default:\n            }\n        }\n        return undefined;\n    }\n}\nexports.LocalChannelStorageService = LocalChannelStorageService;\n//# sourceMappingURL=localChannelStorageService.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst container_definitions_1 = require(\"@prague/container-definitions\");\nconst assert = require(\"assert\");\nconst Deque = require(\"double-ended-queue\");\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"./debug\");\nconst valueType_1 = require(\"./valueType\");\nclass SharedObject extends events_1.EventEmitter {\n    constructor(id, runtime, type) {\n        super();\n        this.id = id;\n        this.runtime = runtime;\n        this.type = type;\n        // tslint:disable-next-line:variable-name\n        this.__sharedObject__ = true;\n        // tslint:disable-next-line:variable-name private fields exposed via getters\n        this._state = container_definitions_1.ConnectionState.Disconnected;\n        // Locally applied operations not yet ACK'd by the server\n        this.pendingOps = new Deque();\n    }\n    get state() {\n        return this._state;\n    }\n    toJSON() {\n        return {\n            type: valueType_1.ValueType[valueType_1.ValueType.Shared],\n            value: this.id,\n        };\n    }\n    /**\n     * A shared object, after construction, can either be loaded in the case that it is already part of\n     * a shared document. Or later attached if it is being newly added.\n     */\n    load(minimumSequenceNumber, headerOrigin, services) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.services = services;\n            yield this.loadCore(minimumSequenceNumber, headerOrigin, services.objectStorage);\n            this.attachDeltaHandler();\n        });\n    }\n    /**\n     * Initializes the object as a local, non-shared object. This object can become shared after\n     * it is attached to the document.\n     */\n    initializeLocal() {\n        this.initializeLocalCore();\n    }\n    /**\n     * Attaches the given shared object to its containing document\n     */\n    attach() {\n        if (!this.isLocal()) {\n            return this;\n        }\n        // Allow derived classes to perform custom processing prior to attaching this object\n        this.attachCore();\n        // Notify the document of the attachment\n        this.services = this.runtime.attachChannel(this);\n        this.attachDeltaHandler();\n        return this;\n    }\n    /**\n     * Returns whether the given shared object is local\n     */\n    isLocal() {\n        return !this.services;\n    }\n    /* tslint:disable:no-unnecessary-override */\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    /**\n     * Processes a message by the local client\n     */\n    submitLocalMessage(content) {\n        assert(!this.isLocal());\n        // Send if we are connected - otherwise just add to the sent list\n        let clientSequenceNumber = -1;\n        if (this.state === container_definitions_1.ConnectionState.Connected) {\n            clientSequenceNumber = this.services.deltaConnection.submit(content);\n        }\n        else {\n            debug_1.debug(`${this.id} Not fully connected - adding to pending list`, content);\n            // Store the message for when it is ACKed and then submit to the server if connected\n        }\n        this.pendingOps.push({ clientSequenceNumber, content });\n        return clientSequenceNumber;\n    }\n    attachDeltaHandler() {\n        this.services.deltaConnection.attach({\n            minSequenceNumberChanged: (value) => {\n                this.processMinSequenceNumberChanged(value);\n            },\n            prepare: (message, local) => {\n                return this.prepare(message, local);\n            },\n            process: (message, local, context) => {\n                this.process(message, local, context);\n            },\n            setConnectionState: (state) => {\n                this.setConnectionState(state);\n            },\n        });\n        // Trigger initial state\n        this.setConnectionState(this.services.deltaConnection.state);\n    }\n    prepare(message, local) {\n        return this.prepareCore(message, local);\n    }\n    setConnectionState(state) {\n        // Should I change the state at the end? So that we *can't* send new stuff before we send old?\n        this._state = state;\n        switch (state) {\n            case container_definitions_1.ConnectionState.Disconnected:\n                // Things that are true now...\n                // - if we had a connection we can no longer send messages over it\n                // - if we had outbound messages some may or may not be ACK'd. Won't know until next message\n                //\n                // - nack could get a new msn - but might as well do it in the join?\n                this.onDisconnect();\n                break;\n            case container_definitions_1.ConnectionState.Connecting:\n                // Things that are now true...\n                // - we will begin to receive inbound messages\n                // - we know what our new client id is.\n                // - still not safe to send messages\n                // While connecting we are still ticking off the previous messages\n                debug_1.debug(`${this.id} is now connecting`);\n                break;\n            case container_definitions_1.ConnectionState.Connected:\n                // Extract all un-ack'd payload operation\n                const pendingOps = this.pendingOps.toArray().map((value) => value.content);\n                this.pendingOps.clear();\n                // And now we are fully connected\n                // - we have a client ID\n                // - we are caught up enough to attempt to send messages\n                this.onConnect(pendingOps);\n                break;\n            default:\n                assert.ok(false, `Unknown ConnectionState ${state}`);\n        }\n    }\n    /**\n     * Handles a message being received from the remote delta server\n     */\n    process(message, local, context) {\n        if (message.type === container_definitions_1.MessageType.Operation && local) {\n            // disconnected ops should never be processed. They should have been fully sent on connected\n            assert(this.pendingOps.length === 0 || this.pendingOps.peekFront().clientSequenceNumber !== -1, `process for disconnected op ${this.pendingOps.peekFront().clientSequenceNumber}`);\n            // One of our messages was sequenced. We can remove it from the local message list. Given these arrive\n            // in order we only need to check the beginning of the local list.\n            if (this.pendingOps.length > 0 &&\n                this.pendingOps.peekFront().clientSequenceNumber === message.clientSequenceNumber) {\n                this.pendingOps.shift();\n                if (this.pendingOps.length === 0) {\n                    this.emit(\"processed\");\n                }\n            }\n            else {\n                debug_1.debug(`Duplicate ack received ${message.clientSequenceNumber}`);\n            }\n        }\n        this.emit(\"pre-op\", message, local);\n        this.processCore(message, local, context);\n        this.emit(\"op\", message, local);\n    }\n}\nexports.SharedObject = SharedObject;\n//# sourceMappingURL=sharedObject.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst registerDebug = require(\"debug\");\nexports.debug = registerDebug(\"prague:api-definitions\");\n//# sourceMappingURL=debug.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class that contains a collection of collaboration extensions\n */\nclass Registry {\n    constructor() {\n        this.extensions = [];\n        this.extensionsMap = {};\n    }\n    /**\n     * Registers a new extension\n     * @param extension The extension to register\n     */\n    register(extension) {\n        this.extensions.push(extension);\n        this.extensionsMap[extension.type] = extension;\n    }\n    /**\n     * Retrieves the extension with the given id\n     * @param id ID for the extension to retrieve\n     */\n    getExtension(type) {\n        if (!(type in this.extensionsMap)) {\n            throw new Error(\"Extension not found\");\n        }\n        return this.extensionsMap[type];\n    }\n}\nexports.Registry = Registry;\n//# sourceMappingURL=extension.js.map","const MaxBatchSize = 100;\nexport class BatchManager {\n    constructor(process) {\n        this.process = process;\n        this.pendingWork = new Map();\n    }\n    add(id, work) {\n        if (!this.pendingWork.has(id)) {\n            this.pendingWork.set(id, []);\n        }\n        this.pendingWork.get(id)\n            .push(work);\n        if (this.pendingWork.get(id).length >= MaxBatchSize) {\n            clearTimeout(this.pendingTimer);\n            this.pendingTimer = undefined;\n            this.startWork();\n        }\n        else if (this.pendingTimer === undefined) {\n            this.pendingTimer = setTimeout(() => {\n                this.pendingTimer = undefined;\n                this.startWork();\n            }, 0);\n        }\n    }\n    /**\n     * Resolves once all pending work is complete\n     */\n    drain() {\n        this.startWork();\n    }\n    startWork() {\n        // Clear the internal flags first to avoid issues in case any of the pending work calls back into\n        // the batch manager. We could also do this with a second setImmediate call but avodiing in order\n        // to process the work quicker.\n        const pendingWork = this.pendingWork;\n        this.pendingWork = new Map();\n        // TODO log to influx how much pending work there is. We want to limit the size of a batch\n        for (const [id, batch] of pendingWork) {\n            this.process(id, batch);\n        }\n    }\n}\n//# sourceMappingURL=batchManager.js.map","// tslint:disable:no-bitwise\n// tslint:disable:no-increment-decrement\n// tslint:disable:no-parameter-reassignment\nexport const NumberComparer = {\n    compare: (a, b) => a - b,\n    min: Number.MIN_VALUE,\n};\nexport class Heap {\n    constructor(comp) {\n        this.comp = comp;\n        this.L = [{ value: comp.min, position: 0 }];\n    }\n    peek() {\n        return this.L[1];\n    }\n    get() {\n        this.swap(1, this.count());\n        const x = this.L.pop();\n        this.fixdown(1);\n        return x.value;\n    }\n    add(x) {\n        const node = { value: x, position: this.L.length };\n        this.L.push(node);\n        this.fixup(this.count());\n        return node;\n    }\n    /**\n     * Allows for heap to be updated after a node's value changes\n     */\n    update(node) {\n        const k = node.position;\n        if (this.isGreaterThanParent(k)) {\n            this.fixup(k);\n        }\n        else {\n            this.fixdown(k);\n        }\n    }\n    /**\n     * Removes the given node from the heap\n     */\n    remove(node) {\n        // Move the node we want to remove to the end of the array\n        const position = node.position;\n        this.swap(node.position, this.L.length - 1);\n        this.L.splice(this.L.length - 1);\n        // Update the swapped node assuming we didn't remove the end of the list\n        if (position !== this.L.length) {\n            this.update(this.L[position]);\n        }\n    }\n    count() {\n        return this.L.length - 1;\n    }\n    fixup(k) {\n        while (this.isGreaterThanParent(k)) {\n            const parent = k >> 1;\n            this.swap(k, parent);\n            k = parent;\n        }\n    }\n    isGreaterThanParent(k) {\n        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);\n    }\n    fixdown(k) {\n        while ((k << 1) <= this.count()) {\n            let j = k << 1;\n            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {\n                j++;\n            }\n            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {\n                break;\n            }\n            this.swap(k, j);\n            k = j;\n        }\n    }\n    swap(k, j) {\n        const tmp = this.L[k];\n        this.L[k] = this.L[j];\n        this.L[k].position = k;\n        this.L[j] = tmp;\n        this.L[j].position = j;\n    }\n}\n//# sourceMappingURL=heap.js.map","import * as assert from \"assert\";\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nexport class Deferred {\n    constructor() {\n        /* tslint:disable:promise-must-complete */\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     */\n    resolve(value) {\n        this.res(value);\n    }\n    /**\n     * Rejects the promise\n     */\n    reject(error) {\n        this.rej(error);\n    }\n}\n/**\n * Helper function that asserts that the given promise only resolves\n */\n/* tslint:disable:promise-function-async */\nexport function assertNotRejected(promise) {\n    // Assert that the given promise only resolves\n    promise.catch((error) => {\n        assert.ok(false);\n    });\n    return promise;\n}\n//# sourceMappingURL=promises.js.map","import * as assert from \"assert\";\n// tslint:disable:no-var-requires\n// tslint:disable-next-line:no-submodule-imports\nconst cloneDeep = require(\"lodash/cloneDeep\");\n/**\n * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary\n * is continuous and always maps to a single value in secondary above the base value. The range\n * defines an increasing step function.\n */\nexport class RangeTracker {\n    get base() {\n        return this.ranges[0].primary;\n    }\n    get primaryHead() {\n        return this.lastPrimary;\n    }\n    get secondaryHead() {\n        return this.lastSecondary;\n    }\n    constructor(primary, secondary) {\n        if (typeof primary === \"number\") {\n            this.ranges = [{ length: 0, primary, secondary }];\n            this.lastPrimary = primary;\n            this.lastSecondary = secondary;\n        }\n        else {\n            /* tslint:disable:no-unsafe-any */\n            this.ranges = cloneDeep(primary.ranges);\n            this.lastPrimary = primary.lastPrimary;\n            this.lastSecondary = primary.lastSecondary;\n        }\n    }\n    /**\n     * Returns a serialized form of the RangeTracker\n     */\n    serialize() {\n        return {\n            lastPrimary: this.lastPrimary,\n            lastSecondary: this.lastSecondary,\n            ranges: cloneDeep(this.ranges),\n        };\n    }\n    // primary is time - secondary is the MSN\n    add(primary, secondary) {\n        // Both values must continuously be increasing - we won't always track the last value we saw so we do so\n        // below to check invariants\n        assert(primary >= this.lastPrimary);\n        assert(secondary >= this.lastSecondary);\n        this.lastPrimary = primary;\n        this.lastSecondary = secondary;\n        // Get quicker references to the head of the range\n        const head = this.ranges[this.ranges.length - 1];\n        const primaryHead = head.primary + head.length;\n        const secondaryHead = head.secondary + head.length;\n        // Same secondary indicates this is not a true inflection point - we can ignore it\n        if (secondary === secondaryHead) {\n            return;\n        }\n        // New secondary - need to update the ranges\n        if (primary === primaryHead) {\n            // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to\n            // preserve 1:N since you can only lookup from the primary to a secondary\n            if (head.length === 0) {\n                // No range represented - we can simply update secondary with the overwritten value\n                head.secondary = secondary;\n            }\n            else {\n                // The values in the range before this one are valid - but we need to create a new one for this update\n                // tslint:disable-next-line:no-increment-decrement\n                head.length--;\n                this.ranges.push({ length: 0, primary, secondary });\n            }\n        }\n        else {\n            if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {\n                // extend the length if both increase by the same amount\n                // tslint:disable-next-line:no-increment-decrement\n                head.length++;\n            }\n            else {\n                // Insert a new node\n                this.ranges.push({ length: 0, primary, secondary });\n            }\n        }\n    }\n    get(primary) {\n        assert(primary >= this.ranges[0].primary);\n        // Find the first range where the starting position is greater than the primary. Our target range is\n        // the one before it.\n        let index = 1;\n        // tslint:disable-next-line:no-increment-decrement\n        for (; index < this.ranges.length; index++) {\n            if (primary < this.ranges[index].primary) {\n                break;\n            }\n        }\n        assert(primary >= this.ranges[index - 1].primary);\n        // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest\n        // stored secondary value to use.\n        const closestRange = this.ranges[index - 1];\n        return Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary;\n    }\n    updateBase(primary) {\n        assert(primary >= this.ranges[0].primary);\n        // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the\n        // previous index by definition (since it's less than the current index's primary but greather than the\n        // previous index's primary) and we know primary must be greater than the base.\n        let index = 1;\n        // tslint:disable-next-line:no-increment-decrement\n        for (; index < this.ranges.length; index++) {\n            if (primary < this.ranges[index].primary) {\n                break;\n            }\n        }\n        assert(primary >= this.ranges[index - 1].primary);\n        // Update the last range values\n        const range = this.ranges[index - 1];\n        const delta = primary - range.primary;\n        range.secondary = range.secondary + Math.min(delta, range.length);\n        range.length = Math.max(range.length - delta, 0);\n        range.primary = primary;\n        // And remove unnecessary ranges\n        this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;\n        // assert that the lowest value is now the input to this method\n        assert.equal(primary, this.ranges[0].primary);\n    }\n}\n//# sourceMappingURL=rangeTracker.js.map","// A rate limiter to make sure that a client can only request help for one task within a time window.\nexport class RateLimitter {\n    constructor(windowMSec) {\n        this.windowMSec = windowMSec;\n        this.requestMap = new Map();\n    }\n    filter(clientId, messages) {\n        const approvedList = [];\n        const currentTime = Date.now();\n        for (const message of messages) {\n            const key = `${clientId}/${message}`;\n            if (!this.requestMap.has(key)) {\n                this.requestMap.set(key, currentTime);\n                approvedList.push(message);\n            }\n            else if (this.requestMap.get(key) + this.windowMSec > currentTime) {\n                continue;\n            }\n            else {\n                this.requestMap.set(key, currentTime);\n                approvedList.push(message);\n            }\n        }\n        return approvedList;\n    }\n}\n//# sourceMappingURL=rateLimitter.js.map","export function safelyParseJSON(json) {\n    let parsed;\n    try {\n        parsed = JSON.parse(json);\n    }\n    catch (e) {\n        //\n    }\n    return parsed;\n}\n//# sourceMappingURL=safeParser.js.map","import { MessageType } from \"@prague/container-definitions\";\nexport function isSystemType(type) {\n    return (type === MessageType.RemoteHelp ||\n        type === MessageType.Integrate ||\n        type === MessageType.ClientJoin ||\n        type === MessageType.ClientLeave ||\n        type === MessageType.Fork);\n}\n//# sourceMappingURL=utils.js.map","export * from \"./batchManager\";\nexport * from \"./blobs\";\nexport * from \"./heap\";\nexport * from \"./promises\";\nexport * from \"./rangeTracker\";\nexport * from \"./rateLimitter\";\nexport * from \"./safeParser\";\nexport * from \"./utils\";\n//# sourceMappingURL=index.js.map","const MaxBatchSize = 100;\nexport class BatchManager {\n    constructor(process) {\n        this.process = process;\n        this.pendingWork = new Map();\n    }\n    add(id, work) {\n        if (!this.pendingWork.has(id)) {\n            this.pendingWork.set(id, []);\n        }\n        this.pendingWork.get(id)\n            .push(work);\n        if (this.pendingWork.get(id).length >= MaxBatchSize) {\n            clearTimeout(this.pendingTimer);\n            this.pendingTimer = undefined;\n            this.startWork();\n        }\n        else if (this.pendingTimer === undefined) {\n            this.pendingTimer = setTimeout(() => {\n                this.pendingTimer = undefined;\n                this.startWork();\n            }, 0);\n        }\n    }\n    /**\n     * Resolves once all pending work is complete\n     */\n    drain() {\n        this.startWork();\n    }\n    startWork() {\n        // Clear the internal flags first to avoid issues in case any of the pending work calls back into\n        // the batch manager. We could also do this with a second setImmediate call but avodiing in order\n        // to process the work quicker.\n        const pendingWork = this.pendingWork;\n        this.pendingWork = new Map();\n        // TODO log to influx how much pending work there is. We want to limit the size of a batch\n        for (const [id, batch] of pendingWork) {\n            this.process(id, batch);\n        }\n    }\n}\n//# sourceMappingURL=batchManager.js.map","// tslint:disable:no-bitwise\n// tslint:disable:no-increment-decrement\n// tslint:disable:no-parameter-reassignment\nexport const NumberComparer = {\n    compare: (a, b) => a - b,\n    min: Number.MIN_VALUE,\n};\nexport class Heap {\n    constructor(comp) {\n        this.comp = comp;\n        this.L = [{ value: comp.min, position: 0 }];\n    }\n    peek() {\n        return this.L[1];\n    }\n    get() {\n        this.swap(1, this.count());\n        const x = this.L.pop();\n        this.fixdown(1);\n        return x.value;\n    }\n    add(x) {\n        const node = { value: x, position: this.L.length };\n        this.L.push(node);\n        this.fixup(this.count());\n        return node;\n    }\n    /**\n     * Allows for heap to be updated after a node's value changes\n     */\n    update(node) {\n        const k = node.position;\n        if (this.isGreaterThanParent(k)) {\n            this.fixup(k);\n        }\n        else {\n            this.fixdown(k);\n        }\n    }\n    /**\n     * Removes the given node from the heap\n     */\n    remove(node) {\n        // Move the node we want to remove to the end of the array\n        const position = node.position;\n        this.swap(node.position, this.L.length - 1);\n        this.L.splice(this.L.length - 1);\n        // Update the swapped node assuming we didn't remove the end of the list\n        if (position !== this.L.length) {\n            this.update(this.L[position]);\n        }\n    }\n    count() {\n        return this.L.length - 1;\n    }\n    fixup(k) {\n        while (this.isGreaterThanParent(k)) {\n            const parent = k >> 1;\n            this.swap(k, parent);\n            k = parent;\n        }\n    }\n    isGreaterThanParent(k) {\n        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);\n    }\n    fixdown(k) {\n        while ((k << 1) <= this.count()) {\n            let j = k << 1;\n            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {\n                j++;\n            }\n            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {\n                break;\n            }\n            this.swap(k, j);\n            k = j;\n        }\n    }\n    swap(k, j) {\n        const tmp = this.L[k];\n        this.L[k] = this.L[j];\n        this.L[k].position = k;\n        this.L[j] = tmp;\n        this.L[j].position = j;\n    }\n}\n//# sourceMappingURL=heap.js.map","import * as assert from \"assert\";\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nexport class Deferred {\n    constructor() {\n        /* tslint:disable:promise-must-complete */\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     */\n    resolve(value) {\n        this.res(value);\n    }\n    /**\n     * Rejects the promise\n     */\n    reject(error) {\n        this.rej(error);\n    }\n}\n/**\n * Helper function that asserts that the given promise only resolves\n */\n/* tslint:disable:promise-function-async */\nexport function assertNotRejected(promise) {\n    // Assert that the given promise only resolves\n    promise.catch((error) => {\n        assert.ok(false);\n    });\n    return promise;\n}\n//# sourceMappingURL=promises.js.map","import * as assert from \"assert\";\n// tslint:disable:no-var-requires\n// tslint:disable-next-line:no-submodule-imports\nconst cloneDeep = require(\"lodash/cloneDeep\");\n/**\n * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary\n * is continuous and always maps to a single value in secondary above the base value. The range\n * defines an increasing step function.\n */\nexport class RangeTracker {\n    get base() {\n        return this.ranges[0].primary;\n    }\n    get primaryHead() {\n        return this.lastPrimary;\n    }\n    get secondaryHead() {\n        return this.lastSecondary;\n    }\n    constructor(primary, secondary) {\n        if (typeof primary === \"number\") {\n            this.ranges = [{ length: 0, primary, secondary }];\n            this.lastPrimary = primary;\n            this.lastSecondary = secondary;\n        }\n        else {\n            /* tslint:disable:no-unsafe-any */\n            this.ranges = cloneDeep(primary.ranges);\n            this.lastPrimary = primary.lastPrimary;\n            this.lastSecondary = primary.lastSecondary;\n        }\n    }\n    /**\n     * Returns a serialized form of the RangeTracker\n     */\n    serialize() {\n        return {\n            lastPrimary: this.lastPrimary,\n            lastSecondary: this.lastSecondary,\n            ranges: cloneDeep(this.ranges),\n        };\n    }\n    // primary is time - secondary is the MSN\n    add(primary, secondary) {\n        // Both values must continuously be increasing - we won't always track the last value we saw so we do so\n        // below to check invariants\n        assert(primary >= this.lastPrimary);\n        assert(secondary >= this.lastSecondary);\n        this.lastPrimary = primary;\n        this.lastSecondary = secondary;\n        // Get quicker references to the head of the range\n        const head = this.ranges[this.ranges.length - 1];\n        const primaryHead = head.primary + head.length;\n        const secondaryHead = head.secondary + head.length;\n        // Same secondary indicates this is not a true inflection point - we can ignore it\n        if (secondary === secondaryHead) {\n            return;\n        }\n        // New secondary - need to update the ranges\n        if (primary === primaryHead) {\n            // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to\n            // preserve 1:N since you can only lookup from the primary to a secondary\n            if (head.length === 0) {\n                // No range represented - we can simply update secondary with the overwritten value\n                head.secondary = secondary;\n            }\n            else {\n                // The values in the range before this one are valid - but we need to create a new one for this update\n                // tslint:disable-next-line:no-increment-decrement\n                head.length--;\n                this.ranges.push({ length: 0, primary, secondary });\n            }\n        }\n        else {\n            if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {\n                // extend the length if both increase by the same amount\n                // tslint:disable-next-line:no-increment-decrement\n                head.length++;\n            }\n            else {\n                // Insert a new node\n                this.ranges.push({ length: 0, primary, secondary });\n            }\n        }\n    }\n    get(primary) {\n        assert(primary >= this.ranges[0].primary);\n        // Find the first range where the starting position is greater than the primary. Our target range is\n        // the one before it.\n        let index = 1;\n        // tslint:disable-next-line:no-increment-decrement\n        for (; index < this.ranges.length; index++) {\n            if (primary < this.ranges[index].primary) {\n                break;\n            }\n        }\n        assert(primary >= this.ranges[index - 1].primary);\n        // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest\n        // stored secondary value to use.\n        const closestRange = this.ranges[index - 1];\n        return Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary;\n    }\n    updateBase(primary) {\n        assert(primary >= this.ranges[0].primary);\n        // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the\n        // previous index by definition (since it's less than the current index's primary but greather than the\n        // previous index's primary) and we know primary must be greater than the base.\n        let index = 1;\n        // tslint:disable-next-line:no-increment-decrement\n        for (; index < this.ranges.length; index++) {\n            if (primary < this.ranges[index].primary) {\n                break;\n            }\n        }\n        assert(primary >= this.ranges[index - 1].primary);\n        // Update the last range values\n        const range = this.ranges[index - 1];\n        const delta = primary - range.primary;\n        range.secondary = range.secondary + Math.min(delta, range.length);\n        range.length = Math.max(range.length - delta, 0);\n        range.primary = primary;\n        // And remove unnecessary ranges\n        this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;\n        // assert that the lowest value is now the input to this method\n        assert.equal(primary, this.ranges[0].primary);\n    }\n}\n//# sourceMappingURL=rangeTracker.js.map","// A rate limiter to make sure that a client can only request help for one task within a time window.\nexport class RateLimitter {\n    constructor(windowMSec) {\n        this.windowMSec = windowMSec;\n        this.requestMap = new Map();\n    }\n    filter(clientId, messages) {\n        const approvedList = [];\n        const currentTime = Date.now();\n        for (const message of messages) {\n            const key = `${clientId}/${message}`;\n            if (!this.requestMap.has(key)) {\n                this.requestMap.set(key, currentTime);\n                approvedList.push(message);\n            }\n            else if (this.requestMap.get(key) + this.windowMSec > currentTime) {\n                continue;\n            }\n            else {\n                this.requestMap.set(key, currentTime);\n                approvedList.push(message);\n            }\n        }\n        return approvedList;\n    }\n}\n//# sourceMappingURL=rateLimitter.js.map","export function safelyParseJSON(json) {\n    let parsed;\n    try {\n        parsed = JSON.parse(json);\n    }\n    catch (e) {\n        //\n    }\n    return parsed;\n}\n//# sourceMappingURL=safeParser.js.map","import { MessageType } from \"@prague/container-definitions\";\nexport function isSystemType(type) {\n    return (type === MessageType.RemoteHelp ||\n        type === MessageType.Integrate ||\n        type === MessageType.ClientJoin ||\n        type === MessageType.ClientLeave ||\n        type === MessageType.Fork);\n}\n//# sourceMappingURL=utils.js.map","export * from \"./batchManager\";\nexport * from \"./blobs\";\nexport * from \"./heap\";\nexport * from \"./promises\";\nexport * from \"./rangeTracker\";\nexport * from \"./rateLimitter\";\nexport * from \"./safeParser\";\nexport * from \"./utils\";\n//# sourceMappingURL=index.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class DistributedSetFactory {\n    load(emitter, raw) {\n        return new DistributedSet(emitter, raw || []);\n    }\n    store(value) {\n        return value.entries();\n    }\n}\nexport class DistributedSet {\n    constructor(emitter, value) {\n        this.emitter = emitter;\n        /**\n         * Can be set to register an event listener for when values are added or deleted from the set.\n         */\n        this.onAdd = (value) => { return; };\n        this.onDelete = (value) => { return; };\n        this.internalSet = new Set(value);\n    }\n    add(value, submitEvent = true) {\n        this.internalSet.add(value);\n        if (submitEvent) {\n            this.emitter.emit(\"add\", value);\n        }\n        this.onAdd(value);\n        return this;\n    }\n    delete(value, submitEvent = true) {\n        this.internalSet.delete(value);\n        if (submitEvent) {\n            this.emitter.emit(\"delete\", value);\n        }\n        this.onDelete(value);\n        return this;\n    }\n    entries() {\n        return Array.from(this.internalSet.values());\n    }\n}\nexport class DistributedSetValueType {\n    // tslint:enable:variable-name\n    constructor() {\n        this._factory = new DistributedSetFactory();\n        this._ops = new Map([[\n                \"add\",\n                {\n                    prepare: (value, params, local, op) => __awaiter(this, void 0, void 0, function* () {\n                        return;\n                    }),\n                    process: (value, params, context, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        value.add(params, false);\n                    },\n                },\n            ],\n            [\n                \"delete\",\n                {\n                    prepare: (value, params, local, op) => __awaiter(this, void 0, void 0, function* () {\n                        return;\n                    }),\n                    process: (value, params, context, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        value.delete(params, false);\n                    },\n                },\n            ]]);\n    }\n    get name() {\n        return DistributedSetValueType.Name;\n    }\n    get factory() {\n        return this._factory;\n    }\n    get ops() {\n        return this._ops;\n    }\n}\nDistributedSetValueType.Name = \"distributedSet\";\n//# sourceMappingURL=set.js.map","export class CounterFactory {\n    load(emitter, raw) {\n        // tslint:disable-next-line:strict-boolean-expressions\n        return new Counter(emitter, raw || 0);\n    }\n    store(value) {\n        return value.value;\n    }\n}\nexport class Counter {\n    // tslint:disable-next-line:variable-name\n    constructor(emitter, _value) {\n        this.emitter = emitter;\n        this._value = _value;\n        /**\n         * Can be set to register an event listener for when the counter is incremented. The callback indicates the\n         * amount the counter was incremented by.\n         */\n        this.onIncrement = (value) => { return; };\n    }\n    get value() {\n        return this._value;\n    }\n    increment(value, submit = true) {\n        this._value = this._value + value;\n        if (submit) {\n            this.emitter.emit(\"increment\", value);\n        }\n        this.onIncrement(value);\n        return this;\n    }\n}\nexport class CounterValueType {\n    // tslint:enable:variable-name\n    constructor() {\n        this._factory = new CounterFactory();\n        this._ops = new Map([[\n                \"increment\",\n                {\n                    prepare: (value, params, local, op) => {\n                        return Promise.resolve();\n                    },\n                    process: (value, params, context, local, op) => {\n                        // Local ops were applied when the message was created\n                        if (local) {\n                            return;\n                        }\n                        value.increment(params, false);\n                    },\n                },\n            ]]);\n    }\n    get name() {\n        return CounterValueType.Name;\n    }\n    get factory() {\n        return this._factory;\n    }\n    get ops() {\n        return this._ops;\n    }\n}\nCounterValueType.Name = \"counter\";\n//# sourceMappingURL=counter.js.map","import * as registerDebug from \"debug\";\nexport const debug = registerDebug(\"prague:component\");\n//# sourceMappingURL=debug.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ComponentHost } from \"@prague/component\";\nimport { MapExtension } from \"@prague/map\";\nimport { Runtime } from \"@prague/runtime\";\nimport { EventEmitter } from \"events\";\nimport { debug } from \"./debug\";\nconst typeToFactorySym = Symbol(\"Component.typeToFactory()\");\n// Internal IPlatform implementation used to defer returning the component\n// from DataStore.open() until after the component's async 'opened()' method has\n// completed.  (See 'Chaincode.run()' below.)\nclass ComponentPlatform extends EventEmitter {\n    constructor(component) {\n        super();\n        this.component = component;\n    }\n    queryInterface(id) {\n        debug(`ComponentPlatform.queryInterface(${id})`);\n        return id === \"component\"\n            ? this.component\n            : Promise.reject(`Unknown 'id': ${id}`);\n    }\n    detach() {\n        debug(`ComponentPlatform.detach()`);\n        return;\n    }\n}\n// Internal/reusable IChaincode implementation returned by DataStore.instantiate().\nclass LegacyChaincode {\n    constructor(component) {\n        this.component = component;\n    }\n    // Returns the SharedObject factory for the given type id.\n    getModule(type) {\n        debug(`Chaincode.getModule(${type})`);\n        return this.component[typeToFactorySym].get(type) || console.assert(false);\n    }\n    // NYI?\n    close() { return Promise.resolve(); }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            debug(\"Chaincode.run()\");\n            return new ComponentPlatform(Promise.resolve(this.component));\n        });\n    }\n}\n/**\n * Base class for chainloadable Prague components.\n */\nexport class Component extends EventEmitter {\n    constructor(types) {\n        super();\n        // tslint:disable-next-line:variable-name\n        this._host = null;\n        // tslint:disable-next-line:variable-name\n        this._platform = null;\n        // tslint:disable-next-line:variable-name\n        this._root = null;\n        /**\n         * Invoked by 'attach' to ensure that create/opened are called the first time\n         * a component is attached.  Subsequent calls ignore are a no-op.\n         */\n        this.ensureOpened = () => __awaiter(this, void 0, void 0, function* () {\n            // If the '_root' map is already initialized, than this is component has already been\n            // prepared.  Promptly return 'this'.\n            if (this._root) {\n                debug(`${this.dbgName}.ensureOpened() - already open`);\n                return this;\n            }\n            if (this.host.existing) {\n                debug(`${this.dbgName}.ensureOpened() - already exists`);\n                // If the component already exists, open it's root map.\n                this._root = (yield this.host.getChannel(Component.rootMapId));\n            }\n            else {\n                debug(`${this.dbgName}.ensureOpened() - new component`);\n                // If this is the first client to attempt opening the component, create the component's\n                // root map and call 'create()' to give the component author a chance to initialize the\n                // component's shared data structures.\n                this._root = this.host.createChannel(Component.rootMapId, MapExtension.Type);\n                this._root.attach();\n                debug(`${this.dbgName}.create() - begin`);\n                yield this.create();\n                debug(`${this.dbgName}.create() - end`);\n            }\n            debug(`${this.dbgName}.opened() - begin`);\n            yield this.opened();\n            debug(`${this.dbgName}.opened() - end`);\n            return this;\n        });\n        // Construct a map of extension types to their corresponding factory.\n        const typeToFactory = new Map(types);\n        // Ensure that the map includes the shared map type.  This is necessary because\n        // all components construct a shared map to be their root.\n        if (!typeToFactory.has(MapExtension.Type)) {\n            typeToFactory.set(MapExtension.Type, new MapExtension());\n        }\n        // Internally expose the 'typeToFactory' map to 'Chaincode.getModule()'.\n        this[typeToFactorySym] = typeToFactory;\n    }\n    get dbgName() {\n        return `${this.constructor.name}${this.host ? `:'${this.host.id}'` : \"\"}`;\n    }\n    get runtime() { return this._host; }\n    get platform() { return this._platform; }\n    get host() { return this._host; }\n    get root() { return this._root; }\n    /**\n     * Returns a promise that resolves once the component is synchronized with its date store.\n     * If the component is already connected, returns a resolved promise.\n     */\n    get connected() {\n        if (this.host.connected) {\n            debug(`${this.dbgName}.connected: Already connected.`);\n            return Promise.resolve();\n        }\n        debug(`${this.dbgName}.connected: Waiting...`);\n        return new Promise((accept) => {\n            this.host.on(\"connected\", () => {\n                debug(`${this.dbgName}.connected: Now connected.`);\n                accept();\n            });\n        });\n    }\n    /**\n     * Constructs an IChaincode from a Component instance.  All chaincode components must\n     * export an 'instantiate()' function from their module that returns an IChaincode as\n     * shown in the following example:\n     *\n     * @example\n     * const pkg = require(\"../package.json\")\n     *\n     * export async function instantiateRuntime(context: IContainerContext) {\n     *     return Component.instantiateRuntime(context, pkg.name,\n     *          [[pkg.name, Promise.resolve({ instantiateComponent })]]);\n     * }\n     * @example\n     */\n    static instantiateRuntime(context, chaincode, registry) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runtimeId = encodeURIComponent(chaincode);\n            debug(`instantiateRuntime(chaincode=${chaincode},registry=${JSON.stringify(registry)})`);\n            const runtime = yield Runtime.Load(new Map(registry.map(([name, ctorFn]) => [\n                name,\n                Promise.resolve({ instantiateComponent: () => Promise.resolve(new ctorFn()) }),\n            ])), context);\n            debug(\"runtime loaded.\");\n            // Register path handler for inbound messages\n            runtime.registerRequestHandler((request) => __awaiter(this, void 0, void 0, function* () {\n                debug(`request(url=${request.url})`);\n                debug(`awaiting root component`);\n                const componentRuntime = yield runtime.getComponent(runtimeId, /* wait: */ true);\n                debug(`have root component`);\n                if (request.url && request.url !== \"/\") {\n                    debug(`delegating to ${request.url}`);\n                    const component = componentRuntime.chaincode;\n                    return component.request(componentRuntime, { url: request.url });\n                }\n                else {\n                    debug(`resolved ${runtimeId}`);\n                    return { status: 200, mimeType: \"prague/component\", value: componentRuntime };\n                }\n            }));\n            // On first boot create the base component\n            if (!runtime.existing) {\n                debug(`createAndAttachComponent(chaincode=${chaincode})`);\n                runtime.createAndAttachComponent(runtimeId, chaincode).catch((error) => {\n                    context.error(error);\n                });\n            }\n            return runtime;\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            debug(`${this.dbgName}.close()`);\n            this.host.close();\n        });\n    }\n    run(runtime) {\n        return __awaiter(this, void 0, void 0, function* () {\n            debug(`${this.dbgName}.run()`);\n            debug(`${this.dbgName}.LoadFromSnapshot() - begin`);\n            this._host = yield ComponentHost.LoadFromSnapshot(runtime, new LegacyChaincode(this));\n            debug(`${this.dbgName}.LoadFromSnapshot() - end`);\n            return this._host;\n        });\n    }\n    attach(platform) {\n        return __awaiter(this, void 0, void 0, function* () {\n            debug(`${this.dbgName}.attach()`);\n            this._platform = platform;\n            return new ComponentPlatform(this.ensureOpened());\n        });\n    }\n    snapshot() {\n        debug(`${this.dbgName}.snapshot()`);\n        return { entries: this._host.snapshotInternal(), sha: null };\n    }\n    /**\n     * Subclasses may override request to internally route requests.\n     */\n    request(runtime, request) {\n        debug(`${this.dbgName}.request(${JSON.stringify(request)})`);\n        return runtime.request(request);\n    }\n}\nComponent.rootMapId = \"root\";\n//# sourceMappingURL=component.js.map","import * as cell from \"@prague/cell\";\nimport { CounterValueType, DistributedSetValueType, MapExtension, registerDefaultValueType, } from \"@prague/map\";\nimport * as sequence from \"@prague/sequence\";\nimport * as stream from \"@prague/stream\";\nimport * as uuid from \"uuid/v4\";\nimport { Component } from \"./component\";\nexport class Document extends Component {\n    constructor() {\n        // Register default map value types\n        registerDefaultValueType(new DistributedSetValueType());\n        registerDefaultValueType(new CounterValueType());\n        registerDefaultValueType(new sequence.SharedStringIntervalCollectionValueType());\n        registerDefaultValueType(new sequence.SharedIntervalCollectionValueType());\n        // Create channel extensions\n        const mapExtension = new MapExtension();\n        const sharedStringExtension = new sequence.SharedStringExtension();\n        const streamExtension = new stream.StreamExtension();\n        const cellExtension = new cell.CellExtension();\n        const objectSequenceExtension = new sequence.SharedObjectSequenceExtension();\n        const numberSequenceExtension = new sequence.SharedNumberSequenceExtension();\n        // Register channel extensions\n        super([\n            [mapExtension.type, mapExtension],\n            [sharedStringExtension.type, sharedStringExtension],\n            [streamExtension.type, streamExtension],\n            [cellExtension.type, cellExtension],\n            [objectSequenceExtension.type, objectSequenceExtension],\n            [numberSequenceExtension.type, numberSequenceExtension],\n        ]);\n    }\n    /**\n     * Subclass implements 'opened()' to finish initialization after the component has been opened/created.\n     */\n    opened() {\n        return Promise.resolve();\n    }\n    /**\n     * Creates a new shared map\n     */\n    createMap(id = uuid()) {\n        return this.runtime.createChannel(id, MapExtension.Type);\n    }\n    /**\n     * Creates a new shared cell.\n     */\n    createCell(id = uuid()) {\n        return this.runtime.createChannel(id, cell.CellExtension.Type);\n    }\n    /**\n     * Creates a new shared string\n     */\n    createString(id = uuid()) {\n        return this.runtime.createChannel(id, sequence.SharedStringExtension.Type);\n    }\n    /**\n     * Creates a new ink shared object\n     */\n    createStream(id = uuid()) {\n        return this.runtime.createChannel(id, stream.StreamExtension.Type);\n    }\n}\n//# sourceMappingURL=document.js.map","import { Component, Document } from \"@prague/app-component\";\r\nimport { CounterValueType } from \"@prague/map\";\r\n\r\nexport class Clicker extends Document {\r\n\r\n  // Create the component's schema and perform other initialization tasks\r\n  // (only called when document is initially created).\r\n  async create() {\r\n    this.root.set(\"clicks\", 0, CounterValueType.Name);\r\n  }\r\n\r\n  async render(host) {\r\n\r\n    // Get the distributed Counter\r\n    const counter = await this.root.wait(\"clicks\");\r\n\r\n    // Create a <span> that displays the current value of 'clicks'.\r\n    const span = document.createElement(\"span\");\r\n    const update = () => {\r\n      span.textContent = counter.value.toString();\r\n    };\r\n    this.root.on(\"valueChanged\", update);\r\n    update();\r\n\r\n    // Create a button that increments the value of 'clicks' when pressed.\r\n    const btn = document.createElement(\"button\");\r\n    btn.textContent = \"+\";\r\n    btn.addEventListener(\"click\", () => {\r\n      counter.increment(1);\r\n    });\r\n\r\n    // Add both to the <div> provided by the host:\r\n    host.appendChild(span);\r\n    host.appendChild(btn);\r\n  }\r\n\r\n  // The component has been loaded. Attempt to get a div from the host. TODO explain this better.\r\n  async opened() {\r\n    // If the host provided a <div>, render the component into that Div\r\n    const maybeDiv = await this.platform.queryInterface(\"div\");\r\n    if (maybeDiv) {\r\n      this.render(maybeDiv);\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nexport async function instantiateRuntime( context) {\r\n  return Component.instantiateRuntime(context, \"@chaincode/counter\", [\r\n    [\"@chaincode/counter\", Clicker]\r\n  ]);\r\n}\r\n","import * as assert from \"assert\";\n/**\n * A deferred creates a promise and the ability to resolve or reject it\n */\nexport class Deferred {\n    constructor() {\n        /* tslint:disable:promise-must-complete */\n        this.p = new Promise((resolve, reject) => {\n            this.res = resolve;\n            this.rej = reject;\n        });\n    }\n    /**\n     * Retrieves the underlying promise for the deferred\n     */\n    get promise() {\n        return this.p;\n    }\n    /**\n     * Resolves the promise\n     */\n    resolve(value) {\n        this.res(value);\n    }\n    /**\n     * Rejects the promise\n     */\n    reject(error) {\n        this.rej(error);\n    }\n}\n/**\n * Helper function that asserts that the given promise only resolves\n */\n/* tslint:disable:promise-function-async */\nexport function assertNotRejected(promise) {\n    // Assert that the given promise only resolves\n    promise.catch((error) => {\n        assert.ok(false);\n    });\n    return promise;\n}\n//# sourceMappingURL=promises.js.map","// tslint:disable\nimport { MessageType } from \"@prague/container-definitions\";\nimport { MergeTree, compareStrings, RegisterCollection, UnassignedSequenceNumber, SubSequence, SegmentType, UniversalSequenceNumber, clock, elapsedMicroseconds } from \"./mergeTree\";\nimport * as Collections from \"./collections\";\nexport class Client {\n    constructor(initText, options) {\n        this.accumTime = 0;\n        this.localTime = 0;\n        this.localOps = 0;\n        this.accumWindowTime = 0;\n        this.maxWindowTime = 0;\n        this.accumWindow = 0;\n        this.accumOps = 0;\n        this.verboseOps = false;\n        this.noVerboseRemoteAnnote = false;\n        this.measureOps = false;\n        this.clientSequenceNumber = 1;\n        this.clientNameToIds = new Collections.RedBlackTree(compareStrings);\n        this.shortClientIdMap = [];\n        this.shortClientBranchIdMap = [];\n        this.shortClientUserInfoMap = [];\n        this.registerCollection = new RegisterCollection();\n        this.localSequenceNumber = UnassignedSequenceNumber;\n        this.opMarkersModified = [];\n        this.pendingConsensus = new Map();\n        this.mergeTree = new MergeTree(initText, options);\n        this.mergeTree.getLongClientId = id => this.getLongClientId(id);\n        this.mergeTree.getUserInfo = id => this.getUserInfo(id);\n        this.mergeTree.markerModifiedHandler = marker => this.markerModified(marker);\n        this.mergeTree.clientIdToBranchId = this.shortClientBranchIdMap;\n        this.q = Collections.ListMakeHead();\n        this.checkQ = Collections.ListMakeHead();\n    }\n    resetModifiedMarkers() {\n        this.opMarkersModified = [];\n    }\n    markerModified(marker) {\n        this.opMarkersModified.push(marker);\n    }\n    setLocalSequenceNumber(seq) {\n        this.localSequenceNumber = seq;\n    }\n    resetLocalSequenceNumber() {\n        this.localSequenceNumber = UnassignedSequenceNumber;\n    }\n    undoSingleSequenceNumber(undoSegments, redoSegments) {\n        let len = undoSegments.length;\n        let index = len - 1;\n        let seq = undoSegments[index].seq;\n        if (seq === 0) {\n            return 0;\n        }\n        while (index >= 0) {\n            let undoInfo = undoSegments[index];\n            if (seq === undoInfo.seq) {\n                this.mergeTree.cherryPickedUndo(undoInfo);\n                redoSegments.push(undoInfo);\n            }\n            else {\n                break;\n            }\n            index--;\n        }\n        undoSegments.length = index + 1;\n        return seq;\n    }\n    historyToPct(pct) {\n        let count = this.undoSegments.length + this.redoSegments.length;\n        let curPct = this.undoSegments.length / count;\n        let seq = -1;\n        if (curPct >= pct) {\n            while (curPct > pct) {\n                seq = this.undoSingleSequenceNumber(this.undoSegments, this.redoSegments);\n                curPct = this.undoSegments.length / count;\n            }\n        }\n        else {\n            while (curPct < pct) {\n                seq = this.undoSingleSequenceNumber(this.redoSegments, this.undoSegments);\n                curPct = this.undoSegments.length / count;\n            }\n        }\n        return seq;\n    }\n    undo() {\n        return this.undoSingleSequenceNumber(this.undoSegments, this.redoSegments);\n    }\n    redo() {\n        return this.undoSingleSequenceNumber(this.redoSegments, this.undoSegments);\n    }\n    cloneFromSegments() {\n        let clone = new Client(\"\", this.mergeTree.options);\n        let segments = [];\n        let newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);\n        clone.mergeTree.root = newRoot;\n        let undoSeg = [];\n        for (let segment of segments) {\n            if (segment.seq !== 0) {\n                undoSeg.push({\n                    seq: segment.seq,\n                    seg: segment,\n                    op: 0 /* INSERT */\n                });\n            }\n            if (segment.removedSeq !== undefined) {\n                undoSeg.push({\n                    seq: segment.removedSeq,\n                    seg: segment,\n                    op: 1 /* REMOVE */\n                });\n            }\n        }\n        undoSeg = undoSeg.sort((a, b) => {\n            if (b.seq === a.seq) {\n                return 0;\n            }\n            else if (b.seq === UnassignedSequenceNumber) {\n                return -1;\n            }\n            else if (a.seq === UnassignedSequenceNumber) {\n                return 1;\n            }\n            else {\n                return a.seq - b.seq;\n            }\n        });\n        clone.undoSegments = undoSeg;\n        clone.redoSegments = [];\n        return clone;\n    }\n    getOrAddShortClientId(longClientId, branchId = 0) {\n        if (!this.clientNameToIds.get(longClientId)) {\n            this.addLongClientId(longClientId, branchId);\n        }\n        return this.getShortClientId(longClientId);\n    }\n    getShortClientId(longClientId) {\n        return this.clientNameToIds.get(longClientId).data.clientId;\n    }\n    getLongClientId(shortClientId) {\n        if (shortClientId >= 0) {\n            return this.shortClientIdMap[shortClientId];\n        }\n        else {\n            return \"original\";\n        }\n    }\n    getUserInfo(shortClientId) {\n        if (shortClientId >= 0) {\n            return this.shortClientUserInfoMap[shortClientId];\n        }\n        else {\n            return null;\n        }\n    }\n    addLongClientId(longClientId, branchId = 0) {\n        this.clientNameToIds.put(longClientId, {\n            branchId,\n            clientId: this.shortClientIdMap.length,\n        });\n        this.shortClientIdMap.push(longClientId);\n        this.shortClientBranchIdMap.push(branchId);\n    }\n    getBranchId(clientId) {\n        return this.shortClientBranchIdMap[clientId];\n    }\n    // TODO: props, end\n    makeInsertMarkerMsg(markerType, behaviors, pos, seq, refSeq, objectId) {\n        return {\n            clientId: this.longClientId,\n            minimumSequenceNumber: undefined,\n            clientSequenceNumber: this.clientSequenceNumber,\n            sequenceNumber: seq,\n            referenceSequenceNumber: refSeq,\n            objectId: objectId,\n            userId: undefined,\n            offset: seq,\n            origin: null,\n            contents: {\n                type: 0 /* INSERT */, marker: { type: markerType, behaviors }, pos1: pos\n            },\n            timestamp: Date.now(),\n            traces: [],\n            type: MessageType.Operation,\n        };\n    }\n    makeInsertMsg(text, pos, seq, refSeq, objectId) {\n        return {\n            clientId: this.longClientId,\n            sequenceNumber: seq,\n            referenceSequenceNumber: refSeq,\n            clientSequenceNumber: this.clientSequenceNumber,\n            minimumSequenceNumber: undefined,\n            objectId: objectId,\n            userId: undefined,\n            offset: seq,\n            origin: null,\n            contents: {\n                type: 0 /* INSERT */, text: text, pos1: pos\n            },\n            timestamp: Date.now(),\n            traces: [],\n            type: MessageType.Operation,\n        };\n    }\n    makeRemoveMsg(start, end, seq, refSeq, objectId) {\n        return {\n            clientId: this.longClientId,\n            sequenceNumber: seq,\n            referenceSequenceNumber: refSeq,\n            clientSequenceNumber: this.clientSequenceNumber,\n            minimumSequenceNumber: undefined,\n            objectId: objectId,\n            userId: undefined,\n            offset: seq,\n            origin: null,\n            contents: {\n                type: 1 /* REMOVE */, pos1: start, pos2: end,\n            },\n            timestamp: Date.now(),\n            traces: [],\n            type: MessageType.Operation,\n        };\n    }\n    makeAnnotateMsg(props, start, end, seq, refSeq, objectId) {\n        return {\n            clientId: this.longClientId,\n            sequenceNumber: seq,\n            referenceSequenceNumber: refSeq,\n            objectId: objectId,\n            clientSequenceNumber: this.clientSequenceNumber,\n            userId: undefined,\n            minimumSequenceNumber: undefined,\n            offset: seq,\n            origin: null,\n            contents: {\n                type: 2 /* ANNOTATE */, pos1: start, pos2: end, props\n            },\n            timestamp: Date.now(),\n            traces: [],\n            type: MessageType.Operation,\n        };\n    }\n    hasMessages() {\n        return this.q.count() > 0;\n    }\n    enqueueMsg(msg) {\n        this.q.enqueue(msg);\n    }\n    dequeueMsg() {\n        return this.q.dequeue();\n    }\n    enqueueTestString() {\n        this.checkQ.enqueue(this.getText());\n    }\n    segmentToOps(segment, opList) {\n        // TODO: branches\n        if (segment.seq === UnassignedSequenceNumber) {\n            let pos = this.mergeTree.getOffset(segment, this.getCurrentSeq(), this.getClientId());\n            let insertOp = {\n                pos1: pos,\n                type: 0 /* INSERT */,\n            };\n            if (segment.getType() === SegmentType.Text) {\n                let textSegment = segment;\n                insertOp.text = textSegment.text;\n            }\n            else {\n                // assume marker\n                let marker = segment;\n                insertOp.marker = { refType: marker.refType };\n            }\n            if (segment.properties) {\n                insertOp.props = segment.properties;\n            }\n            opList.push(insertOp);\n        }\n        if (segment.removedSeq === UnassignedSequenceNumber) {\n            let start = this.mergeTree.getOffset(segment, this.getCurrentSeq(), this.getClientId());\n            let removeOp = {\n                pos1: start,\n                pos2: start + segment.cachedLength,\n                type: 1 /* REMOVE */,\n            };\n            opList.push(removeOp);\n        }\n    }\n    transformOp(op, referenceSequenceNumber, toSequenceNumber) {\n        if ((op.type == 2 /* ANNOTATE */) ||\n            (op.type == 1 /* REMOVE */)) {\n            let ranges = this.mergeTree.tardisRange(op.pos1, op.pos2, referenceSequenceNumber, toSequenceNumber);\n            if (ranges.length == 1) {\n                op.pos1 = ranges[0].start;\n                op.pos2 = ranges[0].end;\n            }\n            else {\n                let groupOp = { type: 3 /* GROUP */ };\n                groupOp.ops = ranges.map((range) => ({\n                    type: op.type,\n                    pos1: range.start,\n                    pos2: range.end,\n                }));\n                return groupOp;\n            }\n        }\n        else if (op.type == 0 /* INSERT */) {\n            op.pos1 = this.mergeTree.tardisPosition(op.pos1, referenceSequenceNumber, toSequenceNumber);\n        }\n        else if (op.type === 3 /* GROUP */) {\n            for (let i = 0, len = op.ops.length; i < len; i++) {\n                op.ops[i] = this.transformOp(op.ops[i], referenceSequenceNumber, toSequenceNumber);\n            }\n        }\n        return op;\n    }\n    transform(op, referenceSequenceNumber, toSequenceNumber) {\n        if (referenceSequenceNumber >= toSequenceNumber) {\n            return op;\n        }\n        return this.transformOp(op, referenceSequenceNumber, toSequenceNumber);\n    }\n    copy(start, end, registerId, refSeq, clientId, longClientId) {\n        let segs = this.mergeTree.cloneSegments(refSeq, clientId, start, end);\n        this.registerCollection.set(longClientId, registerId, segs);\n    }\n    pasteLocal(register, pos, opArgs) {\n        let segs = this.registerCollection.get(this.longClientId, register);\n        if (segs) {\n            this.mergeTree.startGroupOperation();\n            // TODO: build tree from segs and insert all at once\n            for (let seg of segs) {\n                if (seg.getType() === SegmentType.Text) {\n                    let textSegment = seg;\n                    this.insertTextLocal(textSegment.text, pos, textSegment.properties, opArgs);\n                    pos += textSegment.cachedLength;\n                }\n                else {\n                    let marker = seg;\n                    this.insertMarkerLocal(pos, marker.refType, marker.properties, opArgs);\n                    pos += marker.cachedLength;\n                }\n            }\n            this.mergeTree.endGroupOperation();\n        }\n        return pos;\n    }\n    pasteRemote(pos, registerId, seq, refSeq, clientId, longClientId, opArgs) {\n        let segs = this.registerCollection.get(longClientId, registerId);\n        if (segs) {\n            // TODO: build tree from segs and insert all at once\n            for (let seg of segs) {\n                if (seg.getType() === SegmentType.Text) {\n                    let textSegment = seg;\n                    this.insertTextRemote(textSegment.text, pos, textSegment.properties, seq, refSeq, clientId, opArgs);\n                    pos += textSegment.cachedLength;\n                }\n                else {\n                    let marker = seg;\n                    this.insertMarkerRemote({ refType: marker.refType }, pos, marker.properties, seq, refSeq, clientId, opArgs);\n                    pos += marker.cachedLength;\n                }\n            }\n        }\n        // TODO: error reporting\n    }\n    checkNest(op, msg, clid) {\n        let beginMarker = this.mergeTree.getSegmentFromId(op.checkNest.id1);\n        let endMarker = this.mergeTree.getSegmentFromId(op.checkNest.id2);\n        let beginPos = this.mergeTree.getOffset(beginMarker, msg.referenceSequenceNumber, clid);\n        let endPos = endMarker.cachedLength + this.mergeTree.getOffset(endMarker, msg.referenceSequenceNumber, clid);\n        if ((beginPos !== op.pos1) || (endPos !== op.pos2)) {\n            console.log(`remove nest mismatch ${beginPos} ${op.pos1} ${endPos} ${op.pos2}`);\n        }\n    }\n    applyOp(opArgs) {\n        const op = opArgs.op;\n        const msg = opArgs.sequencedMessage;\n        let clid = this.getOrAddShortClientId(msg.clientId);\n        switch (op.type) {\n            case 0 /* INSERT */:\n                if (op.relativePos1) {\n                    op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1, msg.referenceSequenceNumber, clid);\n                    if (op.pos1 < 0) {\n                        // TODO: event when marker id not found\n                        return;\n                    }\n                }\n                if (op.text !== undefined) {\n                    if (op.pos2 !== undefined) {\n                        // replace\n                        this.removeSegmentRemote(op.pos1, op.pos2, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);\n                    }\n                    this.insertTextRemote(op.text, op.pos1, op.props, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);\n                }\n                else if (op.marker !== undefined) {\n                    this.insertMarkerRemote(op.marker, op.pos1, op.props, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);\n                }\n                else if (op.items !== undefined) {\n                    this.insertItemsRemote(op.items, op.isNumberSequence, op.pos1, op.props, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);\n                }\n                else if (op.register !== undefined) {\n                    // TODO: relative addressing\n                    if (op.pos2 !== undefined) {\n                        // copy\n                        this.copy(op.pos1, op.pos2, op.register, msg.referenceSequenceNumber, clid, msg.clientId);\n                    }\n                    else {\n                        // paste\n                        this.pasteRemote(op.pos1, op.register, msg.sequenceNumber, msg.referenceSequenceNumber, clid, msg.clientId, opArgs);\n                    }\n                }\n                break;\n            case 1 /* REMOVE */:\n                if (op.relativePos1) {\n                    op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1, msg.referenceSequenceNumber, clid);\n                    if (op.pos1 < 0) {\n                        // TODO: event when marker id not found\n                        return;\n                    }\n                }\n                if (op.relativePos2) {\n                    op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2, msg.referenceSequenceNumber, clid);\n                    if (op.pos2 < 0) {\n                        // TODO: event when marker id not found\n                        return;\n                    }\n                }\n                if (op.register) {\n                    // cut\n                    this.copy(op.pos1, op.pos2, op.register, msg.referenceSequenceNumber, clid, msg.clientId);\n                }\n                if (op.checkNest) {\n                    this.checkNest(op, msg, clid);\n                }\n                this.removeSegmentRemote(op.pos1, op.pos2, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);\n                break;\n            case 2 /* ANNOTATE */:\n                if (op.relativePos1) {\n                    op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1, msg.referenceSequenceNumber, clid);\n                    if (op.pos1 < 0) {\n                        // TODO: event when marker id not found\n                        return;\n                    }\n                }\n                if (op.relativePos2) {\n                    op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2, msg.referenceSequenceNumber, clid);\n                    if (op.pos2 < 0) {\n                        // TODO: event when marker id not found\n                        return;\n                    }\n                }\n                this.annotateSegmentRemote(op.props, op.pos1, op.pos2, msg.sequenceNumber, msg.referenceSequenceNumber, clid, op.combiningOp, opArgs);\n                break;\n            case 3 /* GROUP */: {\n                for (let memberOp of op.ops) {\n                    this.applyOp({\n                        op: memberOp,\n                        groupOp: op,\n                        sequencedMessage: msg,\n                    });\n                }\n                break;\n            }\n        }\n    }\n    getModifiedMarkersForOp() {\n        return this.opMarkersModified;\n    }\n    coreApplyMsg(msg) {\n        this.resetModifiedMarkers();\n        this.applyOp({\n            op: msg.contents,\n            sequencedMessage: msg\n        });\n    }\n    applyMsg(msg) {\n        if ((msg !== undefined) && (msg.minimumSequenceNumber > this.mergeTree.getCollabWindow().minSeq)) {\n            this.updateMinSeq(msg.minimumSequenceNumber);\n        }\n        // Ensure client ID is registered\n        // TODO support for more than two branch IDs\n        // The existance of msg.origin means we are a branch message - and so should be marked as 0\n        // The non-existance of msg.origin indicates we are local - and should inherit the collab mode ID\n        const branchId = msg.origin ? 0 : this.mergeTree.localBranchId;\n        this.getOrAddShortClientId(msg.clientId, branchId);\n        // Apply if an operation message\n        if (msg.type === MessageType.Operation) {\n            const operationMessage = msg;\n            if (msg.clientId === this.longClientId) {\n                let op = msg.contents;\n                if (op.type !== 2 /* ANNOTATE */) {\n                    this.ackPendingSegment(operationMessage.sequenceNumber);\n                }\n                else {\n                    if (op.combiningOp && (op.combiningOp.name === \"consensus\")) {\n                        this.updateConsensusProperty(op, operationMessage);\n                    }\n                }\n            }\n            else {\n                this.coreApplyMsg(operationMessage);\n            }\n        }\n    }\n    applyMessages(msgCount) {\n        while (msgCount > 0) {\n            let msg = this.q.dequeue();\n            if (msg) {\n                this.applyMsg(msg);\n            }\n            else {\n                break;\n            }\n            msgCount--;\n        }\n        return true;\n    }\n    getLocalSequenceNumber() {\n        let segWindow = this.mergeTree.getCollabWindow();\n        if (segWindow.collaborating) {\n            return this.localSequenceNumber;\n        }\n        else {\n            return UniversalSequenceNumber;\n        }\n    }\n    localTransaction(groupOp, segmentGroup) {\n        segmentGroup = this.mergeTree.startGroupOperation(segmentGroup);\n        for (let op of groupOp.ops) {\n            const opArgs = {\n                op,\n                groupOp,\n            };\n            switch (op.type) {\n                case 0 /* INSERT */:\n                    if (op.relativePos1) {\n                        op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1);\n                        if (op.pos1 < 0) {\n                            // TODO: raise exception or other error flow\n                            break;\n                        }\n                    }\n                    if (op.marker) {\n                        this.insertMarkerLocal(op.pos1, op.marker.refType, op.props, opArgs);\n                    }\n                    else {\n                        this.insertTextLocal(op.text, op.pos1, op.props, opArgs);\n                    }\n                    break;\n                case 2 /* ANNOTATE */:\n                    if (op.relativePos1) {\n                        op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1);\n                        if (op.pos1 < 0) {\n                            // TODO: raise exception or other error flow\n                            break;\n                        }\n                    }\n                    if (op.relativePos2) {\n                        op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2);\n                        if (op.pos2 < 0) {\n                            // TODO: raise exception or other error flow\n                            break;\n                        }\n                    }\n                    this.annotateSegmentLocal(op.props, op.pos1, op.pos2, op.combiningOp, opArgs);\n                    break;\n                case 1 /* REMOVE */:\n                    if (op.relativePos1) {\n                        op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1);\n                        if (op.pos1 < 0) {\n                            // TODO: raise exception or other error flow\n                            break;\n                        }\n                    }\n                    if (op.relativePos2) {\n                        op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2);\n                        if (op.pos2 < 0) {\n                            // TODO: raise exception or other error flow\n                            break;\n                        }\n                    }\n                    this.removeSegmentLocal(op.pos1, op.pos2, opArgs);\n                    break;\n                case 3 /* GROUP */:\n                    console.log(\"unhandled nested group op\");\n                    break;\n            }\n        }\n        this.mergeTree.endGroupOperation();\n        return segmentGroup;\n    }\n    updateConsensusProperty(op, msg) {\n        let markerId = op.relativePos1.id;\n        let consensusInfo = this.pendingConsensus.get(markerId);\n        if (consensusInfo) {\n            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);\n        }\n        this.mergeTree.addMinSeqListener(msg.sequenceNumber, (minSeq) => consensusInfo.callback(consensusInfo.marker));\n    }\n    // marker must have an id\n    annotateMarkerNotifyConsensus(marker, props, consensusCallback, opArgs) {\n        let combiningOp = {\n            name: \"consensus\"\n        };\n        let consensusInfo = {\n            callback: consensusCallback,\n            marker,\n        };\n        let id = marker.getId();\n        this.pendingConsensus.set(id, consensusInfo);\n        this.annotateMarker(props, marker, combiningOp, opArgs);\n    }\n    annotateMarker(props, marker, op, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        this.resetModifiedMarkers();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        let start = this.mergeTree.getOffset(marker, UniversalSequenceNumber, this.getClientId());\n        this.mergeTree.annotateRange(props, start, start + marker.cachedLength, refSeq, clientId, seq, op, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`annotate local cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);\n        }\n    }\n    annotateSegmentLocal(props, start, end, op, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        this.resetModifiedMarkers();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.annotateRange(props, start, end, refSeq, clientId, seq, op, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`annotate local cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);\n        }\n    }\n    annotateSegmentRemote(props, start, end, seq, refSeq, clientId, combiningOp, opArgs) {\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.annotateRange(props, start, end, refSeq, clientId, seq, combiningOp, opArgs);\n        this.mergeTree.getCollabWindow().currentSeq = seq;\n        if (this.measureOps) {\n            this.accumTime += elapsedMicroseconds(clockStart);\n            this.accumOps++;\n            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);\n        }\n        if (this.verboseOps && (!this.noVerboseRemoteAnnote)) {\n            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} seq ${seq} annotate remote start ${start} end ${end} refseq ${refSeq} cli ${clientId} props ${props}`);\n        }\n    }\n    removeSegmentLocal(start, end, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        this.resetModifiedMarkers();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.markRangeRemoved(start, end, refSeq, clientId, seq, false, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`remove local cli ${this.getLongClientId(clientId)} ref seq ${refSeq} [${start},${end})`);\n        }\n    }\n    removeSegmentRemote(start, end, seq, refSeq, clientId, opArgs) {\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.markRangeRemoved(start, end, refSeq, clientId, seq, false, opArgs);\n        this.mergeTree.getCollabWindow().currentSeq = seq;\n        if (this.measureOps) {\n            this.accumTime += elapsedMicroseconds(clockStart);\n            this.accumOps++;\n            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);\n        }\n        if (this.verboseOps) {\n            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} seq ${seq} remove remote start ${start} end ${end} refseq ${refSeq} cli ${this.getLongClientId(clientId)}`);\n        }\n    }\n    insertTextLocal(text, pos, props, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        this.resetModifiedMarkers();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.insertText(pos, refSeq, clientId, seq, text, props, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`insert local text ${text} pos ${pos} cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);\n        }\n    }\n    insertTextMarkerRelative(text, markerPos, props, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        this.resetModifiedMarkers();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.insertTextMarkerRelative(markerPos, refSeq, clientId, seq, text, props, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`insert local text marker relative ${text} pos ${markerPos.id} cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);\n        }\n    }\n    insertSegmentLocal(pos, segment, props, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        segment.seq = seq;\n        segment.clientId = clientId;\n        this.mergeTree.insertSegment(pos, refSeq, clientId, seq, segment, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`insert local segment pos ${pos} cli ${this.getLongClientId(clientId)} ${segment.toString()} ref seq ${refSeq}`);\n        }\n    }\n    insertMarkerLocal(pos, behaviors, props, opArgs) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        let clientId = segWindow.clientId;\n        let refSeq = segWindow.currentSeq;\n        let seq = this.getLocalSequenceNumber();\n        this.resetModifiedMarkers();\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        let marker = this.mergeTree.insertMarker(pos, refSeq, clientId, seq, behaviors, props, opArgs);\n        if (this.measureOps) {\n            this.localTime += elapsedMicroseconds(clockStart);\n            this.localOps++;\n        }\n        if (this.verboseOps) {\n            console.log(`insert local marker pos ${pos} cli ${this.getLongClientId(clientId)} ${marker.toString()} ref seq ${refSeq}`);\n        }\n    }\n    insertItemsRemote(items, isNumberSequence, pos, props, seq, refSeq, clientId, opArgs) {\n        const traceItems = false;\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        let segment;\n        if (isNumberSequence) {\n            segment = new SubSequence(items, seq, clientId);\n        }\n        else {\n            segment = new SubSequence(items, seq, clientId);\n        }\n        if (props) {\n            segment.addProperties(props);\n        }\n        if (traceItems) {\n            console.log(`pre-length: ${this.mergeTree.getLength(UniversalSequenceNumber, this.mergeTree.collabWindow.clientId)} pos: ${pos}`);\n        }\n        this.mergeTree.insertSegment(pos, refSeq, clientId, seq, segment, opArgs);\n        if (traceItems) {\n            console.log(`post-length: ${this.mergeTree.getLength(UniversalSequenceNumber, this.mergeTree.collabWindow.clientId)} pos: ${pos}`);\n        }\n        this.mergeTree.getCollabWindow().currentSeq = seq;\n        if (this.measureOps) {\n            this.accumTime += elapsedMicroseconds(clockStart);\n            this.accumOps++;\n            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);\n        }\n        if (this.verboseOps) {\n            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} ${segment.toString()} seq ${seq} insert remote pos ${pos} refseq ${refSeq} cli ${clientId}`);\n        }\n    }\n    insertMarkerRemote(markerDef, pos, props, seq, refSeq, clientId, opArgs) {\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        let marker = this.mergeTree.insertMarker(pos, refSeq, clientId, seq, markerDef.refType, props, opArgs);\n        this.mergeTree.getCollabWindow().currentSeq = seq;\n        if (this.measureOps) {\n            this.accumTime += elapsedMicroseconds(clockStart);\n            this.accumOps++;\n            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);\n        }\n        if (this.verboseOps) {\n            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} ${marker.toString()} seq ${seq} insert remote pos ${pos} refseq ${refSeq} cli ${clientId}`);\n        }\n    }\n    insertTextRemote(text, pos, props, seq, refSeq, clientId, opArgs) {\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.insertText(pos, refSeq, clientId, seq, text, props, opArgs);\n        this.mergeTree.getCollabWindow().currentSeq = seq;\n        if (this.measureOps) {\n            this.accumTime += elapsedMicroseconds(clockStart);\n            this.accumOps++;\n            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);\n        }\n        if (this.verboseOps) {\n            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} text ${text} seq ${seq} insert remote pos ${pos} refseq ${refSeq} cli ${this.getLongClientId(clientId)}`);\n        }\n    }\n    ackPendingSegment(seq) {\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.ackPendingSegment(seq, this.verboseOps);\n        this.mergeTree.getCollabWindow().currentSeq = seq;\n        if (this.measureOps) {\n            this.accumTime += elapsedMicroseconds(clockStart);\n            this.accumOps++;\n            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);\n        }\n        if (this.verboseOps) {\n            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} ack seq # ${seq}`);\n        }\n    }\n    updateMinSeq(minSeq) {\n        let clockStart;\n        if (this.measureOps) {\n            clockStart = clock();\n        }\n        this.mergeTree.updateGlobalMinSeq(minSeq);\n        if (this.measureOps) {\n            let elapsed = elapsedMicroseconds(clockStart);\n            this.accumWindowTime += elapsed;\n            if (elapsed > this.maxWindowTime) {\n                this.maxWindowTime = elapsed;\n            }\n        }\n    }\n    getPropertiesAtPosition(pos) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        if (this.verboseOps) {\n            console.log(`getPropertiesAtPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);\n        }\n        let propertiesAtPosition;\n        let segoff = this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);\n        let seg = segoff.segment;\n        if (seg) {\n            propertiesAtPosition = seg.properties;\n        }\n        return propertiesAtPosition;\n    }\n    getRangeExtentsOfPosition(pos) {\n        let segWindow = this.mergeTree.getCollabWindow();\n        if (this.verboseOps) {\n            console.log(`getRangeExtentsOfPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);\n        }\n        let startPos;\n        let endPos;\n        let segoff = this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);\n        let seg = segoff.segment;\n        if (seg) {\n            startPos = this.mergeTree.getOffset(seg, segWindow.currentSeq, segWindow.clientId);\n            endPos = startPos + seg.cachedLength;\n        }\n        return { startPos, endPos };\n    }\n    getCurrentSeq() {\n        return this.mergeTree.getCollabWindow().currentSeq;\n    }\n    getClientId() {\n        return this.mergeTree.getCollabWindow().clientId;\n    }\n    getTextAndMarkers(label) {\n        let segmentWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);\n    }\n    getText(start, end) {\n        let segmentWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"\", start, end);\n    }\n    /**\n     * Adds spaces for markers and components, so that position calculations account for them\n     */\n    getTextWithPlaceholders() {\n        let segmentWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \");\n    }\n    getTextRangeWithPlaceholders(start, end) {\n        let segmentWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, \" \", start, end);\n    }\n    getTextRangeWithMarkers(start, end) {\n        let segmentWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, \"*\", start, end);\n    }\n    getLength() {\n        let segmentWindow = this.mergeTree.getCollabWindow();\n        return this.mergeTree.getLength(segmentWindow.currentSeq, segmentWindow.clientId);\n    }\n    relText(clientId, refSeq) {\n        return `cli: ${this.getLongClientId(clientId)} refSeq: ${refSeq}: ` + this.mergeTree.getText(refSeq, clientId);\n    }\n    relItems(clientId, refSeq) {\n        return `cli: ${this.getLongClientId(clientId)} refSeq: ${refSeq}: ` + this.mergeTree.getItems(refSeq, clientId).toString();\n    }\n    startCollaboration(longClientId, minSeq = 0, branchId = 0) {\n        this.longClientId = longClientId;\n        this.addLongClientId(longClientId, branchId);\n        this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, branchId);\n    }\n    updateCollaboration(longClientId) {\n        const oldClientId = this.longClientId;\n        let oldData = this.clientNameToIds.get(oldClientId).data;\n        this.longClientId = longClientId;\n        this.clientNameToIds.put(longClientId, oldData);\n        this.shortClientIdMap[oldData.clientId] = longClientId;\n    }\n    findTile(startPos, tileLabel, preceding = true) {\n        const clientId = this.getClientId();\n        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);\n    }\n}\n//# sourceMappingURL=client.js.map"],"sourceRoot":""}