(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["main"] = factory();
	else
		root["main"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@prague/app-component/lib/component.js":
/*!*************************************************************!*\
  !*** ./node_modules/@prague/app-component/lib/component.js ***!
  \*************************************************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony import */ var _prague_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/component */ "./node_modules/@prague/component/dist/index.js");
/* harmony import */ var _prague_component__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_component__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prague_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/map */ "./node_modules/@prague/map/lib/index.js");
/* harmony import */ var _prague_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @prague/runtime */ "./node_modules/@prague/runtime/dist/index.js");
/* harmony import */ var _prague_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_prague_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debug */ "./node_modules/@prague/app-component/lib/debug.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const typeToFactorySym = Symbol("Component.typeToFactory()");
// Internal IPlatform implementation used to defer returning the component
// from DataStore.open() until after the component's async 'opened()' method has
// completed.  (See 'Chaincode.run()' below.)
class ComponentPlatform extends events__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"] {
    constructor(component) {
        super();
        this.component = component;
    }
    queryInterface(id) {
        Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`ComponentPlatform.queryInterface(${id})`);
        return id === "component"
            ? this.component
            : Promise.reject(`Unknown 'id': ${id}`);
    }
    detach() {
        Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`ComponentPlatform.detach()`);
        return;
    }
}
// Internal/reusable IChaincode implementation returned by DataStore.instantiate().
class LegacyChaincode {
    constructor(component) {
        this.component = component;
    }
    // Returns the SharedObject factory for the given type id.
    getModule(type) {
        Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`Chaincode.getModule(${type})`);
        return this.component[typeToFactorySym].get(type) || console.assert(false);
    }
    // NYI?
    close() { return Promise.resolve(); }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])("Chaincode.run()");
            return new ComponentPlatform(Promise.resolve(this.component));
        });
    }
}
/**
 * Base class for chainloadable Prague components.
 */
class Component extends events__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"] {
    constructor(types) {
        super();
        // tslint:disable-next-line:variable-name
        this._host = null;
        // tslint:disable-next-line:variable-name
        this._platform = null;
        // tslint:disable-next-line:variable-name
        this._root = null;
        /**
         * Invoked by 'attach' to ensure that create/opened are called the first time
         * a component is attached.  Subsequent calls ignore are a no-op.
         */
        this.ensureOpened = () => __awaiter(this, void 0, void 0, function* () {
            // If the '_root' map is already initialized, than this is component has already been
            // prepared.  Promptly return 'this'.
            if (this._root) {
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.ensureOpened() - already open`);
                return this;
            }
            if (this.host.existing) {
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.ensureOpened() - already exists`);
                // If the component already exists, open it's root map.
                this._root = (yield this.host.getChannel(Component.rootMapId));
            }
            else {
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.ensureOpened() - new component`);
                // If this is the first client to attempt opening the component, create the component's
                // root map and call 'create()' to give the component author a chance to initialize the
                // component's shared data structures.
                this._root = this.host.createChannel(Component.rootMapId, _prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"].Type);
                this._root.attach();
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.create() - begin`);
                yield this.create();
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.create() - end`);
            }
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.opened() - begin`);
            yield this.opened();
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.opened() - end`);
            return this;
        });
        // Construct a map of extension types to their corresponding factory.
        const typeToFactory = new Map(types);
        // Ensure that the map includes the shared map type.  This is necessary because
        // all components construct a shared map to be their root.
        if (!typeToFactory.has(_prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"].Type)) {
            typeToFactory.set(_prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"].Type, new _prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"]());
        }
        // Internally expose the 'typeToFactory' map to 'Chaincode.getModule()'.
        this[typeToFactorySym] = typeToFactory;
    }
    get dbgName() {
        return `${this.constructor.name}${this.host ? `:'${this.host.id}'` : ""}`;
    }
    get runtime() { return this._host; }
    get platform() { return this._platform; }
    get host() { return this._host; }
    get root() { return this._root; }
    /**
     * Returns a promise that resolves once the component is synchronized with its date store.
     * If the component is already connected, returns a resolved promise.
     */
    get connected() {
        if (this.host.connected) {
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.connected: Already connected.`);
            return Promise.resolve();
        }
        Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.connected: Waiting...`);
        return new Promise((accept) => {
            this.host.on("connected", () => {
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.connected: Now connected.`);
                accept();
            });
        });
    }
    /**
     * Constructs an IChaincode from a Component instance.  All chaincode components must
     * export an 'instantiate()' function from their module that returns an IChaincode as
     * shown in the following example:
     *
     * @example
     * const pkg = require("../package.json")
     *
     * export async function instantiateRuntime(context: IContainerContext) {
     *     return Component.instantiateRuntime(context, pkg.name,
     *          [[pkg.name, Promise.resolve({ instantiateComponent })]]);
     * }
     * @example
     */
    static instantiateRuntime(context, chaincode, registry) {
        return __awaiter(this, void 0, void 0, function* () {
            const runtimeId = encodeURIComponent(chaincode);
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`instantiateRuntime(chaincode=${chaincode},registry=${JSON.stringify(registry)})`);
            const runtime = yield _prague_runtime__WEBPACK_IMPORTED_MODULE_2__["Runtime"].Load(new Map(registry.map(([name, ctorFn]) => [
                name,
                Promise.resolve({ instantiateComponent: () => Promise.resolve(new ctorFn()) }),
            ])), context);
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])("runtime loaded.");
            // Register path handler for inbound messages
            runtime.registerRequestHandler((request) => __awaiter(this, void 0, void 0, function* () {
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`request(url=${request.url})`);
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`awaiting root component`);
                const componentRuntime = yield runtime.getComponent(runtimeId, /* wait: */ true);
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`have root component`);
                if (request.url && request.url !== "/") {
                    Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`delegating to ${request.url}`);
                    const component = componentRuntime.chaincode;
                    return component.request(componentRuntime, { url: request.url });
                }
                else {
                    Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`resolved ${runtimeId}`);
                    return { status: 200, mimeType: "prague/component", value: componentRuntime };
                }
            }));
            // On first boot create the base component
            if (!runtime.existing) {
                Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`createAndAttachComponent(chaincode=${chaincode})`);
                runtime.createAndAttachComponent(runtimeId, chaincode).catch((error) => {
                    context.error(error);
                });
            }
            return runtime;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.close()`);
            this.host.close();
        });
    }
    run(runtime) {
        return __awaiter(this, void 0, void 0, function* () {
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.run()`);
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.LoadFromSnapshot() - begin`);
            this._host = yield _prague_component__WEBPACK_IMPORTED_MODULE_0__["ComponentHost"].LoadFromSnapshot(runtime, new LegacyChaincode(this));
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.LoadFromSnapshot() - end`);
            return this._host;
        });
    }
    attach(platform) {
        return __awaiter(this, void 0, void 0, function* () {
            Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.attach()`);
            this._platform = platform;
            return new ComponentPlatform(this.ensureOpened());
        });
    }
    snapshot() {
        Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.snapshot()`);
        return { entries: this._host.snapshotInternal(), sha: null };
    }
    /**
     * Subclasses may override request to internally route requests.
     */
    request(runtime, request) {
        Object(_debug__WEBPACK_IMPORTED_MODULE_4__["debug"])(`${this.dbgName}.request(${JSON.stringify(request)})`);
        return runtime.request(request);
    }
}
Component.rootMapId = "root";
//# sourceMappingURL=component.js.map

/***/ }),

/***/ "./node_modules/@prague/app-component/lib/debug.js":
/*!*********************************************************!*\
  !*** ./node_modules/@prague/app-component/lib/debug.js ***!
  \*********************************************************/
/*! exports provided: debug */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const debug = debug__WEBPACK_IMPORTED_MODULE_0__("prague:component");
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@prague/app-component/lib/document.js":
/*!************************************************************!*\
  !*** ./node_modules/@prague/app-component/lib/document.js ***!
  \************************************************************/
/*! exports provided: Document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Document", function() { return Document; });
/* harmony import */ var _prague_cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/cell */ "./node_modules/@prague/cell/lib/index.js");
/* harmony import */ var _prague_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/map */ "./node_modules/@prague/map/lib/index.js");
/* harmony import */ var _prague_sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @prague/sequence */ "./node_modules/@prague/sequence/lib/index.js");
/* harmony import */ var _prague_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prague/stream */ "./node_modules/@prague/stream/lib/index.js");
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js");
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(uuid_v4__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./component */ "./node_modules/@prague/app-component/lib/component.js");






class Document extends _component__WEBPACK_IMPORTED_MODULE_5__["Component"] {
    constructor() {
        // Register default map value types
        Object(_prague_map__WEBPACK_IMPORTED_MODULE_1__["registerDefaultValueType"])(new _prague_map__WEBPACK_IMPORTED_MODULE_1__["DistributedSetValueType"]());
        Object(_prague_map__WEBPACK_IMPORTED_MODULE_1__["registerDefaultValueType"])(new _prague_map__WEBPACK_IMPORTED_MODULE_1__["CounterValueType"]());
        Object(_prague_map__WEBPACK_IMPORTED_MODULE_1__["registerDefaultValueType"])(new _prague_sequence__WEBPACK_IMPORTED_MODULE_2__["SharedStringIntervalCollectionValueType"]());
        Object(_prague_map__WEBPACK_IMPORTED_MODULE_1__["registerDefaultValueType"])(new _prague_sequence__WEBPACK_IMPORTED_MODULE_2__["SharedIntervalCollectionValueType"]());
        // Create channel extensions
        const mapExtension = new _prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"]();
        const sharedStringExtension = new _prague_sequence__WEBPACK_IMPORTED_MODULE_2__["SharedStringExtension"]();
        const streamExtension = new _prague_stream__WEBPACK_IMPORTED_MODULE_3__["StreamExtension"]();
        const cellExtension = new _prague_cell__WEBPACK_IMPORTED_MODULE_0__["CellExtension"]();
        const objectSequenceExtension = new _prague_sequence__WEBPACK_IMPORTED_MODULE_2__["SharedObjectSequenceExtension"]();
        const numberSequenceExtension = new _prague_sequence__WEBPACK_IMPORTED_MODULE_2__["SharedNumberSequenceExtension"]();
        // Register channel extensions
        super([
            [mapExtension.type, mapExtension],
            [sharedStringExtension.type, sharedStringExtension],
            [streamExtension.type, streamExtension],
            [cellExtension.type, cellExtension],
            [objectSequenceExtension.type, objectSequenceExtension],
            [numberSequenceExtension.type, numberSequenceExtension],
        ]);
    }
    /**
     * Subclass implements 'opened()' to finish initialization after the component has been opened/created.
     */
    opened() {
        return Promise.resolve();
    }
    /**
     * Creates a new shared map
     */
    createMap(id = uuid_v4__WEBPACK_IMPORTED_MODULE_4__()) {
        return this.runtime.createChannel(id, _prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"].Type);
    }
    /**
     * Creates a new shared cell.
     */
    createCell(id = uuid_v4__WEBPACK_IMPORTED_MODULE_4__()) {
        return this.runtime.createChannel(id, _prague_cell__WEBPACK_IMPORTED_MODULE_0__["CellExtension"].Type);
    }
    /**
     * Creates a new shared string
     */
    createString(id = uuid_v4__WEBPACK_IMPORTED_MODULE_4__()) {
        return this.runtime.createChannel(id, _prague_sequence__WEBPACK_IMPORTED_MODULE_2__["SharedStringExtension"].Type);
    }
    /**
     * Creates a new ink shared object
     */
    createStream(id = uuid_v4__WEBPACK_IMPORTED_MODULE_4__()) {
        return this.runtime.createChannel(id, _prague_stream__WEBPACK_IMPORTED_MODULE_3__["StreamExtension"].Type);
    }
}
//# sourceMappingURL=document.js.map

/***/ }),

/***/ "./node_modules/@prague/app-component/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@prague/app-component/lib/index.js ***!
  \*********************************************************/
/*! exports provided: Component, Document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ "./node_modules/@prague/app-component/lib/component.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _component__WEBPACK_IMPORTED_MODULE_0__["Component"]; });

/* harmony import */ var _document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./document */ "./node_modules/@prague/app-component/lib/document.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Document", function() { return _document__WEBPACK_IMPORTED_MODULE_1__["Document"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/lib/cell.js":
/*!***********************************************!*\
  !*** ./node_modules/@prague/cell/lib/cell.js ***!
  \***********************************************/
/*! exports provided: CellValueType, Cell */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CellValueType", function() { return CellValueType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return Cell; });
/* harmony import */ var _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/api-definitions */ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/index.js");
/* harmony import */ var _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug */ "./node_modules/@prague/cell/lib/debug.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/cell/lib/extension.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




var CellValueType;
(function (CellValueType) {
    // The value is another shared object
    CellValueType[CellValueType["Shared"] = 0] = "Shared";
    // The value is a plain JavaScript object
    CellValueType[CellValueType["Plain"] = 1] = "Plain";
})(CellValueType || (CellValueType = {}));
const snapshotFileName = "header";
/**
 * Implementation of a cell shared object
 */
class Cell extends _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["SharedObject"] {
    /**
     * Constructs a new shared cell. If the object is non-local an id and service interfaces will
     * be provided
     */
    constructor(id, runtime) {
        super(id, runtime, _extension__WEBPACK_IMPORTED_MODULE_3__["CellExtension"].Type);
    }
    /**
     * Retrieves the value of the cell.
     */
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.data;
        });
    }
    /**
     * Sets the value of the cell.
     */
    set(value) {
        return __awaiter(this, void 0, void 0, function* () {
            let operationValue;
            /* tslint:disable:no-unsafe-any */
            if (value instanceof _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["SharedObject"]) {
                // Convert any local shared objects to our internal storage format
                if (!this.isLocal()) {
                    value.attach();
                }
                operationValue = {
                    type: CellValueType[CellValueType.Shared],
                    value: value.id,
                };
            }
            else {
                operationValue = {
                    type: CellValueType[CellValueType.Plain],
                    value,
                };
            }
            const op = {
                type: "setCell",
                value: operationValue,
            };
            this.setCore(value);
            this.submitIfAttached(op);
        });
    }
    // Deletes the value from the cell.
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            const op = {
                type: "deleteCell",
            };
            this.deleteCore();
            this.submitIfAttached(op);
        });
    }
    /**
     * Returns whether cell is empty or not.
     */
    empty() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.data === undefined ? true : false;
        });
    }
    snapshot() {
        // Get a serializable form of data
        let content;
        if (this.data instanceof _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["SharedObject"]) {
            content = {
                type: CellValueType[CellValueType.Shared],
                value: this.data.id,
            };
        }
        else {
            content = {
                type: CellValueType[CellValueType.Plain],
                value: this.data,
            };
        }
        // And then construct the tree for it
        const tree = {
            entries: [
                {
                    mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["FileMode"].File,
                    path: snapshotFileName,
                    type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["TreeEntry"].Blob],
                    value: {
                        contents: JSON.stringify(content),
                        encoding: "utf-8",
                    },
                },
            ],
            sha: null,
        };
        return tree;
    }
    loadCore(minimumSequenceNumber, headerOrigin, storage) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawContent = yield storage.read(snapshotFileName);
            // tslint:disable-next-line:strict-boolean-expressions
            const content = rawContent
                ? JSON.parse(Buffer.from(rawContent, "base64")
                    .toString("utf-8"))
                : { type: CellValueType[CellValueType.Plain], value: undefined };
            this.data = content.type === CellValueType[CellValueType.Shared]
                ? yield this.runtime.getChannel(content.value)
                : content.value;
        });
    }
    initializeLocalCore() {
        this.data = undefined;
    }
    attachCore() {
        return;
    }
    onDisconnect() {
        Object(_debug__WEBPACK_IMPORTED_MODULE_2__["debug"])(`Cell ${this.id} is now disconnected`);
    }
    onConnect(pending) {
        for (const message of pending) {
            this.submitLocalMessage(message);
        }
        return;
    }
    prepareCore(message, local) {
        return __awaiter(this, void 0, void 0, function* () {
            if (message.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Operation && !local) {
                const op = message.contents;
                if (op.type === "setCell") {
                    /* tslint:disable:no-return-await */
                    return op.value.type === CellValueType[CellValueType.Shared]
                        ? yield this.runtime.getChannel(op.value.value)
                        : op.value.value;
                }
            }
        });
    }
    processCore(message, local, context) {
        if (message.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Operation && !local) {
            const op = message.contents;
            switch (op.type) {
                case "setCell":
                    this.setCore(context);
                    break;
                case "deleteCell":
                    this.deleteCore();
                    break;
                default:
                    throw new Error("Unknown operation");
            }
        }
    }
    processMinSequenceNumberChanged(value) {
        return;
    }
    submitIfAttached(message) {
        if (this.isLocal()) {
            return;
        }
        this.submitLocalMessage(message);
    }
    setCore(value) {
        this.data = value;
        this.emit("valueChanged", value);
    }
    deleteCore() {
        this.data = undefined;
        this.emit("delete");
    }
}
//# sourceMappingURL=cell.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/cell/lib/debug.js":
/*!************************************************!*\
  !*** ./node_modules/@prague/cell/lib/debug.js ***!
  \************************************************/
/*! exports provided: debug */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const debug = debug__WEBPACK_IMPORTED_MODULE_0__("prague:cell");
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/lib/extension.js":
/*!****************************************************!*\
  !*** ./node_modules/@prague/cell/lib/extension.js ***!
  \****************************************************/
/*! exports provided: CellExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CellExtension", function() { return CellExtension; });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/@prague/cell/lib/cell.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

/**
 * The extension that defines the map
 */
class CellExtension {
    constructor() {
        this.type = CellExtension.Type;
    }
    load(document, id, minimumSequenceNumber, services, headerOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            const cell = new _cell__WEBPACK_IMPORTED_MODULE_0__["Cell"](id, document);
            yield cell.load(minimumSequenceNumber, headerOrigin, services);
            return cell;
        });
    }
    create(document, id) {
        const cell = new _cell__WEBPACK_IMPORTED_MODULE_0__["Cell"](id, document);
        cell.initializeLocal();
        return cell;
    }
}
CellExtension.Type = "https://graph.microsoft.com/types/cell";
//# sourceMappingURL=extension.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@prague/cell/lib/index.js ***!
  \************************************************/
/*! exports provided: CellValueType, Cell, CellExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/@prague/cell/lib/cell.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CellValueType", function() { return _cell__WEBPACK_IMPORTED_MODULE_0__["CellValueType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cell", function() { return _cell__WEBPACK_IMPORTED_MODULE_0__["Cell"]; });

/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/cell/lib/extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CellExtension", function() { return _extension__WEBPACK_IMPORTED_MODULE_1__["CellExtension"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/debug.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/debug.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const registerDebug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
exports.debug = registerDebug("prague:api-definitions");
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/extension.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/extension.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class that contains a collection of collaboration extensions
 */
class Registry {
    constructor() {
        this.extensions = [];
        this.extensionsMap = {};
    }
    /**
     * Registers a new extension
     * @param extension The extension to register
     */
    register(extension) {
        this.extensions.push(extension);
        this.extensionsMap[extension.type] = extension;
    }
    /**
     * Retrieves the extension with the given id
     * @param id ID for the extension to retrieve
     */
    getExtension(type) {
        if (!(type in this.extensionsMap)) {
            throw new Error("Extension not found");
        }
        return this.extensionsMap[type];
    }
}
exports.Registry = Registry;
//# sourceMappingURL=extension.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./sharedObject */ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/sharedObject.js"));
__export(__webpack_require__(/*! ./extension */ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/extension.js"));
__export(__webpack_require__(/*! ./valueType */ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/valueType.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/sharedObject.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/sharedObject.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
const assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
const Deque = __webpack_require__(/*! double-ended-queue */ "./node_modules/double-ended-queue/js/deque.js");
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const debug_1 = __webpack_require__(/*! ./debug */ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/debug.js");
const valueType_1 = __webpack_require__(/*! ./valueType */ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/valueType.js");
class SharedObject extends events_1.EventEmitter {
    constructor(id, runtime, type) {
        super();
        this.id = id;
        this.runtime = runtime;
        this.type = type;
        // tslint:disable-next-line:variable-name
        this.__sharedObject__ = true;
        // tslint:disable-next-line:variable-name private fields exposed via getters
        this._state = container_definitions_1.ConnectionState.Disconnected;
        // Locally applied operations not yet ACK'd by the server
        this.pendingOps = new Deque();
    }
    get state() {
        return this._state;
    }
    toJSON() {
        return {
            type: valueType_1.ValueType[valueType_1.ValueType.Shared],
            value: this.id,
        };
    }
    /**
     * A shared object, after construction, can either be loaded in the case that it is already part of
     * a shared document. Or later attached if it is being newly added.
     */
    load(minimumSequenceNumber, headerOrigin, services) {
        return __awaiter(this, void 0, void 0, function* () {
            this.services = services;
            yield this.loadCore(minimumSequenceNumber, headerOrigin, services.objectStorage);
            this.attachDeltaHandler();
        });
    }
    /**
     * Initializes the object as a local, non-shared object. This object can become shared after
     * it is attached to the document.
     */
    initializeLocal() {
        this.initializeLocalCore();
    }
    /**
     * Attaches the given shared object to its containing document
     */
    attach() {
        if (!this.isLocal()) {
            return this;
        }
        // Allow derived classes to perform custom processing prior to attaching this object
        this.attachCore();
        // Notify the document of the attachment
        this.services = this.runtime.attachChannel(this);
        this.attachDeltaHandler();
        return this;
    }
    /**
     * Returns whether the given shared object is local
     */
    isLocal() {
        return !this.services;
    }
    /* tslint:disable:no-unnecessary-override */
    on(event, listener) {
        return super.on(event, listener);
    }
    /**
     * Processes a message by the local client
     */
    submitLocalMessage(content) {
        assert(!this.isLocal());
        // Send if we are connected - otherwise just add to the sent list
        let clientSequenceNumber = -1;
        if (this.state === container_definitions_1.ConnectionState.Connected) {
            clientSequenceNumber = this.services.deltaConnection.submit(content);
        }
        else {
            debug_1.debug(`${this.id} Not fully connected - adding to pending list`, content);
            // Store the message for when it is ACKed and then submit to the server if connected
        }
        this.pendingOps.push({ clientSequenceNumber, content });
        return clientSequenceNumber;
    }
    attachDeltaHandler() {
        this.services.deltaConnection.attach({
            minSequenceNumberChanged: (value) => {
                this.processMinSequenceNumberChanged(value);
            },
            prepare: (message, local) => {
                return this.prepare(message, local);
            },
            process: (message, local, context) => {
                this.process(message, local, context);
            },
            setConnectionState: (state) => {
                this.setConnectionState(state);
            },
        });
        // Trigger initial state
        this.setConnectionState(this.services.deltaConnection.state);
    }
    prepare(message, local) {
        return this.prepareCore(message, local);
    }
    setConnectionState(state) {
        // Should I change the state at the end? So that we *can't* send new stuff before we send old?
        this._state = state;
        switch (state) {
            case container_definitions_1.ConnectionState.Disconnected:
                // Things that are true now...
                // - if we had a connection we can no longer send messages over it
                // - if we had outbound messages some may or may not be ACK'd. Won't know until next message
                //
                // - nack could get a new msn - but might as well do it in the join?
                this.onDisconnect();
                break;
            case container_definitions_1.ConnectionState.Connecting:
                // Things that are now true...
                // - we will begin to receive inbound messages
                // - we know what our new client id is.
                // - still not safe to send messages
                // While connecting we are still ticking off the previous messages
                debug_1.debug(`${this.id} is now connecting`);
                break;
            case container_definitions_1.ConnectionState.Connected:
                // Extract all un-ack'd payload operation
                const pendingOps = this.pendingOps.toArray().map((value) => value.content);
                this.pendingOps.clear();
                // And now we are fully connected
                // - we have a client ID
                // - we are caught up enough to attempt to send messages
                this.onConnect(pendingOps);
                break;
            default:
                assert.ok(false, `Unknown ConnectionState ${state}`);
        }
    }
    /**
     * Handles a message being received from the remote delta server
     */
    process(message, local, context) {
        if (message.type === container_definitions_1.MessageType.Operation && local) {
            // disconnected ops should never be processed. They should have been fully sent on connected
            assert(this.pendingOps.length === 0 || this.pendingOps.peekFront().clientSequenceNumber !== -1, `process for disconnected op ${this.pendingOps.peekFront().clientSequenceNumber}`);
            // One of our messages was sequenced. We can remove it from the local message list. Given these arrive
            // in order we only need to check the beginning of the local list.
            if (this.pendingOps.length > 0 &&
                this.pendingOps.peekFront().clientSequenceNumber === message.clientSequenceNumber) {
                this.pendingOps.shift();
                if (this.pendingOps.length === 0) {
                    this.emit("processed");
                }
            }
            else {
                debug_1.debug(`Duplicate ack received ${message.clientSequenceNumber}`);
            }
        }
        this.emit("pre-op", message, local);
        this.processCore(message, local, context);
        this.emit("op", message, local);
    }
}
exports.SharedObject = SharedObject;
//# sourceMappingURL=sharedObject.js.map

/***/ }),

/***/ "./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/valueType.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@prague/cell/node_modules/@prague/api-definitions/dist/valueType.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// TODO this is probably too map specific - but is used to serailize objects in certain cases
var ValueType;
(function (ValueType) {
    // The value is a shared object
    ValueType[ValueType["Shared"] = 0] = "Shared";
    // The value is a plain JavaScript object
    ValueType[ValueType["Plain"] = 1] = "Plain";
    // The value is a counter
    ValueType[ValueType["Counter"] = 2] = "Counter";
    // The value is a set
    ValueType[ValueType["Set"] = 3] = "Set";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=valueType.js.map

/***/ }),

/***/ "./node_modules/@prague/component/dist/channelDeltaConnection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@prague/component/dist/channelDeltaConnection.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
class ChannelDeltaConnection {
    constructor(objectId, 
    // tslint:disable-next-line:variable-name
    _state, submitFn) {
        this.objectId = objectId;
        this._state = _state;
        this.submitFn = submitFn;
    }
    get state() {
        return this._state;
    }
    attach(handler) {
        /* tslint:disable:strict-boolean-expressions */
        assert(!this.handler);
        this.handler = handler;
    }
    setConnectionState(state) {
        this._state = state;
        this.handler.setConnectionState(state);
    }
    prepare(message, local) {
        assert(this.handler);
        return this.handler.prepare(message, local);
    }
    process(message, local, context) {
        assert(this.handler);
        this.handler.process(message, local, context);
    }
    updateMinSequenceNumber(value) {
        assert(this.handler);
        this.handler.minSequenceNumberChanged(value);
    }
    /**
     * Send new messages to the server
     */
    submit(message) {
        return this.submitFn(message);
    }
}
exports.ChannelDeltaConnection = ChannelDeltaConnection;
//# sourceMappingURL=channelDeltaConnection.js.map

/***/ }),

/***/ "./node_modules/@prague/component/dist/channelStorageService.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prague/component/dist/channelStorageService.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ChannelStorageService {
    constructor(tree, storage) {
        this.storage = storage;
        this.flattenedTree = {};
        // Create a map from paths to blobs
        /* tslint:disable:strict-boolean-expressions */
        if (tree) {
            ChannelStorageService.flattenTree("", tree, this.flattenedTree);
        }
    }
    static flattenTree(base, tree, results) {
        // tslint:disable-next-line:forin
        for (const path in tree.trees) {
            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);
        }
        // tslint:disable-next-line:forin
        for (const blob in tree.blobs) {
            results[`${base}${blob}`] = tree.blobs[blob];
        }
    }
    /* tslint:disable:promise-function-async */
    read(path) {
        const sha = this.getShaForPath(path);
        return this.storage.read(sha);
    }
    getShaForPath(path) {
        return this.flattenedTree[path];
    }
}
exports.ChannelStorageService = ChannelStorageService;
//# sourceMappingURL=channelStorageService.js.map

/***/ }),

/***/ "./node_modules/@prague/component/dist/componentHost.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prague/component/dist/componentHost.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
const utils_1 = __webpack_require__(/*! @prague/utils */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/index.js");
const assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const channelDeltaConnection_1 = __webpack_require__(/*! ./channelDeltaConnection */ "./node_modules/@prague/component/dist/channelDeltaConnection.js");
const channelStorageService_1 = __webpack_require__(/*! ./channelStorageService */ "./node_modules/@prague/component/dist/channelStorageService.js");
const localChannelStorageService_1 = __webpack_require__(/*! ./localChannelStorageService */ "./node_modules/@prague/component/dist/localChannelStorageService.js");
class ServicePlatform extends events_1.EventEmitter {
    constructor(services) {
        super();
        this.qi = new Map(services);
    }
    queryInterface(id) {
        return this.qi.get(id) || Promise.reject(`queryInterface() failed - Unknown id '${id}'.`);
    }
    detach() {
        return;
    }
}
/**
 * Base component class
 */
class ComponentHost extends events_1.EventEmitter {
    // tslint:enable-next-line:variable-name
    constructor(componentRuntime, tenantId, documentId, id, parentBranch, existing, options, blobManager, deltaManager, quorum, chaincode, storageService, snapshotFn, closeFn) {
        super();
        this.componentRuntime = componentRuntime;
        this.tenantId = tenantId;
        this.documentId = documentId;
        this.id = id;
        this.parentBranch = parentBranch;
        this.existing = existing;
        this.options = options;
        this.blobManager = blobManager;
        this.deltaManager = deltaManager;
        this.quorum = quorum;
        this.chaincode = chaincode;
        this.storageService = storageService;
        this.snapshotFn = snapshotFn;
        this.closeFn = closeFn;
        this.channels = new Map();
        this.channelsDeferred = new Map();
        this.closed = false;
        this.pendingAttach = new Map();
    }
    static LoadFromSnapshot(componentRuntime, chaincode) {
        return __awaiter(this, void 0, void 0, function* () {
            const tree = componentRuntime.baseSnapshot;
            const runtime = new ComponentHost(componentRuntime, componentRuntime.tenantId, componentRuntime.documentId, componentRuntime.id, componentRuntime.parentBranch, componentRuntime.existing, componentRuntime.options, componentRuntime.blobManager, componentRuntime.deltaManager, componentRuntime.getQuorum(), chaincode, componentRuntime.storage, componentRuntime.snapshotFn, componentRuntime.closeFn);
            // Must always receive the component type inside of the attributes
            if (tree && tree.trees) {
                Object.keys(tree.trees).forEach((path) => {
                    // Reserve space for the channel
                    runtime.reserve(path);
                });
                /* tslint:disable:promise-function-async */
                const loadSnapshotsP = Object.keys(tree.trees).map((path) => {
                    return runtime.loadSnapshotChannel(path, tree.trees[path], componentRuntime.storage, componentRuntime.branch);
                });
                yield Promise.all(loadSnapshotsP);
            }
            // Start the runtime
            yield runtime.start();
            return runtime;
        });
    }
    get connected() {
        return this.componentRuntime.connected;
    }
    // Interface used to access the runtime code
    get platform() {
        return this._platform;
    }
    get clientId() {
        return this.componentRuntime.clientId;
    }
    createAndAttachComponent(id, pkg) {
        return this.componentRuntime.createAndAttachComponent(id, pkg);
    }
    getComponent(id, wait) {
        return this.componentRuntime.getComponent(id, wait);
    }
    /**
     * Opens the component with the given 'id'.  Once the component is retrieved, it is attached
     * with the given list of services.
     */
    openComponent(id, wait, services) {
        return __awaiter(this, void 0, void 0, function* () {
            const runtime = yield this.componentRuntime.getComponent(id, wait);
            const platform = yield runtime.attach(new ServicePlatform(services));
            return platform.queryInterface("component");
        });
    }
    request(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = request.url.substr(1);
            const value = yield this.getChannel(id);
            return { mimeType: "prague/dataType", status: 200, value };
        });
    }
    getChannel(id) {
        this.verifyNotClosed();
        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist
        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if
        // it doesn't exist
        if (!this.channelsDeferred.has(id)) {
            this.channelsDeferred.set(id, new utils_1.Deferred());
        }
        return this.channelsDeferred.get(id).promise;
    }
    createChannel(id, type) {
        this.verifyNotClosed();
        const extension = this.chaincode.getModule(type);
        const channel = extension.create(this, id);
        this.channels.set(id, { baseSha: null, object: channel, connection: null, storage: null });
        if (this.channelsDeferred.has(id)) {
            this.channelsDeferred.get(id).resolve(channel);
        }
        else {
            const deferred = new utils_1.Deferred();
            deferred.resolve(channel);
            this.channelsDeferred.set(id, deferred);
        }
        return channel;
    }
    attachChannel(channel) {
        this.verifyNotClosed();
        // Get the object snapshot and include it in the initial attach
        const snapshot = channel.snapshot();
        const message = {
            id: channel.id,
            snapshot,
            type: channel.type,
        };
        this.pendingAttach.set(channel.id, message);
        this.submit(container_definitions_1.MessageType.Attach, message);
        // Store a reference to the object in our list of objects and then get the services
        // used to attach it to the stream
        const services = this.getObjectServices(channel.id, null, this.storageService);
        const entry = this.channels.get(channel.id);
        assert.equal(entry.object, channel);
        entry.connection = services.deltaConnection;
        entry.storage = services.objectStorage;
        return services;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            this._platform = yield this.chaincode.run(this, null);
        });
    }
    changeConnectionState(value, clientId) {
        this.verifyNotClosed();
        // Resend all pending attach messages prior to notifying clients
        if (value === container_definitions_1.ConnectionState.Connected) {
            for (const [, message] of this.pendingAttach) {
                this.submit(container_definitions_1.MessageType.Attach, message);
            }
        }
        for (const [, object] of this.channels) {
            if (object.connection) {
                object.connection.setConnectionState(value);
            }
        }
        if (value === container_definitions_1.ConnectionState.Connected) {
            this.emit("connected", clientId);
        }
    }
    getQuorum() {
        this.verifyNotClosed();
        return this.quorum;
    }
    snapshot(message) {
        this.verifyNotClosed();
        return this.snapshotFn(message);
    }
    save(tag) {
        this.verifyNotClosed();
        this.submit(container_definitions_1.MessageType.Save, tag);
    }
    uploadBlob(file) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            const sha = utils_1.gitHashFile(file.content);
            file.sha = sha;
            file.url = this.storageService.getRawUrl(sha);
            yield this.blobManager.createBlob(file);
            this.submit(container_definitions_1.MessageType.BlobUploaded, yield this.blobManager.createBlob(file));
            return file;
        });
    }
    getBlob(sha) {
        this.verifyNotClosed();
        return this.blobManager.getBlob(sha);
    }
    getBlobMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.blobManager.getBlobMetadata();
        });
    }
    stop() {
        this.verifyNotClosed();
        this.closed = true;
        return this.snapshotInternal();
    }
    close() {
        this.closeFn();
    }
    prepare(message, local) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (message.type) {
                case container_definitions_1.MessageType.Attach:
                    return this.prepareAttach(message, local);
                case container_definitions_1.MessageType.Operation:
                    return this.prepareOp(message, local);
                default:
                    return;
            }
        });
    }
    process(message, local, context) {
        let target = null;
        switch (message.type) {
            case container_definitions_1.MessageType.Attach:
                target = this.processAttach(message, local, context);
                break;
            case container_definitions_1.MessageType.Operation:
                target = this.processOp(message, local, context);
                break;
            default:
        }
        this.emit("op", message, target);
    }
    updateMinSequenceNumber(msn) {
        for (const [, object] of this.channels) {
            if (!object.object.isLocal()) {
                object.connection.updateMinSequenceNumber(msn);
            }
        }
    }
    snapshotInternal() {
        const entries = new Array();
        this.updateMinSequenceNumber(this.deltaManager.minimumSequenceNumber);
        // Craft the .attributes file for each distributed object
        for (const [objectId, object] of this.channels) {
            // If the object isn't local - and we have received the sequenced op creating the object (i.e. it has a
            // base mapping) - then we go ahead and snapshot
            if (!object.object.isLocal()) {
                const snapshot = object.object.snapshot();
                // Add in the object attributes to the returned tree
                const objectAttributes = {
                    type: object.object.type,
                };
                snapshot.entries.push({
                    mode: container_definitions_1.FileMode.File,
                    path: ".attributes",
                    type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob],
                    value: {
                        contents: JSON.stringify(objectAttributes),
                        encoding: "utf-8",
                    },
                });
                // If baseSha exists then the previous snapshot is still valid
                if (object.baseSha) {
                    snapshot.sha = object.baseSha;
                }
                // And then store the tree
                entries.push({
                    mode: container_definitions_1.FileMode.Directory,
                    path: objectId,
                    type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Tree],
                    value: snapshot,
                });
            }
        }
        return entries;
    }
    submitMessage(type, content) {
        this.submit(type, content);
    }
    submit(type, content) {
        this.verifyNotClosed();
        return this.componentRuntime.submitMessage(type, content);
    }
    reserve(id) {
        if (!this.channelsDeferred.has(id)) {
            this.channelsDeferred.set(id, new utils_1.Deferred());
        }
    }
    prepareOp(message, local) {
        this.verifyNotClosed();
        const envelope = message.contents;
        const objectDetails = this.channels.get(envelope.address);
        assert(objectDetails);
        const transformed = {
            clientId: message.clientId,
            clientSequenceNumber: message.clientSequenceNumber,
            contents: envelope.contents,
            metadata: message.metadata,
            minimumSequenceNumber: message.minimumSequenceNumber,
            origin: message.origin,
            referenceSequenceNumber: message.referenceSequenceNumber,
            sequenceNumber: message.sequenceNumber,
            timestamp: message.timestamp,
            traces: message.traces,
            type: message.type,
        };
        return objectDetails.connection.prepare(transformed, local);
    }
    processOp(message, local, context) {
        this.verifyNotClosed();
        const envelope = message.contents;
        const objectDetails = this.channels.get(envelope.address);
        assert(objectDetails);
        // Clear base sha since the channel is now dirty
        objectDetails.baseSha = null;
        const transformed = {
            clientId: message.clientId,
            clientSequenceNumber: message.clientSequenceNumber,
            contents: envelope.contents,
            metadata: message.metadata,
            minimumSequenceNumber: message.minimumSequenceNumber,
            origin: message.origin,
            referenceSequenceNumber: message.referenceSequenceNumber,
            sequenceNumber: message.sequenceNumber,
            timestamp: message.timestamp,
            traces: message.traces,
            type: message.type,
        };
        objectDetails.connection.process(transformed, local, context);
        return objectDetails.object;
    }
    processAttach(message, local, context) {
        this.verifyNotClosed();
        const attachMessage = message.contents;
        // If a non-local operation then go and create the object - otherwise mark it as officially attached.
        if (local) {
            assert(this.pendingAttach.has(attachMessage.id));
            this.pendingAttach.delete(attachMessage.id);
        }
        else {
            const channelState = context;
            this.channels.set(channelState.object.id, channelState);
            if (this.channelsDeferred.has(channelState.object.id)) {
                this.channelsDeferred.get(channelState.object.id).resolve(channelState.object);
            }
            else {
                const deferred = new utils_1.Deferred();
                deferred.resolve(channelState.object);
                this.channelsDeferred.set(channelState.object.id, deferred);
            }
        }
        return this.channels.get(attachMessage.id).object;
    }
    prepareAttach(message, local) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            if (local) {
                return;
            }
            const attachMessage = message.contents;
            // create storage service that wraps the attach data
            const localStorage = new localChannelStorageService_1.LocalChannelStorageService(attachMessage.snapshot);
            const connection = new channelDeltaConnection_1.ChannelDeltaConnection(attachMessage.id, this.componentRuntime.connectionState, (submitMessage) => {
                const submitEnvelope = {
                    address: attachMessage.id,
                    contents: submitMessage,
                };
                return this.submit(container_definitions_1.MessageType.Operation, submitEnvelope);
            });
            const services = {
                baseSha: null,
                deltaConnection: connection,
                objectStorage: localStorage,
            };
            const origin = message.origin ? message.origin.id : this.id;
            const value = yield this.loadChannel(attachMessage.id, attachMessage.type, message.minimumSequenceNumber, services, origin);
            return value;
        });
    }
    loadSnapshotChannel(id, tree, storage, branch) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelAttributes = yield utils_1.readAndParse(storage, tree.blobs[".attributes"]);
            const services = this.getObjectServices(id, tree, storage);
            const channelDetails = yield this.loadChannel(id, channelAttributes.type, this.deltaManager.minimumSequenceNumber, services, branch);
            assert(!this.channels.has(id));
            this.channels.set(id, channelDetails);
            this.channelsDeferred.get(id).resolve(channelDetails.object);
        });
    }
    loadChannel(id, type, minSequenceNumber, services, originBranch) {
        return __awaiter(this, void 0, void 0, function* () {
            // Pass the transformedMessages - but the object really should be storing this
            const extension = this.chaincode.getModule(type);
            // TODO need to fix up the SN vs. MSN stuff here. If want to push messages to object also need
            // to store the mappings from channel ID to doc ID.
            const value = yield extension.load(this, id, minSequenceNumber, services, originBranch);
            return {
                baseSha: services.baseSha,
                connection: services.deltaConnection,
                object: value,
                storage: services.objectStorage,
            };
        });
    }
    getObjectServices(id, tree, storage) {
        const deltaConnection = new channelDeltaConnection_1.ChannelDeltaConnection(id, this.componentRuntime.connectionState, (message) => {
            const envelope = { address: id, contents: message };
            return this.submit(container_definitions_1.MessageType.Operation, envelope);
        });
        const objectStorage = new channelStorageService_1.ChannelStorageService(tree, storage);
        return {
            baseSha: tree ? tree.sha : null,
            deltaConnection,
            objectStorage,
        };
    }
    verifyNotClosed() {
        if (this.closed) {
            throw new Error("Runtime is closed");
        }
    }
}
exports.ComponentHost = ComponentHost;
//# sourceMappingURL=componentHost.js.map

/***/ }),

/***/ "./node_modules/@prague/component/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@prague/component/dist/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./componentHost */ "./node_modules/@prague/component/dist/componentHost.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/component/dist/localChannelStorageService.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@prague/component/dist/localChannelStorageService.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
class LocalChannelStorageService {
    constructor(tree) {
        this.tree = tree;
    }
    /* tslint:disable:promise-function-async */
    read(path) {
        const contents = this.readSync(path);
        return contents !== undefined ? Promise.resolve(contents) : Promise.reject("Not found");
    }
    /**
     * Provides a synchronous access point to locally stored data
     */
    readSync(path) {
        return this.readSyncInternal(path, this.tree);
    }
    readSyncInternal(path, tree) {
        for (const entry of tree.entries) {
            switch (entry.type) {
                case container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob]:
                    if (path === entry.path) {
                        const blob = entry.value;
                        return blob.encoding === "utf-8"
                            ? new Buffer(blob.contents).toString("base64")
                            : blob.contents;
                    }
                    break;
                case container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Tree]:
                    if (path.indexOf(entry.path) === 0) {
                        return this.readSyncInternal(path.substr(entry.path.length + 1), entry.value);
                    }
                    break;
                default:
            }
        }
        return undefined;
    }
}
exports.LocalChannelStorageService = LocalChannelStorageService;
//# sourceMappingURL=localChannelStorageService.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/batchManager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/batchManager.js ***!
  \***************************************************************************************/
/*! exports provided: BatchManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchManager", function() { return BatchManager; });
const MaxBatchSize = 100;
class BatchManager {
    constructor(process) {
        this.process = process;
        this.pendingWork = new Map();
    }
    add(id, work) {
        if (!this.pendingWork.has(id)) {
            this.pendingWork.set(id, []);
        }
        this.pendingWork.get(id)
            .push(work);
        if (this.pendingWork.get(id).length >= MaxBatchSize) {
            clearTimeout(this.pendingTimer);
            this.pendingTimer = undefined;
            this.startWork();
        }
        else if (this.pendingTimer === undefined) {
            this.pendingTimer = setTimeout(() => {
                this.pendingTimer = undefined;
                this.startWork();
            }, 0);
        }
    }
    /**
     * Resolves once all pending work is complete
     */
    drain() {
        this.startWork();
    }
    startWork() {
        // Clear the internal flags first to avoid issues in case any of the pending work calls back into
        // the batch manager. We could also do this with a second setImmediate call but avodiing in order
        // to process the work quicker.
        const pendingWork = this.pendingWork;
        this.pendingWork = new Map();
        // TODO log to influx how much pending work there is. We want to limit the size of a batch
        for (const [id, batch] of pendingWork) {
            this.process(id, batch);
        }
    }
}
//# sourceMappingURL=batchManager.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/blobs.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/blobs.js ***!
  \********************************************************************************/
/*! exports provided: gitHashFile, flatten, readAndParse, buildHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gitHashFile", function() { return gitHashFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readAndParse", function() { return readAndParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildHierarchy", function() { return buildHierarchy; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sha.js/sha1 */ "./node_modules/sha.js/sha1.js");
/* harmony import */ var sha_js_sha1__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// tslint:disable-next-line:no-submodule-imports

/**
 * Create Hash (Github hashes the string with blob and size)
 * @param file The contents of the file in a buffer
 */
function gitHashFile(file) {
    const size = file.byteLength;
    const filePrefix = "blob " + size.toString() + String.fromCharCode(0);
    /* tslint:disable:no-unsafe-any */
    const engine = new sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__();
    return engine.update(filePrefix)
        .update(file)
        .digest("hex");
}
function flatten(tree, blobMap) {
    const entries = flattenCore("", tree, blobMap);
    return {
        sha: null,
        tree: entries,
        url: null,
    };
}
function readAndParse(storage, sha) {
    return __awaiter(this, void 0, void 0, function* () {
        const encoded = yield storage.read(sha);
        const decoded = Buffer
            .from(encoded, "base64")
            .toString();
        return JSON.parse(decoded);
    });
}
function flattenCore(path, treeEntries, blobMap) {
    const entries = new Array();
    for (const treeEntry of treeEntries) {
        const subPath = `${path}${treeEntry.path}`;
        if (treeEntry.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob]) {
            const blob = treeEntry.value;
            const buffer = Buffer.from(blob.contents, blob.encoding);
            const sha = gitHashFile(buffer);
            blobMap.set(sha, buffer.toString("base64"));
            const entry = {
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"][treeEntry.mode],
                path: subPath,
                sha,
                size: buffer.length,
                type: "blob",
                url: "",
            };
            entries.push(entry);
        }
        else {
            const t = treeEntry.value;
            const entry = {
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"][treeEntry.mode],
                path: subPath,
                sha: null,
                size: -1,
                type: "tree",
                url: "",
            };
            entries.push(entry);
            const subTreeEntries = flattenCore(subPath + "/", t.entries, blobMap);
            entries.push(...subTreeEntries);
        }
    }
    return entries;
}
function buildHierarchy(flatTree) {
    if (!flatTree) {
        return null;
    }
    const lookup = {};
    const root = { sha: flatTree.sha, blobs: {}, commits: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.tree) {
        const lastIndex = entry.path.lastIndexOf("/");
        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entry.path.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { sha: entry.sha, blobs: {}, commits: {}, trees: {} };
            node.trees[entryPathBase] = newTree;
            lookup[entry.path] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[entryPathBase] = entry.sha;
        }
        else if (entry.type === "commit") {
            node.commits[entryPathBase] = entry.sha;
        }
    }
    return root;
}
//# sourceMappingURL=blobs.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/heap.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/heap.js ***!
  \*******************************************************************************/
/*! exports provided: NumberComparer, Heap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberComparer", function() { return NumberComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return Heap; });
// tslint:disable:no-bitwise
// tslint:disable:no-increment-decrement
// tslint:disable:no-parameter-reassignment
const NumberComparer = {
    compare: (a, b) => a - b,
    min: Number.MIN_VALUE,
};
class Heap {
    constructor(comp) {
        this.comp = comp;
        this.L = [{ value: comp.min, position: 0 }];
    }
    peek() {
        return this.L[1];
    }
    get() {
        this.swap(1, this.count());
        const x = this.L.pop();
        this.fixdown(1);
        return x.value;
    }
    add(x) {
        const node = { value: x, position: this.L.length };
        this.L.push(node);
        this.fixup(this.count());
        return node;
    }
    /**
     * Allows for heap to be updated after a node's value changes
     */
    update(node) {
        const k = node.position;
        if (this.isGreaterThanParent(k)) {
            this.fixup(k);
        }
        else {
            this.fixdown(k);
        }
    }
    /**
     * Removes the given node from the heap
     */
    remove(node) {
        // Move the node we want to remove to the end of the array
        const position = node.position;
        this.swap(node.position, this.L.length - 1);
        this.L.splice(this.L.length - 1);
        // Update the swapped node assuming we didn't remove the end of the list
        if (position !== this.L.length) {
            this.update(this.L[position]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    fixup(k) {
        while (this.isGreaterThanParent(k)) {
            const parent = k >> 1;
            this.swap(k, parent);
            k = parent;
        }
    }
    isGreaterThanParent(k) {
        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);
    }
    fixdown(k) {
        while ((k << 1) <= this.count()) {
            let j = k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {
                break;
            }
            this.swap(k, j);
            k = j;
        }
    }
    swap(k, j) {
        const tmp = this.L[k];
        this.L[k] = this.L[j];
        this.L[k].position = k;
        this.L[j] = tmp;
        this.L[j].position = j;
    }
}
//# sourceMappingURL=heap.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/index.js ***!
  \********************************************************************************/
/*! exports provided: BatchManager, gitHashFile, flatten, readAndParse, buildHierarchy, NumberComparer, Heap, Deferred, assertNotRejected, RangeTracker, RateLimitter, safelyParseJSON, isSystemType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _batchManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batchManager */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/batchManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchManager", function() { return _batchManager__WEBPACK_IMPORTED_MODULE_0__["BatchManager"]; });

/* harmony import */ var _blobs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blobs */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/blobs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gitHashFile", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["gitHashFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["flatten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readAndParse", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["readAndParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildHierarchy", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["buildHierarchy"]; });

/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./heap */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/heap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberComparer", function() { return _heap__WEBPACK_IMPORTED_MODULE_2__["NumberComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return _heap__WEBPACK_IMPORTED_MODULE_2__["Heap"]; });

/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./promises */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/promises.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Deferred", function() { return _promises__WEBPACK_IMPORTED_MODULE_3__["Deferred"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertNotRejected", function() { return _promises__WEBPACK_IMPORTED_MODULE_3__["assertNotRejected"]; });

/* harmony import */ var _rangeTracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rangeTracker */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/rangeTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RangeTracker", function() { return _rangeTracker__WEBPACK_IMPORTED_MODULE_4__["RangeTracker"]; });

/* harmony import */ var _rateLimitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rateLimitter */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/rateLimitter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RateLimitter", function() { return _rateLimitter__WEBPACK_IMPORTED_MODULE_5__["RateLimitter"]; });

/* harmony import */ var _safeParser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./safeParser */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/safeParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "safelyParseJSON", function() { return _safeParser__WEBPACK_IMPORTED_MODULE_6__["safelyParseJSON"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ "./node_modules/@prague/component/node_modules/@prague/utils/lib/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSystemType", function() { return _utils__WEBPACK_IMPORTED_MODULE_7__["isSystemType"]; });









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/promises.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/promises.js ***!
  \***********************************************************************************/
/*! exports provided: Deferred, assertNotRejected */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deferred", function() { return Deferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertNotRejected", function() { return assertNotRejected; });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_0__);

/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        /* tslint:disable:promise-must-complete */
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Retrieves the underlying promise for the deferred
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     */
    resolve(value) {
        this.res(value);
    }
    /**
     * Rejects the promise
     */
    reject(error) {
        this.rej(error);
    }
}
/**
 * Helper function that asserts that the given promise only resolves
 */
/* tslint:disable:promise-function-async */
function assertNotRejected(promise) {
    // Assert that the given promise only resolves
    promise.catch((error) => {
        assert__WEBPACK_IMPORTED_MODULE_0__["ok"](false);
    });
    return promise;
}
//# sourceMappingURL=promises.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/rangeTracker.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/rangeTracker.js ***!
  \***************************************************************************************/
/*! exports provided: RangeTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeTracker", function() { return RangeTracker; });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_0__);

// tslint:disable:no-var-requires
// tslint:disable-next-line:no-submodule-imports
const cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/**
 * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary
 * is continuous and always maps to a single value in secondary above the base value. The range
 * defines an increasing step function.
 */
class RangeTracker {
    get base() {
        return this.ranges[0].primary;
    }
    get primaryHead() {
        return this.lastPrimary;
    }
    get secondaryHead() {
        return this.lastSecondary;
    }
    constructor(primary, secondary) {
        if (typeof primary === "number") {
            this.ranges = [{ length: 0, primary, secondary }];
            this.lastPrimary = primary;
            this.lastSecondary = secondary;
        }
        else {
            /* tslint:disable:no-unsafe-any */
            this.ranges = cloneDeep(primary.ranges);
            this.lastPrimary = primary.lastPrimary;
            this.lastSecondary = primary.lastSecondary;
        }
    }
    /**
     * Returns a serialized form of the RangeTracker
     */
    serialize() {
        return {
            lastPrimary: this.lastPrimary,
            lastSecondary: this.lastSecondary,
            ranges: cloneDeep(this.ranges),
        };
    }
    // primary is time - secondary is the MSN
    add(primary, secondary) {
        // Both values must continuously be increasing - we won't always track the last value we saw so we do so
        // below to check invariants
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.lastPrimary);
        assert__WEBPACK_IMPORTED_MODULE_0__(secondary >= this.lastSecondary);
        this.lastPrimary = primary;
        this.lastSecondary = secondary;
        // Get quicker references to the head of the range
        const head = this.ranges[this.ranges.length - 1];
        const primaryHead = head.primary + head.length;
        const secondaryHead = head.secondary + head.length;
        // Same secondary indicates this is not a true inflection point - we can ignore it
        if (secondary === secondaryHead) {
            return;
        }
        // New secondary - need to update the ranges
        if (primary === primaryHead) {
            // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to
            // preserve 1:N since you can only lookup from the primary to a secondary
            if (head.length === 0) {
                // No range represented - we can simply update secondary with the overwritten value
                head.secondary = secondary;
            }
            else {
                // The values in the range before this one are valid - but we need to create a new one for this update
                // tslint:disable-next-line:no-increment-decrement
                head.length--;
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
        else {
            if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {
                // extend the length if both increase by the same amount
                // tslint:disable-next-line:no-increment-decrement
                head.length++;
            }
            else {
                // Insert a new node
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
    }
    get(primary) {
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[0].primary);
        // Find the first range where the starting position is greater than the primary. Our target range is
        // the one before it.
        let index = 1;
        // tslint:disable-next-line:no-increment-decrement
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[index - 1].primary);
        // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest
        // stored secondary value to use.
        const closestRange = this.ranges[index - 1];
        return Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary;
    }
    updateBase(primary) {
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[0].primary);
        // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the
        // previous index by definition (since it's less than the current index's primary but greather than the
        // previous index's primary) and we know primary must be greater than the base.
        let index = 1;
        // tslint:disable-next-line:no-increment-decrement
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[index - 1].primary);
        // Update the last range values
        const range = this.ranges[index - 1];
        const delta = primary - range.primary;
        range.secondary = range.secondary + Math.min(delta, range.length);
        range.length = Math.max(range.length - delta, 0);
        range.primary = primary;
        // And remove unnecessary ranges
        this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;
        // assert that the lowest value is now the input to this method
        assert__WEBPACK_IMPORTED_MODULE_0__["equal"](primary, this.ranges[0].primary);
    }
}
//# sourceMappingURL=rangeTracker.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/rateLimitter.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/rateLimitter.js ***!
  \***************************************************************************************/
/*! exports provided: RateLimitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RateLimitter", function() { return RateLimitter; });
// A rate limiter to make sure that a client can only request help for one task within a time window.
class RateLimitter {
    constructor(windowMSec) {
        this.windowMSec = windowMSec;
        this.requestMap = new Map();
    }
    filter(clientId, messages) {
        const approvedList = [];
        const currentTime = Date.now();
        for (const message of messages) {
            const key = `${clientId}/${message}`;
            if (!this.requestMap.has(key)) {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
            else if (this.requestMap.get(key) + this.windowMSec > currentTime) {
                continue;
            }
            else {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
        }
        return approvedList;
    }
}
//# sourceMappingURL=rateLimitter.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/safeParser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/safeParser.js ***!
  \*************************************************************************************/
/*! exports provided: safelyParseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safelyParseJSON", function() { return safelyParseJSON; });
function safelyParseJSON(json) {
    let parsed;
    try {
        parsed = JSON.parse(json);
    }
    catch (e) {
        //
    }
    return parsed;
}
//# sourceMappingURL=safeParser.js.map

/***/ }),

/***/ "./node_modules/@prague/component/node_modules/@prague/utils/lib/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@prague/component/node_modules/@prague/utils/lib/utils.js ***!
  \********************************************************************************/
/*! exports provided: isSystemType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSystemType", function() { return isSystemType; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);

function isSystemType(type) {
    return (type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].RemoteHelp ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Integrate ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].ClientJoin ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].ClientLeave ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Fork);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@prague/container-definitions/dist/blobs.js":
/*!******************************************************************!*\
  !*** ./node_modules/@prague/container-definitions/dist/blobs.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getFileBlobType(mimeType) {
    switch (mimeType) {
        case "image/jpeg":
        case "image/png":
        case "image/gif":
        case "image/bmp": {
            return "image";
        }
        case "video/mp4": {
            return "video";
        }
        case "text/plain": {
            return "text";
        }
        default: {
            return "generic";
        }
    }
}
exports.getFileBlobType = getFileBlobType;
//# sourceMappingURL=blobs.js.map

/***/ }),

/***/ "./node_modules/@prague/container-definitions/dist/chaincode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prague/container-definitions/dist/chaincode.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ConnectionState;
(function (ConnectionState) {
    /**
     * The document is no longer connected to the delta server
     */
    ConnectionState[ConnectionState["Disconnected"] = 0] = "Disconnected";
    /**
     * The document has an inbound connection but is still pending for outbound deltas
     */
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    /**
     * The document is fully connected
     */
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
//# sourceMappingURL=chaincode.js.map

/***/ }),

/***/ "./node_modules/@prague/container-definitions/dist/clients.js":
/*!********************************************************************!*\
  !*** ./node_modules/@prague/container-definitions/dist/clients.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Browser = "browser";
exports.Robot = "robot";
//# sourceMappingURL=clients.js.map

/***/ }),

/***/ "./node_modules/@prague/container-definitions/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@prague/container-definitions/dist/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./blobs */ "./node_modules/@prague/container-definitions/dist/blobs.js"));
__export(__webpack_require__(/*! ./chaincode */ "./node_modules/@prague/container-definitions/dist/chaincode.js"));
__export(__webpack_require__(/*! ./clients */ "./node_modules/@prague/container-definitions/dist/clients.js"));
__export(__webpack_require__(/*! ./protocol */ "./node_modules/@prague/container-definitions/dist/protocol.js"));
__export(__webpack_require__(/*! ./storage */ "./node_modules/@prague/container-definitions/dist/storage.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/container-definitions/dist/protocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@prague/container-definitions/dist/protocol.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Blob uploaded
    MessageType["BlobUploaded"] = "blobUploaded";
    // TODO the attach and operation names are partially historican. We may want to rename to align with changes
    // coming from code loading.
    // Creates a new channel and attaches chaincode to it
    MessageType["Attach"] = "attach";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Chunked operation.
    MessageType["ChunkedOp"] = "chunkedOp";
    // Forced snapshot
    MessageType["Save"] = "saveOp";
    // System message to indicate the creation of a new fork
    MessageType["Fork"] = "fork";
    // Message sent when forwarding a sequenced message to an upstream branch
    MessageType["Integrate"] = "integrate";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "./node_modules/@prague/container-definitions/dist/storage.js":
/*!********************************************************************!*\
  !*** ./node_modules/@prague/container-definitions/dist/storage.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Commit"] = "160000";
    FileMode["Symlink"] = "120000";
})(FileMode = exports.FileMode || (exports.FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry[TreeEntry["Blob"] = 0] = "Blob";
    TreeEntry[TreeEntry["Commit"] = 1] = "Commit";
    TreeEntry[TreeEntry["Tree"] = 2] = "Tree";
})(TreeEntry = exports.TreeEntry || (exports.TreeEntry = {}));
//# sourceMappingURL=storage.js.map

/***/ }),

/***/ "./node_modules/@prague/map/lib/counter.js":
/*!*************************************************!*\
  !*** ./node_modules/@prague/map/lib/counter.js ***!
  \*************************************************/
/*! exports provided: CounterFactory, Counter, CounterValueType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CounterFactory", function() { return CounterFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Counter", function() { return Counter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CounterValueType", function() { return CounterValueType; });
class CounterFactory {
    load(emitter, raw) {
        // tslint:disable-next-line:strict-boolean-expressions
        return new Counter(emitter, raw || 0);
    }
    store(value) {
        return value.value;
    }
}
class Counter {
    // tslint:disable-next-line:variable-name
    constructor(emitter, _value) {
        this.emitter = emitter;
        this._value = _value;
        /**
         * Can be set to register an event listener for when the counter is incremented. The callback indicates the
         * amount the counter was incremented by.
         */
        this.onIncrement = (value) => { return; };
    }
    get value() {
        return this._value;
    }
    increment(value, submit = true) {
        this._value = this._value + value;
        if (submit) {
            this.emitter.emit("increment", value);
        }
        this.onIncrement(value);
        return this;
    }
}
class CounterValueType {
    // tslint:enable:variable-name
    constructor() {
        this._factory = new CounterFactory();
        this._ops = new Map([[
                "increment",
                {
                    prepare: (value, params, local, op) => {
                        return Promise.resolve();
                    },
                    process: (value, params, context, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        value.increment(params, false);
                    },
                },
            ]]);
    }
    get name() {
        return CounterValueType.Name;
    }
    get factory() {
        return this._factory;
    }
    get ops() {
        return this._ops;
    }
}
CounterValueType.Name = "counter";
//# sourceMappingURL=counter.js.map

/***/ }),

/***/ "./node_modules/@prague/map/lib/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/@prague/map/lib/debug.js ***!
  \***********************************************/
/*! exports provided: debug */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const debug = debug__WEBPACK_IMPORTED_MODULE_0__("prague:map");
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@prague/map/lib/extension.js":
/*!***************************************************!*\
  !*** ./node_modules/@prague/map/lib/extension.js ***!
  \***************************************************/
/*! exports provided: registerDefaultValueType, MapExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerDefaultValueType", function() { return registerDefaultValueType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapExtension", function() { return MapExtension; });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/@prague/map/lib/map.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// register default types
const defaultValueTypes = new Array();
function registerDefaultValueType(type) {
    defaultValueTypes.push(type);
}
/**
 * The extension that defines the map
 */
class MapExtension {
    constructor() {
        this.type = MapExtension.Type;
    }
    load(runtime, id, minimumSequenceNumber, services, headerOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            const map = new _map__WEBPACK_IMPORTED_MODULE_0__["SharedMap"](id, runtime, MapExtension.Type);
            this.registerValueTypes(map, defaultValueTypes);
            yield map.load(minimumSequenceNumber, headerOrigin, services);
            return map;
        });
    }
    create(document, id) {
        const map = new _map__WEBPACK_IMPORTED_MODULE_0__["SharedMap"](id, document, MapExtension.Type);
        this.registerValueTypes(map, defaultValueTypes);
        map.initializeLocal();
        return map;
    }
    registerValueTypes(map, valueTypes) {
        for (const type of valueTypes) {
            map.registerValueType(type);
        }
    }
}
MapExtension.Type = "https://graph.microsoft.com/types/map";
//# sourceMappingURL=extension.js.map

/***/ }),

/***/ "./node_modules/@prague/map/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@prague/map/lib/index.js ***!
  \***********************************************/
/*! exports provided: CounterFactory, Counter, CounterValueType, registerDefaultValueType, MapExtension, copyMap, SharedMap, DistributedSetFactory, DistributedSet, DistributedSetValueType, MapView, DirectoryView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _counter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./counter */ "./node_modules/@prague/map/lib/counter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CounterFactory", function() { return _counter__WEBPACK_IMPORTED_MODULE_0__["CounterFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Counter", function() { return _counter__WEBPACK_IMPORTED_MODULE_0__["Counter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CounterValueType", function() { return _counter__WEBPACK_IMPORTED_MODULE_0__["CounterValueType"]; });

/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/map/lib/extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerDefaultValueType", function() { return _extension__WEBPACK_IMPORTED_MODULE_1__["registerDefaultValueType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapExtension", function() { return _extension__WEBPACK_IMPORTED_MODULE_1__["MapExtension"]; });

/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ "./node_modules/@prague/map/lib/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyMap", function() { return _map__WEBPACK_IMPORTED_MODULE_2__["copyMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedMap", function() { return _map__WEBPACK_IMPORTED_MODULE_2__["SharedMap"]; });

/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./set */ "./node_modules/@prague/map/lib/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DistributedSetFactory", function() { return _set__WEBPACK_IMPORTED_MODULE_3__["DistributedSetFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DistributedSet", function() { return _set__WEBPACK_IMPORTED_MODULE_3__["DistributedSet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DistributedSetValueType", function() { return _set__WEBPACK_IMPORTED_MODULE_3__["DistributedSetValueType"]; });

/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view */ "./node_modules/@prague/map/lib/view.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapView", function() { return _view__WEBPACK_IMPORTED_MODULE_4__["MapView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DirectoryView", function() { return _view__WEBPACK_IMPORTED_MODULE_4__["DirectoryView"]; });






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/map/lib/map.js":
/*!*********************************************!*\
  !*** ./node_modules/@prague/map/lib/map.js ***!
  \*********************************************/
/*! exports provided: copyMap, SharedMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyMap", function() { return copyMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedMap", function() { return SharedMap; });
/* harmony import */ var _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/api-definitions */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/index.js");
/* harmony import */ var _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug */ "./node_modules/@prague/map/lib/debug.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/map/lib/extension.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view */ "./node_modules/@prague/map/lib/view.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const snapshotFileName = "header";
const contentPath = "content";
/**
 * Copies all values from the provided SharedMap to the given Map
 */
function copyMap(from, to) {
    from.forEach((value, key) => {
        /* tslint:disable:no-unsafe-any */
        to.set(key, value);
    });
}
class ContentObjectStorage {
    constructor(storage) {
        this.storage = storage;
    }
    /* tslint:disable:promise-function-async */
    read(path) {
        return this.storage.read(`content/${path}`);
    }
}
/**
 * Implementation of a map shared object
 */
class SharedMap extends _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["SharedObject"] {
    /**
     * Constructs a new shared map. If the object is non-local an id and service interfaces will
     * be provided
     */
    constructor(id, runtime, type = _extension__WEBPACK_IMPORTED_MODULE_3__["MapExtension"].Type) {
        super(id, runtime, type);
        this.valueTypes = new Map();
        this.serializeFilter = (key, value, valueType) => value;
        this.messageHandler = new Map();
        this.pendingKeys = new Map();
        this.pendingClearClientSequenceNumber = -1;
        this.setMessageHandlers();
        this.initializeView();
        this[Symbol.toStringTag] = this.view.data[Symbol.toStringTag];
    }
    internalView() {
        return this.view;
    }
    keys() {
        return this.view.keys();
    }
    // TODO: entries and values will have incorrect content until
    // map contains plain values and meta-data is segregated into
    // separate map
    entries() {
        return this.view.data.entries();
    }
    values() {
        return this.view.data.values();
    }
    [Symbol.iterator]() {
        return this.view.data[Symbol.iterator]();
    }
    get size() {
        return this.view.data.size;
    }
    forEach(callbackFn) {
        this.view.forEach(callbackFn);
    }
    /**
     * Retrieves the value with the given key from the map.
     */
    get(key) {
        return this.view.get(key);
    }
    wait(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.view.wait(key);
        });
    }
    has(key) {
        return this.view.has(key);
    }
    set(key, value, type) {
        this.view.set(key, value, type);
        return this;
    }
    delete(key) {
        return this.view.delete(key);
    }
    clear() {
        return this.view.clear();
    }
    snapshot() {
        const tree = {
            entries: [
                {
                    mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["FileMode"].File,
                    path: snapshotFileName,
                    type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["TreeEntry"].Blob],
                    value: {
                        contents: this.view.serialize(this.serializeFilter),
                        encoding: "utf-8",
                    },
                },
            ],
            sha: null,
        };
        // Add the snapshot of the content to the tree
        const contentSnapshot = this.snapshotContent();
        if (contentSnapshot) {
            tree.entries.push({
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["FileMode"].Directory,
                path: contentPath,
                type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["TreeEntry"].Tree],
                value: contentSnapshot,
            });
        }
        return tree;
    }
    submitMapClearMessage(op) {
        const clientSequenceNumber = this.submitMapMessage(op);
        if (clientSequenceNumber !== -1) {
            this.pendingClearClientSequenceNumber = clientSequenceNumber;
        }
    }
    submitMapKeyMessage(op) {
        const clientSequenceNumber = this.submitMapMessage(op);
        if (clientSequenceNumber !== -1) {
            this.pendingKeys.set(op.key, clientSequenceNumber);
        }
    }
    submitMapMessage(op) {
        // Local operations do not require any extra processing
        if (this.isLocal()) {
            return -1;
        }
        // Once we have performed the attach submit the local operation
        return this.submitLocalMessage(op);
    }
    /**
     * Registers a new value type on the map
     */
    registerValueType(type) {
        this.valueTypes.set(type.name, type);
        function getOpHandler(op) {
            const handler = type.ops.get(op.value.type);
            if (!handler) {
                throw new Error("Unknown type message");
            }
            return handler;
        }
        const valueTypeMessageHandler = {
            prepare: (op, local, message) => __awaiter(this, void 0, void 0, function* () {
                const handler = getOpHandler(op);
                const value = this.view.get(op.key);
                return handler.prepare(value, op.value.value, local, message);
            }),
            process: (op, context, local, message) => {
                const handler = getOpHandler(op);
                const value = this.view.get(op.key);
                handler.process(value, op.value.value, context, local, message);
                this.emit("valueChanged", { key: op.key }, local, message);
            },
            submit: (op) => {
                this.submitLocalMessage(op);
            },
        };
        this.messageHandler.set(type.name, valueTypeMessageHandler);
    }
    hasValueType(type) {
        return this.valueTypes.has(type);
    }
    getValueType(type) {
        return this.valueTypes.get(type);
    }
    registerSerializeFilter(filter) {
        this.serializeFilter = filter;
    }
    /* tslint:disable:no-unnecessary-override */
    on(event, listener) {
        return super.on(event, listener);
    }
    onDisconnect() {
        Object(_debug__WEBPACK_IMPORTED_MODULE_2__["debug"])(`Map ${this.id} is now disconnected`);
        this.onDisconnectContent();
    }
    onConnect(pending) {
        Object(_debug__WEBPACK_IMPORTED_MODULE_2__["debug"])(`Map ${this.id} is now connected`);
        // REVIEW: Does it matter that the map and content message get out of order?
        // Filter the nonAck and pending messages into a map set and a content set.
        const mapMessages = [];
        const contentMessages = [];
        for (const message of pending) {
            if (this.isMapMessage(message)) {
                mapMessages.push(message);
            }
            else {
                contentMessages.push(message);
            }
        }
        // Deal with the map messages - for the map it's always last one wins so we just resend
        for (const message of mapMessages) {
            const handler = this.messageHandler.get(message.type);
            handler.submit(message);
        }
        // Allow content to catch up
        this.onConnectContent(contentMessages);
    }
    loadCore(minimumSequenceNumber, headerOrigin, storage) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield storage.read(snapshotFileName);
            const data = header ? JSON.parse(Buffer.from(header, "base64")
                .toString("utf-8")) : {};
            yield this.view.populate(data);
            const contentStorage = new ContentObjectStorage(storage);
            yield this.loadContent(minimumSequenceNumber, headerOrigin, contentStorage);
        });
    }
    initializeLocalCore() {
        this.initializeContent();
    }
    processMinSequenceNumberChanged(value) {
        this.processMinSequenceNumberChangedContent(value);
    }
    loadContent(minimumSequenceNumber, headerOrigin, services) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    initializeContent() {
        return;
    }
    prepareCore(message, local) {
        if (message.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Operation) {
            const op = message.contents;
            if (this.messageHandler.has(op.type)) {
                return this.messageHandler.get(op.type)
                    .prepare(op, local, message);
            }
        }
        return this.prepareContent(message, local);
    }
    processCore(message, local, context) {
        let handled = false;
        if (message.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_1__["MessageType"].Operation) {
            const op = message.contents;
            if (this.messageHandler.has(op.type)) {
                this.messageHandler.get(op.type)
                    .process(op, context, local, message);
                handled = true;
            }
        }
        if (!handled) {
            this.processContent(message, local, context);
        }
    }
    attachCore() {
        this.view.attachAll();
        this.attachContent();
    }
    // The following three methods enable derived classes to provide custom content that is stored
    // with the map
    attachContent() {
        return;
    }
    prepareContent(message, local) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve();
        });
    }
    /**
     * Processes a content message
     */
    processContent(message, local, context) {
        return;
    }
    /**
     * Message sent to notify derived content of disconnection
     */
    onDisconnectContent() {
        return;
    }
    /**
     * Message sent upon reconnecting to the delta stream
     */
    onConnectContent(pending) {
        for (const message of pending) {
            this.submitLocalMessage(message);
        }
        return;
    }
    /**
     * Snapshots the content
     */
    snapshotContent() {
        return null;
    }
    /**
     * Notifies the content that the minimum sequence number has changed
     */
    processMinSequenceNumberChangedContent(value) {
        return;
    }
    needProcessKeyOperations(op, local, message) {
        if (this.pendingClearClientSequenceNumber !== -1) {
            // If I have a NACK clear, we can ignore all ops.
            return false;
        }
        if ((this.pendingKeys.size !== 0 && this.pendingKeys.has(op.key))) {
            // Found an NACK op, clear it from the map if the latest sequence number in the map match the message's
            // and don't process the op.
            if (local) {
                const pendingKeyClientSequenceNumber = this.pendingKeys.get(op.key);
                if (pendingKeyClientSequenceNumber === message.clientSequenceNumber) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    initializeView() {
        this.view = new _view__WEBPACK_IMPORTED_MODULE_4__["MapView"](this, this.runtime, this.id);
    }
    setMessageHandlers() {
        const defaultPrepare = (op, local) => Promise.resolve();
        // tslint:disable:no-backbone-get-set-outside-model
        this.messageHandler.set("clear", {
            prepare: defaultPrepare,
            process: (op, context, local, message) => {
                if (local) {
                    if (this.pendingClearClientSequenceNumber === message.clientSequenceNumber) {
                        this.pendingClearClientSequenceNumber = -1;
                    }
                    return false;
                }
                if (this.pendingKeys.size !== 0) {
                    this.view.clearExceptPendingKeys(this.pendingKeys);
                    return;
                }
                this.view.clearCore(local, message);
            },
            submit: (op) => {
                this.submitMapClearMessage(op);
            },
        });
        this.messageHandler.set("delete", {
            prepare: defaultPrepare,
            process: (op, context, local, message) => {
                if (!this.needProcessKeyOperations(op, local, message)) {
                    return;
                }
                return this.view.deleteCore(op.key, local, message);
            },
            submit: (op) => {
                this.submitMapKeyMessage(op);
            },
        });
        this.messageHandler.set("set", {
            prepare: (op, local) => {
                return local ? Promise.resolve(null) : this.view.prepareSetCore(op.key, op.value);
            },
            process: (op, context, local, message) => {
                if (!this.needProcessKeyOperations(op, local, message)) {
                    return;
                }
                this.view.setCore(op.key, context, local, message);
            },
            submit: (op) => {
                this.submitMapKeyMessage(op);
            },
        });
    }
    isMapMessage(message) {
        const type = message.type;
        return this.messageHandler.has(type);
    }
}
//# sourceMappingURL=map.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/map/lib/set.js":
/*!*********************************************!*\
  !*** ./node_modules/@prague/map/lib/set.js ***!
  \*********************************************/
/*! exports provided: DistributedSetFactory, DistributedSet, DistributedSetValueType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistributedSetFactory", function() { return DistributedSetFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistributedSet", function() { return DistributedSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistributedSetValueType", function() { return DistributedSetValueType; });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class DistributedSetFactory {
    load(emitter, raw) {
        return new DistributedSet(emitter, raw || []);
    }
    store(value) {
        return value.entries();
    }
}
class DistributedSet {
    constructor(emitter, value) {
        this.emitter = emitter;
        /**
         * Can be set to register an event listener for when values are added or deleted from the set.
         */
        this.onAdd = (value) => { return; };
        this.onDelete = (value) => { return; };
        this.internalSet = new Set(value);
    }
    add(value, submitEvent = true) {
        this.internalSet.add(value);
        if (submitEvent) {
            this.emitter.emit("add", value);
        }
        this.onAdd(value);
        return this;
    }
    delete(value, submitEvent = true) {
        this.internalSet.delete(value);
        if (submitEvent) {
            this.emitter.emit("delete", value);
        }
        this.onDelete(value);
        return this;
    }
    entries() {
        return Array.from(this.internalSet.values());
    }
}
class DistributedSetValueType {
    // tslint:enable:variable-name
    constructor() {
        this._factory = new DistributedSetFactory();
        this._ops = new Map([[
                "add",
                {
                    prepare: (value, params, local, op) => __awaiter(this, void 0, void 0, function* () {
                        return;
                    }),
                    process: (value, params, context, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        value.add(params, false);
                    },
                },
            ],
            [
                "delete",
                {
                    prepare: (value, params, local, op) => __awaiter(this, void 0, void 0, function* () {
                        return;
                    }),
                    process: (value, params, context, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        value.delete(params, false);
                    },
                },
            ]]);
    }
    get name() {
        return DistributedSetValueType.Name;
    }
    get factory() {
        return this._factory;
    }
    get ops() {
        return this._ops;
    }
}
DistributedSetValueType.Name = "distributedSet";
//# sourceMappingURL=set.js.map

/***/ }),

/***/ "./node_modules/@prague/map/lib/view.js":
/*!**********************************************!*\
  !*** ./node_modules/@prague/map/lib/view.js ***!
  \**********************************************/
/*! exports provided: MapView, DirectoryView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapView", function() { return MapView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectoryView", function() { return DirectoryView; });
/* harmony import */ var _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/api-definitions */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/index.js");
/* harmony import */ var _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// tslint:disable:align

class ValueOpEmitter {
    constructor(type, key, map) {
        this.type = type;
        this.key = key;
        this.map = map;
    }
    emit(name, params) {
        const op = {
            key: this.key,
            type: this.type,
            value: {
                type: name,
                value: params,
            },
        };
        this.map.submitMapMessage(op);
        this.map.emit("valueChanged", { key: this.key }, true, null);
    }
}
class MapView {
    constructor(map, runtime, id) {
        this.map = map;
        this.runtime = runtime;
        this.data = new Map();
    }
    populate(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const localValuesP = new Array();
            // tslint:disable-next-line:forin
            for (const key in data) {
                const value = data[key];
                const localValueP = this.fill(key, value)
                    .then((filledValue) => ({ key, value: filledValue }));
                localValuesP.push(localValueP);
            }
            const localValues = yield Promise.all(localValuesP);
            for (const localValue of localValues) {
                this.data.set(localValue.key, localValue.value);
            }
        });
    }
    // TODO: fix to pass-through when meta-data moved to separate map
    forEach(callbackFn) {
        this.data.forEach((value, key, m) => {
            callbackFn(value.localValue, key, m);
        });
    }
    get(key) {
        if (!this.data.has(key)) {
            return undefined;
        }
        // Let's stash the *type* of the object on the key
        const value = this.data.get(key);
        return value.localValue;
    }
    getMap() {
        return this.map;
    }
    wait(key) {
        return __awaiter(this, void 0, void 0, function* () {
            // Return immediately if the value already exists
            if (this.has(key)) {
                /* tslint:disable:no-unsafe-any */
                /* tslint:disable:no-object-literal-type-assertion */
                return this.get(key);
            }
            // Otherwise subscribe to changes
            return new Promise((resolve, reject) => {
                const callback = (value) => {
                    if (key === value.key) {
                        resolve(this.get(value.key));
                        this.map.removeListener("valueChanged", callback);
                    }
                };
                this.map.on("valueChanged", callback);
            });
        });
    }
    has(key) {
        return this.data.has(key);
    }
    attachAll() {
        for (const [, value] of this.data) {
            if (value.localValue instanceof _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["SharedObject"]) {
                value.localValue.attach();
            }
        }
    }
    prepareOperationValue(key, value, type) {
        let operationValue;
        if (type) {
            const valueType = this.map.getValueType(type);
            if (!valueType) {
                throw new Error(`Unknown type '${type}' specified`);
            }
            // set operationValue first with the raw value params prior to doing the load
            operationValue = {
                type,
                value,
            };
            // tslint:disable-next-line:no-parameter-reassignment
            value = valueType.factory.load(new ValueOpEmitter(type, key, this.map), value);
        }
        else {
            const valueType = value instanceof _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["SharedObject"]
                ? _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Shared]
                : _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Plain];
            operationValue = this.spill({ localType: valueType, localValue: value });
        }
        return { operationValue, localValue: value };
    }
    set(key, value, type) {
        const values = this.prepareOperationValue(key, value, type);
        const op = {
            key,
            type: "set",
            value: values.operationValue,
        };
        this.setCore(op.key, {
            localType: values.operationValue.type,
            localValue: values.localValue,
        }, true, null);
        this.map.submitMapKeyMessage(op);
    }
    delete(key) {
        const op = {
            key,
            type: "delete",
        };
        const successfullyRemoved = this.deleteCore(op.key, true, null);
        this.map.submitMapKeyMessage(op);
        return successfullyRemoved;
    }
    keys() {
        return this.data.keys();
    }
    clear() {
        const op = {
            type: "clear",
        };
        this.clearCore(true, null);
        this.map.submitMapClearMessage(op);
    }
    /**
     * Serializes the shared map to a JSON string
     */
    serialize(filter) {
        const serialized = {};
        this.data.forEach((value, key) => {
            const spilledValue = this.spill(value);
            const filteredValue = filter(key, spilledValue.value, spilledValue.type);
            serialized[key] = { type: spilledValue.type, value: filteredValue };
        });
        return JSON.stringify(serialized);
    }
    setCore(key, value, local, op) {
        this.data.set(key, value);
        this.map.emit("valueChanged", { key }, local, op);
    }
    prepareSetCore(key, value) {
        return this.fill(key, value);
    }
    clearCore(local, op) {
        this.data.clear();
        this.map.emit("clear", local, op);
    }
    deleteCore(key, local, op) {
        const successfullyRemoved = this.data.delete(key);
        this.map.emit("valueChanged", { key }, local, op);
        return successfullyRemoved;
    }
    clearExceptPendingKeys(pendingKeys) {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        pendingKeys.forEach((value, key, map) => {
            temp.set(key, this.data.get(key));
        });
        this.data.clear();
        temp.forEach((value, key, map) => {
            this.data.set(key, value);
        });
    }
    fill(key, remote) {
        return __awaiter(this, void 0, void 0, function* () {
            let translatedValue;
            if (remote.type === _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Shared]) {
                const distributedObject = yield this.runtime.getChannel(remote.value);
                translatedValue = distributedObject;
            }
            else if (remote.type === _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Plain]) {
                translatedValue = remote.value;
            }
            else if (this.map.hasValueType(remote.type)) {
                const valueType = this.map.getValueType(remote.type);
                translatedValue = valueType.factory.load(new ValueOpEmitter(remote.type, key, this.map), remote.value);
            }
            else {
                return Promise.reject("Unknown value type");
            }
            return {
                localType: remote.type,
                localValue: translatedValue,
            };
        });
    }
    spill(local) {
        if (local.localType === _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Shared]) {
            const distributedObject = local.localValue;
            // Attach the collab object to the document. If already attached the attach call will noop.
            // This feels slightly out of place here since it has a side effect. But is part of spilling a document.
            // Not sure if there is some kind of prep call to separate the op creation from things needed to make it
            // (like attaching)
            if (!this.map.isLocal()) {
                distributedObject.attach();
            }
            return {
                type: _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Shared],
                value: distributedObject.id,
            };
        }
        else if (this.map.hasValueType(local.localType)) {
            const valueType = this.map.getValueType(local.localType);
            return {
                type: local.localType,
                value: valueType.factory.store(local.localValue),
            };
        }
        else {
            return {
                type: _prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"][_prague_api_definitions__WEBPACK_IMPORTED_MODULE_0__["ValueType"].Plain],
                value: local.localValue,
            };
        }
    }
}
class DirectoryView extends MapView {
    constructor(directory, runtime, id) {
        super(directory, runtime, id);
    }
}
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/debug.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/debug.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const registerDebug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
exports.debug = registerDebug("prague:api-definitions");
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/extension.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/extension.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class that contains a collection of collaboration extensions
 */
class Registry {
    constructor() {
        this.extensions = [];
        this.extensionsMap = {};
    }
    /**
     * Registers a new extension
     * @param extension The extension to register
     */
    register(extension) {
        this.extensions.push(extension);
        this.extensionsMap[extension.type] = extension;
    }
    /**
     * Retrieves the extension with the given id
     * @param id ID for the extension to retrieve
     */
    getExtension(type) {
        if (!(type in this.extensionsMap)) {
            throw new Error("Extension not found");
        }
        return this.extensionsMap[type];
    }
}
exports.Registry = Registry;
//# sourceMappingURL=extension.js.map

/***/ }),

/***/ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./sharedObject */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/sharedObject.js"));
__export(__webpack_require__(/*! ./extension */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/extension.js"));
__export(__webpack_require__(/*! ./valueType */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/valueType.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/sharedObject.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/sharedObject.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
const assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
const Deque = __webpack_require__(/*! double-ended-queue */ "./node_modules/double-ended-queue/js/deque.js");
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const debug_1 = __webpack_require__(/*! ./debug */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/debug.js");
const valueType_1 = __webpack_require__(/*! ./valueType */ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/valueType.js");
class SharedObject extends events_1.EventEmitter {
    constructor(id, runtime, type) {
        super();
        this.id = id;
        this.runtime = runtime;
        this.type = type;
        // tslint:disable-next-line:variable-name
        this.__sharedObject__ = true;
        // tslint:disable-next-line:variable-name private fields exposed via getters
        this._state = container_definitions_1.ConnectionState.Disconnected;
        // Locally applied operations not yet ACK'd by the server
        this.pendingOps = new Deque();
    }
    get state() {
        return this._state;
    }
    toJSON() {
        return {
            type: valueType_1.ValueType[valueType_1.ValueType.Shared],
            value: this.id,
        };
    }
    /**
     * A shared object, after construction, can either be loaded in the case that it is already part of
     * a shared document. Or later attached if it is being newly added.
     */
    load(minimumSequenceNumber, headerOrigin, services) {
        return __awaiter(this, void 0, void 0, function* () {
            this.services = services;
            yield this.loadCore(minimumSequenceNumber, headerOrigin, services.objectStorage);
            this.attachDeltaHandler();
        });
    }
    /**
     * Initializes the object as a local, non-shared object. This object can become shared after
     * it is attached to the document.
     */
    initializeLocal() {
        this.initializeLocalCore();
    }
    /**
     * Attaches the given shared object to its containing document
     */
    attach() {
        if (!this.isLocal()) {
            return this;
        }
        // Allow derived classes to perform custom processing prior to attaching this object
        this.attachCore();
        // Notify the document of the attachment
        this.services = this.runtime.attachChannel(this);
        this.attachDeltaHandler();
        return this;
    }
    /**
     * Returns whether the given shared object is local
     */
    isLocal() {
        return !this.services;
    }
    /* tslint:disable:no-unnecessary-override */
    on(event, listener) {
        return super.on(event, listener);
    }
    /**
     * Processes a message by the local client
     */
    submitLocalMessage(content) {
        assert(!this.isLocal());
        // Send if we are connected - otherwise just add to the sent list
        let clientSequenceNumber = -1;
        if (this.state === container_definitions_1.ConnectionState.Connected) {
            clientSequenceNumber = this.services.deltaConnection.submit(content);
        }
        else {
            debug_1.debug(`${this.id} Not fully connected - adding to pending list`, content);
            // Store the message for when it is ACKed and then submit to the server if connected
        }
        this.pendingOps.push({ clientSequenceNumber, content });
        return clientSequenceNumber;
    }
    attachDeltaHandler() {
        this.services.deltaConnection.attach({
            minSequenceNumberChanged: (value) => {
                this.processMinSequenceNumberChanged(value);
            },
            prepare: (message, local) => {
                return this.prepare(message, local);
            },
            process: (message, local, context) => {
                this.process(message, local, context);
            },
            setConnectionState: (state) => {
                this.setConnectionState(state);
            },
        });
        // Trigger initial state
        this.setConnectionState(this.services.deltaConnection.state);
    }
    prepare(message, local) {
        return this.prepareCore(message, local);
    }
    setConnectionState(state) {
        // Should I change the state at the end? So that we *can't* send new stuff before we send old?
        this._state = state;
        switch (state) {
            case container_definitions_1.ConnectionState.Disconnected:
                // Things that are true now...
                // - if we had a connection we can no longer send messages over it
                // - if we had outbound messages some may or may not be ACK'd. Won't know until next message
                //
                // - nack could get a new msn - but might as well do it in the join?
                this.onDisconnect();
                break;
            case container_definitions_1.ConnectionState.Connecting:
                // Things that are now true...
                // - we will begin to receive inbound messages
                // - we know what our new client id is.
                // - still not safe to send messages
                // While connecting we are still ticking off the previous messages
                debug_1.debug(`${this.id} is now connecting`);
                break;
            case container_definitions_1.ConnectionState.Connected:
                // Extract all un-ack'd payload operation
                const pendingOps = this.pendingOps.toArray().map((value) => value.content);
                this.pendingOps.clear();
                // And now we are fully connected
                // - we have a client ID
                // - we are caught up enough to attempt to send messages
                this.onConnect(pendingOps);
                break;
            default:
                assert.ok(false, `Unknown ConnectionState ${state}`);
        }
    }
    /**
     * Handles a message being received from the remote delta server
     */
    process(message, local, context) {
        if (message.type === container_definitions_1.MessageType.Operation && local) {
            // disconnected ops should never be processed. They should have been fully sent on connected
            assert(this.pendingOps.length === 0 || this.pendingOps.peekFront().clientSequenceNumber !== -1, `process for disconnected op ${this.pendingOps.peekFront().clientSequenceNumber}`);
            // One of our messages was sequenced. We can remove it from the local message list. Given these arrive
            // in order we only need to check the beginning of the local list.
            if (this.pendingOps.length > 0 &&
                this.pendingOps.peekFront().clientSequenceNumber === message.clientSequenceNumber) {
                this.pendingOps.shift();
                if (this.pendingOps.length === 0) {
                    this.emit("processed");
                }
            }
            else {
                debug_1.debug(`Duplicate ack received ${message.clientSequenceNumber}`);
            }
        }
        this.emit("pre-op", message, local);
        this.processCore(message, local, context);
        this.emit("op", message, local);
    }
}
exports.SharedObject = SharedObject;
//# sourceMappingURL=sharedObject.js.map

/***/ }),

/***/ "./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/valueType.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@prague/map/node_modules/@prague/api-definitions/dist/valueType.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// TODO this is probably too map specific - but is used to serailize objects in certain cases
var ValueType;
(function (ValueType) {
    // The value is a shared object
    ValueType[ValueType["Shared"] = 0] = "Shared";
    // The value is a plain JavaScript object
    ValueType[ValueType["Plain"] = 1] = "Plain";
    // The value is a counter
    ValueType[ValueType["Counter"] = 2] = "Counter";
    // The value is a set
    ValueType[ValueType["Set"] = 3] = "Set";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=valueType.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/client.js":
/*!*******************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/client.js ***!
  \*******************************************************/
/*! exports provided: Client */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Client", function() { return Client; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeTree */ "./node_modules/@prague/merge-tree/lib/mergeTree.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collections */ "./node_modules/@prague/merge-tree/lib/collections.js");
// tslint:disable



class Client {
    constructor(initText, options) {
        this.accumTime = 0;
        this.localTime = 0;
        this.localOps = 0;
        this.accumWindowTime = 0;
        this.maxWindowTime = 0;
        this.accumWindow = 0;
        this.accumOps = 0;
        this.verboseOps = false;
        this.noVerboseRemoteAnnote = false;
        this.measureOps = false;
        this.clientSequenceNumber = 1;
        this.clientNameToIds = new _collections__WEBPACK_IMPORTED_MODULE_2__["RedBlackTree"](_mergeTree__WEBPACK_IMPORTED_MODULE_1__["compareStrings"]);
        this.shortClientIdMap = [];
        this.shortClientBranchIdMap = [];
        this.shortClientUserInfoMap = [];
        this.registerCollection = new _mergeTree__WEBPACK_IMPORTED_MODULE_1__["RegisterCollection"]();
        this.localSequenceNumber = _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"];
        this.opMarkersModified = [];
        this.pendingConsensus = new Map();
        this.mergeTree = new _mergeTree__WEBPACK_IMPORTED_MODULE_1__["MergeTree"](initText, options);
        this.mergeTree.getLongClientId = id => this.getLongClientId(id);
        this.mergeTree.getUserInfo = id => this.getUserInfo(id);
        this.mergeTree.markerModifiedHandler = marker => this.markerModified(marker);
        this.mergeTree.clientIdToBranchId = this.shortClientBranchIdMap;
        this.q = _collections__WEBPACK_IMPORTED_MODULE_2__["ListMakeHead"]();
        this.checkQ = _collections__WEBPACK_IMPORTED_MODULE_2__["ListMakeHead"]();
    }
    resetModifiedMarkers() {
        this.opMarkersModified = [];
    }
    markerModified(marker) {
        this.opMarkersModified.push(marker);
    }
    setLocalSequenceNumber(seq) {
        this.localSequenceNumber = seq;
    }
    resetLocalSequenceNumber() {
        this.localSequenceNumber = _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"];
    }
    undoSingleSequenceNumber(undoSegments, redoSegments) {
        let len = undoSegments.length;
        let index = len - 1;
        let seq = undoSegments[index].seq;
        if (seq === 0) {
            return 0;
        }
        while (index >= 0) {
            let undoInfo = undoSegments[index];
            if (seq === undoInfo.seq) {
                this.mergeTree.cherryPickedUndo(undoInfo);
                redoSegments.push(undoInfo);
            }
            else {
                break;
            }
            index--;
        }
        undoSegments.length = index + 1;
        return seq;
    }
    historyToPct(pct) {
        let count = this.undoSegments.length + this.redoSegments.length;
        let curPct = this.undoSegments.length / count;
        let seq = -1;
        if (curPct >= pct) {
            while (curPct > pct) {
                seq = this.undoSingleSequenceNumber(this.undoSegments, this.redoSegments);
                curPct = this.undoSegments.length / count;
            }
        }
        else {
            while (curPct < pct) {
                seq = this.undoSingleSequenceNumber(this.redoSegments, this.undoSegments);
                curPct = this.undoSegments.length / count;
            }
        }
        return seq;
    }
    undo() {
        return this.undoSingleSequenceNumber(this.undoSegments, this.redoSegments);
    }
    redo() {
        return this.undoSingleSequenceNumber(this.redoSegments, this.undoSegments);
    }
    cloneFromSegments() {
        let clone = new Client("", this.mergeTree.options);
        let segments = [];
        let newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);
        clone.mergeTree.root = newRoot;
        let undoSeg = [];
        for (let segment of segments) {
            if (segment.seq !== 0) {
                undoSeg.push({
                    seq: segment.seq,
                    seg: segment,
                    op: 0 /* INSERT */
                });
            }
            if (segment.removedSeq !== undefined) {
                undoSeg.push({
                    seq: segment.removedSeq,
                    seg: segment,
                    op: 1 /* REMOVE */
                });
            }
        }
        undoSeg = undoSeg.sort((a, b) => {
            if (b.seq === a.seq) {
                return 0;
            }
            else if (b.seq === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"]) {
                return -1;
            }
            else if (a.seq === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"]) {
                return 1;
            }
            else {
                return a.seq - b.seq;
            }
        });
        clone.undoSegments = undoSeg;
        clone.redoSegments = [];
        return clone;
    }
    getOrAddShortClientId(longClientId, branchId = 0) {
        if (!this.clientNameToIds.get(longClientId)) {
            this.addLongClientId(longClientId, branchId);
        }
        return this.getShortClientId(longClientId);
    }
    getShortClientId(longClientId) {
        return this.clientNameToIds.get(longClientId).data.clientId;
    }
    getLongClientId(shortClientId) {
        if (shortClientId >= 0) {
            return this.shortClientIdMap[shortClientId];
        }
        else {
            return "original";
        }
    }
    getUserInfo(shortClientId) {
        if (shortClientId >= 0) {
            return this.shortClientUserInfoMap[shortClientId];
        }
        else {
            return null;
        }
    }
    addLongClientId(longClientId, branchId = 0) {
        this.clientNameToIds.put(longClientId, {
            branchId,
            clientId: this.shortClientIdMap.length,
        });
        this.shortClientIdMap.push(longClientId);
        this.shortClientBranchIdMap.push(branchId);
    }
    getBranchId(clientId) {
        return this.shortClientBranchIdMap[clientId];
    }
    // TODO: props, end
    makeInsertMarkerMsg(markerType, behaviors, pos, seq, refSeq, objectId) {
        return {
            clientId: this.longClientId,
            minimumSequenceNumber: undefined,
            clientSequenceNumber: this.clientSequenceNumber,
            sequenceNumber: seq,
            referenceSequenceNumber: refSeq,
            objectId: objectId,
            userId: undefined,
            offset: seq,
            origin: null,
            contents: {
                type: 0 /* INSERT */, marker: { type: markerType, behaviors }, pos1: pos
            },
            timestamp: Date.now(),
            traces: [],
            type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Operation,
        };
    }
    makeInsertMsg(text, pos, seq, refSeq, objectId) {
        return {
            clientId: this.longClientId,
            sequenceNumber: seq,
            referenceSequenceNumber: refSeq,
            clientSequenceNumber: this.clientSequenceNumber,
            minimumSequenceNumber: undefined,
            objectId: objectId,
            userId: undefined,
            offset: seq,
            origin: null,
            contents: {
                type: 0 /* INSERT */, text: text, pos1: pos
            },
            timestamp: Date.now(),
            traces: [],
            type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Operation,
        };
    }
    makeRemoveMsg(start, end, seq, refSeq, objectId) {
        return {
            clientId: this.longClientId,
            sequenceNumber: seq,
            referenceSequenceNumber: refSeq,
            clientSequenceNumber: this.clientSequenceNumber,
            minimumSequenceNumber: undefined,
            objectId: objectId,
            userId: undefined,
            offset: seq,
            origin: null,
            contents: {
                type: 1 /* REMOVE */, pos1: start, pos2: end,
            },
            timestamp: Date.now(),
            traces: [],
            type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Operation,
        };
    }
    makeAnnotateMsg(props, start, end, seq, refSeq, objectId) {
        return {
            clientId: this.longClientId,
            sequenceNumber: seq,
            referenceSequenceNumber: refSeq,
            objectId: objectId,
            clientSequenceNumber: this.clientSequenceNumber,
            userId: undefined,
            minimumSequenceNumber: undefined,
            offset: seq,
            origin: null,
            contents: {
                type: 2 /* ANNOTATE */, pos1: start, pos2: end, props
            },
            timestamp: Date.now(),
            traces: [],
            type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Operation,
        };
    }
    hasMessages() {
        return this.q.count() > 0;
    }
    enqueueMsg(msg) {
        this.q.enqueue(msg);
    }
    dequeueMsg() {
        return this.q.dequeue();
    }
    enqueueTestString() {
        this.checkQ.enqueue(this.getText());
    }
    segmentToOps(segment, opList) {
        // TODO: branches
        if (segment.seq === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"]) {
            let pos = this.mergeTree.getOffset(segment, this.getCurrentSeq(), this.getClientId());
            let insertOp = {
                pos1: pos,
                type: 0 /* INSERT */,
            };
            if (segment.getType() === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["SegmentType"].Text) {
                let textSegment = segment;
                insertOp.text = textSegment.text;
            }
            else {
                // assume marker
                let marker = segment;
                insertOp.marker = { refType: marker.refType };
            }
            if (segment.properties) {
                insertOp.props = segment.properties;
            }
            opList.push(insertOp);
        }
        if (segment.removedSeq === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"]) {
            let start = this.mergeTree.getOffset(segment, this.getCurrentSeq(), this.getClientId());
            let removeOp = {
                pos1: start,
                pos2: start + segment.cachedLength,
                type: 1 /* REMOVE */,
            };
            opList.push(removeOp);
        }
    }
    transformOp(op, referenceSequenceNumber, toSequenceNumber) {
        if ((op.type == 2 /* ANNOTATE */) ||
            (op.type == 1 /* REMOVE */)) {
            let ranges = this.mergeTree.tardisRange(op.pos1, op.pos2, referenceSequenceNumber, toSequenceNumber);
            if (ranges.length == 1) {
                op.pos1 = ranges[0].start;
                op.pos2 = ranges[0].end;
            }
            else {
                let groupOp = { type: 3 /* GROUP */ };
                groupOp.ops = ranges.map((range) => ({
                    type: op.type,
                    pos1: range.start,
                    pos2: range.end,
                }));
                return groupOp;
            }
        }
        else if (op.type == 0 /* INSERT */) {
            op.pos1 = this.mergeTree.tardisPosition(op.pos1, referenceSequenceNumber, toSequenceNumber);
        }
        else if (op.type === 3 /* GROUP */) {
            for (let i = 0, len = op.ops.length; i < len; i++) {
                op.ops[i] = this.transformOp(op.ops[i], referenceSequenceNumber, toSequenceNumber);
            }
        }
        return op;
    }
    transform(op, referenceSequenceNumber, toSequenceNumber) {
        if (referenceSequenceNumber >= toSequenceNumber) {
            return op;
        }
        return this.transformOp(op, referenceSequenceNumber, toSequenceNumber);
    }
    copy(start, end, registerId, refSeq, clientId, longClientId) {
        let segs = this.mergeTree.cloneSegments(refSeq, clientId, start, end);
        this.registerCollection.set(longClientId, registerId, segs);
    }
    pasteLocal(register, pos, opArgs) {
        let segs = this.registerCollection.get(this.longClientId, register);
        if (segs) {
            this.mergeTree.startGroupOperation();
            // TODO: build tree from segs and insert all at once
            for (let seg of segs) {
                if (seg.getType() === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["SegmentType"].Text) {
                    let textSegment = seg;
                    this.insertTextLocal(textSegment.text, pos, textSegment.properties, opArgs);
                    pos += textSegment.cachedLength;
                }
                else {
                    let marker = seg;
                    this.insertMarkerLocal(pos, marker.refType, marker.properties, opArgs);
                    pos += marker.cachedLength;
                }
            }
            this.mergeTree.endGroupOperation();
        }
        return pos;
    }
    pasteRemote(pos, registerId, seq, refSeq, clientId, longClientId, opArgs) {
        let segs = this.registerCollection.get(longClientId, registerId);
        if (segs) {
            // TODO: build tree from segs and insert all at once
            for (let seg of segs) {
                if (seg.getType() === _mergeTree__WEBPACK_IMPORTED_MODULE_1__["SegmentType"].Text) {
                    let textSegment = seg;
                    this.insertTextRemote(textSegment.text, pos, textSegment.properties, seq, refSeq, clientId, opArgs);
                    pos += textSegment.cachedLength;
                }
                else {
                    let marker = seg;
                    this.insertMarkerRemote({ refType: marker.refType }, pos, marker.properties, seq, refSeq, clientId, opArgs);
                    pos += marker.cachedLength;
                }
            }
        }
        // TODO: error reporting
    }
    checkNest(op, msg, clid) {
        let beginMarker = this.mergeTree.getSegmentFromId(op.checkNest.id1);
        let endMarker = this.mergeTree.getSegmentFromId(op.checkNest.id2);
        let beginPos = this.mergeTree.getOffset(beginMarker, msg.referenceSequenceNumber, clid);
        let endPos = endMarker.cachedLength + this.mergeTree.getOffset(endMarker, msg.referenceSequenceNumber, clid);
        if ((beginPos !== op.pos1) || (endPos !== op.pos2)) {
            console.log(`remove nest mismatch ${beginPos} ${op.pos1} ${endPos} ${op.pos2}`);
        }
    }
    applyOp(opArgs) {
        const op = opArgs.op;
        const msg = opArgs.sequencedMessage;
        let clid = this.getOrAddShortClientId(msg.clientId);
        switch (op.type) {
            case 0 /* INSERT */:
                if (op.relativePos1) {
                    op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1, msg.referenceSequenceNumber, clid);
                    if (op.pos1 < 0) {
                        // TODO: event when marker id not found
                        return;
                    }
                }
                if (op.text !== undefined) {
                    if (op.pos2 !== undefined) {
                        // replace
                        this.removeSegmentRemote(op.pos1, op.pos2, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);
                    }
                    this.insertTextRemote(op.text, op.pos1, op.props, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);
                }
                else if (op.marker !== undefined) {
                    this.insertMarkerRemote(op.marker, op.pos1, op.props, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);
                }
                else if (op.items !== undefined) {
                    this.insertItemsRemote(op.items, op.isNumberSequence, op.pos1, op.props, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);
                }
                else if (op.register !== undefined) {
                    // TODO: relative addressing
                    if (op.pos2 !== undefined) {
                        // copy
                        this.copy(op.pos1, op.pos2, op.register, msg.referenceSequenceNumber, clid, msg.clientId);
                    }
                    else {
                        // paste
                        this.pasteRemote(op.pos1, op.register, msg.sequenceNumber, msg.referenceSequenceNumber, clid, msg.clientId, opArgs);
                    }
                }
                break;
            case 1 /* REMOVE */:
                if (op.relativePos1) {
                    op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1, msg.referenceSequenceNumber, clid);
                    if (op.pos1 < 0) {
                        // TODO: event when marker id not found
                        return;
                    }
                }
                if (op.relativePos2) {
                    op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2, msg.referenceSequenceNumber, clid);
                    if (op.pos2 < 0) {
                        // TODO: event when marker id not found
                        return;
                    }
                }
                if (op.register) {
                    // cut
                    this.copy(op.pos1, op.pos2, op.register, msg.referenceSequenceNumber, clid, msg.clientId);
                }
                if (op.checkNest) {
                    this.checkNest(op, msg, clid);
                }
                this.removeSegmentRemote(op.pos1, op.pos2, msg.sequenceNumber, msg.referenceSequenceNumber, clid, opArgs);
                break;
            case 2 /* ANNOTATE */:
                if (op.relativePos1) {
                    op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1, msg.referenceSequenceNumber, clid);
                    if (op.pos1 < 0) {
                        // TODO: event when marker id not found
                        return;
                    }
                }
                if (op.relativePos2) {
                    op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2, msg.referenceSequenceNumber, clid);
                    if (op.pos2 < 0) {
                        // TODO: event when marker id not found
                        return;
                    }
                }
                this.annotateSegmentRemote(op.props, op.pos1, op.pos2, msg.sequenceNumber, msg.referenceSequenceNumber, clid, op.combiningOp, opArgs);
                break;
            case 3 /* GROUP */: {
                for (let memberOp of op.ops) {
                    this.applyOp({
                        op: memberOp,
                        groupOp: op,
                        sequencedMessage: msg,
                    });
                }
                break;
            }
        }
    }
    getModifiedMarkersForOp() {
        return this.opMarkersModified;
    }
    coreApplyMsg(msg) {
        this.resetModifiedMarkers();
        this.applyOp({
            op: msg.contents,
            sequencedMessage: msg
        });
    }
    applyMsg(msg) {
        if ((msg !== undefined) && (msg.minimumSequenceNumber > this.mergeTree.getCollabWindow().minSeq)) {
            this.updateMinSeq(msg.minimumSequenceNumber);
        }
        // Ensure client ID is registered
        // TODO support for more than two branch IDs
        // The existance of msg.origin means we are a branch message - and so should be marked as 0
        // The non-existance of msg.origin indicates we are local - and should inherit the collab mode ID
        const branchId = msg.origin ? 0 : this.mergeTree.localBranchId;
        this.getOrAddShortClientId(msg.clientId, branchId);
        // Apply if an operation message
        if (msg.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Operation) {
            const operationMessage = msg;
            if (msg.clientId === this.longClientId) {
                let op = msg.contents;
                if (op.type !== 2 /* ANNOTATE */) {
                    this.ackPendingSegment(operationMessage.sequenceNumber);
                }
                else {
                    if (op.combiningOp && (op.combiningOp.name === "consensus")) {
                        this.updateConsensusProperty(op, operationMessage);
                    }
                }
            }
            else {
                this.coreApplyMsg(operationMessage);
            }
        }
    }
    applyMessages(msgCount) {
        while (msgCount > 0) {
            let msg = this.q.dequeue();
            if (msg) {
                this.applyMsg(msg);
            }
            else {
                break;
            }
            msgCount--;
        }
        return true;
    }
    getLocalSequenceNumber() {
        let segWindow = this.mergeTree.getCollabWindow();
        if (segWindow.collaborating) {
            return this.localSequenceNumber;
        }
        else {
            return _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UniversalSequenceNumber"];
        }
    }
    localTransaction(groupOp, segmentGroup) {
        segmentGroup = this.mergeTree.startGroupOperation(segmentGroup);
        for (let op of groupOp.ops) {
            const opArgs = {
                op,
                groupOp,
            };
            switch (op.type) {
                case 0 /* INSERT */:
                    if (op.relativePos1) {
                        op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1);
                        if (op.pos1 < 0) {
                            // TODO: raise exception or other error flow
                            break;
                        }
                    }
                    if (op.marker) {
                        this.insertMarkerLocal(op.pos1, op.marker.refType, op.props, opArgs);
                    }
                    else {
                        this.insertTextLocal(op.text, op.pos1, op.props, opArgs);
                    }
                    break;
                case 2 /* ANNOTATE */:
                    if (op.relativePos1) {
                        op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1);
                        if (op.pos1 < 0) {
                            // TODO: raise exception or other error flow
                            break;
                        }
                    }
                    if (op.relativePos2) {
                        op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2);
                        if (op.pos2 < 0) {
                            // TODO: raise exception or other error flow
                            break;
                        }
                    }
                    this.annotateSegmentLocal(op.props, op.pos1, op.pos2, op.combiningOp, opArgs);
                    break;
                case 1 /* REMOVE */:
                    if (op.relativePos1) {
                        op.pos1 = this.mergeTree.posFromRelativePos(op.relativePos1);
                        if (op.pos1 < 0) {
                            // TODO: raise exception or other error flow
                            break;
                        }
                    }
                    if (op.relativePos2) {
                        op.pos2 = this.mergeTree.posFromRelativePos(op.relativePos2);
                        if (op.pos2 < 0) {
                            // TODO: raise exception or other error flow
                            break;
                        }
                    }
                    this.removeSegmentLocal(op.pos1, op.pos2, opArgs);
                    break;
                case 3 /* GROUP */:
                    console.log("unhandled nested group op");
                    break;
            }
        }
        this.mergeTree.endGroupOperation();
        return segmentGroup;
    }
    updateConsensusProperty(op, msg) {
        let markerId = op.relativePos1.id;
        let consensusInfo = this.pendingConsensus.get(markerId);
        if (consensusInfo) {
            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);
        }
        this.mergeTree.addMinSeqListener(msg.sequenceNumber, (minSeq) => consensusInfo.callback(consensusInfo.marker));
    }
    // marker must have an id
    annotateMarkerNotifyConsensus(marker, props, consensusCallback, opArgs) {
        let combiningOp = {
            name: "consensus"
        };
        let consensusInfo = {
            callback: consensusCallback,
            marker,
        };
        let id = marker.getId();
        this.pendingConsensus.set(id, consensusInfo);
        this.annotateMarker(props, marker, combiningOp, opArgs);
    }
    annotateMarker(props, marker, op, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        this.resetModifiedMarkers();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        let start = this.mergeTree.getOffset(marker, _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UniversalSequenceNumber"], this.getClientId());
        this.mergeTree.annotateRange(props, start, start + marker.cachedLength, refSeq, clientId, seq, op, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`annotate local cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);
        }
    }
    annotateSegmentLocal(props, start, end, op, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        this.resetModifiedMarkers();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.annotateRange(props, start, end, refSeq, clientId, seq, op, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`annotate local cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);
        }
    }
    annotateSegmentRemote(props, start, end, seq, refSeq, clientId, combiningOp, opArgs) {
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.annotateRange(props, start, end, refSeq, clientId, seq, combiningOp, opArgs);
        this.mergeTree.getCollabWindow().currentSeq = seq;
        if (this.measureOps) {
            this.accumTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumOps++;
            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);
        }
        if (this.verboseOps && (!this.noVerboseRemoteAnnote)) {
            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} seq ${seq} annotate remote start ${start} end ${end} refseq ${refSeq} cli ${clientId} props ${props}`);
        }
    }
    removeSegmentLocal(start, end, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        this.resetModifiedMarkers();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.markRangeRemoved(start, end, refSeq, clientId, seq, false, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`remove local cli ${this.getLongClientId(clientId)} ref seq ${refSeq} [${start},${end})`);
        }
    }
    removeSegmentRemote(start, end, seq, refSeq, clientId, opArgs) {
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.markRangeRemoved(start, end, refSeq, clientId, seq, false, opArgs);
        this.mergeTree.getCollabWindow().currentSeq = seq;
        if (this.measureOps) {
            this.accumTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumOps++;
            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);
        }
        if (this.verboseOps) {
            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} seq ${seq} remove remote start ${start} end ${end} refseq ${refSeq} cli ${this.getLongClientId(clientId)}`);
        }
    }
    insertTextLocal(text, pos, props, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        this.resetModifiedMarkers();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.insertText(pos, refSeq, clientId, seq, text, props, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`insert local text ${text} pos ${pos} cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);
        }
    }
    insertTextMarkerRelative(text, markerPos, props, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        this.resetModifiedMarkers();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.insertTextMarkerRelative(markerPos, refSeq, clientId, seq, text, props, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`insert local text marker relative ${text} pos ${markerPos.id} cli ${this.getLongClientId(clientId)} ref seq ${refSeq}`);
        }
    }
    insertSegmentLocal(pos, segment, props, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        segment.seq = seq;
        segment.clientId = clientId;
        this.mergeTree.insertSegment(pos, refSeq, clientId, seq, segment, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`insert local segment pos ${pos} cli ${this.getLongClientId(clientId)} ${segment.toString()} ref seq ${refSeq}`);
        }
    }
    insertMarkerLocal(pos, behaviors, props, opArgs) {
        let segWindow = this.mergeTree.getCollabWindow();
        let clientId = segWindow.clientId;
        let refSeq = segWindow.currentSeq;
        let seq = this.getLocalSequenceNumber();
        this.resetModifiedMarkers();
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        let marker = this.mergeTree.insertMarker(pos, refSeq, clientId, seq, behaviors, props, opArgs);
        if (this.measureOps) {
            this.localTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.localOps++;
        }
        if (this.verboseOps) {
            console.log(`insert local marker pos ${pos} cli ${this.getLongClientId(clientId)} ${marker.toString()} ref seq ${refSeq}`);
        }
    }
    insertItemsRemote(items, isNumberSequence, pos, props, seq, refSeq, clientId, opArgs) {
        const traceItems = false;
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        let segment;
        if (isNumberSequence) {
            segment = new _mergeTree__WEBPACK_IMPORTED_MODULE_1__["SubSequence"](items, seq, clientId);
        }
        else {
            segment = new _mergeTree__WEBPACK_IMPORTED_MODULE_1__["SubSequence"](items, seq, clientId);
        }
        if (props) {
            segment.addProperties(props);
        }
        if (traceItems) {
            console.log(`pre-length: ${this.mergeTree.getLength(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["UniversalSequenceNumber"], this.mergeTree.collabWindow.clientId)} pos: ${pos}`);
        }
        this.mergeTree.insertSegment(pos, refSeq, clientId, seq, segment, opArgs);
        if (traceItems) {
            console.log(`post-length: ${this.mergeTree.getLength(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["UniversalSequenceNumber"], this.mergeTree.collabWindow.clientId)} pos: ${pos}`);
        }
        this.mergeTree.getCollabWindow().currentSeq = seq;
        if (this.measureOps) {
            this.accumTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumOps++;
            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);
        }
        if (this.verboseOps) {
            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} ${segment.toString()} seq ${seq} insert remote pos ${pos} refseq ${refSeq} cli ${clientId}`);
        }
    }
    insertMarkerRemote(markerDef, pos, props, seq, refSeq, clientId, opArgs) {
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        let marker = this.mergeTree.insertMarker(pos, refSeq, clientId, seq, markerDef.refType, props, opArgs);
        this.mergeTree.getCollabWindow().currentSeq = seq;
        if (this.measureOps) {
            this.accumTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumOps++;
            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);
        }
        if (this.verboseOps) {
            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} ${marker.toString()} seq ${seq} insert remote pos ${pos} refseq ${refSeq} cli ${clientId}`);
        }
    }
    insertTextRemote(text, pos, props, seq, refSeq, clientId, opArgs) {
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.insertText(pos, refSeq, clientId, seq, text, props, opArgs);
        this.mergeTree.getCollabWindow().currentSeq = seq;
        if (this.measureOps) {
            this.accumTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumOps++;
            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);
        }
        if (this.verboseOps) {
            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} text ${text} seq ${seq} insert remote pos ${pos} refseq ${refSeq} cli ${this.getLongClientId(clientId)}`);
        }
    }
    ackPendingSegment(seq) {
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.ackPendingSegment(seq, this.verboseOps);
        this.mergeTree.getCollabWindow().currentSeq = seq;
        if (this.measureOps) {
            this.accumTime += Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumOps++;
            this.accumWindow += (this.getCurrentSeq() - this.mergeTree.getCollabWindow().minSeq);
        }
        if (this.verboseOps) {
            console.log(`@cli ${this.getLongClientId(this.mergeTree.getCollabWindow().clientId)} ack seq # ${seq}`);
        }
    }
    updateMinSeq(minSeq) {
        let clockStart;
        if (this.measureOps) {
            clockStart = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["clock"])();
        }
        this.mergeTree.updateGlobalMinSeq(minSeq);
        if (this.measureOps) {
            let elapsed = Object(_mergeTree__WEBPACK_IMPORTED_MODULE_1__["elapsedMicroseconds"])(clockStart);
            this.accumWindowTime += elapsed;
            if (elapsed > this.maxWindowTime) {
                this.maxWindowTime = elapsed;
            }
        }
    }
    getPropertiesAtPosition(pos) {
        let segWindow = this.mergeTree.getCollabWindow();
        if (this.verboseOps) {
            console.log(`getPropertiesAtPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);
        }
        let propertiesAtPosition;
        let segoff = this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);
        let seg = segoff.segment;
        if (seg) {
            propertiesAtPosition = seg.properties;
        }
        return propertiesAtPosition;
    }
    getRangeExtentsOfPosition(pos) {
        let segWindow = this.mergeTree.getCollabWindow();
        if (this.verboseOps) {
            console.log(`getRangeExtentsOfPosition cli ${this.getLongClientId(segWindow.clientId)} ref seq ${segWindow.currentSeq}`);
        }
        let startPos;
        let endPos;
        let segoff = this.mergeTree.getContainingSegment(pos, segWindow.currentSeq, segWindow.clientId);
        let seg = segoff.segment;
        if (seg) {
            startPos = this.mergeTree.getOffset(seg, segWindow.currentSeq, segWindow.clientId);
            endPos = startPos + seg.cachedLength;
        }
        return { startPos, endPos };
    }
    getCurrentSeq() {
        return this.mergeTree.getCollabWindow().currentSeq;
    }
    getClientId() {
        return this.mergeTree.getCollabWindow().clientId;
    }
    getTextAndMarkers(label) {
        let segmentWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);
    }
    getText(start, end) {
        let segmentWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, "", start, end);
    }
    /**
     * Adds spaces for markers and components, so that position calculations account for them
     */
    getTextWithPlaceholders() {
        let segmentWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ");
    }
    getTextRangeWithPlaceholders(start, end) {
        let segmentWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ", start, end);
    }
    getTextRangeWithMarkers(start, end) {
        let segmentWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getText(segmentWindow.currentSeq, segmentWindow.clientId, "*", start, end);
    }
    getLength() {
        let segmentWindow = this.mergeTree.getCollabWindow();
        return this.mergeTree.getLength(segmentWindow.currentSeq, segmentWindow.clientId);
    }
    relText(clientId, refSeq) {
        return `cli: ${this.getLongClientId(clientId)} refSeq: ${refSeq}: ` + this.mergeTree.getText(refSeq, clientId);
    }
    relItems(clientId, refSeq) {
        return `cli: ${this.getLongClientId(clientId)} refSeq: ${refSeq}: ` + this.mergeTree.getItems(refSeq, clientId).toString();
    }
    startCollaboration(longClientId, minSeq = 0, branchId = 0) {
        this.longClientId = longClientId;
        this.addLongClientId(longClientId, branchId);
        this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, branchId);
    }
    updateCollaboration(longClientId) {
        const oldClientId = this.longClientId;
        let oldData = this.clientNameToIds.get(oldClientId).data;
        this.longClientId = longClientId;
        this.clientNameToIds.put(longClientId, oldData);
        this.shortClientIdMap[oldData.clientId] = longClientId;
    }
    findTile(startPos, tileLabel, preceding = true) {
        const clientId = this.getClientId();
        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);
    }
}
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/collections.js":
/*!************************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/collections.js ***!
  \************************************************************/
/*! exports provided: Stack, ListRemoveEntry, ListMakeEntry, ListMakeHead, List, numberComparer, Heap, LinearDictionary, RedBlackTree, integerRangeUnion, integerRangeOverlaps, integerRangeComparer, integerRangeCopy, integerRangeToString, IntegerRangeTree, intervalComparer, IntervalTree, TST */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListRemoveEntry", function() { return ListRemoveEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListMakeEntry", function() { return ListMakeEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListMakeHead", function() { return ListMakeHead; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberComparer", function() { return numberComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return Heap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearDictionary", function() { return LinearDictionary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedBlackTree", function() { return RedBlackTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integerRangeUnion", function() { return integerRangeUnion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integerRangeOverlaps", function() { return integerRangeOverlaps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integerRangeComparer", function() { return integerRangeComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integerRangeCopy", function() { return integerRangeCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "integerRangeToString", function() { return integerRangeToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntegerRangeTree", function() { return IntegerRangeTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intervalComparer", function() { return intervalComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalTree", function() { return IntervalTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TST", function() { return TST; });
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeTree */ "./node_modules/@prague/merge-tree/lib/mergeTree.js");
// tslint:disable

class Stack {
    constructor() {
        this.items = [];
    }
    push(val) {
        this.items.push(val);
    }
    empty() {
        return this.items.length == 0;
    }
    top() {
        return this.items[this.items.length - 1];
    }
    pop() {
        return this.items.pop();
    }
}
function ListRemoveEntry(entry) {
    if (entry === undefined) {
        return undefined;
    }
    else if (entry.isHead) {
        return undefined;
    }
    else {
        entry.next.prev = entry.prev;
        entry.prev.next = entry.next;
    }
    return (entry);
}
function ListMakeEntry(data) {
    var entry = new List(false, data);
    entry.prev = entry;
    entry.next = entry;
    return entry;
}
function ListMakeHead() {
    var entry = new List(true, undefined);
    entry.prev = entry;
    entry.next = entry;
    return entry;
}
class List {
    constructor(isHead, data) {
        this.isHead = isHead;
        this.data = data;
    }
    clear() {
        if (this.isHead) {
            this.prev = this;
            this.next = this;
        }
    }
    add(data) {
        var entry = ListMakeEntry(data);
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return (entry);
    }
    dequeue() {
        if (!this.empty()) {
            let removedEntry = ListRemoveEntry(this.next);
            return removedEntry.data;
        }
    }
    enqueue(data) {
        return this.add(data);
    }
    walk(fn) {
        for (var entry = this.next; !(entry.isHead); entry = entry.next) {
            fn(entry.data, entry);
        }
    }
    some(fn, rev) {
        for (var entry = this; !(entry.isHead); entry = rev ? entry.prev : entry.next) {
            if (fn(entry.data, entry)) {
                return (entry.data);
            }
        }
    }
    count() {
        var entry;
        var i;
        entry = this.next;
        for (i = 0; !(entry.isHead); i++) {
            entry = entry.next;
        }
        return (i);
    }
    first() {
        if (!this.empty()) {
            return (this.next.data);
        }
    }
    last() {
        if (!this.empty()) {
            return (this.prev.data);
        }
    }
    empty() {
        return (this.next == this);
    }
    pushEntry(entry) {
        entry.isHead = false;
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
    }
    push(data) {
        var entry = ListMakeEntry(data);
        entry.data = data;
        entry.isHead = false;
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
    }
    popEntry(head) {
        if (this.next.isHead)
            return (undefined);
        else
            return (ListRemoveEntry(this.next));
    }
    insertEntry(entry) {
        entry.isHead = false;
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return entry;
    }
    insertAfter(data) {
        var entry = ListMakeEntry(data);
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
        return (entry);
    }
    insertBefore(data) {
        var entry = ListMakeEntry(data);
        return this.insertEntryBefore(entry);
    }
    insertEntryBefore(entry) {
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return (entry);
    }
}
var numberComparer = {
    min: Number.MIN_VALUE,
    compare: (a, b) => a - b,
};
class Heap {
    constructor(a, comp) {
        this.comp = comp;
        this.L = [comp.min];
        for (var i = 0, len = a.length; i < len; i++) {
            this.add(a[i]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    peek() {
        return this.L[1];
    }
    get() {
        var x = this.L[1];
        this.L[1] = this.L[this.count()];
        this.L.pop();
        this.fixdown(1);
        return x;
    }
    add(x) {
        this.L.push(x);
        this.fixup(this.count());
    }
    fixup(k) {
        while (k > 1 && (this.comp.compare(this.L[k >> 1], this.L[k]) > 0)) {
            var tmp = this.L[k >> 1];
            this.L[k >> 1] = this.L[k];
            this.L[k] = tmp;
            k = k >> 1;
        }
    }
    fixdown(k) {
        while ((k << 1) <= (this.count())) {
            var j = k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[k], this.L[j]) <= 0) {
                break;
            }
            var tmp = this.L[k];
            this.L[k] = this.L[j];
            this.L[j] = tmp;
            k = j;
        }
    }
}
// for testing
function LinearDictionary(compareKeys) {
    let a = [];
    function compareProps(a, b) {
        return compareKeys(a.key, b.key);
    }
    function diag() {
        console.log(`size is ${a.length}`);
    }
    function mapRange(action, accum, start, end) {
        if (start === undefined) {
            start = min().key;
        }
        if (end === undefined) {
            end = max().key;
        }
        for (let i = 0, len = a.length; i < len; i++) {
            if (compareKeys(start, a[i].key) <= 0) {
                let ecmp = compareKeys(end, a[i].key);
                if (ecmp < 0) {
                    break;
                }
                if (!action(a[i], accum)) {
                    break;
                }
            }
        }
    }
    function map(action, accum) {
        mapRange(action, accum);
    }
    function min() {
        if (a.length > 0) {
            return a[0];
        }
    }
    function max() {
        if (a.length > 0) {
            return a[a.length - 1];
        }
    }
    function get(key) {
        for (let i = 0, len = a.length; i < len; i++) {
            if (a[i].key == key) {
                return a[i];
            }
        }
    }
    function put(key, data) {
        if (key !== undefined) {
            if (data === undefined) {
                remove(key);
            }
            else {
                a.push({ key: key, data: data });
                a.sort(compareProps); // go to insertion sort if too slow
            }
        }
    }
    function remove(key) {
        if (key !== undefined) {
            for (let i = 0, len = a.length; i < len; i++) {
                if (a[i].key == key) {
                    a[i] = a[len - 1];
                    a.length--;
                    a.sort(compareProps);
                    break;
                }
            }
        }
    }
    return {
        min: min,
        max: max,
        map: map,
        mapRange: mapRange,
        remove: remove,
        get: get,
        put: put,
        diag: diag
    };
}
class RedBlackTree {
    constructor(compareKeys, aug) {
        this.compareKeys = compareKeys;
        this.aug = aug;
    }
    makeNode(key, data, color, size) {
        let node = { key: key, data: data, color: color, size: size };
        if (this.aug && this.aug.init) {
            this.aug.init(node);
        }
        return node;
    }
    isRed(node) {
        return node && (node.color == 0 /* RED */);
    }
    nodeSize(node) {
        return node ? node.size : 0;
    }
    size() {
        return this.nodeSize(this.root);
    }
    isEmpty() {
        return !this.root;
    }
    get(key) {
        if (key !== undefined) {
            return this.nodeGet(this.root, key);
        }
    }
    nodeGet(node, key) {
        while (node) {
            let cmp = this.compareKeys(key, node.key);
            if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
            else {
                return node;
            }
        }
    }
    contains(key) {
        return this.get(key);
    }
    gather(key, matcher) {
        let results = [];
        if (key !== undefined) {
            this.nodeGather(this.root, results, key, matcher);
        }
        return results;
    }
    nodeGather(node, results, key, matcher) {
        if (node) {
            if (matcher.continueSubtree(node.left, key)) {
                this.nodeGather(node.left, results, key, matcher);
            }
            if (matcher.matchNode(node, key)) {
                results.push(node);
            }
            if (matcher.continueSubtree(node.right, key)) {
                this.nodeGather(node.right, results, key, matcher);
            }
        }
    }
    put(key, data, conflict) {
        if (key !== undefined) {
            if (data === undefined) {
                this.remove(key);
            }
            else {
                this.root = this.nodePut(this.root, key, data, conflict);
                this.root.color = 1 /* BLACK */;
            }
        }
    }
    nodePut(node, key, data, conflict) {
        if (!node) {
            return this.makeNode(key, data, 0 /* RED */, 1);
        }
        else {
            let cmp = this.compareKeys(key, node.key);
            if (cmp < 0) {
                node.left = this.nodePut(node.left, key, data, conflict);
            }
            else if (cmp > 0) {
                node.right = this.nodePut(node.right, key, data, conflict);
            }
            else {
                if (conflict) {
                    const kd = conflict(key, node.key, data, node.data);
                    if (kd.key) {
                        node.key = kd.key;
                    }
                    if (kd.data) {
                        node.data = kd.data;
                    }
                    else {
                        node.data = data;
                    }
                }
                else {
                    node.data = data;
                }
            }
            if (this.isRed(node.right) && (!this.isRed(node.left))) {
                node = this.rotateLeft(node);
            }
            if (this.isRed(node.left) && this.isRed(node.left.left)) {
                node = this.rotateRight(node);
            }
            if (this.isRed(node.left) && this.isRed(node.right)) {
                this.flipColors(node);
            }
            node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
            if (this.aug) {
                this.updateLocal(node);
            }
            return node;
        }
    }
    updateLocal(node) {
        if (this.aug) {
            if (this.isRed(node.left)) {
                this.aug.update(node.left);
            }
            if (this.isRed(node.right)) {
                this.aug.update(node.right);
            }
            this.aug.update(node);
        }
    }
    removeMin() {
        if (!this.isEmpty()) {
            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
                this.root.color = 0 /* RED */;
            }
            this.root = this.nodeRemoveMin(this.root);
            if (!this.isEmpty()) {
                this.root.color = 1 /* BLACK */;
            }
        }
        // TODO: error on empty
    }
    nodeRemoveMin(node) {
        if (node.left) {
            if ((!this.isRed(node.left)) && (!this.isRed(node.left.left))) {
                node = this.moveRedLeft(node);
            }
            node.left = this.nodeRemoveMin(node.left);
            return this.balance(node);
        }
    }
    removeMax() {
        if (this.isEmpty()) {
            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
                this.root.color = 0 /* RED */;
            }
            this.root = this.nodeRemoveMax(this.root);
            if (!this.isEmpty()) {
                this.root.color = 1 /* BLACK */;
            }
        }
        // TODO: error on empty
    }
    nodeRemoveMax(node) {
        if (this.isRed(node.left)) {
            node = this.rotateRight(node);
        }
        if (!node.right) {
            return undefined;
        }
        if ((!this.isRed(node.right)) && (!this.isRed(node.right.left))) {
            node = this.moveRedRight(node);
        }
        node.right = this.nodeRemoveMax(node.right);
        return this.balance(node);
    }
    remove(key) {
        if (key !== undefined) {
            if (!this.contains(key)) {
                return;
            }
            if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
                this.root.color = 0 /* RED */;
            }
            this.root = this.nodeRemove(this.root, key);
        }
        // TODO: error on undefined key
    }
    nodeRemove(node, key) {
        if (this.compareKeys(key, node.key) < 0) {
            if ((!this.isRed(node.left)) && (!this.isRed(node.left.left))) {
                node = this.moveRedLeft(node);
            }
            node.left = this.nodeRemove(node.left, key);
        }
        else {
            if (this.isRed(node.left)) {
                node = this.rotateRight(node);
            }
            if ((this.compareKeys(key, node.key) == 0) && (!node.right)) {
                return undefined;
            }
            if ((!this.isRed(node.right)) && (!this.isRed(node.right.left))) {
                node = this.moveRedRight(node);
            }
            if (this.compareKeys(key, node.key) == 0) {
                let subtreeMin = this.nodeMin(node.right);
                node.key = subtreeMin.key;
                node.data = subtreeMin.data;
                node.right = this.nodeRemoveMin(node.right);
            }
            else {
                node.right = this.nodeRemove(node.right, key);
            }
        }
        return this.balance(node);
    }
    height() {
        return this.nodeHeight(this.root);
    }
    nodeHeight(node) {
        if (node === undefined) {
            return -1;
        }
        else {
            return 1 + Math.max(this.nodeHeight(node.left), this.nodeHeight(node.right));
        }
    }
    floor(key) {
        if (!this.isEmpty()) {
            return this.nodeFloor(this.root, key);
        }
    }
    nodeFloor(node, key) {
        if (node) {
            let cmp = this.compareKeys(key, node.key);
            if (cmp == 0) {
                return node;
            }
            else if (cmp < 0) {
                return this.nodeFloor(node.left, key);
            }
            else {
                let rightFloor = this.nodeFloor(node.right, key);
                if (rightFloor) {
                    return rightFloor;
                }
                else {
                    return node;
                }
            }
        }
    }
    ceil(key) {
        if (!this.isEmpty()) {
            return this.nodeCeil(this.root, key);
        }
    }
    nodeCeil(node, key) {
        if (node) {
            let cmp = this.compareKeys(key, node.key);
            if (cmp == 0) {
                return node;
            }
            else if (cmp > 0) {
                return this.nodeCeil(node.right, key);
            }
            else {
                let leftCeil = this.nodeCeil(node.left, key);
                if (leftCeil) {
                    return leftCeil;
                }
                else {
                    return node;
                }
            }
        }
    }
    min() {
        if (!this.isEmpty()) {
            return this.nodeMin(this.root);
        }
        // TODO: error on empty
    }
    nodeMin(node) {
        if (!node.left) {
            return node;
        }
        else {
            return this.nodeMin(node.left);
        }
    }
    max() {
        if (!this.isEmpty()) {
            return this.nodeMax(this.root);
        }
        // TODO: error on empty
    }
    nodeMax(node) {
        if (!node.right) {
            return node;
        }
        else {
            return this.nodeMax(node.right);
        }
    }
    rotateRight(node) {
        let leftChild = node.left;
        node.left = leftChild.right;
        leftChild.right = node;
        leftChild.color = leftChild.right.color;
        leftChild.right.color = 0 /* RED */;
        leftChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(leftChild);
        }
        return leftChild;
    }
    rotateLeft(node) {
        let rightChild = node.right;
        node.right = rightChild.left;
        rightChild.left = node;
        rightChild.color = rightChild.left.color;
        rightChild.left.color = 0 /* RED */;
        rightChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(rightChild);
        }
        return rightChild;
    }
    oppositeColor(c) {
        return (c == 1 /* BLACK */) ? 0 /* RED */ : 1 /* BLACK */;
    }
    flipColors(node) {
        node.color = this.oppositeColor(node.color);
        node.left.color = this.oppositeColor(node.left.color);
        node.right.color = this.oppositeColor(node.right.color);
    }
    moveRedLeft(node) {
        this.flipColors(node);
        if (this.isRed(node.right.left)) {
            node.right = this.rotateRight(node.right);
            node = this.rotateLeft(node);
            this.flipColors(node);
        }
        return node;
    }
    moveRedRight(node) {
        this.flipColors(node);
        if (this.isRed(node.left.left)) {
            node = this.rotateRight(node);
            this.flipColors(node);
        }
        return node;
    }
    balance(node) {
        if (this.isRed(node.right)) {
            node = this.rotateLeft(node);
        }
        if (this.isRed(node.left) && this.isRed(node.left.left)) {
            node = this.rotateRight(node);
        }
        if (this.isRed(node.left) && (this.isRed(node.right))) {
            this.flipColors(node);
        }
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.aug.update(node);
        }
        return node;
    }
    mapRange(action, accum, start, end) {
        this.nodeMap(this.root, action, start, end);
    }
    map(action, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, action, accum);
    }
    keys() {
        let keyList = [];
        let actions = {
            showStructure: true,
            infix: (node) => {
                keyList.push(node.key);
                return true;
            }
        };
        this.walk(actions);
        return keyList;
    }
    /**
     * Depth-first traversal with custom action; if action returns
     * false, traversal is halted.
     * @param action action to apply to each node
     */
    walk(actions) {
        this.nodeWalk(this.root, actions);
    }
    nodeWalk(node, actions) {
        let go = true;
        if (node) {
            if (actions.pre) {
                if (actions.showStructure || (node.color === 1 /* BLACK */)) {
                    go = actions.pre(node);
                }
            }
            if (node.left) {
                go = this.nodeWalk(node.left, actions);
            }
            if (go && actions.infix) {
                if (actions.showStructure || (node.color === 1 /* BLACK */)) {
                    go = actions.infix(node);
                }
            }
            if (go) {
                go = this.nodeWalk(node.right, actions);
            }
            if (go && actions.post) {
                if (actions.showStructure || (node.color === 1 /* BLACK */)) {
                    go = actions.post(node);
                }
            }
        }
        return go;
    }
    nodeMap(node, action, accum, start, end) {
        if (!node) {
            return true;
        }
        if (start === undefined) {
            start = this.nodeMin(node).key;
        }
        if (end === undefined) {
            end = this.nodeMax(node).key;
        }
        let cmpStart = this.compareKeys(start, node.key);
        let cmpEnd = this.compareKeys(end, node.key);
        let go = true;
        if (cmpStart < 0) {
            go = this.nodeMap(node.left, action, accum, start, end);
        }
        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {
            // REVIEW: test for black node here
            go = action(node, accum);
        }
        if (go && (cmpEnd > 0)) {
            go = this.nodeMap(node.right, action, accum, start, end);
        }
        return go;
    }
    diag() {
        console.log(`Height is ${this.height()}`);
    }
}
/**
 * Union of two ranges; assumes for both ranges start <= end.
 * @param a A range
 * @param b A range
 */
function integerRangeUnion(a, b) {
    return {
        start: Math.min(a.start, b.start),
        end: Math.max(a.end, b.end)
    };
}
function integerRangeOverlaps(a, b) {
    return (a.start < b.end) && (a.end > b.start);
}
function integerRangeComparer(a, b) {
    if (a.start === b.start) {
        return a.end - b.end;
    }
    else {
        return a.start - b.start;
    }
}
function integerRangeCopy(r) {
    return { start: r.start, end: r.end };
}
function integerRangeToString(range) {
    return `[${range.start},${range.end})`;
}
// TODO: handle duplicate keys
class IntegerRangeTree {
    constructor() {
        this.ranges = new RedBlackTree(integerRangeComparer, this);
        this.diag = false;
    }
    remove(r) {
        this.ranges.remove(r);
    }
    put(r) {
        this.ranges.put(r, { minmax: integerRangeCopy(r) });
    }
    toString() {
        return this.nodeToString(this.ranges.root);
    }
    nodeToString(node) {
        let buf = "";
        let indentAmt = 0;
        let actions = {
            pre: (node) => {
                let red = "";
                if (node.color === 0 /* RED */) {
                    red = "R ";
                }
                buf += _mergeTree__WEBPACK_IMPORTED_MODULE_0__["internedSpaces"](indentAmt);
                buf += `${red}key: ${integerRangeToString(node.key)} minmax: ${integerRangeToString(node.data.minmax)}\n`;
                indentAmt += 2;
                return true;
            },
            post: (node) => {
                indentAmt -= 2;
                return true;
            },
            showStructure: true
        };
        this.ranges.nodeWalk(node, actions);
        return buf;
    }
    matchPos(pos) {
        return this.match({ start: pos, end: pos + 1 });
    }
    match(r) {
        return this.ranges.gather(r, this);
    }
    matchNode(node, key) {
        return node && integerRangeOverlaps(node.key, key);
    }
    continueSubtree(node, key) {
        let cont = node && integerRangeOverlaps(node.data.minmax, key);
        if (this.diag && (!cont)) {
            if (node) {
                console.log(`skipping subtree of size ${node.size} key ${integerRangeToString(key)}`);
                console.log(this.nodeToString(node));
            }
        }
        return cont;
    }
    update(node) {
        if (node.left && node.right) {
            node.data.minmax = integerRangeUnion(node.key, integerRangeUnion(node.left.data.minmax, node.right.data.minmax));
        }
        else {
            if (node.left) {
                node.data.minmax = integerRangeUnion(node.key, node.left.data.minmax);
            }
            else if (node.right) {
                node.data.minmax = integerRangeUnion(node.key, node.right.data.minmax);
            }
            else {
                node.data.minmax = integerRangeCopy(node.key);
            }
        }
    }
}
function intervalComparer(a, b) {
    return a.compare(b);
}
class IntervalTree {
    constructor() {
        this.intervals = new RedBlackTree(intervalComparer, this);
        this.diag = false;
        this.timePut = false;
        this.putTime = 0;
        this.putCount = 0;
    }
    printTiming() {
        console.log(`put total = ${this.putTime} avg=${(this.putTime / this.putCount).toFixed(2)}`);
    }
    remove(x) {
        this.intervals.remove(x);
    }
    put(x, conflict) {
        let rbConflict;
        if (conflict) {
            rbConflict = (key, currentKey) => {
                const ival = conflict(key, currentKey);
                return {
                    key: ival,
                };
            };
        }
        if (this.timePut) {
            let clockStart = _mergeTree__WEBPACK_IMPORTED_MODULE_0__["clock"]();
            this.intervals.put(x, { minmax: x.clone() }, rbConflict);
            this.putTime += _mergeTree__WEBPACK_IMPORTED_MODULE_0__["elapsedMicroseconds"](clockStart);
            this.putCount++;
        }
        else {
            this.intervals.put(x, { minmax: x.clone() }, rbConflict);
        }
    }
    map(fn) {
        let actions = {
            infix: (node) => {
                fn(node.key);
                return true;
            },
            showStructure: true,
        };
        this.intervals.walk(actions);
    }
    // TODO: toString()
    match(x) {
        return this.intervals.gather(x, this);
    }
    matchNode(node, key) {
        return node && node.key.overlaps(key);
    }
    continueSubtree(node, key) {
        let cont = node && node.data.minmax.overlaps(key);
        if (this.diag && (!cont)) {
            if (node) {
                console.log(`skipping subtree of size ${node.size} key ${key.toString()}`);
                // console.log(this.nodeToString(node));
            }
        }
        return cont;
    }
    update(node) {
        if (node.left && node.right) {
            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));
        }
        else {
            if (node.left) {
                node.data.minmax = node.key.union(node.left.data.minmax);
            }
            else if (node.right) {
                node.data.minmax = node.key.union(node.right.data.minmax);
            }
            else {
                node.data.minmax = node.key.clone();
            }
        }
    }
}
class TST {
    constructor() {
        this.n = 0;
    }
    size() {
        return this.n;
    }
    contains(key) {
        return this.get(key);
    }
    get(key) {
        let x = this.nodeGet(this.root, key, 0);
        if (x === undefined) {
            return undefined;
        }
        return x.val;
    }
    nodeGet(x, key, d) {
        if (x === undefined) {
            return undefined;
        }
        let c = key.charAt(d);
        if (c < x.c) {
            return this.nodeGet(x.left, key, d);
        }
        else if (c > x.c) {
            return this.nodeGet(x.right, key, d);
        }
        else if (d < (key.length - 1)) {
            return this.nodeGet(x.mid, key, d + 1);
        }
        else
            return x;
    }
    put(key, val) {
        if (!this.contains(key)) {
            this.n++;
        }
        this.root = this.nodePut(this.root, key, val, 0);
        // console.log(`put ${key}`);
    }
    nodePut(x, key, val, d) {
        let c = key.charAt(d);
        if (x === undefined) {
            x = { c };
        }
        if (c < x.c) {
            x.left = this.nodePut(x.left, key, val, d);
        }
        else if (c > x.c) {
            x.right = this.nodePut(x.right, key, val, d);
        }
        else if (d < (key.length - 1)) {
            x.mid = this.nodePut(x.mid, key, val, d + 1);
        }
        else {
            x.val = val;
        }
        return x;
    }
    neighbors(text, distance = 2) {
        let q = [];
        this.nodeProximity(this.root, { text: "" }, 0, text, distance, q);
        q = q.filter(value => (value.text.length > 0));
        return q;
    }
    keysWithPrefix(text) {
        let q = [];
        let x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push(text);
        }
        this.collect(x.mid, { text }, q);
        return q;
    }
    collect(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collect(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push(prefix.text + x.c);
        }
        this.collect(x.mid, { text: prefix.text + x.c }, q);
        this.collect(x.right, prefix, q);
    }
    pairsWithPrefix(text) {
        let q = [];
        let x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push({ key: text, val: x.val });
        }
        this.collectPairs(x.mid, { text }, q);
        return q;
    }
    collectPairs(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collectPairs(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push({ key: prefix.text + x.c, val: x.val });
        }
        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);
        this.collectPairs(x.right, prefix, q);
    }
    patternCollect(x, prefix, d, pattern, q) {
        if (x === undefined) {
            return;
        }
        let c = pattern.charAt(d);
        if ((c === '.') || (c < x.c)) {
            this.patternCollect(x.left, prefix, d, pattern, q);
        }
        else if ((c === '.') || (c === x.c)) {
            if ((d === (pattern.length - 1)) && (x.val !== undefined)) {
                q.push(prefix.text + x.c);
            }
            else if (d < (pattern.length - 1)) {
                this.patternCollect(x.mid, { text: prefix.text + x.c }, d + 1, pattern, q);
            }
        }
        if ((c === '.') || (c > x.c)) {
            this.patternCollect(x.right, prefix, d, pattern, q);
        }
    }
    nodeProximity(x, prefix, d, pattern, distance, q) {
        if ((x === undefined) || (distance < 0)) {
            return;
        }
        let c = pattern.charAt(d);
        if ((distance > 0) || (c < x.c)) {
            this.nodeProximity(x.left, prefix, d, pattern, distance, q);
        }
        if (x.val !== undefined) {
            let remD = distance - (pattern.length - d);
            if (remD >= 0) {
                let invD = distance;
                if (c !== x.c) {
                    invD--;
                }
                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });
            }
        }
        let recurD = (d < (pattern.length - 1)) ? d + 1 : d;
        if (c === x.c) {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);
        }
        else {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);
        }
        if ((distance > 0) || (c > x.c)) {
            this.nodeProximity(x.right, prefix, d, pattern, distance, q);
        }
    }
    match(pattern) {
        let q = [];
        this.patternCollect(this.root, { text: "" }, 0, pattern, q);
        return q;
    }
}
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/index.js ***!
  \******************************************************/
/*! exports provided: loadSegments, LocalReference, SegmentType, MergeNode, ordinalToArray, MaxNodesInBlock, MergeBlock, BaseSegment, SubSequence, runToSeg, ExternalSegment, reservedTileLabelsKey, reservedRangeLabelsKey, reservedMarkerIdKey, reservedMarkerSimpleTypeKey, Marker, TextSegment, segmentCopy, IncrementalExecOp, IncrementalMapState, UniversalSequenceNumber, UnassignedSequenceNumber, TreeMaintenanceSequenceNumber, LocalClientId, NonCollabClient, CollaborationWindow, compareNumbers, compareStrings, PartialSequenceLengths, clock, elapsedMicroseconds, useCheckQ, internedSpaces, RegisterCollection, clientSeqComparer, MergeTree, ReferenceType, IntervalType, combine, matchProperties, extend, addProperties, extendIfUndefined, createMap, Snapshot, Stack, ListRemoveEntry, ListMakeEntry, ListMakeHead, List, numberComparer, Heap, LinearDictionary, RedBlackTree, integerRangeUnion, integerRangeOverlaps, integerRangeComparer, integerRangeCopy, integerRangeToString, IntegerRangeTree, intervalComparer, IntervalTree, TST, Client, SegmentGroupCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeTree */ "./node_modules/@prague/merge-tree/lib/mergeTree.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalReference", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["LocalReference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SegmentType", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["SegmentType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MergeNode", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["MergeNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ordinalToArray", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["ordinalToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MaxNodesInBlock", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["MaxNodesInBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MergeBlock", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["MergeBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseSegment", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["BaseSegment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SubSequence", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["SubSequence"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "runToSeg", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["runToSeg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExternalSegment", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["ExternalSegment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reservedTileLabelsKey", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["reservedTileLabelsKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reservedRangeLabelsKey", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["reservedRangeLabelsKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reservedMarkerIdKey", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["reservedMarkerIdKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reservedMarkerSimpleTypeKey", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["reservedMarkerSimpleTypeKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Marker", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["Marker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextSegment", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "segmentCopy", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["segmentCopy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IncrementalExecOp", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["IncrementalExecOp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IncrementalMapState", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["IncrementalMapState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UniversalSequenceNumber", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnassignedSequenceNumber", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["UnassignedSequenceNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TreeMaintenanceSequenceNumber", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["TreeMaintenanceSequenceNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalClientId", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["LocalClientId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NonCollabClient", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["NonCollabClient"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CollaborationWindow", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["CollaborationWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compareNumbers", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["compareNumbers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compareStrings", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["compareStrings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PartialSequenceLengths", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["PartialSequenceLengths"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clock", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["clock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elapsedMicroseconds", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["elapsedMicroseconds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCheckQ", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["useCheckQ"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "internedSpaces", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["internedSpaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RegisterCollection", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["RegisterCollection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clientSeqComparer", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["clientSeqComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MergeTree", function() { return _mergeTree__WEBPACK_IMPORTED_MODULE_0__["MergeTree"]; });

/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ops */ "./node_modules/@prague/merge-tree/lib/ops.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReferenceType", function() { return _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalType", function() { return _ops__WEBPACK_IMPORTED_MODULE_1__["IntervalType"]; });

/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties */ "./node_modules/@prague/merge-tree/lib/properties.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return _properties__WEBPACK_IMPORTED_MODULE_2__["combine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchProperties", function() { return _properties__WEBPACK_IMPORTED_MODULE_2__["matchProperties"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _properties__WEBPACK_IMPORTED_MODULE_2__["extend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addProperties", function() { return _properties__WEBPACK_IMPORTED_MODULE_2__["addProperties"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendIfUndefined", function() { return _properties__WEBPACK_IMPORTED_MODULE_2__["extendIfUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMap", function() { return _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]; });

/* harmony import */ var _snapshot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./snapshot */ "./node_modules/@prague/merge-tree/lib/snapshot.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snapshot", function() { return _snapshot__WEBPACK_IMPORTED_MODULE_3__["Snapshot"]; });

/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collections */ "./node_modules/@prague/merge-tree/lib/collections.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["Stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListRemoveEntry", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["ListRemoveEntry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListMakeEntry", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["ListMakeEntry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListMakeHead", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["ListMakeHead"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "List", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["List"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberComparer", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["numberComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["Heap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearDictionary", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["LinearDictionary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RedBlackTree", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["RedBlackTree"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "integerRangeUnion", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["integerRangeUnion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "integerRangeOverlaps", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["integerRangeOverlaps"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "integerRangeComparer", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["integerRangeComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "integerRangeCopy", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["integerRangeCopy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "integerRangeToString", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["integerRangeToString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntegerRangeTree", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["IntegerRangeTree"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "intervalComparer", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["intervalComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalTree", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["IntervalTree"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TST", function() { return _collections__WEBPACK_IMPORTED_MODULE_4__["TST"]; });

/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text */ "./node_modules/@prague/merge-tree/lib/text.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadSegments", function() { return _text__WEBPACK_IMPORTED_MODULE_5__["loadSegments"]; });

/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client */ "./node_modules/@prague/merge-tree/lib/client.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Client", function() { return _client__WEBPACK_IMPORTED_MODULE_6__["Client"]; });

/* harmony import */ var _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./segmentGroupCollection */ "./node_modules/@prague/merge-tree/lib/segmentGroupCollection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SegmentGroupCollection", function() { return _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_7__["SegmentGroupCollection"]; });









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/mergeTree.js":
/*!**********************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/mergeTree.js ***!
  \**********************************************************/
/*! exports provided: LocalReference, SegmentType, MergeNode, ordinalToArray, MaxNodesInBlock, MergeBlock, BaseSegment, SubSequence, runToSeg, ExternalSegment, reservedTileLabelsKey, reservedRangeLabelsKey, reservedMarkerIdKey, reservedMarkerSimpleTypeKey, Marker, TextSegment, segmentCopy, IncrementalExecOp, IncrementalMapState, UniversalSequenceNumber, UnassignedSequenceNumber, TreeMaintenanceSequenceNumber, LocalClientId, NonCollabClient, CollaborationWindow, compareNumbers, compareStrings, PartialSequenceLengths, clock, elapsedMicroseconds, useCheckQ, internedSpaces, RegisterCollection, clientSeqComparer, MergeTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalReference", function() { return LocalReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentType", function() { return SegmentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeNode", function() { return MergeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ordinalToArray", function() { return ordinalToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxNodesInBlock", function() { return MaxNodesInBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeBlock", function() { return MergeBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseSegment", function() { return BaseSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubSequence", function() { return SubSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runToSeg", function() { return runToSeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExternalSegment", function() { return ExternalSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reservedTileLabelsKey", function() { return reservedTileLabelsKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reservedRangeLabelsKey", function() { return reservedRangeLabelsKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reservedMarkerIdKey", function() { return reservedMarkerIdKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reservedMarkerSimpleTypeKey", function() { return reservedMarkerSimpleTypeKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Marker", function() { return Marker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextSegment", function() { return TextSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "segmentCopy", function() { return segmentCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementalExecOp", function() { return IncrementalExecOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementalMapState", function() { return IncrementalMapState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniversalSequenceNumber", function() { return UniversalSequenceNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnassignedSequenceNumber", function() { return UnassignedSequenceNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TreeMaintenanceSequenceNumber", function() { return TreeMaintenanceSequenceNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalClientId", function() { return LocalClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NonCollabClient", function() { return NonCollabClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollaborationWindow", function() { return CollaborationWindow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareNumbers", function() { return compareNumbers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareStrings", function() { return compareStrings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PartialSequenceLengths", function() { return PartialSequenceLengths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clock", function() { return clock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elapsedMicroseconds", function() { return elapsedMicroseconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useCheckQ", function() { return useCheckQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "internedSpaces", function() { return internedSpaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RegisterCollection", function() { return RegisterCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clientSeqComparer", function() { return clientSeqComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeTree", function() { return MergeTree; });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "./node_modules/@prague/merge-tree/lib/collections.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ops */ "./node_modules/@prague/merge-tree/lib/ops.js");
/* harmony import */ var _properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties */ "./node_modules/@prague/merge-tree/lib/properties.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./segmentGroupCollection */ "./node_modules/@prague/merge-tree/lib/segmentGroupCollection.js");





class LocalReference {
    constructor(segment, offset = 0, refType = _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].Simple) {
        this.segment = segment;
        this.offset = offset;
        this.refType = refType;
    }
    min(b) {
        if (this.compare(b) < 0) {
            return this;
        }
        else {
            return b;
        }
    }
    max(b) {
        if (this.compare(b) > 0) {
            return this;
        }
        else {
            return b;
        }
    }
    compare(b) {
        if (this.segment === b.segment) {
            return this.offset - b.offset;
        }
        else {
            if (this.segment.ordinal < b.segment.ordinal) {
                return -1;
            }
            else {
                return 1;
            }
        }
    }
    toPosition(mergeTree, refSeq, clientId) {
        if (this.segment) {
            return this.offset + mergeTree.getOffset(this.segment, refSeq, clientId);
        }
        else {
            return -1;
        }
    }
    hasTileLabels() {
        return refHasTileLabels(this);
    }
    hasRangeLabels() {
        return refHasRangeLabels(this);
    }
    hasTileLabel(label) {
        return refHasTileLabel(this, label);
    }
    hasRangeLabel(label) {
        return refHasRangeLabel(this, label);
    }
    getTileLabels() {
        return refGetTileLabels(this);
    }
    getRangeLabels() {
        return refGetRangeLabels(this);
    }
    isLeaf() {
        return false;
    }
    addProperties(newProps, op) {
        this.properties = _properties__WEBPACK_IMPORTED_MODULE_2__["addProperties"](this.properties, newProps, op);
    }
    getSegment() {
        return this.segment;
    }
    getOffset() {
        return this.offset;
    }
    getProperties() {
        return this.properties;
    }
}
var SegmentType;
(function (SegmentType) {
    SegmentType[SegmentType["Base"] = 0] = "Base";
    SegmentType[SegmentType["Text"] = 1] = "Text";
    SegmentType[SegmentType["Marker"] = 2] = "Marker";
    SegmentType[SegmentType["External"] = 3] = "External";
    SegmentType[SegmentType["Custom"] = 4] = "Custom";
    SegmentType[SegmentType["Run"] = 5] = "Run";
})(SegmentType || (SegmentType = {}));
class MergeNode {
    isLeaf() {
        return false;
    }
}
function addTile(tile, tiles) {
    for (let tileLabel of tile.getTileLabels()) {
        tiles[tileLabel] = tile;
    }
}
function addTileIfNotPresent(tile, tiles) {
    for (let tileLabel of tile.getTileLabels()) {
        if (tiles[tileLabel] === undefined) {
            tiles[tileLabel] = tile;
        }
    }
}
function applyStackDelta(currentStackMap, deltaStackMap) {
    for (let label in deltaStackMap) {
        let deltaStack = deltaStackMap[label];
        if (!deltaStack.empty()) {
            let currentStack = currentStackMap[label];
            if (currentStack === undefined) {
                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_0__["Stack"]();
                currentStackMap[label] = currentStack;
            }
            for (let delta of deltaStack.items) {
                applyRangeReference(currentStack, delta);
            }
        }
    }
}
function applyRangeReference(stack, delta) {
    if (delta.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin) {
        stack.push(delta);
        return true;
    }
    else {
        // assume delta is end reference
        let top = stack.top();
        // TODO: match end with begin
        if (top && (top.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin)) {
            stack.pop();
        }
        else {
            stack.push(delta);
        }
        return false;
    }
}
function addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {
    function updateRangeInfo(label, refPos) {
        let stack = rangeStacks[label];
        if (stack === undefined) {
            stack = new _collections__WEBPACK_IMPORTED_MODULE_0__["Stack"]();
            rangeStacks[label] = stack;
        }
        applyRangeReference(stack, refPos);
    }
    if (node.isLeaf()) {
        let segment = node;
        if (mergeTree.localNetLength(segment) > 0) {
            if (segment.getType() == SegmentType.Marker) {
                let marker = node;
                let markerId = marker.getId();
                // also in insertMarker but need for reload segs case
                // can add option for this only from reload segs
                if (markerId) {
                    mergeTree.mapIdToSegment(markerId, marker);
                }
                if (marker.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].Tile) {
                    addTile(marker, rightmostTiles);
                    addTileIfNotPresent(marker, leftmostTiles);
                }
                if (marker.refType & (_ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd)) {
                    for (let label of marker.getRangeLabels()) {
                        updateRangeInfo(label, marker);
                    }
                }
            }
            else {
                // TODO: generalize to other segment types
                let textSegment = node;
                if (textSegment.localRefs && (textSegment.hierRefCount !== undefined) &&
                    (textSegment.hierRefCount > 0)) {
                    for (let lref of textSegment.localRefs) {
                        if (lref.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].Tile) {
                            addTile(lref, rightmostTiles);
                            addTileIfNotPresent(lref, leftmostTiles);
                        }
                        if (lref.refType & (_ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd)) {
                            for (let label of lref.getRangeLabels()) {
                                updateRangeInfo(label, lref);
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        let block = node;
        applyStackDelta(rangeStacks, block.rangeStacks);
        _properties__WEBPACK_IMPORTED_MODULE_2__["extend"](rightmostTiles, block.rightmostTiles);
        _properties__WEBPACK_IMPORTED_MODULE_2__["extendIfUndefined"](leftmostTiles, block.leftmostTiles);
    }
}
function ordinalToArray(ord) {
    let a = [];
    if (ord) {
        for (let i = 0, len = ord.length; i < len; i++) {
            a.push(ord.charCodeAt(i));
        }
    }
    return a;
}
const MaxNodesInBlock = 8;
class MergeBlock extends MergeNode {
    constructor(childCount) {
        super();
        this.childCount = childCount;
        this.children = new Array(MaxNodesInBlock);
    }
    hierBlock() {
        return undefined;
    }
    setOrdinal(child, index) {
        let childCount = this.childCount;
        if (childCount === 8) {
            childCount = 7;
        }
        assert__WEBPACK_IMPORTED_MODULE_3__((childCount >= 1) && (childCount <= 7));
        let localOrdinal;
        let ordinalWidth = 1 << (MaxNodesInBlock - (childCount + 1));
        if (index === 0) {
            localOrdinal = ordinalWidth - 1;
        }
        else {
            let prevOrd = this.children[index - 1].ordinal;
            let prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);
            localOrdinal = prevOrdCode + ordinalWidth;
        }
        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);
        if (MergeBlock.traceOrdinals) {
            console.log(`so: prnt chld prev ${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${(index > 0) ? ordinalToArray(this.children[index - 1].ordinal) : "NA"}`);
        }
        assert__WEBPACK_IMPORTED_MODULE_3__(child.ordinal.length === (this.ordinal.length + 1));
        if (index > 0) {
            assert__WEBPACK_IMPORTED_MODULE_3__(child.ordinal > this.children[index - 1].ordinal);
            //console.log(`${ordinalToArray(this.ordinal)} ${ordinalToArray(child.ordinal)} ${ordinalToArray(this.children[index - 1].ordinal)}`);
            //    console.log(`ord width ${ordinalWidth}`);
        }
    }
    assignChild(child, index, updateOrdinal = true) {
        child.parent = this;
        child.index = index;
        if (updateOrdinal) {
            this.setOrdinal(child, index);
        }
        this.children[index] = child;
    }
}
MergeBlock.traceOrdinals = false;
class HierMergeBlock extends MergeBlock {
    constructor(childCount) {
        super(childCount);
        this.rightmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
        this.leftmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
        this.rangeStacks = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
    }
    addNodeReferences(mergeTree, node) {
        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);
    }
    hierBlock() {
        return this;
    }
    hierToString(indentCount) {
        let strbuf = "";
        for (let key in this.rangeStacks) {
            let stack = this.rangeStacks[key];
            strbuf += internedSpaces(indentCount);
            strbuf += `${key}: `;
            for (let item of stack.items) {
                strbuf += `${item.toString()} `;
            }
            strbuf += "\n";
        }
        return strbuf;
    }
}
function nodeTotalLength(mergeTree, node) {
    if (!node.isLeaf()) {
        return node.cachedLength;
    }
    else {
        return mergeTree.localNetLength(node);
    }
}
class BaseSegment extends MergeNode {
    constructor(seq, clientId) {
        super();
        this.seq = seq;
        this.clientId = clientId;
        this.segmentGroups = new _segmentGroupCollection__WEBPACK_IMPORTED_MODULE_4__["SegmentGroupCollection"](this);
    }
    addLocalRef(lref) {
        if ((this.hierRefCount === undefined) || (this.hierRefCount === 0)) {
            if (lref.hasRangeLabels() || lref.hasTileLabels()) {
                this.hierRefCount = 1;
            }
        }
        if (!this.localRefs) {
            this.localRefs = [lref];
        }
        else {
            let i = 0, len = this.localRefs.length;
            for (; i < len; i++) {
                if (this.localRefs[i].offset > lref.offset) {
                    break;
                }
            }
            if (i < len) {
                for (let k = len; k > i; k--) {
                    this.localRefs[k] = this.localRefs[k - 1];
                }
                this.localRefs[i] = lref;
            }
            else {
                this.localRefs.push(lref);
            }
        }
    }
    removeLocalRef(lref) {
        if (this.localRefs) {
            for (let i = 0, len = this.localRefs.length; i < len; i++) {
                if (lref === this.localRefs[i]) {
                    for (let j = i; j < (len - 1); j++) {
                        this.localRefs[j] = this.localRefs[j + 1];
                    }
                    this.localRefs.length--;
                    if (lref.hasRangeLabels() || lref.hasTileLabels()) {
                        this.hierRefCount--;
                    }
                    return lref;
                }
            }
        }
    }
    splitLocalRefs(pos, leafSegment) {
        let aRefs = [];
        let bRefs = [];
        for (let localRef of this.localRefs) {
            if (localRef.offset < pos) {
                aRefs.push(localRef);
            }
            else {
                localRef.segment = leafSegment;
                localRef.offset -= pos;
                bRefs.push(localRef);
            }
        }
        this.localRefs = aRefs;
        leafSegment.localRefs = bRefs;
    }
    addProperties(newProps, op, seq) {
        this.properties = _properties__WEBPACK_IMPORTED_MODULE_2__["addProperties"](this.properties, newProps, op, seq);
    }
    hasProperty(key) {
        return this.properties && (this.properties[key] !== undefined);
    }
    isLeaf() {
        return true;
    }
    cloneInto(b) {
        b.clientId = this.clientId;
        // TODO: deep clone properties
        b.properties = _properties__WEBPACK_IMPORTED_MODULE_2__["extend"](_properties__WEBPACK_IMPORTED_MODULE_2__["createMap"](), this.properties);
        b.removedClientId = this.removedClientId;
        // TODO: copy removed client overlap and branch removal info
        b.removedSeq = this.removedSeq;
        b.seq = this.seq;
    }
    canAppend(segment, mergeTree) {
        return false;
    }
    addSerializedProps(jseg) {
        if (this.properties) {
            jseg.props = this.properties;
        }
    }
    toJSONObject() {
        let obj = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
        this.addSerializedProps(obj);
        return obj;
    }
    // TODO: use function in properties.ts
    matchProperties(b) {
        if (this.properties) {
            if (!b.properties) {
                return false;
            }
            else {
                let bProps = b.properties;
                // for now, straightforward; later use hashing
                for (let key in this.properties) {
                    if (bProps[key] === undefined) {
                        return false;
                    }
                    else if (bProps[key] !== this.properties[key]) {
                        return false;
                    }
                }
                for (let key in bProps) {
                    if (this.properties[key] === undefined) {
                        return false;
                    }
                }
            }
        }
        else {
            if (b.properties) {
                return false;
            }
        }
        return true;
    }
}
const MaxRun = 128;
class SubSequence extends BaseSegment {
    constructor(items, seq, clientId) {
        super(seq, clientId);
        this.items = items;
        this.cachedLength = items.length;
    }
    toJSONObject() {
        const obj = { items: this.items };
        super.addSerializedProps(obj);
        return obj;
    }
    splitAt(pos) {
        if (pos > 0) {
            const remainingItems = this.items.slice(pos);
            this.items = this.items.slice(0, pos);
            this.cachedLength = this.items.length;
            const leafSegment = new SubSequence(remainingItems, this.seq, this.clientId);
            if (this.properties) {
                leafSegment.addProperties(_properties__WEBPACK_IMPORTED_MODULE_2__["extend"](_properties__WEBPACK_IMPORTED_MODULE_2__["createMap"](), this.properties));
            }
            segmentCopy(this, leafSegment);
            if (this.localRefs) {
                this.splitLocalRefs(pos, leafSegment);
            }
            return leafSegment;
        }
    }
    clone(start = 0, end) {
        let clonedItems = this.items;
        if (end === undefined) {
            clonedItems = clonedItems.slice(start);
        }
        else {
            clonedItems = clonedItems.slice(start, end);
        }
        const b = new SubSequence(clonedItems, this.seq, this.clientId);
        this.cloneInto(b);
        return b;
    }
    getType() {
        return SegmentType.Run;
    }
    canAppend(segment, mergeTree) {
        if (!this.removedSeq) {
            if (segment.getType() === SegmentType.Run) {
                if (this.matchProperties(segment)) {
                    const branchId = mergeTree.getBranchId(this.clientId);
                    const segBranchId = mergeTree.getBranchId(segment.clientId);
                    if ((segBranchId === branchId) && (mergeTree.localNetLength(segment) > 0)) {
                        return ((this.cachedLength <= MaxRun) ||
                            (segment.cachedLength <= MaxRun));
                    }
                }
            }
        }
        return false;
    }
    toString() {
        return this.items.toString();
    }
    append(segment) {
        if (segment.getType() === SegmentType.Run) {
            const rseg = segment;
            if (segment.localRefs) {
                const adj = this.cachedLength;
                for (const localRef of segment.localRefs) {
                    localRef.offset += adj;
                    localRef.segment = this;
                }
            }
            this.items = this.items.concat(rseg.items);
            this.cachedLength = this.items.length;
            return this;
        }
        else {
            throw new Error("can only append another run segment");
        }
    }
    // TODO: retain removed items for undo
    // returns true if entire run removed
    removeRange(start, end) {
        let remnantItems = [];
        const len = this.items.length;
        if (start > 0) {
            remnantItems = remnantItems.concat(this.items.slice(0, start));
        }
        if (end < len) {
            remnantItems = remnantItems.concat(this.items.slice(end));
        }
        this.items = remnantItems;
        this.cachedLength = this.items.length;
        return (this.items.length === 0);
    }
}
function runToSeg(segSpec) {
    const seg = new SubSequence(segSpec.items, UniversalSequenceNumber, LocalClientId);
    if (segSpec.props) {
        seg.addProperties(segSpec.props);
    }
    return seg;
}
/**
 * A non-shared placeholder for external content.
 */
class ExternalSegment extends BaseSegment {
    constructor(placeholderSeq, sequenceLength, sequenceIndex) {
        super();
        this.placeholderSeq = placeholderSeq;
        this.sequenceLength = sequenceLength;
        this.sequenceIndex = sequenceIndex;
    }
    toJSONObject() {
        let obj = { sequenceIndex: this.sequenceIndex, sequenceLength: this.sequenceLength };
        super.addSerializedProps(obj);
        return obj;
    }
    mergeTreeInsert(mergeTree, pos, refSeq, clientId, seq, opArgs) {
        mergeTree.insert(pos, refSeq, clientId, seq, this, (block, pos, refSeq, clientId, seq, eseg) => mergeTree.blockInsert(block, pos, refSeq, clientId, seq, eseg), opArgs);
    }
    clone() {
        throw new Error('clone not implemented');
    }
    append(segment) {
        throw new Error('Can not append to external segment');
    }
    getType() {
        return SegmentType.External;
    }
    removeRange(start, end) {
        throw new Error('Method not implemented.');
    }
    splitAt(pos) {
        throw new Error('Method not implemented.');
    }
}
let reservedTileLabelsKey = "referenceTileLabels";
let reservedRangeLabelsKey = "referenceRangeLabels";
let reservedMarkerIdKey = "markerId";
let reservedMarkerSimpleTypeKey = "markerSimpleType";
function refHasTileLabels(refPos) {
    return (refPos.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].Tile) &&
        refPos.properties && refPos.properties[reservedTileLabelsKey];
}
function refHasRangeLabels(refPos) {
    return (refPos.refType & (_ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd)) &&
        refPos.properties && refPos.properties[reservedRangeLabelsKey];
}
function refHasTileLabel(refPos, label) {
    if (refPos.hasTileLabels()) {
        for (let refLabel of refPos.properties[reservedTileLabelsKey]) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
function refHasRangeLabel(refPos, label) {
    if (refPos.hasRangeLabels()) {
        for (let refLabel of refPos.properties[reservedRangeLabelsKey]) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
function refGetTileLabels(refPos) {
    if (refPos.hasTileLabels()) {
        return refPos.properties[reservedTileLabelsKey];
    }
    else {
        return [];
    }
}
function refGetRangeLabels(refPos) {
    if (refPos.hasRangeLabels()) {
        return refPos.properties[reservedRangeLabelsKey];
    }
    else {
        return [];
    }
}
class Marker extends BaseSegment {
    constructor(refType, seq, clientId) {
        super(seq, clientId);
        this.refType = refType;
        this.cachedLength = 1;
    }
    static make(refType, props, seq, clientId) {
        let marker = new Marker(refType, seq, clientId);
        if (props) {
            marker.addProperties(props);
        }
        return marker;
    }
    toJSONObject() {
        let obj = { marker: { refType: this.refType } };
        super.addSerializedProps(obj);
        return obj;
    }
    clone() {
        let b = Marker.make(this.refType, this.properties, this.seq, this.clientId);
        this.cloneInto(b);
        return b;
    }
    getSegment() {
        return this;
    }
    getOffset() {
        return 0;
    }
    hasSimpleType(simpleTypeName) {
        return this.hasProperty(reservedMarkerSimpleTypeKey) &&
            this.properties[reservedMarkerSimpleTypeKey] === simpleTypeName;
    }
    getProperties() {
        return this.properties;
    }
    getId() {
        if (this.properties && this.properties[reservedMarkerIdKey]) {
            return this.properties[reservedMarkerIdKey];
        }
    }
    hasTileLabels() {
        return refHasTileLabels(this);
    }
    hasRangeLabels() {
        return refHasRangeLabels(this);
    }
    hasTileLabel(label) {
        return refHasTileLabel(this, label);
    }
    hasRangeLabel(label) {
        return refHasRangeLabel(this, label);
    }
    getTileLabels() {
        return refGetTileLabels(this);
    }
    getRangeLabels() {
        return refGetRangeLabels(this);
    }
    toString() {
        let bbuf = "";
        if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].Tile) {
            bbuf += "Tile";
        }
        if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeBegin";
        }
        if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeEnd";
        }
        let lbuf = "";
        let id = this.getId();
        if (id) {
            bbuf += ` (${id}) `;
        }
        if (this.hasTileLabels()) {
            lbuf += "tile -- ";
            let labels = this.properties[reservedTileLabelsKey];
            for (let i = 0, len = labels.length; i < len; i++) {
                let tileLabel = labels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += tileLabel;
            }
        }
        if (this.hasRangeLabels()) {
            let rangeKind = "begin";
            if (this.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd) {
                rangeKind = "end";
            }
            if (this.hasTileLabels()) {
                lbuf += " ";
            }
            lbuf += `range ${rangeKind} -- `;
            let labels = this.properties[reservedRangeLabelsKey];
            for (let i = 0, len = labels.length; i < len; i++) {
                let rangeLabel = labels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += rangeLabel;
            }
        }
        let pbuf = "";
        if (this.properties) {
            pbuf += JSON.stringify(this.properties);
        }
        return `M ${bbuf}: ${lbuf} ${pbuf}`;
    }
    getType() {
        return SegmentType.Marker;
    }
    removeRange(start, end) {
        console.log("remove range called on marker");
        return false;
    }
    splitAt(pos) {
        return undefined;
    }
    canAppend(segment) {
        return false;
    }
    append(segment) {
        return undefined;
    }
}
class TextSegment extends BaseSegment {
    constructor(text, seq, clientId) {
        super(seq, clientId);
        this.text = text;
        this.cachedLength = text.length;
    }
    static make(text, props, seq, clientId) {
        let tseg = new TextSegment(text, seq, clientId);
        if (props) {
            tseg.addProperties(props);
        }
        return tseg;
    }
    toJSONObject() {
        let obj = { text: this.text };
        super.addSerializedProps(obj);
        return obj;
    }
    splitAt(pos) {
        if (pos > 0) {
            let remainingText = this.text.substring(pos);
            this.text = this.text.substring(0, pos);
            this.cachedLength = this.text.length;
            let leafSegment = new TextSegment(remainingText, this.seq, this.clientId);
            if (this.properties) {
                leafSegment.addProperties(_properties__WEBPACK_IMPORTED_MODULE_2__["extend"](_properties__WEBPACK_IMPORTED_MODULE_2__["createMap"](), this.properties));
            }
            segmentCopy(this, leafSegment);
            if (this.localRefs) {
                this.splitLocalRefs(pos, leafSegment);
            }
            return leafSegment;
        }
    }
    clone(start = 0, end) {
        let text = this.text;
        if (end === undefined) {
            text = text.substring(start);
        }
        else {
            text = text.substring(start, end);
        }
        let b = TextSegment.make(text, this.properties, this.seq, this.clientId);
        this.cloneInto(b);
        return b;
    }
    getType() {
        return SegmentType.Text;
    }
    canAppend(segment, mergeTree) {
        if ((!this.removedSeq) && (this.text.charAt(this.text.length - 1) != '\n')) {
            if (segment.getType() === SegmentType.Text) {
                if (this.matchProperties(segment)) {
                    let branchId = mergeTree.getBranchId(this.clientId);
                    let segBranchId = mergeTree.getBranchId(segment.clientId);
                    if ((segBranchId === branchId) && (mergeTree.localNetLength(segment) > 0)) {
                        return ((this.cachedLength <= MergeTree.TextSegmentGranularity) ||
                            (segment.cachedLength <= MergeTree.TextSegmentGranularity));
                    }
                }
            }
        }
        return false;
    }
    toString() {
        return this.text;
    }
    append(segment) {
        if (segment.getType() === SegmentType.Text) {
            if (segment.localRefs) {
                let adj = this.text.length;
                for (let localRef of segment.localRefs) {
                    localRef.offset += adj;
                    localRef.segment = this;
                }
            }
            this.text += segment.text;
            this.cachedLength = this.text.length;
            return this;
        }
        else {
            throw new Error("can only append text segment");
        }
    }
    // TODO: retain removed text for undo
    // returns true if entire string removed
    removeRange(start, end) {
        let remnantString = "";
        let len = this.text.length;
        if (start > 0) {
            remnantString += this.text.substring(0, start);
        }
        if (end < len) {
            remnantString += this.text.substring(end);
        }
        this.text = remnantString;
        this.cachedLength = remnantString.length;
        return (remnantString.length == 0);
    }
}
function segmentCopy(from, to) {
    to.parent = from.parent;
    to.removedClientId = from.removedClientId;
    to.removedSeq = from.removedSeq;
    if (from.removalsByBranch) {
        to.removalsByBranch = [];
        for (let i = 0, len = from.removalsByBranch.length; i < len; i++) {
            let fromRemovalInfo = from.removalsByBranch[i];
            if (fromRemovalInfo) {
                to.removalsByBranch[i] = {
                    removedClientId: fromRemovalInfo.removedClientId,
                    removedSeq: fromRemovalInfo.removedSeq,
                    removedClientOverlap: fromRemovalInfo.removedClientOverlap,
                };
            }
        }
    }
    to.seq = from.seq;
    to.clientId = from.clientId;
    to.removedClientOverlap = from.removedClientOverlap;
    from.segmentGroups.copyTo(to);
}
function incrementalGatherText(segment, state) {
    if (segment.getType() == SegmentType.Text) {
        let textSegment = segment;
        if (MergeTree.traceGatherText) {
            console.log(`@cli ${this.collabWindow ? this.collabwindow.clientId : -1} gather seg seq ${textSegment.seq} rseq ${textSegment.removedSeq} text ${textSegment.text}`);
        }
        if ((state.start <= 0) && (state.end >= textSegment.text.length)) {
            state.context.text += textSegment.text;
        }
        else {
            if (state.end >= textSegment.text.length) {
                state.context.text += textSegment.text.substring(state.start);
            }
            else {
                state.context.text += textSegment.text.substring(state.start, state.end);
            }
        }
    }
    state.op = IncrementalExecOp.Go;
}
var IncrementalExecOp;
(function (IncrementalExecOp) {
    IncrementalExecOp[IncrementalExecOp["Go"] = 0] = "Go";
    IncrementalExecOp[IncrementalExecOp["Stop"] = 1] = "Stop";
    IncrementalExecOp[IncrementalExecOp["Yield"] = 2] = "Yield";
})(IncrementalExecOp || (IncrementalExecOp = {}));
class IncrementalMapState {
    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {
        this.block = block;
        this.actions = actions;
        this.pos = pos;
        this.refSeq = refSeq;
        this.clientId = clientId;
        this.context = context;
        this.start = start;
        this.end = end;
        this.childIndex = childIndex;
        this.op = IncrementalExecOp.Go;
    }
}
/**
 * Sequence numbers for shared segments start at 1 or greater.  Every segment marked
 * with sequence number zero will be counted as part of the requested string.
 */
const UniversalSequenceNumber = 0;
const UnassignedSequenceNumber = -1;
const TreeMaintenanceSequenceNumber = -2;
const LocalClientId = -1;
const NonCollabClient = -2;
class CollaborationWindow {
    constructor() {
        this.clientId = LocalClientId;
        this.collaborating = false;
        // lowest-numbered segment in window; no client can reference a state before this one
        this.minSeq = 0;
        // highest-numbered segment in window and current
        // reference segment for this client
        this.currentSeq = 0;
    }
    loadFrom(a) {
        this.clientId = a.clientId;
        this.collaborating = a.collaborating;
        this.localMinSeq = a.localMinSeq;
        this.globalMinSeq = a.globalMinSeq;
        this.minSeq = a.minSeq;
        this.currentSeq = a.currentSeq;
    }
}
/**
 * Returns the partial length whose sequence number is
 * the greatest sequence number within a that is
 * less than or equal to key.
 * @param {PartialLength[]} a array of partial segment lengths
 * @param {number} key sequence number
 */
function latestLEQ(a, key) {
    let best = -1;
    let lo = 0;
    let hi = a.length - 1;
    while (lo <= hi) {
        let mid = lo + Math.floor((hi - lo) / 2);
        if (a[mid].seq <= key) {
            if ((best < 0) || (a[best].seq < a[mid].seq)) {
                best = mid;
            }
            lo = mid + 1;
        }
        else {
            hi = mid - 1;
        }
    }
    return best;
}
function compareNumbers(a, b) {
    return a - b;
}
function compareStrings(a, b) {
    return a.localeCompare(b);
}
/**
 * Keep track of partial sums of segment lengths for all sequence numbers
 * in the current collaboration window (if any).  Only used during active
 * collaboration.
 */
class PartialSequenceLengths {
    constructor(minSeq) {
        this.minSeq = minSeq;
        this.minLength = 0;
        this.segmentCount = 0;
        this.partialLengths = [];
        this.clientSeqNumbers = [];
    }
    cliLatestLEQ(clientId, refSeq) {
        let cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs) {
            return latestLEQ(cliSeqs, refSeq);
        }
        else {
            return -1;
        }
    }
    cliLatest(clientId) {
        let cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs && (cliSeqs.length > 0)) {
            return cliSeqs.length - 1;
        }
        else {
            return -1;
        }
    }
    compare(b) {
        function comparePartialLengths(aList, bList) {
            let aLen = aList.length;
            let bLen = bList.length;
            if (aLen != bLen) {
                return false;
            }
            for (let i = 0; i < aLen; i++) {
                let aPartial = aList[i];
                let bPartial = bList[i];
                if ((aPartial.seq != bPartial.seq) || (aPartial.clientId != bPartial.clientId) ||
                    (aPartial.seglen != bPartial.seglen) || (aPartial.len != bPartial.len) ||
                    (aPartial.overlapRemoveClients && (!bPartial.overlapRemoveClients))) {
                    return false;
                }
            }
            return true;
        }
        if (!comparePartialLengths(this.partialLengths, b.partialLengths)) {
            return false;
        }
        for (let clientId in this.clientSeqNumbers) {
            if (!b.clientSeqNumbers[clientId]) {
                return false;
            }
            else if (!comparePartialLengths(this.clientSeqNumbers[clientId], b.clientSeqNumbers[clientId])) {
                return false;
            }
        }
        return true;
    }
    branchToString(glc, branchId = 0) {
        let buf = "";
        for (let partial of this.partialLengths) {
            buf += `(${partial.seq},${partial.len}) `;
        }
        for (let clientId in this.clientSeqNumbers) {
            if (this.clientSeqNumbers[clientId].length > 0) {
                buf += `Client `;
                if (glc) {
                    buf += `${glc(+clientId)}`;
                }
                else {
                    buf += `${clientId}`;
                }
                buf += '[';
                for (let partial of this.clientSeqNumbers[clientId]) {
                    buf += `(${partial.seq},${partial.len})`;
                }
                buf += ']';
            }
        }
        buf = `Br ${branchId}, min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};` + buf;
        return buf;
    }
    toString(glc, indentCount = 0) {
        let buf = this.branchToString(glc);
        if (this.downstreamPartialLengths) {
            for (let i = 0, len = this.downstreamPartialLengths.length; i < len; i++) {
                buf += "\n";
                buf += internedSpaces(indentCount);
                buf += this.downstreamPartialLengths[i].branchToString(glc, i + 1);
            }
        }
        return buf;
    }
    getPartialLength(mergeTree, refSeq, clientId) {
        let branchId = mergeTree.getBranchId(clientId);
        if (MergeTree.traceTraversal) {
            console.log(`plen branch ${branchId}`);
        }
        if (branchId > 0) {
            return this.downstreamPartialLengths[branchId - 1].getBranchPartialLength(refSeq, clientId);
        }
        else {
            return this.getBranchPartialLength(refSeq, clientId);
        }
    }
    getBranchPartialLength(refSeq, clientId) {
        let pLen = this.minLength;
        let seqIndex = latestLEQ(this.partialLengths, refSeq);
        let cliLatestindex = this.cliLatest(clientId);
        let cliSeq = this.clientSeqNumbers[clientId];
        if (seqIndex >= 0) {
            pLen += this.partialLengths[seqIndex].len;
            if (cliLatestindex >= 0) {
                let cliLatest = cliSeq[cliLatestindex];
                if (cliLatest.seq > refSeq) {
                    pLen += cliLatest.len;
                    let precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);
                    if (precedingCliIndex >= 0) {
                        pLen -= cliSeq[precedingCliIndex].len;
                    }
                }
            }
        }
        else {
            if (cliLatestindex >= 0) {
                let cliLatest = cliSeq[cliLatestindex];
                pLen += cliLatest.len;
            }
        }
        return pLen;
    }
    // clear away partial sums for sequence numbers earlier than the current window
    zamboni(segmentWindow) {
        function copyDown(partialLengths) {
            let mindex = latestLEQ(partialLengths, segmentWindow.minSeq);
            let minLength = 0;
            //console.log(`mindex ${mindex}`);
            if (mindex >= 0) {
                minLength = partialLengths[mindex].len;
                let seqCount = partialLengths.length;
                if (mindex <= (seqCount - 1)) {
                    // still some entries remaining
                    let remainingCount = (seqCount - mindex) - 1;
                    //copy down
                    for (let i = 0; i < remainingCount; i++) {
                        partialLengths[i] = partialLengths[i + mindex + 1];
                        partialLengths[i].len -= minLength;
                    }
                    partialLengths.length = remainingCount;
                }
            }
            return minLength;
        }
        this.minLength += copyDown(this.partialLengths);
        for (let clientId in this.clientSeqNumbers) {
            let cliPartials = this.clientSeqNumbers[clientId];
            if (cliPartials) {
                copyDown(cliPartials);
            }
        }
    }
    addClientSeqNumber(clientId, seq, seglen) {
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        let cli = this.clientSeqNumbers[clientId];
        let pLen = seglen;
        if (cli.length > 0) {
            pLen += cli[cli.length - 1].len;
        }
        cli.push({ seq: seq, len: pLen, seglen: seglen });
    }
    // assumes sequence number already coalesced
    addClientSeqNumberFromPartial(partialLength) {
        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);
        if (partialLength.overlapRemoveClients) {
            partialLength.overlapRemoveClients.map((oc) => {
                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);
                return true;
            });
        }
    }
    update(mergeTree, block, seq, clientId, collabWindow) {
        let segBranchId = mergeTree.getBranchId(clientId);
        // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);
        if (segBranchId == 0) {
            this.updateBranch(mergeTree, 0, block, seq, clientId, collabWindow);
        }
        if (mergeTree.localBranchId > 0) {
            for (let i = 0; i < mergeTree.localBranchId; i++) {
                let branchId = i + 1;
                if (segBranchId <= branchId) {
                    this.downstreamPartialLengths[i].updateBranch(mergeTree, branchId, block, seq, clientId, collabWindow);
                }
            }
        }
    }
    // assume: seq is latest sequence number; no structural change to sub-tree, but a segment
    // with sequence number seq has been added within the sub-tree
    // TODO: assert client id matches
    updateBranch(mergeTree, branchId, node, seq, clientId, collabWindow) {
        let seqSeglen = 0;
        let segCount = 0;
        // compute length for seq across children
        for (let i = 0; i < node.childCount; i++) {
            let child = node.children[i];
            if (!child.isLeaf()) {
                let childBlock = child;
                let branchPartialLengths = childBlock.partialLengths.partialLengthsForBranch(branchId);
                let partialLengths = branchPartialLengths.partialLengths;
                let seqIndex = latestLEQ(partialLengths, seq);
                if (seqIndex >= 0) {
                    let leqPartial = partialLengths[seqIndex];
                    if (leqPartial.seq == seq) {
                        seqSeglen += leqPartial.seglen;
                    }
                }
                segCount += branchPartialLengths.segmentCount;
            }
            else {
                let segment = child;
                let segBranchId = mergeTree.getBranchId(segment.clientId);
                let removalInfo = mergeTree.getRemovalInfo(branchId, segBranchId, segment);
                if (segment.seq == seq) {
                    if (removalInfo.removedSeq !== seq) {
                        seqSeglen += segment.cachedLength;
                    }
                }
                else {
                    if (removalInfo.removedSeq === seq) {
                        seqSeglen -= segment.cachedLength;
                    }
                }
                segCount++;
            }
        }
        this.segmentCount = segCount;
        function addSeq(partialLengths, seq, clientId) {
            let seqPartialLen;
            let penultPartialLen;
            let leqIndex = latestLEQ(partialLengths, seq);
            if (leqIndex >= 0) {
                let pLen = partialLengths[leqIndex];
                if (pLen.seq == seq) {
                    seqPartialLen = pLen;
                    leqIndex = latestLEQ(partialLengths, seq - 1);
                    if (leqIndex >= 0) {
                        penultPartialLen = partialLengths[leqIndex];
                    }
                }
                else {
                    penultPartialLen = pLen;
                }
            }
            if (seqPartialLen === undefined) {
                seqPartialLen = {
                    seq: seq,
                    seglen: seqSeglen,
                    clientId: clientId
                };
                partialLengths.push(seqPartialLen);
            }
            else {
                seqPartialLen.seglen = seqSeglen;
                // assert client id matches
            }
            if (penultPartialLen !== undefined) {
                seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;
            }
            else {
                seqPartialLen.len = seqPartialLen.seglen;
            }
        }
        addSeq(this.partialLengths, seq, clientId);
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        addSeq(this.clientSeqNumbers[clientId], seq);
        //    console.log(this.toString());
        if (PartialSequenceLengths.options.zamboni) {
            this.zamboni(collabWindow);
        }
        //   console.log('ZZZ');
        //   console.log(this.toString());
    }
    static fromLeaves(mergeTree, branchId, combinedPartialLengths, block, collabWindow) {
        combinedPartialLengths.minLength = 0;
        combinedPartialLengths.segmentCount = block.childCount;
        function getOverlapClients(overlapClientids, seglen) {
            let bst = new _collections__WEBPACK_IMPORTED_MODULE_0__["RedBlackTree"](compareNumbers);
            for (let clientId of overlapClientids) {
                bst.put(clientId, { clientId: clientId, seglen: seglen });
            }
            return bst;
        }
        function accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {
            if (partialLength.overlapRemoveClients) {
                for (let clientId of overlapRemoveClientIds) {
                    let ovlapClientNode = partialLength.overlapRemoveClients.get(clientId);
                    if (!ovlapClientNode) {
                        partialLength.overlapRemoveClients.put(clientId, { clientId: clientId, seglen: seglen });
                    }
                    else {
                        ovlapClientNode.data.seglen += seglen;
                    }
                }
            }
            else {
                partialLength.overlapRemoveClients = getOverlapClients(overlapRemoveClientIds, seglen);
            }
        }
        function insertSegment(segment, removedSeq = false, removalInfo = undefined) {
            let seq = segment.seq;
            let segmentLen = segment.cachedLength;
            let clientId = segment.clientId;
            let removeClientOverlap;
            if (removedSeq) {
                seq = removalInfo.removedSeq;
                segmentLen = -segmentLen;
                clientId = removalInfo.removedClientId;
                if (removalInfo.removedClientOverlap) {
                    removeClientOverlap = removalInfo.removedClientOverlap;
                }
            }
            let seqPartials = combinedPartialLengths.partialLengths;
            let seqPartialsLen = seqPartials.length;
            // find the first entry with sequence number greater or equal to seq
            let indexFirstGTE = 0;
            for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {
                if (seqPartials[indexFirstGTE].seq >= seq) {
                    break;
                }
            }
            if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq == seq)) {
                seqPartials[indexFirstGTE].seglen += segmentLen;
                if (removeClientOverlap) {
                    accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);
                }
            }
            else {
                let pLen;
                if (removeClientOverlap) {
                    let overlapClients = getOverlapClients(removeClientOverlap, segmentLen);
                    pLen = { seq: seq, clientId: clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };
                }
                else {
                    pLen = { seq: seq, clientId: clientId, len: 0, seglen: segmentLen };
                }
                if (indexFirstGTE < seqPartialsLen) {
                    // shift entries with greater sequence numbers
                    // TODO: investigate performance improvement using BST
                    for (let k = seqPartialsLen; k > indexFirstGTE; k--) {
                        seqPartials[k] = seqPartials[k - 1];
                    }
                    seqPartials[indexFirstGTE] = pLen;
                }
                else {
                    seqPartials.push(pLen);
                }
            }
        }
        function seqLTE(seq, minSeq) {
            return (seq != UnassignedSequenceNumber) && (seq <= minSeq);
        }
        for (let i = 0; i < block.childCount; i++) {
            let child = block.children[i];
            if (child.isLeaf()) {
                // leaf segment
                let segment = child;
                let segBranchId = mergeTree.getBranchId(segment.clientId);
                // console.log(`seg br ${segBranchId} cli ${glc(mergeTree, segment.clientId)} me ${glc(mergeTree, mergeTree.collabWindow.clientId)}`);
                if (segBranchId <= branchId) {
                    if (seqLTE(segment.seq, collabWindow.minSeq)) {
                        combinedPartialLengths.minLength += segment.cachedLength;
                    }
                    else {
                        if (segment.seq != UnassignedSequenceNumber) {
                            insertSegment(segment);
                        }
                    }
                    let removalInfo = mergeTree.getRemovalInfo(branchId, segBranchId, segment);
                    if (seqLTE(removalInfo.removedSeq, collabWindow.minSeq)) {
                        combinedPartialLengths.minLength -= segment.cachedLength;
                    }
                    else {
                        if ((removalInfo.removedSeq !== undefined) &&
                            (removalInfo.removedSeq != UnassignedSequenceNumber)) {
                            insertSegment(segment, true, removalInfo);
                        }
                    }
                }
            }
        }
        // post-process correctly-ordered partials computing sums and creating
        // lists for each present client id
        let seqPartials = combinedPartialLengths.partialLengths;
        let seqPartialsLen = seqPartials.length;
        let prevLen = 0;
        for (let i = 0; i < seqPartialsLen; i++) {
            seqPartials[i].len = prevLen + seqPartials[i].seglen;
            prevLen = seqPartials[i].len;
            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);
        }
    }
    static combine(mergeTree, block, collabWindow, recur = false) {
        let partialLengthsTopBranch = PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, 0, recur);
        if (mergeTree.localBranchId > 0) {
            partialLengthsTopBranch.downstreamPartialLengths = [];
            for (let i = 0; i < mergeTree.localBranchId; i++) {
                partialLengthsTopBranch.downstreamPartialLengths[i] =
                    PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, i + 1, recur);
            }
        }
        return partialLengthsTopBranch;
    }
    partialLengthsForBranch(branchId) {
        if (branchId > 0) {
            return this.downstreamPartialLengths[branchId - 1];
        }
        else {
            return this;
        }
    }
    /**
     * Combine the partial lengths of block's children
     * @param {IMergeBlock} block an interior node; it is assumed that each interior node child of this block
     * has its partials up to date
     * @param {CollaborationWindow} collabWindow segment window fo the segment tree containing textSegmentBlock
     */
    static combineBranch(mergeTree, block, collabWindow, branchId, recur = false) {
        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
        PartialSequenceLengths.fromLeaves(mergeTree, branchId, combinedPartialLengths, block, collabWindow);
        let prevPartial;
        function combineOverlapClients(a, b) {
            if (a.overlapRemoveClients) {
                if (b.overlapRemoveClients) {
                    b.overlapRemoveClients.map((bProp) => {
                        let aProp = a.overlapRemoveClients.get(bProp.key);
                        if (aProp) {
                            aProp.data.seglen += bProp.data.seglen;
                        }
                        else {
                            a.overlapRemoveClients.put(bProp.data.clientId, bProp.data);
                        }
                        return true;
                    });
                }
            }
            else {
                a.overlapRemoveClients = b.overlapRemoveClients;
            }
        }
        function addNext(partialLength) {
            let seq = partialLength.seq;
            let pLen = 0;
            if (prevPartial) {
                if (prevPartial.seq == partialLength.seq) {
                    prevPartial.seglen += partialLength.seglen;
                    prevPartial.len += partialLength.seglen;
                    combineOverlapClients(prevPartial, partialLength);
                    return;
                }
                else {
                    pLen = prevPartial.len;
                    // previous sequence number is finished
                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
                }
            }
            prevPartial = {
                seq: seq,
                clientId: partialLength.clientId,
                len: pLen + partialLength.seglen,
                seglen: partialLength.seglen,
                overlapRemoveClients: partialLength.overlapRemoveClients
            };
            combinedPartialLengths.partialLengths.push(prevPartial);
        }
        let childPartials = [];
        for (let i = 0; i < block.childCount; i++) {
            let child = block.children[i];
            if (!child.isLeaf()) {
                let childBlock = child;
                if (recur) {
                    childBlock.partialLengths = PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);
                }
                childPartials.push(childBlock.partialLengths.partialLengthsForBranch(branchId));
            }
        }
        let childPartialsLen = childPartials.length;
        if (childPartialsLen != 0) {
            // some children are interior nodes
            if (combinedPartialLengths.partialLengths.length > 0) {
                // some children were leaves; add combined partials from these segments
                childPartials.push(combinedPartialLengths);
                childPartialsLen++;
                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
            }
            let indices = new Array(childPartialsLen);
            let childPartialsCounts = new Array(childPartialsLen);
            for (let i = 0; i < childPartialsLen; i++) {
                indices[i] = 0;
                childPartialsCounts[i] = childPartials[i].partialLengths.length;
                combinedPartialLengths.minLength += childPartials[i].minLength;
                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;
            }
            let outerIndexOfEarliest = 0;
            let earliestPartialLength;
            while (outerIndexOfEarliest >= 0) {
                outerIndexOfEarliest = -1;
                for (let k = 0; k < childPartialsLen; k++) {
                    // find next earliest sequence number
                    if (indices[k] < childPartialsCounts[k]) {
                        let cpLen = childPartials[k].partialLengths[indices[k]];
                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {
                            outerIndexOfEarliest = k;
                            earliestPartialLength = cpLen;
                        }
                    }
                }
                if (outerIndexOfEarliest >= 0) {
                    addNext(earliestPartialLength);
                    indices[outerIndexOfEarliest]++;
                }
            }
            // add client entry for last partial, if any
            if (prevPartial) {
                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
            }
        }
        // TODO: incremental zamboni during build
        //console.log(combinedPartialLengths.toString());
        //console.log(`ZZZ...(min ${segmentWindow.minSeq})`);
        if (PartialSequenceLengths.options.zamboni) {
            combinedPartialLengths.zamboni(collabWindow);
        }
        //console.log(combinedPartialLengths.toString());
        return combinedPartialLengths;
    }
}
PartialSequenceLengths.options = {
    zamboni: true
};
function clock() {
    if (process.hrtime) {
        return process.hrtime();
    }
    else {
        return Date.now();
    }
}
function elapsedMicroseconds(start) {
    if (process.hrtime) {
        let end = process.hrtime(start);
        let duration = Math.round((end[0] * 1000000) + (end[1] / 1000));
        return duration;
    }
    else {
        return 1000 * (Date.now() - start);
    }
}
/**
 * Used for in-memory testing.  This will queue a reference string for each client message.
 */
const useCheckQ = false;
let indentStrings = ["", " ", "  "];
function internedSpaces(n) {
    if (indentStrings[n] === undefined) {
        indentStrings[n] = "";
        for (let i = 0; i < n; i++) {
            indentStrings[n] += " ";
        }
    }
    return indentStrings[n];
}
class RegisterCollection {
    constructor() {
        this.clientCollections = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
        // TODO: snapshot
    }
    set(clientId, id, segments) {
        if (!this.clientCollections[clientId]) {
            this.clientCollections[clientId] = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
        }
        this.clientCollections[clientId][id] = segments;
    }
    get(clientId, id) {
        let clientCollection = this.clientCollections[clientId];
        if (clientCollection) {
            return clientCollection[id];
        }
    }
    getLength(clientId, id) {
        let segs = this.get(clientId, id);
        let len = 0;
        if (segs) {
            for (let seg of segs) {
                len += seg.cachedLength;
            }
        }
        return len;
    }
    removeClient(clientId) {
        this.clientCollections[clientId] = undefined;
    }
}
var clientSeqComparer = {
    min: { refSeq: -1, clientId: "" },
    compare: (a, b) => a.refSeq - b.refSeq
};
var LRUSegmentComparer = {
    min: { maxSeq: -2 },
    compare: (a, b) => a.maxSeq - b.maxSeq
};
function glc(mergeTree, id) {
    if (mergeTree.getLongClientId) {
        return mergeTree.getLongClientId(id);
    }
    else {
        return id.toString();
    }
}
function applyLeafRangeMarker(marker, searchInfo) {
    for (let rangeLabel of searchInfo.rangeLabels) {
        if (marker.hasRangeLabel(rangeLabel)) {
            let currentStack = searchInfo.stacks[rangeLabel];
            if (currentStack === undefined) {
                currentStack = new _collections__WEBPACK_IMPORTED_MODULE_0__["Stack"]();
                searchInfo.stacks[rangeLabel] = currentStack;
            }
            applyRangeReference(currentStack, marker);
        }
    }
}
function recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (segment.getType() === SegmentType.Marker) {
        let marker = segment;
        if (marker.refType &
            (_ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd)) {
            applyLeafRangeMarker(marker, searchInfo);
        }
    }
    return false;
}
function rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    if (node.isLeaf()) {
        let seg = node;
        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && (seg.getType() === SegmentType.Marker)) {
            let marker = seg;
            if (marker.refType &
                (_ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestBegin | _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].NestEnd)) {
                applyLeafRangeMarker(marker, searchInfo);
            }
        }
    }
    else {
        let block = node;
        applyStackDelta(searchInfo.stacks, block.rangeStacks);
    }
    return true;
}
function recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (segment.getType() === SegmentType.Marker) {
        let marker = segment;
        if (marker.hasTileLabel(searchInfo.tileLabel)) {
            searchInfo.tile = marker;
        }
    }
    return false;
}
function tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    if (node.isLeaf()) {
        let seg = node;
        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && (seg.getType() === SegmentType.Marker)) {
            let marker = seg;
            if (marker.hasTileLabel(searchInfo.tileLabel)) {
                searchInfo.tile = marker;
            }
        }
    }
    else {
        let block = node;
        let marker;
        if (searchInfo.posPrecedesTile) {
            marker = block.rightmostTiles[searchInfo.tileLabel];
        }
        else {
            marker = block.leftmostTiles[searchInfo.tileLabel];
        }
        if (marker !== undefined) {
            searchInfo.tile = marker;
        }
    }
    return true;
}
let minListenerComparer = {
    min: { minRequired: Number.MIN_VALUE },
    compare: (a, b) => a.minRequired - b.minRequired,
};
// represents a sequence of text segments
class MergeTree {
    // TODO: make and use interface describing options
    constructor(text, options) {
        this.text = text;
        this.options = options;
        this.windowTime = 0;
        this.packTime = 0;
        this.ordTime = 0;
        this.maxOrdTime = 0;
        this.blockUpdateMarkers = false;
        this.collabWindow = new CollaborationWindow();
        // TODO: change this to ES6 map; add remove on segment remove
        // for now assume only markers have ids and so point directly at the Segment
        // if we need to have pointers to non-markers, we can change to point at local refs
        this.idToSegment = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
        this.clientIdToBranchId = [];
        this.localBranchId = 0;
        this.minSeqPending = false;
        this.gatherSegment = (segment, pos, refSeq, clientId, start, end, accumSegments) => {
            if (start < 0) {
                start = 0;
            }
            if (end > segment.cachedLength) {
                end = segment.cachedLength;
            }
            if (segment.getType() === SegmentType.Text) {
                let textSegment = segment;
                accumSegments.segments.push(textSegment.clone(start, end));
            }
            else {
                let marker = segment;
                accumSegments.segments.push(marker.clone());
            }
            return true;
        };
        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {
            if (segment.getType() == SegmentType.Text) {
                let textSegment = segment;
                if (MergeTree.traceGatherText) {
                    console.log(`@cli ${this.getLongClientId(this.collabWindow.clientId)} gather seg seq ${textSegment.seq} rseq ${textSegment.removedSeq} text ${textSegment.text}`);
                }
                let beginTags = "";
                let endTags = "";
                if (accumText.parallelArrays) {
                    // TODO: let clients pass in function to get tag
                    let tags = [];
                    let initTags = [];
                    if (textSegment.properties && (textSegment.properties["font-weight"])) {
                        tags.push("b");
                    }
                    if (textSegment.properties && (textSegment.properties["text-decoration"])) {
                        tags.push("u");
                    }
                    let remTags = [];
                    if (tags.length > 0) {
                        for (let tag of tags) {
                            if (accumText.tagsInProgress.indexOf(tag) < 0) {
                                beginTags += `<${tag}>`;
                                initTags.push(tag);
                            }
                        }
                        for (let accumTag of accumText.tagsInProgress) {
                            if (tags.indexOf(accumTag) < 0) {
                                endTags += `</${accumTag}>`;
                                remTags.push(accumTag);
                            }
                        }
                        for (let initTag of initTags.reverse()) {
                            accumText.tagsInProgress.push(initTag);
                        }
                    }
                    else {
                        for (let accumTag of accumText.tagsInProgress) {
                            endTags += `</${accumTag}>`;
                            remTags.push(accumTag);
                        }
                    }
                    for (let remTag of remTags) {
                        let remdex = accumText.tagsInProgress.indexOf(remTag);
                        if (remdex >= 0) {
                            accumText.tagsInProgress.splice(remdex, 1);
                        }
                    }
                }
                accumText.textSegment.text += endTags;
                accumText.textSegment.text += beginTags;
                if ((start <= 0) && (end >= textSegment.text.length)) {
                    accumText.textSegment.text += textSegment.text;
                }
                else {
                    if (start < 0) {
                        start = 0;
                    }
                    if (end >= textSegment.text.length) {
                        accumText.textSegment.text += textSegment.text.substring(start);
                    }
                    else {
                        accumText.textSegment.text += textSegment.text.substring(start, end);
                    }
                }
            }
            else {
                if (accumText.placeholder && (accumText.placeholder.length > 0)) {
                    if (accumText.placeholder === "*") {
                        let marker = segment;
                        accumText.textSegment.text += `\n${marker.toString()}`;
                    }
                    else {
                        for (let i = 0; i < segment.cachedLength; i++) {
                            accumText.textSegment.text += accumText.placeholder;
                        }
                    }
                }
                else if (accumText.parallelArrays) {
                    let marker = segment;
                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {
                        accumText.parallelMarkers.push(marker);
                        accumText.parallelText.push(accumText.textSegment.text);
                        accumText.textSegment.text = "";
                    }
                }
            }
            return true;
        };
        this.splitLeafSegment = (segment, pos) => {
            let segmentChanges = {};
            if (pos > 0) {
                segmentChanges.next = segment.splitAt(pos);
            }
            return segmentChanges;
        };
        this.blockUpdateActions = MergeTree.initBlockUpdateActions;
        if (options) {
            if (options.blockUpdateMarkers) {
                this.blockUpdateMarkers = options.blockUpdateMarkers;
            }
            if (options.localMinSeq !== undefined) {
                this.collabWindow.localMinSeq = options.localMinSeq;
            }
        }
        this.root = this.initialTextNode(this.text);
    }
    makeBlock(childCount) {
        let block;
        if (this.blockUpdateMarkers) {
            block = new HierMergeBlock(childCount);
        }
        else {
            block = new MergeBlock(childCount);
        }
        block.ordinal = "";
        return block;
    }
    initialTextNode(text) {
        let block = this.makeBlock(1);
        block.ordinal = "";
        block.assignChild(new TextSegment(text, UniversalSequenceNumber, LocalClientId), 0);
        block.cachedLength = text.length;
        return block;
    }
    clone() {
        let options = {
            blockUpdateMarkers: this.blockUpdateMarkers,
            localMinSeq: this.collabWindow.localMinSeq
        };
        let b = new MergeTree("", options);
        // for now assume that b will not collaborate
        b.root = b.blockClone(this.root);
    }
    blockClone(block, segments) {
        let bBlock = this.makeBlock(block.childCount);
        for (let i = 0; i < block.childCount; i++) {
            let child = block.children[i];
            if (child.isLeaf()) {
                let segment = this.segmentClone(child);
                bBlock.assignChild(segment, i);
                if (segments) {
                    segments.push(segment);
                }
            }
            else {
                bBlock.assignChild(this.blockClone(child, segments), i);
            }
        }
        this.nodeUpdateLengthNewStructure(bBlock);
        this.nodeUpdateOrdinals(bBlock);
        return bBlock;
    }
    segmentClone(segment) {
        let b = segment.clone();
        return b;
    }
    startGroupOperation(liveSegmentGroup) {
        // TODO: assert undefined
        if (this.collabWindow.collaborating) {
            if (liveSegmentGroup) {
                this.transactionSegmentGroup = liveSegmentGroup;
            }
            else {
                this.transactionSegmentGroup = { segments: [] };
                this.pendingSegments.enqueue(this.transactionSegmentGroup);
            }
            return this.transactionSegmentGroup;
        }
    }
    endGroupOperation() {
        if (this.collabWindow.collaborating) {
            this.transactionSegmentGroup = undefined;
        }
    }
    localNetLength(segment) {
        let segBranchId = this.getBranchId(segment.clientId);
        let removalInfo = segment;
        if (this.localBranchId > segBranchId) {
            removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, segment);
        }
        if (removalInfo.removedSeq !== undefined) {
            return 0;
        }
        else {
            return segment.cachedLength;
        }
    }
    getBranchId(clientId) {
        if ((this.clientIdToBranchId.length > clientId) && (clientId >= 0)) {
            return this.clientIdToBranchId[clientId];
        }
        else if (clientId === LocalClientId) {
            return 0;
        }
        else {
            return this.localBranchId;
        }
    }
    // TODO: remove id when segment removed
    mapIdToSegment(id, segment) {
        this.idToSegment[id] = segment;
    }
    addNode(block, node) {
        let index = block.childCount++;
        block.assignChild(node, index, false);
        return index;
    }
    reloadFromSegments(segments) {
        let segCap = MaxNodesInBlock - 1;
        const measureReloadTime = false;
        let buildMergeBlock = (nodes) => {
            const nodeCount = Math.ceil(nodes.length / segCap);
            const blocks = [];
            let nodeIndex = 0;
            for (let i = 0; i < nodeCount; i++) {
                let len = 0;
                blocks[i] = this.makeBlock(0);
                for (let j = 0; j < segCap; j++) {
                    if (nodeIndex < nodes.length) {
                        let childIndex = this.addNode(blocks[i], nodes[nodeIndex]);
                        len += nodes[nodeIndex].cachedLength;
                        if (this.blockUpdateMarkers) {
                            let hierBlock = blocks[i].hierBlock();
                            hierBlock.addNodeReferences(this, nodes[nodeIndex]);
                        }
                        if (this.blockUpdateActions) {
                            this.blockUpdateActions.child(blocks[i], childIndex);
                        }
                    }
                    else {
                        break;
                    }
                    nodeIndex++;
                }
                blocks[i].cachedLength = len;
            }
            if (blocks.length == 1) {
                return blocks[0];
            }
            else {
                return buildMergeBlock(blocks);
            }
        };
        let clockStart;
        if (measureReloadTime) {
            clockStart = clock();
        }
        if (segments.length > 0) {
            this.root = this.makeBlock(1);
            let block = buildMergeBlock(segments);
            this.root.assignChild(block, 0, false);
            if (this.blockUpdateMarkers) {
                let hierRoot = this.root.hierBlock();
                hierRoot.addNodeReferences(this, block);
            }
            if (this.blockUpdateActions) {
                this.blockUpdateActions.child(this.root, 0);
            }
            this.nodeUpdateOrdinals(this.root);
            this.root.cachedLength = block.cachedLength;
        }
        else {
            this.root = this.makeBlock(0);
            this.root.cachedLength = 0;
        }
        this.root.index = 0;
        if (measureReloadTime) {
            console.log(`reload time ${elapsedMicroseconds(clockStart)}`);
        }
    }
    // for now assume min starts at zero
    startCollaboration(localClientId, minSeq, branchId) {
        this.collabWindow.clientId = localClientId;
        this.collabWindow.minSeq = minSeq;
        this.collabWindow.collaborating = true;
        this.collabWindow.currentSeq = minSeq;
        this.localBranchId = branchId;
        this.segmentsToScour = new _collections__WEBPACK_IMPORTED_MODULE_0__["Heap"]([], LRUSegmentComparer);
        this.pendingSegments = _collections__WEBPACK_IMPORTED_MODULE_0__["ListMakeHead"]();
        let measureFullCollab = false;
        let clockStart;
        if (measureFullCollab) {
            clockStart = clock();
        }
        this.nodeUpdateLengthNewStructure(this.root, true);
        if (measureFullCollab) {
            console.log(`update partial lengths at start ${elapsedMicroseconds(clockStart)}`);
        }
    }
    addToLRUSet(segment, seq) {
        this.segmentsToScour.add({ segment: segment, maxSeq: seq });
    }
    underflow(node) {
        return node.childCount < (MaxNodesInBlock / 2);
    }
    scourNode(node, holdNodes) {
        let prevSegment;
        for (let k = 0; k < node.childCount; k++) {
            let childNode = node.children[k];
            if (childNode.isLeaf()) {
                let segment = childNode;
                if ((segment.removedSeq !== undefined) && (segment.removedSeq !== UnassignedSequenceNumber)) {
                    let createBrid = this.getBranchId(segment.clientId);
                    let removeBrid = this.getBranchId(segment.removedClientId);
                    if ((removeBrid != createBrid) || (segment.removedSeq > this.collabWindow.minSeq)) {
                        holdNodes.push(segment);
                    }
                    else {
                        if (MergeTree.traceZRemove) {
                            console.log(`${this.getLongClientId(this.collabWindow.clientId)}: Zremove ${segment.text}; cli ${this.getLongClientId(segment.clientId)}`);
                        }
                        segment.parent = undefined;
                    }
                    prevSegment = undefined;
                }
                else {
                    if ((segment.seq <= this.collabWindow.minSeq) &&
                        segment.segmentGroups.empty && (segment.seq != UnassignedSequenceNumber)) {
                        if (prevSegment && prevSegment.canAppend(segment, this)) {
                            if (MergeTree.traceAppend) {
                                console.log(`${this.getLongClientId(this.collabWindow.clientId)}: append ${prevSegment.text} + ${segment.text}; cli ${this.getLongClientId(prevSegment.clientId)} + cli ${this.getLongClientId(segment.clientId)}`);
                            }
                            prevSegment.append(segment);
                            segment.parent = undefined;
                        }
                        else {
                            holdNodes.push(segment);
                            if (this.localNetLength(segment) > 0) {
                                prevSegment = segment;
                            }
                            else {
                                prevSegment = undefined;
                            }
                        }
                    }
                    else {
                        holdNodes.push(segment);
                        prevSegment = undefined;
                    }
                }
            }
            else {
                holdNodes.push(childNode);
                prevSegment = undefined;
            }
        }
    }
    // interior node with all node children
    pack(block) {
        let parent = block.parent;
        let children = parent.children;
        let childIndex;
        let childBlock;
        let holdNodes = [];
        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
            // debug assert not isLeaf()
            childBlock = children[childIndex];
            this.scourNode(childBlock, holdNodes);
            // will replace this block with a packed block
            childBlock.parent = undefined;
        }
        let totalNodeCount = holdNodes.length;
        let halfCount = MaxNodesInBlock / 2;
        let childCount = Math.min(MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));
        if (childCount < 1) {
            childCount = 1;
        }
        let baseCount = Math.floor(totalNodeCount / childCount);
        let extraCount = totalNodeCount % childCount;
        let packedBlocks = new Array(MaxNodesInBlock);
        let readCount = 0;
        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {
            let nodeCount = baseCount;
            if (extraCount > 0) {
                nodeCount++;
                extraCount--;
            }
            let packedBlock = this.makeBlock(nodeCount);
            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {
                let nodeToPack = holdNodes[readCount++];
                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);
            }
            packedBlock.parent = parent;
            packedBlocks[nodeIndex] = packedBlock;
            this.nodeUpdateLengthNewStructure(packedBlock);
        }
        if (readCount != totalNodeCount) {
            console.log(`total count ${totalNodeCount} readCount ${readCount}`);
        }
        parent.children = packedBlocks;
        for (let j = 0; j < childCount; j++) {
            parent.assignChild(packedBlocks[j], j, false);
        }
        parent.childCount = childCount;
        if (this.underflow(parent) && (parent.parent)) {
            this.pack(parent);
        }
        else {
            this.nodeUpdateOrdinals(parent);
            this.blockUpdatePathLengths(parent, UnassignedSequenceNumber, -1, true);
        }
    }
    zamboniSegments() {
        //console.log(`scour line ${segmentsToScour.count()}`);
        let clockStart;
        if (MergeTree.options.measureWindowTime) {
            clockStart = clock();
        }
        let segmentToScour = this.segmentsToScour.peek();
        if (segmentToScour && (segmentToScour.maxSeq <= this.collabWindow.minSeq)) {
            for (let i = 0; i < MergeTree.zamboniSegmentsMaxCount; i++) {
                segmentToScour = this.segmentsToScour.get();
                if (segmentToScour && segmentToScour.segment.parent &&
                    (segmentToScour.maxSeq <= this.collabWindow.minSeq)) {
                    let block = segmentToScour.segment.parent;
                    let childrenCopy = [];
                    //                console.log(`scouring from ${segmentToScour.segment.seq}`);
                    this.scourNode(block, childrenCopy);
                    let newChildCount = childrenCopy.length;
                    if (newChildCount < block.childCount) {
                        block.childCount = newChildCount;
                        block.children = childrenCopy;
                        for (let j = 0; j < newChildCount; j++) {
                            block.assignChild(childrenCopy[j], j, false);
                        }
                        if (this.underflow(block) && block.parent) {
                            //nodeUpdatePathLengths(node, UnassignedSequenceNumber, -1, true);
                            let packClockStart;
                            if (MergeTree.options.measureWindowTime) {
                                packClockStart = clock();
                            }
                            this.pack(block);
                            if (MergeTree.options.measureWindowTime) {
                                this.packTime += elapsedMicroseconds(packClockStart);
                            }
                        }
                        else {
                            this.nodeUpdateOrdinals(block);
                            this.blockUpdatePathLengths(block, UnassignedSequenceNumber, -1, true);
                        }
                    }
                }
                else {
                    break;
                }
            }
        }
        if (MergeTree.options.measureWindowTime) {
            this.windowTime += elapsedMicroseconds(clockStart);
        }
    }
    getCollabWindow() {
        return this.collabWindow;
    }
    getStats() {
        let nodeGetStats = (block) => {
            let stats = { maxHeight: 0, nodeCount: 0, leafCount: 0, removedLeafCount: 0, liveCount: 0, histo: [] };
            for (let k = 0; k < MaxNodesInBlock; k++) {
                stats.histo[k] = 0;
            }
            for (let i = 0; i < block.childCount; i++) {
                let child = block.children[i];
                let height = 1;
                if (!child.isLeaf()) {
                    let childStats = nodeGetStats(child);
                    height = 1 + childStats.maxHeight;
                    stats.nodeCount += childStats.nodeCount;
                    stats.leafCount += childStats.leafCount;
                    stats.removedLeafCount += childStats.removedLeafCount;
                    stats.liveCount += childStats.liveCount;
                    for (let i = 0; i < MaxNodesInBlock; i++) {
                        stats.histo[i] += childStats.histo[i];
                    }
                }
                else {
                    stats.leafCount++;
                    let segment = child;
                    if (segment.removedSeq !== undefined) {
                        stats.removedLeafCount++;
                    }
                }
                if (height > stats.maxHeight) {
                    stats.maxHeight = height;
                }
            }
            stats.histo[block.childCount]++;
            stats.nodeCount++;
            stats.liveCount += block.childCount;
            return stats;
        };
        let rootStats = nodeGetStats(this.root);
        if (MergeTree.options.measureWindowTime) {
            rootStats.windowTime = this.windowTime;
            rootStats.packTime = this.packTime;
            rootStats.ordTime = this.ordTime;
            rootStats.maxOrdTime = this.maxOrdTime;
        }
        return rootStats;
    }
    tardisPosition(pos, fromSeq, toSeq, toClientId = NonCollabClient) {
        return this.tardisPositionFromClient(pos, fromSeq, toSeq, NonCollabClient, toClientId);
    }
    tardisPositionFromClient(pos, fromSeq, toSeq, fromClientId, toClientId = NonCollabClient) {
        if (((fromSeq < toSeq) || (toClientId === this.collabWindow.clientId)) && pos < this.getLength(fromSeq, fromClientId)) {
            if ((toSeq <= this.collabWindow.currentSeq) && (fromSeq >= this.collabWindow.minSeq)) {
                let segoff = this.getContainingSegment(pos, fromSeq, fromClientId);
                let toPos = this.getOffset(segoff.segment, toSeq, toClientId);
                let ret = toPos + segoff.offset;
                assert__WEBPACK_IMPORTED_MODULE_3__(ret !== undefined);
                return ret;
            }
            assert__WEBPACK_IMPORTED_MODULE_3__(false);
        }
        else {
            return pos;
        }
    }
    tardisRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, fromClientId, toClientId = NonCollabClient) {
        let ranges = [];
        let recordRange = (segment, pos, refSeq, clientId, segStart, segEnd) => {
            if (this.nodeLength(segment, toSeq, toClientId) > 0) {
                let offset = this.getOffset(segment, toSeq, toClientId);
                if (segStart < 0) {
                    segStart = 0;
                }
                if (segEnd > segment.cachedLength) {
                    segEnd = segment.cachedLength;
                }
                ranges.push({ start: offset + segStart, end: offset + segEnd });
            }
            return true;
        };
        this.mapRange({ leaf: recordRange }, fromSeq, fromClientId, undefined, rangeStart, rangeEnd);
        return ranges;
    }
    tardisRange(rangeStart, rangeEnd, fromSeq, toSeq, toClientId = NonCollabClient) {
        return this.tardisRangeFromClient(rangeStart, rangeEnd, fromSeq, toSeq, NonCollabClient, toClientId);
    }
    getLength(refSeq, clientId) {
        return this.blockLength(this.root, refSeq, clientId);
    }
    getOffset(node, refSeq, clientId) {
        let totalOffset = 0;
        let parent = node.parent;
        let prevParent;
        while (parent) {
            let children = parent.children;
            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {
                let child = children[childIndex];
                if ((prevParent && (child == prevParent)) || (child == node)) {
                    break;
                }
                totalOffset += this.nodeLength(child, refSeq, clientId);
            }
            prevParent = parent;
            parent = parent.parent;
        }
        return totalOffset;
    }
    searchFromPos(pos, target) {
        let start = pos;
        let end = pos + MergeTree.searchChunkSize;
        let chunk = "";
        let found = false;
        while (!found) {
            if (end > this.root.cachedLength) {
                end = this.root.cachedLength;
            }
            chunk += this.getText(UniversalSequenceNumber, this.collabWindow.clientId, "", start, end);
            let result = chunk.match(target);
            if (result !== null) {
                return { text: result[0], pos: result.index };
            }
            start += MergeTree.searchChunkSize;
            if (start >= this.root.cachedLength) {
                break;
            }
            end += MergeTree.searchChunkSize;
        }
    }
    incrementalGetText(refSeq, clientId, start, end) {
        if (start === undefined) {
            start = 0;
        }
        if (end === undefined) {
            end = this.blockLength(this.root, refSeq, clientId);
        }
        let context = new TextSegment("");
        let stack = new _collections__WEBPACK_IMPORTED_MODULE_0__["Stack"]();
        let initialState = new IncrementalMapState(this.root, { leaf: incrementalGatherText }, 0, refSeq, clientId, context, start, end, 0);
        stack.push(initialState);
        while (!stack.empty()) {
            this.incrementalBlockMap(stack);
        }
        return context.text;
    }
    getTextAndMarkers(refSeq, clientId, label, start, end) {
        if (start === undefined) {
            start = 0;
        }
        if (end === undefined) {
            end = this.blockLength(this.root, refSeq, clientId);
        }
        let accum = {
            textSegment: new TextSegment(""), parallelMarkerLabel: label, parallelArrays: true, parallelMarkers: [], parallelText: [],
            tagsInProgress: []
        };
        if (MergeTree.traceGatherText) {
            console.log(`get text on cli ${glc(this, this.collabWindow.clientId)} ref cli ${glc(this, clientId)} refSeq ${refSeq}`);
        }
        this.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, start, end);
        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };
    }
    cloneSegments(refSeq, clientId, start = 0, end) {
        if (end === undefined) {
            end = this.blockLength(this.root, refSeq, clientId);
        }
        let accum = {
            segments: []
        };
        this.mapRange({ leaf: this.gatherSegment }, refSeq, clientId, accum, start, end);
        return accum.segments;
    }
    getItems(refSeq, clientId, start, end) {
        let accum = [];
        function gatherItems(segment, pos, refSeq, clientId, start, end) {
            if (segment.getType() === SegmentType.Run) {
                const runSeg = segment;
                for (const item of runSeg.items) {
                    accum.push(item);
                }
                return true;
            }
        }
        this.mapRange({ leaf: gatherItems }, refSeq, clientId, accum, start, end);
        return accum;
    }
    getText(refSeq, clientId, placeholder = "", start, end) {
        if (start === undefined) {
            start = 0;
        }
        if (end === undefined) {
            end = this.blockLength(this.root, refSeq, clientId);
        }
        let accum = { textSegment: new TextSegment(""), placeholder };
        if (MergeTree.traceGatherText) {
            console.log(`get text on cli ${glc(this, this.collabWindow.clientId)} ref cli ${glc(this, clientId)} refSeq ${refSeq}`);
        }
        this.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, start, end);
        return accum.textSegment.text;
    }
    getContainingSegment(pos, refSeq, clientId) {
        let segment;
        let offset;
        let leaf = (leafSeg, segpos, refSeq, clientId, start) => {
            segment = leafSeg;
            offset = start;
            return false;
        };
        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf });
        return { segment, offset };
    }
    blockLength(node, refSeq, clientId) {
        if ((this.collabWindow.collaborating) && (clientId != this.collabWindow.clientId)) {
            return node.partialLengths.getPartialLength(this, refSeq, clientId);
        }
        else {
            return node.cachedLength;
        }
    }
    getRemovalInfo(branchId, segBranchId, segment) {
        if (branchId > segBranchId) {
            let index = (branchId - segBranchId) - 1;
            if (!segment.removalsByBranch) {
                segment.removalsByBranch = [];
            }
            if (!segment.removalsByBranch[index]) {
                segment.removalsByBranch[index] = {};
            }
            return segment.removalsByBranch[index];
        }
        else {
            return segment;
        }
    }
    nodeLength(node, refSeq, clientId) {
        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId == clientId)) {
            // local client sees all segments, even when collaborating
            if (!node.isLeaf()) {
                return node.cachedLength;
            }
            else {
                return this.localNetLength(node);
            }
        }
        else {
            // sequence number within window
            let branchId = this.getBranchId(clientId);
            if (!node.isLeaf()) {
                return node.partialLengths.getPartialLength(this, refSeq, clientId);
            }
            else {
                let segment = node;
                let segBranchId = this.getBranchId(segment.clientId);
                if ((segBranchId <= branchId) && ((segment.clientId === clientId) ||
                    ((segment.seq != UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {
                    let removalInfo = segment;
                    if (branchId > segBranchId) {
                        removalInfo = this.getRemovalInfo(branchId, segBranchId, segment);
                    }
                    // segment happened by reference sequence number or segment from requesting client
                    if (removalInfo.removedSeq !== undefined) {
                        if ((removalInfo.removedClientId === clientId) ||
                            (removalInfo.removedClientOverlap && (removalInfo.removedClientOverlap.indexOf(clientId) >= 0)) ||
                            ((removalInfo.removedSeq != UnassignedSequenceNumber) && (removalInfo.removedSeq <= refSeq))) {
                            return 0;
                        }
                        else {
                            return segment.cachedLength;
                        }
                    }
                    else {
                        return segment.cachedLength;
                    }
                }
                else {
                    // segment invisible to client at reference sequence number/branch id/client id of op
                    return 0;
                }
            }
        }
    }
    updateLocalMinSeq(localMinSeq) {
        this.collabWindow.localMinSeq = localMinSeq;
        this.setMinSeq(Math.min(this.collabWindow.globalMinSeq, localMinSeq));
    }
    addMinSeqListener(minRequired, onMinGE) {
        if (!this.minSeqListeners) {
            this.minSeqListeners = new _collections__WEBPACK_IMPORTED_MODULE_0__["Heap"]([], minListenerComparer);
        }
        this.minSeqListeners.add({ minRequired, onMinGE });
    }
    notifyMinSeqListeners() {
        this.minSeqPending = false;
        while ((this.minSeqListeners.count() > 0) &&
            (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {
            let minListener = this.minSeqListeners.get();
            minListener.onMinGE(this.collabWindow.minSeq);
        }
    }
    setMinSeq(minSeq) {
        if (minSeq > this.collabWindow.minSeq) {
            this.collabWindow.minSeq = minSeq;
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
            if (this.minSeqListeners && this.minSeqListeners.count()) {
                this.minSeqPending = true;
            }
        }
    }
    commitGlobalMin() {
        if (this.collabWindow.globalMinSeq !== undefined) {
            this.collabWindow.localMinSeq = this.collabWindow.globalMinSeq;
            this.setMinSeq(this.collabWindow.globalMinSeq);
        }
    }
    updateGlobalMinSeq(globalMinSeq) {
        if (this.collabWindow.localMinSeq === undefined) {
            this.setMinSeq(globalMinSeq);
        }
        else {
            this.collabWindow.globalMinSeq = globalMinSeq;
            this.setMinSeq(Math.min(globalMinSeq, this.collabWindow.localMinSeq));
        }
    }
    referencePositionToLocalPosition(refPos, refSeq = UniversalSequenceNumber, clientId = this.collabWindow.clientId) {
        let seg = refPos.getSegment();
        let offset = refPos.getOffset();
        return offset + this.getOffset(seg, refSeq, clientId);
    }
    getStackContext(startPos, clientId, rangeLabels) {
        let searchInfo = {
            mergeTree: this,
            stacks: _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"](),
            rangeLabels
        };
        this.search(startPos, UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);
        return searchInfo.stacks;
    }
    // TODO: with annotation op change value
    cherryPickedUndo(undoInfo) {
        let segment = undoInfo.seg;
        // no branches
        if (segment.removedSeq !== undefined) {
            segment.removedSeq = undefined;
            segment.removedClientId = undefined;
        }
        else {
            if (undoInfo.op === 1 /* REMOVE */) {
                segment.removedSeq = undoInfo.seq;
            }
            else {
                segment.removedSeq = UnassignedSequenceNumber;
            }
            segment.removedClientId = this.collabWindow.clientId;
        }
        this.blockUpdatePathLengths(segment.parent, UnassignedSequenceNumber, -1, true);
    }
    // TODO: filter function
    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {
        let searchInfo = {
            mergeTree: this,
            posPrecedesTile,
            tileLabel,
        };
        if (posPrecedesTile) {
            this.search(startPos, UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        else {
            this.backwardSearch(startPos, UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        if (searchInfo.tile) {
            let pos;
            if (searchInfo.tile.isLeaf()) {
                let marker = searchInfo.tile;
                pos = this.getOffset(marker, UniversalSequenceNumber, clientId);
            }
            else {
                let localRef = searchInfo.tile;
                pos = localRef.toPosition(this, UniversalSequenceNumber, clientId);
            }
            return { tile: searchInfo.tile, pos };
        }
    }
    search(pos, refSeq, clientId, actions, clientData) {
        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);
    }
    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {
        let children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, segpos, refSeq, clientId, undefined, undefined, clientData);
        }
        let contains = actions && actions.contains;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            let child = children[childIndex];
            let len = this.nodeLength(child, refSeq, clientId);
            if (((!contains) && (pos < len)) || (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {
                // found entry containing pos
                if (!child.isLeaf()) {
                    return this.searchBlock(child, pos, segpos, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);
                }
                pos -= len;
                segpos += len;
            }
        }
        if (actions && actions.post) {
            actions.post(block, segpos, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    backwardSearch(pos, refSeq, clientId, actions, clientData) {
        return this.backwardSearchBlock(this.root, pos, this.getLength(refSeq, clientId), refSeq, clientId, actions, clientData);
    }
    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {
        let children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
        let contains = actions && actions.contains;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            let child = children[childIndex];
            let len = this.nodeLength(child, refSeq, clientId);
            let segpos = segEnd - len;
            if (((!contains) && (pos >= segpos)) ||
                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {
                // found entry containing pos
                if (!child.isLeaf()) {
                    return this.backwardSearchBlock(child, pos, segEnd, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);
                }
                segEnd = segpos;
            }
        }
        if (actions && actions.post) {
            actions.post(block, segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    updateRoot(splitNode, refSeq, clientId, seq) {
        if (splitNode !== undefined) {
            let newRoot = this.makeBlock(2);
            newRoot.index = 0;
            newRoot.ordinal = "";
            newRoot.assignChild(this.root, 0, false);
            newRoot.assignChild(splitNode, 1, false);
            this.root = newRoot;
            this.nodeUpdateOrdinals(this.root);
            this.nodeUpdateLengthNewStructure(this.root);
        }
    }
    /**
     * Assign sequence number to existing segment; update partial lengths to reflect the change
     * @param seq sequence number given by server to pending segment
     */
    ackPendingSegment(seq, verboseOps = false) {
        let pendingSegmentGroup = this.pendingSegments.dequeue();
        let nodesToUpdate = [];
        let clientId;
        let overwrite = false;
        if (pendingSegmentGroup !== undefined) {
            if (verboseOps) {
                console.log(`segment group has ${pendingSegmentGroup.segments.length} segments`);
            }
            pendingSegmentGroup.segments.map((pendingSegment) => {
                if (pendingSegment.seq === UnassignedSequenceNumber) {
                    pendingSegment.seq = seq;
                }
                else {
                    let segBranchId = this.getBranchId(pendingSegment.clientId);
                    let removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, pendingSegment);
                    if (removalInfo.removedSeq !== undefined) {
                        if (removalInfo.removedSeq != UnassignedSequenceNumber) {
                            overwrite = true;
                            if (MergeTree.diagOverlappingRemove) {
                                console.log(`grump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)} from ${pendingSegment.removedSeq} text ${pendingSegment.toString()}`);
                            }
                        }
                        else {
                            removalInfo.removedSeq = seq;
                        }
                    }
                }
                const segmentGroup = pendingSegment.segmentGroups.dequeue();
                assert__WEBPACK_IMPORTED_MODULE_3__["equal"](segmentGroup, pendingSegmentGroup);
                clientId = this.collabWindow.clientId;
                if (nodesToUpdate.indexOf(pendingSegment.parent) < 0) {
                    nodesToUpdate.push(pendingSegment.parent);
                }
            });
            for (let node of nodesToUpdate) {
                this.blockUpdatePathLengths(node, seq, clientId, overwrite);
                //nodeUpdatePathLengths(node, seq, clientId, true);
            }
        }
    }
    addToPendingList(segment, segmentGroup) {
        if (segmentGroup === undefined) {
            if (this.transactionSegmentGroup) {
                segmentGroup = this.transactionSegmentGroup;
            }
            else {
                segmentGroup = { segments: [] };
                this.pendingSegments.enqueue(segmentGroup);
            }
        }
        // TODO: share this group with UNDO
        segment.segmentGroups.enqueue(segmentGroup);
        return segmentGroup;
    }
    // TODO: error checking
    getSegmentFromId(id) {
        return this.idToSegment[id];
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos Id of marker (may be indirect) and whether position is before or after marker.
     * @param refseq The reference sequence number at which to compute the position.
     * @param clientId The client id with which to compute the position.
     */
    posFromRelativePos(relativePos, refseq = UniversalSequenceNumber, clientId = this.collabWindow.clientId) {
        let pos = -1;
        let marker;
        if (relativePos.id) {
            marker = this.getSegmentFromId(relativePos.id);
        }
        if (marker) {
            pos = this.getOffset(marker, refseq, clientId);
            if (!relativePos.before) {
                pos += marker.cachedLength;
                if (relativePos.offset !== undefined) {
                    pos += relativePos.offset;
                }
            }
            else {
                if (relativePos.offset !== undefined) {
                    pos -= relativePos.offset;
                }
            }
        }
        return pos;
    }
    insert(pos, refSeq, clientId, seq, segData, traverse, opArgs) {
        this.ensureIntervalBoundary(pos, refSeq, clientId);
        if (MergeTree.traceOrdinals) {
            this.ordinalIntegrity();
        }
        //traceTraversal = true;
        let splitNode = traverse(this.root, pos, refSeq, clientId, seq, segData);
        //traceTraversal = false;
        this.updateRoot(splitNode, refSeq, clientId, seq);
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                mergeTreeClientId: clientId,
                operation: 0 /* INSERT */,
                mergeTree: this,
                segments: [segData]
            });
        }
    }
    insertSegment(pos, refSeq, clientId, seq, segment, opArgs) {
        // const tt = MergeTree.traceTraversal;
        // MergeTree.traceTraversal = true;
        this.insert(pos, refSeq, clientId, seq, segment, (block, pos, refSeq, clientId, seq, seg) => this.blockInsert(block, pos, refSeq, clientId, seq, seg), opArgs);
        // MergeTree.traceTraversal = tt;
    }
    insertMarker(pos, refSeq, clientId, seq, behaviors, props, opArgs) {
        let marker = Marker.make(behaviors, props, seq, clientId);
        let markerId = marker.getId();
        if (markerId) {
            this.mapIdToSegment(markerId, marker);
        }
        this.insert(pos, refSeq, clientId, seq, marker, (block, pos, refSeq, clientId, seq, marker) => this.blockInsert(block, pos, refSeq, clientId, seq, marker), opArgs);
        // report segment if client interested
        if (this.markerModifiedHandler && (seq !== UnassignedSequenceNumber)) {
            this.markerModifiedHandler(marker);
        }
        return marker;
    }
    insertTextMarkerRelative(markerPos, refSeq, clientId, seq, text, props, opArgs) {
        let pos = this.posFromRelativePos(markerPos, refSeq, clientId);
        if (pos >= 0) {
            let newSegment = TextSegment.make(text, props, seq, clientId);
            // MergeTree.traceTraversal = true;
            this.insert(pos, refSeq, clientId, seq, newSegment, (block, pos, refSeq, clientId, seq, segment) => this.blockInsert(this.root, pos, refSeq, clientId, seq, segment), opArgs);
            MergeTree.traceTraversal = false;
            if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&
                (seq != UnassignedSequenceNumber)) {
                this.zamboniSegments();
            }
        }
    }
    insertText(pos, refSeq, clientId, seq, text, props, opArgs) {
        let newSegment = TextSegment.make(text, props, seq, clientId);
        // MergeTree.traceTraversal = true;
        this.insert(pos, refSeq, clientId, seq, newSegment, (block, pos, refSeq, clientId, seq, segment) => this.blockInsert(this.root, pos, refSeq, clientId, seq, segment), opArgs);
        MergeTree.traceTraversal = false;
        if (MergeTree.traceOrdinals) {
            this.ordinalIntegrity();
        }
        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&
            (seq != UnassignedSequenceNumber)) {
            this.zamboniSegments();
        }
    }
    blockInsert(block, pos, refSeq, clientId, seq, newSegment) {
        let segIsLocal = false;
        let checkSegmentIsLocal = (segment, pos, refSeq, clientId) => {
            if (segment.seq == UnassignedSequenceNumber) {
                if (MergeTree.diagInsertTie) {
                    console.log(`@cli ${glc(this, this.collabWindow.clientId)}: promoting continue due to seq ${segment.seq} text ${segment.toString()} ref ${refSeq}`);
                }
                segIsLocal = true;
            }
            // only need to look at first segment that follows finished node
            return false;
        };
        let continueFrom = (node) => {
            segIsLocal = false;
            this.rightExcursion(node, checkSegmentIsLocal);
            if (MergeTree.diagInsertTie && segIsLocal && (newSegment.getType() === SegmentType.Text)) {
                let text = newSegment.toString();
                console.log(`@cli ${glc(this, this.collabWindow.clientId)}: attempting continue with seq ${seq} text ${text} ref ${refSeq}`);
            }
            return segIsLocal;
        };
        let onLeaf = (segment, pos, context) => {
            let saveIfLocal = (locSegment) => {
                // save segment so can assign sequence number when acked by server
                if (this.collabWindow.collaborating) {
                    if ((locSegment.seq == UnassignedSequenceNumber) &&
                        (clientId == this.collabWindow.clientId)) {
                        this.addToPendingList(locSegment);
                    }
                    else if ((locSegment.seq >= this.collabWindow.minSeq) &&
                        MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(locSegment, locSegment.seq);
                    }
                }
            };
            let segmentChanges = {};
            if (segment) {
                // insert before segment
                segmentChanges.replaceCurrent = newSegment;
                segmentChanges.next = segment;
            }
            else {
                segmentChanges.next = newSegment;
            }
            saveIfLocal(newSegment);
            return segmentChanges;
        };
        return this.insertingWalk(block, pos, refSeq, clientId, seq, newSegment.getType(), { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });
    }
    ensureIntervalBoundary(pos, refSeq, clientId) {
        let splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, TreeMaintenanceSequenceNumber, SegmentType.Base, { leaf: this.splitLeafSegment });
        this.updateRoot(splitNode, refSeq, clientId, TreeMaintenanceSequenceNumber);
    }
    // assume called only when pos == len
    breakTie(pos, len, seq, node, refSeq, clientId, candidateSegment) {
        if (node.isLeaf()) {
            let segment = node;
            // TODO: marker/marker tie break & alternate tie break rules
            if (pos == 0) {
                return segment.seq !== UnassignedSequenceNumber;
            }
            else {
                return false;
            }
        }
        else {
            return true;
        }
    }
    // visit segments starting from node's right siblings, then up to node's parent
    leftExcursion(node, leafAction) {
        let actions = { leaf: leafAction };
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            let children = parent.children;
            let childIndex;
            let node;
            let matchedStart = false;
            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {
                node = children[childIndex];
                if (matchedStart) {
                    if (!node.isLeaf()) {
                        let childBlock = node;
                        go = this.nodeMapReverse(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);
                    }
                    else {
                        go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    // visit segments starting from node's right siblings, then up to node's parent
    rightExcursion(node, leafAction) {
        let actions = { leaf: leafAction };
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            let children = parent.children;
            let childIndex;
            let node;
            let matchedStart = false;
            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
                node = children[childIndex];
                if (matchedStart) {
                    if (!node.isLeaf()) {
                        let childBlock = node;
                        go = this.nodeMap(childBlock, actions, 0, UniversalSequenceNumber, this.collabWindow.clientId, undefined);
                    }
                    else {
                        go = leafAction(node, 0, UniversalSequenceNumber, this.collabWindow.clientId, 0, 0);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    insertingWalk(block, pos, refSeq, clientId, seq, segType, context) {
        let children = block.children;
        let childIndex;
        let child;
        let newNode;
        let fromSplit;
        let found = false;
        for (childIndex = 0; childIndex < block.childCount; childIndex++) {
            child = children[childIndex];
            let len = this.nodeLength(child, refSeq, clientId);
            if (MergeTree.traceTraversal) {
                let segInfo;
                if ((!child.isLeaf()) && this.collabWindow.collaborating) {
                    segInfo = `minLength: ${child.partialLengths.minLength}`;
                }
                else {
                    let segment = child;
                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: ${segment.toString()}`;
                    if (segment.removedSeq !== undefined) {
                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;
                    }
                }
                console.log(`@tcli: ${glc(this, this.collabWindow.clientId)} len: ${len} pos: ${pos} ` + segInfo);
            }
            if ((pos < len) || ((pos == len) && this.breakTie(pos, len, seq, child, refSeq, clientId, context.candidateSegment))) {
                // found entry containing pos
                found = true;
                if (!child.isLeaf()) {
                    let childBlock = child;
                    //internal node
                    let splitNode = this.insertingWalk(childBlock, pos, refSeq, clientId, seq, segType, context);
                    if (splitNode === undefined) {
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        else {
                            this.blockUpdateLength(block, seq, clientId);
                        }
                        return undefined;
                    }
                    else if (splitNode == MergeTree.theUnfinishedNode) {
                        if (MergeTree.traceTraversal) {
                            console.log(`@cli ${glc(this, this.collabWindow.clientId)} unfinished bus pos ${pos} len ${len}`);
                        }
                        pos -= len; // act as if shifted segment
                        continue;
                    }
                    else {
                        newNode = splitNode;
                        fromSplit = splitNode;
                        childIndex++; // insert after
                    }
                }
                else {
                    if (MergeTree.traceTraversal) {
                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action`);
                    }
                    const segment = child;
                    const branchId = this.getBranchId(clientId);
                    const segmentBranchId = this.getBranchId(segment.clientId);
                    const removalInfo = this.getRemovalInfo(branchId, segmentBranchId, segment);
                    if (removalInfo && removalInfo.removedSeq) {
                        continue;
                    }
                    let segmentChanges = context.leaf(segment, pos, context);
                    if (segmentChanges.replaceCurrent) {
                        if (MergeTree.traceOrdinals) {
                            console.log(`assign from leaf with block ord ${ordinalToArray(block.ordinal)}`);
                        }
                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);
                        segmentChanges.replaceCurrent.ordinal = child.ordinal;
                    }
                    if (segmentChanges.next) {
                        newNode = segmentChanges.next;
                        childIndex++; // insert after
                    }
                    else {
                        // no change
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        return undefined;
                    }
                }
                break;
            }
            else {
                pos -= len;
            }
        }
        if (MergeTree.traceTraversal) {
            if ((!found) && (pos > 0)) {
                console.log(`inserting walk fell through pos ${pos} len: ${this.blockLength(this.root, refSeq, clientId)}`);
            }
        }
        if (!newNode) {
            if (pos == 0) {
                if ((seq != UnassignedSequenceNumber) && context.continuePredicate &&
                    context.continuePredicate(block)) {
                    return MergeTree.theUnfinishedNode;
                }
                else {
                    if (MergeTree.traceTraversal) {
                        console.log(`@tcli: ${glc(this, this.collabWindow.clientId)}: leaf action pos 0`);
                    }
                    let segmentChanges = context.leaf(undefined, pos, context);
                    newNode = segmentChanges.next;
                    // assert segmentChanges.replaceCurrent === undefined
                }
            }
        }
        if (newNode) {
            for (let i = block.childCount; i > childIndex; i--) {
                block.children[i] = block.children[i - 1];
                block.children[i].index = i;
            }
            block.assignChild(newNode, childIndex, false);
            block.childCount++;
            block.setOrdinal(newNode, childIndex);
            if (block.childCount < MaxNodesInBlock) {
                if (fromSplit) {
                    if (MergeTree.traceOrdinals) {
                        console.log(`split ord ${ordinalToArray(fromSplit.ordinal)}`);
                    }
                    this.nodeUpdateOrdinals(fromSplit);
                }
                if (context.structureChange) {
                    this.nodeUpdateLengthNewStructure(block);
                }
                else {
                    this.blockUpdateLength(block, seq, clientId);
                }
                return undefined;
            }
            else {
                // don't update ordinals because higher block will do it
                return this.split(block);
            }
        }
        else {
            return undefined;
        }
    }
    split(node) {
        let halfCount = MaxNodesInBlock / 2;
        let newNode = this.makeBlock(halfCount);
        node.childCount = halfCount;
        // update ordinals to reflect lowered child count
        this.nodeUpdateOrdinals(node);
        for (let i = 0; i < halfCount; i++) {
            newNode.assignChild(node.children[halfCount + i], i, false);
            node.children[halfCount + i] = undefined;
        }
        this.nodeUpdateLengthNewStructure(node);
        this.nodeUpdateLengthNewStructure(newNode);
        return newNode;
    }
    ordinalIntegrity() {
        console.log("chk ordnls");
        this.nodeOrdinalIntegrity(this.root);
    }
    nodeOrdinalIntegrity(block) {
        let olen = block.ordinal.length;
        for (let i = 0; i < block.childCount; i++) {
            if (block.children[i].ordinal) {
                if (olen !== (block.children[i].ordinal.length - 1)) {
                    console.log("node integrity issue");
                }
                if (i > 0) {
                    if (block.children[i].ordinal <= block.children[i - 1].ordinal) {
                        console.log("node sib integrity issue");
                        console.log(`??: prnt chld prev ${ordinalToArray(block.ordinal)} ${ordinalToArray(block.children[i].ordinal)} ${(i > 0) ? ordinalToArray(block.children[i - 1].ordinal) : "NA"}`);
                    }
                }
                if (!block.children[i].isLeaf()) {
                    this.nodeOrdinalIntegrity(block.children[i]);
                }
            }
            else {
                console.log(`node child ordinal not set ${i}`);
                console.log(`??: prnt ${ordinalToArray(block.ordinal)}`);
            }
        }
    }
    nodeUpdateOrdinals(block) {
        if (MergeTree.traceOrdinals) {
            console.log(`update ordinals for children of node with ordinal ${ordinalToArray(block.ordinal)}`);
        }
        let clockStart;
        if (MergeTree.options.measureOrdinalTime) {
            clockStart = clock();
        }
        for (let i = 0; i < block.childCount; i++) {
            let child = block.children[i];
            block.setOrdinal(child, i);
            if (!child.isLeaf()) {
                this.nodeUpdateOrdinals(child);
            }
        }
        if (MergeTree.options.measureOrdinalTime) {
            let elapsed = elapsedMicroseconds(clockStart);
            if (elapsed > this.maxOrdTime) {
                this.maxOrdTime = elapsed;
            }
            this.ordTime += elapsed;
        }
    }
    addOverlappingClient(removalInfo, clientId) {
        if (!removalInfo.removedClientOverlap) {
            removalInfo.removedClientOverlap = [];
        }
        if (MergeTree.diagOverlappingRemove) {
            console.log(`added cli ${glc(this, clientId)} to rseq: ${removalInfo.removedSeq}`);
        }
        removalInfo.removedClientOverlap.push(clientId);
    }
    annotateRange(props, start, end, refSeq, clientId, seq, combiningOp, opArgs) {
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        const annotatedSegments = [];
        let annotateSegment = (segment) => {
            let segType = segment.getType();
            if ((segType == SegmentType.Marker) || (segType == SegmentType.Text)) {
                annotatedSegments.push(segment);
                segment.addProperties(props, combiningOp, seq);
                if (this.markerModifiedHandler && (segType === SegmentType.Marker) && (seq !== UnassignedSequenceNumber)) {
                    this.markerModifiedHandler(segment);
                }
            }
            return true;
        };
        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                mergeTreeClientId: clientId,
                operation: 2 /* ANNOTATE */,
                mergeTree: this,
                segments: annotatedSegments
            });
        }
    }
    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        let segmentGroup;
        const removedSegments = [];
        let savedLocalRefs = [];
        let markRemoved = (segment, pos, start, end) => {
            let branchId = this.getBranchId(clientId);
            let segBranchId = this.getBranchId(segment.clientId);
            for (let brid = branchId; brid <= this.localBranchId; brid++) {
                let removalInfo = this.getRemovalInfo(brid, segBranchId, segment);
                if (removalInfo.removedSeq != undefined) {
                    if (MergeTree.diagOverlappingRemove) {
                        console.log(`yump @seq ${seq} cli ${glc(this, this.collabWindow.clientId)}: overlaps deleted segment ${removalInfo.removedSeq} text '${segment.toString()}'`);
                    }
                    overwrite = true;
                    if (removalInfo.removedSeq === UnassignedSequenceNumber) {
                        // will only happen on local branch (brid === this.localBranchId)
                        // replace because comes later
                        removalInfo.removedClientId = clientId;
                        removalInfo.removedSeq = seq;
                    }
                    else {
                        // do not replace earlier sequence number for remove
                        this.addOverlappingClient(removalInfo, clientId);
                    }
                }
                else {
                    removalInfo.removedClientId = clientId;
                    removalInfo.removedSeq = seq;
                    removedSegments.push(segment);
                    if (segment.localRefs && (brid === this.localBranchId)) {
                        savedLocalRefs.push(segment.localRefs);
                        segment.localRefs = undefined;
                    }
                }
            }
            // save segment so can assign removed sequence number when acked by server
            if (this.collabWindow.collaborating) {
                // report segment if client interested
                if (this.markerModifiedHandler && (segment.getType() === SegmentType.Marker) && (seq !== UnassignedSequenceNumber)) {
                    this.markerModifiedHandler(segment);
                }
                // use removal information
                let removalInfo = this.getRemovalInfo(this.localBranchId, segBranchId, segment);
                if ((removalInfo.removedSeq === UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
                //console.log(`saved local removed seg with text: ${textSegment.text}`);
            }
            return true;
        };
        let afterMarkRemoved = (node, pos, start, end) => {
            if (overwrite) {
                this.nodeUpdateLengthNewStructure(node);
            }
            else {
                this.blockUpdateLength(node, seq, clientId);
            }
            return true;
        };
        // MergeTree.traceTraversal = true;
        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);
        if (savedLocalRefs.length > 0) {
            let afterSeg;
            for (let segSavedRefs of savedLocalRefs) {
                for (let localRef of segSavedRefs) {
                    if (localRef.refType && (localRef.refType & _ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].SlideOnRemove)) {
                        if (!afterSeg) {
                            let afterSegOff = this.getContainingSegment(start, refSeq, clientId);
                            afterSeg = afterSegOff.segment;
                        }
                        if (afterSeg) {
                            localRef.segment = afterSeg;
                            localRef.offset = 0;
                            afterSeg.addLocalRef(localRef);
                        }
                    }
                }
            }
            if (afterSeg) {
                this.blockUpdatePathLengths(afterSeg.parent, TreeMaintenanceSequenceNumber, LocalClientId);
            }
        }
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                mergeTreeClientId: clientId,
                operation: 1 /* REMOVE */,
                mergeTree: this,
                segments: removedSegments
            });
        }
        if (this.collabWindow.collaborating && (seq != UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
        // MergeTree.traceTraversal = false;
    }
    // This method is deprecated should not be used. It modifies existing segments.
    removeRange(start, end, refSeq, clientId) {
        let removeInfo = {};
        this.nodeRemoveRange(this.root, start, end, refSeq, clientId, removeInfo);
        if (removeInfo.highestBlockRemovingChildren) {
            let remBlock = removeInfo.highestBlockRemovingChildren;
            this.nodeUpdateOrdinals(remBlock);
        }
    }
    nodeRemoveRange(block, start, end, refSeq, clientId, removeInfo) {
        let children = block.children;
        let startIndex;
        if (start < 0) {
            startIndex = -1;
        }
        let endIndex = block.childCount;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            let child = children[childIndex];
            let len = this.nodeLength(child, refSeq, clientId);
            if ((start >= 0) && (start < len)) {
                startIndex = childIndex;
                if (!child.isLeaf()) {
                    this.nodeRemoveRange(child, start, end, refSeq, clientId, removeInfo);
                }
                else {
                    let segment = child;
                    if (segment.removeRange(start, end)) {
                        startIndex--;
                    }
                }
            }
            // REVIEW: run this clause even if above clause runs
            if (end < len) {
                endIndex = childIndex;
                if (end > 0) {
                    if (endIndex > startIndex) {
                        if (!child.isLeaf()) {
                            this.nodeRemoveRange(child, start, end, refSeq, clientId, removeInfo);
                        }
                        else {
                            let segment = child;
                            if (segment.removeRange(0, end)) {
                                endIndex++;
                            }
                        }
                    }
                }
                break;
            }
            start -= len;
            end -= len;
        }
        let deleteCount = (endIndex - startIndex) - 1;
        let deleteStart = startIndex + 1;
        if (deleteCount > 0) {
            // delete nodes in middle of range
            let copyStart = deleteStart + deleteCount;
            let copyCount = block.childCount - copyStart;
            for (let j = 0; j < copyCount; j++) {
                block.assignChild(children[copyStart + j], deleteStart + j, false);
            }
            block.childCount -= deleteCount;
            if (removeInfo.highestBlockRemovingChildren && removeInfo.highestBlockRemovingChildren.parent &&
                (removeInfo.highestBlockRemovingChildren.parent === block.parent)) {
                removeInfo.highestBlockRemovingChildren = block.parent;
            }
            else {
                removeInfo.highestBlockRemovingChildren = block;
            }
        }
        this.nodeUpdateLengthNewStructure(block);
    }
    nodeUpdateLengthNewStructure(node, recur = false) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating) {
            node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow, recur);
        }
    }
    removeLocalReference(segment, lref) {
        let removedRef = segment.removeLocalRef(lref);
        if (removedRef) {
            this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);
        }
    }
    addLocalReference(lref) {
        let segment = lref.segment;
        segment.addLocalRef(lref);
        this.blockUpdatePathLengths(segment.parent, TreeMaintenanceSequenceNumber, LocalClientId);
    }
    blockUpdate(block) {
        let len = 0;
        let hierBlock;
        if (this.blockUpdateMarkers) {
            hierBlock = block.hierBlock();
            hierBlock.rightmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
            hierBlock.leftmostTiles = _properties__WEBPACK_IMPORTED_MODULE_2__["createMap"]();
            hierBlock.rangeStacks = {};
        }
        for (let i = 0; i < block.childCount; i++) {
            let child = block.children[i];
            len += nodeTotalLength(this, child);
            if (this.blockUpdateMarkers) {
                hierBlock.addNodeReferences(this, child);
            }
            if (this.blockUpdateActions) {
                this.blockUpdateActions.child(block, i);
            }
        }
        block.cachedLength = len;
    }
    blockUpdatePathLengths(block, seq, clientId, newStructure = false) {
        while (block !== undefined) {
            if (newStructure) {
                this.nodeUpdateLengthNewStructure(block);
            }
            else {
                this.blockUpdateLength(block, seq, clientId);
            }
            block = block.parent;
        }
    }
    blockUpdateLength(node, seq, clientId) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating && (seq != UnassignedSequenceNumber) && (seq != TreeMaintenanceSequenceNumber)) {
            if (node.partialLengths !== undefined) {
                if (MergeTree.options.incrementalUpdate) {
                    node.partialLengths.update(this, node, seq, clientId, this.collabWindow);
                }
                else {
                    node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);
                }
            }
            else {
                node.partialLengths = PartialSequenceLengths.combine(this, node, this.collabWindow);
            }
        }
    }
    map(actions, refSeq, clientId, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);
    }
    mapRange(actions, refSeq, clientId, accum, start, end) {
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);
    }
    rangeToString(start, end) {
        let strbuf = "";
        for (let childIndex = 0; childIndex < this.root.childCount; childIndex++) {
            let child = this.root.children[childIndex];
            if (!child.isLeaf()) {
                let block = child;
                let len = this.blockLength(block, UniversalSequenceNumber, this.collabWindow.clientId);
                if ((start <= len) && (end > 0)) {
                    strbuf += this.nodeToString(block, strbuf, 0);
                }
                start -= len;
                end -= len;
            }
        }
        return strbuf;
    }
    nodeToString(block, strbuf, indentCount = 0) {
        strbuf += internedSpaces(indentCount);
        strbuf += `Node (len ${block.cachedLength}) p len (${block.parent ? block.parent.cachedLength : 0}) ord ${ordinalToArray(block.ordinal)} with ${block.childCount} segs:\n`;
        if (this.blockUpdateMarkers) {
            strbuf += internedSpaces(indentCount);
            strbuf += block.hierToString(indentCount);
        }
        if (this.collabWindow.collaborating) {
            strbuf += internedSpaces(indentCount);
            strbuf += block.partialLengths.toString((id) => glc(this, id), indentCount) + '\n';
        }
        let children = block.children;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            let child = children[childIndex];
            if (!child.isLeaf()) {
                strbuf = this.nodeToString(child, strbuf, indentCount + 4);
            }
            else {
                let segment = child;
                strbuf += internedSpaces(indentCount + 4);
                strbuf += `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} ord: ${ordinalToArray(segment.ordinal)}`;
                let segBranchId = this.getBranchId(segment.clientId);
                let branchId = this.localBranchId;
                let removalInfo = this.getRemovalInfo(branchId, segBranchId, segment);
                if (removalInfo.removedSeq !== undefined) {
                    strbuf += ` rcli: ${glc(this, removalInfo.removedClientId)} rseq: ${removalInfo.removedSeq}`;
                }
                strbuf += "\n";
                strbuf += internedSpaces(indentCount + 4);
                strbuf += segment.toString();
                strbuf += "\n";
            }
        }
        return strbuf;
    }
    toString() {
        return this.nodeToString(this.root, "", 0);
    }
    incrementalBlockMap(stateStack) {
        while (!stateStack.empty()) {
            let state = stateStack.top();
            if (state.op != IncrementalExecOp.Go) {
                return;
            }
            if (state.childIndex == 0) {
                if (state.start === undefined) {
                    state.start = 0;
                }
                if (state.end === undefined) {
                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);
                }
                if (state.actions.pre) {
                    state.actions.pre(state);
                }
            }
            if ((state.op == IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {
                let child = state.block.children[state.childIndex];
                let len = this.nodeLength(child, state.refSeq, state.clientId);
                if (MergeTree.traceIncrTraversal) {
                    if (child.isLeaf()) {
                        console.log(`considering (r ${state.refSeq} c ${glc(this, state.clientId)}) seg with text ${child.text} len ${len} seq ${child.seq} rseq ${child.removedSeq} cli ${glc(this, child.clientId)}`);
                    }
                }
                if ((len > 0) && (state.start < len) && (state.end > 0)) {
                    if (!child.isLeaf()) {
                        let childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);
                        stateStack.push(childState);
                    }
                    else {
                        if (MergeTree.traceIncrTraversal) {
                            console.log(`action on seg with text ${child.text}`);
                        }
                        state.actions.leaf(child, state);
                    }
                }
                state.pos += len;
                state.start -= len;
                state.end -= len;
                state.childIndex++;
            }
            else {
                if (state.childIndex == state.block.childCount) {
                    if ((state.op == IncrementalExecOp.Go) && state.actions.post) {
                        state.actions.post(state);
                    }
                    stateStack.pop();
                }
            }
        }
    }
    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {
        if (start === undefined) {
            start = 0;
        }
        if (end === undefined) {
            end = this.blockLength(node, refSeq, clientId);
        }
        let go = true;
        if (actions.pre) {
            go = actions.pre(node, pos, refSeq, clientId, start, end, accum);
            if (!go) {
                // cancel this node but not entire traversal
                return true;
            }
        }
        let children = node.children;
        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {
            let child = children[childIndex];
            let len = this.nodeLength(child, refSeq, clientId);
            if (MergeTree.traceTraversal) {
                let segInfo;
                if ((!child.isLeaf()) && this.collabWindow.collaborating) {
                    segInfo = `minLength: ${child.partialLengths.minLength}`;
                }
                else {
                    let segment = child;
                    segInfo = `cli: ${glc(this, segment.clientId)} seq: ${segment.seq} text: '${segment.toString()}'`;
                    if (segment.removedSeq !== undefined) {
                        segInfo += ` rcli: ${glc(this, segment.removedClientId)} rseq: ${segment.removedSeq}`;
                    }
                }
                console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map len: ${len} start: ${start} end: ${end} ` + segInfo);
            }
            let isLeaf = child.isLeaf();
            if (go && (end > 0) && (len > 0) && (start < len)) {
                // found entry containing pos
                if (!isLeaf) {
                    if (go) {
                        go = this.nodeMap(child, actions, pos, refSeq, clientId, accum, start, end);
                    }
                }
                else {
                    if (MergeTree.traceTraversal) {
                        console.log(`@tcli ${glc(this, this.collabWindow.clientId)}: map leaf action`);
                    }
                    go = actions.leaf(child, pos, refSeq, clientId, start, end, accum);
                }
            }
            if (!go) {
                break;
            }
            if (actions.shift) {
                actions.shift(child, pos, refSeq, clientId, start, end, accum);
            }
            pos += len;
            start -= len;
            end -= len;
        }
        if (go && actions.post) {
            go = actions.post(node, pos, refSeq, clientId, start, end, accum);
        }
        return go;
    }
    // straight call every segment; goes until leaf action returns false
    nodeMapReverse(block, actions, pos, refSeq, clientId, accum) {
        let go = true;
        let children = block.children;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            let child = children[childIndex];
            let isLeaf = child.isLeaf();
            if (go) {
                // found entry containing pos
                if (!isLeaf) {
                    if (go) {
                        go = this.nodeMapReverse(child, actions, pos, refSeq, clientId, accum);
                    }
                }
                else {
                    go = actions.leaf(child, pos, refSeq, clientId, 0, 0, accum);
                }
            }
            if (!go) {
                break;
            }
        }
        return go;
    }
}
// must be an even number
MergeTree.TextSegmentGranularity = 128;
MergeTree.zamboniSegmentsMaxCount = 2;
MergeTree.options = {
    incrementalUpdate: true,
    zamboniSegments: true,
    measureWindowTime: true,
    measureOrdinalTime: true,
};
MergeTree.searchChunkSize = 256;
MergeTree.traceAppend = false;
MergeTree.traceZRemove = false;
MergeTree.traceOrdinals = false;
MergeTree.traceGatherText = false;
MergeTree.diagInsertTie = false;
MergeTree.skipLeftShift = true;
MergeTree.diagOverlappingRemove = false;
MergeTree.traceTraversal = false;
MergeTree.traceIncrTraversal = false;
MergeTree.theUnfinishedNode = { childCount: -1 };
//# sourceMappingURL=mergeTree.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/ops.js":
/*!****************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/ops.js ***!
  \****************************************************/
/*! exports provided: ReferenceType, IntervalType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReferenceType", function() { return ReferenceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalType", function() { return IntervalType; });
// tslint:disable:no-bitwise
// tslint:disable:ban-types
var ReferenceType;
(function (ReferenceType) {
    ReferenceType[ReferenceType["Simple"] = 0] = "Simple";
    ReferenceType[ReferenceType["Tile"] = 1] = "Tile";
    ReferenceType[ReferenceType["NestBegin"] = 2] = "NestBegin";
    ReferenceType[ReferenceType["NestEnd"] = 4] = "NestEnd";
    ReferenceType[ReferenceType["RangeBegin"] = 16] = "RangeBegin";
    ReferenceType[ReferenceType["RangeEnd"] = 32] = "RangeEnd";
    ReferenceType[ReferenceType["SlideOnRemove"] = 64] = "SlideOnRemove";
    ReferenceType[ReferenceType["Transient"] = 256] = "Transient";
})(ReferenceType || (ReferenceType = {}));
var IntervalType;
(function (IntervalType) {
    IntervalType[IntervalType["Simple"] = 0] = "Simple";
    IntervalType[IntervalType["Nest"] = 1] = "Nest";
    IntervalType[IntervalType["SlideOnRemove"] = 2] = "SlideOnRemove";
    IntervalType[IntervalType["Transient"] = 4] = "Transient";
})(IntervalType || (IntervalType = {}));
//# sourceMappingURL=ops.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/properties.js":
/*!***********************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/properties.js ***!
  \***********************************************************/
/*! exports provided: combine, matchProperties, extend, addProperties, extendIfUndefined, createMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return combine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchProperties", function() { return matchProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProperties", function() { return addProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendIfUndefined", function() { return extendIfUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMap", function() { return createMap; });
function combine(combiningInfo, currentValue, newValue, seq) {
    if (currentValue === undefined) {
        currentValue = combiningInfo.defaultValue;
    }
    // fixed set of operations for now
    switch (combiningInfo.name) {
        case "incr":
            currentValue += newValue;
            if (combiningInfo.minValue) {
                if (currentValue < combiningInfo.minValue) {
                    currentValue = combiningInfo.minValue;
                }
            }
            break;
        case "consensus":
            if (currentValue === undefined) {
                currentValue = {
                    value: newValue,
                    seq
                };
            }
            else {
                let cv = currentValue;
                if (cv.seq === -1) {
                    cv.seq = seq;
                }
            }
            break;
    }
    return currentValue;
}
function matchProperties(a, b) {
    if (a) {
        if (!b) {
            return false;
        }
        else {
            // for now, straightforward; later use hashing
            for (let key in a) {
                if (b[key] === undefined) {
                    return false;
                }
                else if (b[key] !== a[key]) {
                    return false;
                }
            }
            for (let key in b) {
                if (a[key] === undefined) {
                    return false;
                }
            }
        }
    }
    else {
        if (b) {
            return false;
        }
    }
    return true;
}
function extend(base, extension, combiningOp, seq) {
    if (extension !== undefined) {
        if ((typeof extension !== "object")) {
            console.log(`oh my ${extension}`);
        }
        for (let key in extension) {
            let v = extension[key];
            if (v === null) {
                delete base[key];
            }
            else {
                if (combiningOp && (combiningOp.name !== "rewrite")) {
                    base[key] = combine(combiningOp, base[key], v, seq);
                }
                else {
                    base[key] = v;
                }
            }
        }
    }
    return base;
}
function addProperties(oldProps, newProps, op, seq) {
    if ((!oldProps) || (op && (op.name === "rewrite"))) {
        oldProps = createMap();
    }
    extend(oldProps, newProps, op, seq);
    return oldProps;
}
function extendIfUndefined(base, extension) {
    if (extension !== undefined) {
        if ((typeof extension !== "object")) {
            console.log(`oh my ${extension}`);
        }
        for (let key in extension) {
            if (base[key] === undefined) {
                base[key] = extension[key];
            }
        }
    }
    return base;
}
/** Create a MapLike with good performance. */
function createMap() {
    const map = Object.create(null); // tslint:disable-line:no-null-keyword
    // Using 'delete' on an object causes V8 to put the object in dictionary mode.
    // This disables creation of hidden classes, which are expensive when an object is
    // constantly changing shape.
    map["__"] = undefined;
    delete map["__"];
    return map;
}
//# sourceMappingURL=properties.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/segmentGroupCollection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/segmentGroupCollection.js ***!
  \***********************************************************************/
/*! exports provided: SegmentGroupCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentGroupCollection", function() { return SegmentGroupCollection; });
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collections */ "./node_modules/@prague/merge-tree/lib/collections.js");

class SegmentGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.segmentGroups = Object(_collections__WEBPACK_IMPORTED_MODULE_0__["ListMakeHead"])();
    }
    get size() {
        return this.segmentGroups.count();
    }
    get empty() {
        return this.segmentGroups.empty();
    }
    enqueue(segmentGroup) {
        this.segmentGroups.enqueue(segmentGroup);
        segmentGroup.segments.push(this.segment);
    }
    dequeue() {
        return this.segmentGroups.dequeue();
    }
    clear() {
        this.segmentGroups.clear();
    }
    copyTo(segment) {
        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));
    }
}
//# sourceMappingURL=segmentGroupCollection.js.map

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/snapshot.js":
/*!*********************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/snapshot.js ***!
  \*********************************************************/
/*! exports provided: Snapshot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Snapshot", function() { return Snapshot; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeTree */ "./node_modules/@prague/merge-tree/lib/mergeTree.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class Snapshot {
    constructor(mergeTree, filename, onCompletion) {
        this.mergeTree = mergeTree;
        this.filename = filename;
        this.onCompletion = onCompletion;
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        let segs = [];
        let sequenceLength = 0;
        let segCount = 0;
        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {
            let pseg = allSegments[startIndex + segCount];
            segCount++;
            segs.push(pseg);
            sequenceLength += allLengths[startIndex + segCount];
        }
        return {
            chunkStartSegmentIndex: startIndex,
            chunkSegmentCount: segCount,
            chunkLengthChars: sequenceLength,
            totalLengthChars: this.header.segmentsTotalLength,
            totalSegmentCount: allSegments.length,
            chunkSequenceNumber: this.header.seq,
            segmentTexts: segs
        };
    }
    emit() {
        let chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, 10000);
        let chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, chunk1.totalLengthChars, chunk1.chunkSegmentCount);
        const tree = {
            entries: [
                {
                    mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"].File,
                    path: "header",
                    type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob],
                    value: {
                        contents: JSON.stringify(chunk1),
                        encoding: "utf-8",
                    },
                },
                {
                    mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"].File,
                    path: "body",
                    type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob],
                    value: {
                        contents: JSON.stringify(chunk2),
                        encoding: "utf-8",
                    },
                },
            ],
            sha: null,
        };
        return tree;
    }
    extractSync() {
        let collabWindow = this.mergeTree.getCollabWindow();
        this.seq = collabWindow.minSeq;
        this.header = {
            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, _mergeTree__WEBPACK_IMPORTED_MODULE_1__["NonCollabClient"]),
            seq: this.mergeTree.collabWindow.minSeq,
        };
        let segs = [];
        let segLengths = [];
        let extractSegment = (segment, pos, refSeq, clientId, start, end) => {
            if ((segment.seq != _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"]) && (segment.seq <= this.seq) &&
                ((segment.removedSeq === undefined) || (segment.removedSeq == _mergeTree__WEBPACK_IMPORTED_MODULE_1__["UnassignedSequenceNumber"]) ||
                    (segment.removedSeq > this.seq))) {
                segs.push(segment.toJSONObject());
                segLengths.push(segment.cachedLength);
            }
            return true;
        };
        this.mergeTree.map({ leaf: extractSegment }, this.seq, _mergeTree__WEBPACK_IMPORTED_MODULE_1__["NonCollabClient"]);
        this.segments = segs;
        this.segmentLengths = segLengths;
        return segs;
    }
    static loadChunk(storage, path) {
        return __awaiter(this, void 0, void 0, function* () {
            let chunkAsString = yield storage.read(path);
            return Snapshot.processChunk(chunkAsString);
        });
    }
    static processChunk(chunk) {
        return JSON.parse(Buffer.from(chunk, "base64").toString("utf-8"));
    }
}
Snapshot.SnapChunkMaxSize = 0x20000;
Snapshot.SegmentLengthSize = 0x4;
Snapshot.SnapshotHeaderSize = 0x14;
Snapshot.EmptyChunk = {
    chunkStartSegmentIndex: -1,
    chunkSegmentCount: -1,
    chunkLengthChars: -1,
    totalLengthChars: -1,
    totalSegmentCount: -1,
    chunkSequenceNumber: 0,
    segmentTexts: [],
};
//# sourceMappingURL=snapshot.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/merge-tree/lib/text.js":
/*!*****************************************************!*\
  !*** ./node_modules/@prague/merge-tree/lib/text.js ***!
  \*****************************************************/
/*! exports provided: loadSegments, loadText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadSegments", function() { return loadSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadText", function() { return loadText; });
/* harmony import */ var _mergeTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeTree */ "./node_modules/@prague/merge-tree/lib/mergeTree.js");
/* harmony import */ var _ops__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ops */ "./node_modules/@prague/merge-tree/lib/ops.js");


function loadSegments(content, segLimit, markers = false, withProps = true) {
    // tslint:disable-next-line:no-parameter-reassignment
    content = content.replace(/^\uFEFF/, "");
    const seq = _mergeTree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"];
    const cli = _mergeTree__WEBPACK_IMPORTED_MODULE_0__["LocalClientId"];
    const paragraphs = content.split("\r\n");
    // tslint:disable-next-line:no-increment-decrement
    for (let i = 0, len = paragraphs.length; i < len; i++) {
        paragraphs[i] = paragraphs[i]
            .replace(/\r\n/g, " ")
            .replace(/\u201c|\u201d/g, '"')
            .replace(/\u2019/g, "'");
        if (!markers && i !== paragraphs.length - 1) {
            paragraphs[i] += "\n";
        }
    }
    const segments = [];
    for (const paragraph of paragraphs) {
        let pgMarker;
        if (markers) {
            pgMarker = _mergeTree__WEBPACK_IMPORTED_MODULE_0__["Marker"].make(_ops__WEBPACK_IMPORTED_MODULE_1__["ReferenceType"].Tile, { [_mergeTree__WEBPACK_IMPORTED_MODULE_0__["reservedTileLabelsKey"]]: ["pg"] }, seq, cli);
        }
        if (withProps) {
            if ((paragraph.indexOf("Chapter") >= 0) || (paragraph.indexOf("PRIDE AND PREJ") >= 0)) {
                if (markers) {
                    pgMarker.addProperties({ header: 2 });
                    segments.push(new _mergeTree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"](paragraph, seq, cli));
                }
                else {
                    segments.push(_mergeTree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"].make(paragraph, { fontSize: "140%", lineHeight: "150%" }, seq, cli));
                }
            }
            else {
                const emphStrings = paragraph.split("_");
                // tslint:disable-next-line:no-increment-decrement
                for (let i = 0, len = emphStrings.length; i < len; i++) {
                    // tslint:disable-next-line:no-bitwise
                    if (i & 1) {
                        if (emphStrings[i].length > 0) {
                            segments.push(_mergeTree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"].make(emphStrings[i], { fontStyle: "italic" }, seq, cli));
                        }
                    }
                    else {
                        if (emphStrings[i].length > 0) {
                            segments.push(new _mergeTree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"](emphStrings[i], seq, cli));
                        }
                    }
                }
            }
        }
        else {
            segments.push(new _mergeTree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"](paragraph, seq, cli));
        }
        if (markers) {
            segments.push(pgMarker);
        }
    }
    if (segLimit > 0) {
        segments.length = segLimit;
    }
    return segments;
}
function loadText(content, mergeTree, segLimit, markers = false) {
    const segments = loadSegments(content, segLimit, markers);
    mergeTree.reloadFromSegments(segments);
    // console.log(`Number of Segments: ${segments.length}`);
    // console.log(`Height: ${mergeTree.getStats().maxHeight}`);
    // console.log(segTree.toString());
    return mergeTree;
}
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/componentRuntime.js":
/*!***************************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/componentRuntime.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
// tslint:disable:no-unsafe-any
class ComponentRuntime extends events_1.EventEmitter {
    constructor(hostRuntime, pkg, id, existing, chaincode, storage, baseSnapshot) {
        super();
        this.hostRuntime = hostRuntime;
        this.pkg = pkg;
        this.id = id;
        this.existing = existing;
        this.chaincode = chaincode;
        this.storage = storage;
        this.baseSnapshot = baseSnapshot;
        this.closed = false;
        // Tracks the base snapshot hash. If no ops effect this component then the sha value can be returned on a
        // snapshot call
        this.baseSha = null;
        this.baseSha = baseSnapshot ? baseSnapshot.sha : null;
    }
    static create(hostRuntime, id, pkg, storage) {
        return __awaiter(this, void 0, void 0, function* () {
            const factory = yield hostRuntime.getPackage(pkg);
            const extension = yield factory.instantiateComponent();
            const component = new ComponentRuntime(hostRuntime, pkg, id, false, extension, storage, null);
            return component;
        });
    }
    static LoadFromSnapshot(hostRuntime, id, pkg, storage, channels) {
        return __awaiter(this, void 0, void 0, function* () {
            const factory = yield hostRuntime.getPackage(pkg);
            const extension = yield factory.instantiateComponent();
            const component = new ComponentRuntime(hostRuntime, pkg, id, true, extension, storage, channels);
            return component;
        });
    }
    get tenantId() {
        return this.hostRuntime.tenantId;
    }
    get documentId() {
        return this.hostRuntime.id;
    }
    get parentBranch() {
        return this.hostRuntime.parentBranch;
    }
    get options() {
        return this.hostRuntime.options;
    }
    get clientId() {
        return this.hostRuntime.clientId;
    }
    get blobManager() {
        return this.hostRuntime.blobManager;
    }
    get deltaManager() {
        return this.hostRuntime.deltaManager;
    }
    get connected() {
        return this.hostRuntime.connected;
    }
    get connectionState() {
        return this.hostRuntime.connectionState;
    }
    get submitFn() {
        return this.hostRuntime.submitFn;
    }
    get snapshotFn() {
        return this.hostRuntime.snapshotFn;
    }
    get closeFn() {
        return this.hostRuntime.closeFn;
    }
    get branch() {
        return this.hostRuntime.branch;
    }
    createAndAttachComponent(id, pkg) {
        return this.hostRuntime.createAndAttachComponent(id, pkg);
    }
    getComponent(id, wait) {
        return this.hostRuntime.getComponent(id, wait);
    }
    changeConnectionState(value, clientId) {
        this.verifyNotClosed();
        this.handler.changeConnectionState(value, clientId);
    }
    // Called after a snapshot to update the base sha
    updateBaseSha(sha) {
        this.baseSha = sha;
    }
    prepare(message, local) {
        this.verifyNotClosed();
        return this.handler.prepare(message, local);
    }
    process(message, local, context) {
        this.verifyNotClosed();
        // component has been modified and will need to regenerate its snapshot
        this.baseSha = null;
        return this.handler.process(message, local, context);
    }
    getQuorum() {
        this.verifyNotClosed();
        return this.hostRuntime.getQuorum();
    }
    getBlobMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.blobManager.getBlobMetadata();
        });
    }
    stop() {
        this.verifyNotClosed();
        this.closed = true;
        return this.snapshot();
    }
    close() {
        this.hostRuntime.closeFn();
    }
    updateMinSequenceNumber(msn) {
        this.handler.updateMinSequenceNumber(msn);
    }
    snapshot() {
        const componentAttributes = { pkg: this.pkg };
        const snapshot = this.chaincode.snapshot();
        snapshot.entries.push({
            mode: container_definitions_1.FileMode.File,
            path: ".component",
            type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob],
            value: {
                contents: JSON.stringify(componentAttributes),
                encoding: "utf-8",
            },
        });
        // base sha still being set means previous snapshot is still valid
        if (this.baseSha) {
            snapshot.sha = this.baseSha;
        }
        return snapshot;
    }
    request(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.handler.request(request);
        });
    }
    submitMessage(type, content) {
        return this.submit(type, content);
    }
    error(err) {
        return;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            this.handler = yield this.chaincode.run(this);
        });
    }
    attach(platform) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chaincode.attach(platform);
        });
    }
    submit(type, content) {
        this.verifyNotClosed();
        const envelope = {
            address: this.id,
            contents: {
                content,
                type,
            },
        };
        return this.hostRuntime.submitFn(container_definitions_1.MessageType.Operation, envelope);
    }
    verifyNotClosed() {
        if (this.closed) {
            throw new Error("Runtime is closed");
        }
    }
}
exports.ComponentRuntime = ComponentRuntime;
//# sourceMappingURL=componentRuntime.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/componentStorageService.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/componentStorageService.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class ComponentStorageService {
    constructor(storageService, blobs) {
        this.storageService = storageService;
        this.blobs = blobs;
    }
    get repositoryUrl() {
        return this.storageService.repositoryUrl;
    }
    // TODO Will a subcomponent ever need this? Or we can probably restrict the ref to itself
    getSnapshotTree(version) {
        return this.storageService.getSnapshotTree(version);
    }
    getVersions(sha, count) {
        return this.storageService.getVersions(sha, count);
    }
    getContent(version, path) {
        return this.storageService.getContent(version, path);
    }
    read(sha) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.blobs.has(sha)) {
                return this.blobs.get(sha);
            }
            return this.storageService.read(sha);
        });
    }
    // TODO the write as well potentially doesn't seem necessary
    write(root, parents, message, ref) {
        return this.storageService.write(root, parents, message, ref);
    }
    createBlob(file) {
        return this.storageService.createBlob(file);
    }
    getRawUrl(sha) {
        return this.storageService.getRawUrl(sha);
    }
}
exports.ComponentStorageService = ComponentStorageService;
//# sourceMappingURL=componentStorageService.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/debug.js":
/*!****************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/debug.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const registerDebug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
exports.debug = registerDebug("prague:process-loader");
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./runtime */ "./node_modules/@prague/runtime/dist/runtime.js"));
__export(__webpack_require__(/*! ./webPlatform */ "./node_modules/@prague/runtime/dist/webPlatform.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/leaderElection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/leaderElection.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const debug_1 = __webpack_require__(/*! ./debug */ "./node_modules/@prague/runtime/dist/debug.js");
exports.QuorumKey = "leader";
class LeaderElector extends events_1.EventEmitter {
    constructor(quorum, clientId) {
        super();
        this.quorum = quorum;
        this.clientId = clientId;
        this.attachQuorumListeners();
    }
    proposeLeadership() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.quorum.propose(exports.QuorumKey, this.clientId);
        });
    }
    getLeader() {
        return this.leader;
    }
    attachQuorumListeners() {
        this.quorum.on("approveProposal", (sequenceNumber, key, value) => {
            if (key === exports.QuorumKey) {
                this.leader = value;
                this.emit("newLeader", this.leader);
            }
        });
        this.quorum.on("addProposal", (proposal) => {
            if (proposal.key === exports.QuorumKey) {
                if (this.leader !== undefined) {
                    proposal.reject();
                }
            }
        });
        this.quorum.on("removeMember", (removedClientId) => {
            if (this.leader === undefined || removedClientId === this.leader) {
                this.leader = undefined;
                this.emit("leaderLeft", removedClientId);
            }
            else {
                this.emit("memberLeft", removedClientId);
            }
        });
        this.quorum.on("rejectProposal", (sequenceNumber, key, value) => {
            // Use of 'any' in template literal should be as safe as ("" + value) coercion.
            // tslint:disable-next-line:no-unsafe-any
            debug_1.debug(`Proposal rejected @${sequenceNumber}. ${key}:${value}`);
        });
    }
}
exports.LeaderElector = LeaderElector;
//# sourceMappingURL=leaderElection.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/runtime.js":
/*!******************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/runtime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
const utils_1 = __webpack_require__(/*! @prague/utils */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/index.js");
const assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const componentRuntime_1 = __webpack_require__(/*! ./componentRuntime */ "./node_modules/@prague/runtime/dist/componentRuntime.js");
const componentStorageService_1 = __webpack_require__(/*! ./componentStorageService */ "./node_modules/@prague/runtime/dist/componentStorageService.js");
const debug_1 = __webpack_require__(/*! ./debug */ "./node_modules/@prague/runtime/dist/debug.js");
const leaderElection_1 = __webpack_require__(/*! ./leaderElection */ "./node_modules/@prague/runtime/dist/leaderElection.js");
const taskAnalyzer_1 = __webpack_require__(/*! ./taskAnalyzer */ "./node_modules/@prague/runtime/dist/taskAnalyzer.js");
// Context will define the component level mappings
class Runtime extends events_1.EventEmitter {
    constructor(registry, context) {
        super();
        this.registry = registry;
        this.context = context;
        this.tasks = [];
        // Components tracked by the Domain
        this.components = new Map();
        this.componentsDeferred = new Map();
        this.closed = false;
        this.pendingAttach = new Map();
        this.lastMinSequenceNumber = context.minimumSequenceNumber;
    }
    static Load(registry, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const runtime = new Runtime(registry, context);
            const components = new Map();
            const snapshotTreesP = Object.keys(context.baseSnapshot.commits).map((key) => __awaiter(this, void 0, void 0, function* () {
                const moduleSha = context.baseSnapshot.commits[key];
                const commit = (yield context.storage.getVersions(moduleSha, 1))[0];
                const moduleTree = yield context.storage.getSnapshotTree(commit);
                return { id: key, tree: moduleTree };
            }));
            const snapshotTree = yield Promise.all(snapshotTreesP);
            for (const value of snapshotTree) {
                components.set(value.id, value.tree);
            }
            const componentsP = new Array();
            for (const [componentId, snapshot] of components) {
                const componentP = runtime.loadComponent(componentId, snapshot, context.blobs);
                componentsP.push(componentP);
            }
            yield Promise.all(componentsP);
            return runtime;
        });
    }
    get connectionState() {
        return this.context.connectionState;
    }
    get tenantId() {
        return this.context.tenantId;
    }
    get id() {
        return this.context.id;
    }
    get parentBranch() {
        return this.context.parentBranch;
    }
    get existing() {
        return this.context.existing;
    }
    // tslint:disable-next-line:no-unsafe-any
    get options() {
        return this.context.options;
    }
    get clientId() {
        return this.context.clientId;
    }
    get blobManager() {
        return this.context.blobManager;
    }
    get deltaManager() {
        return this.context.deltaManager;
    }
    get storage() {
        return this.context.storage;
    }
    get branch() {
        return this.context.branch;
    }
    get minimumSequenceNumber() {
        return this.context.minimumSequenceNumber;
    }
    get submitFn() {
        return this.context.submitFn;
    }
    get snapshotFn() {
        return this.context.snapshotFn;
    }
    get closeFn() {
        return this.context.closeFn;
    }
    get connected() {
        return this.connectionState === container_definitions_1.ConnectionState.Connected;
    }
    loadComponent(id, snapshotTree, extraBlobs) {
        return __awaiter(this, void 0, void 0, function* () {
            // Need to rip through snapshot and use that to populate extraBlobs
            const runtimeStorage = new componentStorageService_1.ComponentStorageService(this.storage, extraBlobs);
            const details = yield utils_1.readAndParse(this.storage, snapshotTree.blobs[".component"]);
            const componentP = componentRuntime_1.ComponentRuntime.LoadFromSnapshot(this, id, details.pkg, runtimeStorage, snapshotTree);
            const deferred = new utils_1.Deferred();
            deferred.resolve(componentP);
            this.componentsDeferred.set(id, deferred);
            const component = yield componentP;
            this.components.set(id, component);
            yield component.start();
        });
    }
    registerRequestHandler(handler) {
        this.requestHandler = handler;
    }
    getPackage(name) {
        return this.registry.get(name);
    }
    request(request) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.requestHandler) {
                return { status: 404, mimeType: "text/plain", value: `${request.url} not found` };
            }
            else {
                return this.requestHandler(request);
            }
        });
    }
    snapshot(tagMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            // Pull in the prior version and snapshot tree to store against
            const lastVersion = yield this.storage.getVersions(this.id, 1);
            const tree = lastVersion.length > 0
                ? yield this.storage.getSnapshotTree(lastVersion[0])
                : { blobs: {}, commits: {}, trees: {} };
            // Iterate over each component and ask it to snapshot
            const channelEntries = new Map();
            this.components.forEach((component, key) => channelEntries.set(key, component.snapshot()));
            // Use base tree to know previous component snapshot and then snapshot each component
            const channelCommitsP = new Array();
            for (const [channelId, channelSnapshot] of channelEntries) {
                // If sha exists then previous commit is still valid
                if (channelSnapshot.sha) {
                    channelCommitsP.push(Promise.resolve({
                        commit: tree.commits[channelId],
                        id: channelId,
                    }));
                }
                else {
                    const parent = channelId in tree.commits ? [tree.commits[channelId]] : [];
                    const channelCommitP = this.storage
                        .write(channelSnapshot, parent, `${channelId} commit ${tagMessage}`, channelId)
                        .then((commit) => {
                        this.components.get(channelId).updateBaseSha(commit.tree.sha);
                        return { id: channelId, commit: commit.sha };
                    });
                    channelCommitsP.push(channelCommitP);
                }
            }
            const root = { entries: [], sha: null };
            // Add in module references to the component snapshots
            const channelCommits = yield Promise.all(channelCommitsP);
            let gitModules = "";
            for (const channelCommit of channelCommits) {
                root.entries.push({
                    mode: container_definitions_1.FileMode.Commit,
                    path: channelCommit.id,
                    type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Commit],
                    value: channelCommit.commit,
                });
                const repoUrl = "https://github.com/kurtb/praguedocs.git"; // this.storageService.repositoryUrl
                gitModules += `[submodule "${channelCommit.id}"]\n\tpath = ${channelCommit.id}\n\turl = ${repoUrl}\n\n`;
            }
            // Write the module lookup details
            root.entries.push({
                mode: container_definitions_1.FileMode.File,
                path: ".gitmodules",
                type: container_definitions_1.TreeEntry[container_definitions_1.TreeEntry.Blob],
                value: {
                    contents: gitModules,
                    encoding: "utf-8",
                },
            });
            return root;
        });
    }
    requestSnapshot(tagMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.requestSnapshot(tagMessage);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            this.closed = true;
        });
    }
    changeConnectionState(value, clientId) {
        this.verifyNotClosed();
        // Resend all pending attach messages prior to notifying clients
        if (value === container_definitions_1.ConnectionState.Connected) {
            for (const [, message] of this.pendingAttach) {
                this.submit(container_definitions_1.MessageType.Attach, message);
            }
        }
        for (const [, component] of this.components) {
            component.changeConnectionState(value, clientId);
        }
        if (value === container_definitions_1.ConnectionState.Connected) {
            this.emit("connected", this.clientId);
        }
    }
    prepare(message, local) {
        switch (message.type) {
            case container_definitions_1.MessageType.Operation:
                return this.prepareOperation(message, local);
            case container_definitions_1.MessageType.Attach:
                return this.prepareAttach(message, local);
            default:
                return Promise.resolve();
        }
    }
    process(message, local, context) {
        switch (message.type) {
            case container_definitions_1.MessageType.Operation:
                this.processOperation(message, local, context);
                break;
            case container_definitions_1.MessageType.Attach:
                this.processAttach(message, local, context);
                break;
            default:
        }
        this.emit("op", message);
        if (this.lastMinSequenceNumber !== message.minimumSequenceNumber) {
            this.lastMinSequenceNumber = message.minimumSequenceNumber;
            this.updateMinSequenceNumber(message.minimumSequenceNumber);
        }
    }
    postProcess(message, local, context) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (message.type) {
                case container_definitions_1.MessageType.Attach:
                    return this.postProcessAttach(message, local, context);
                default:
            }
        });
    }
    updateMinSequenceNumber(minimumSequenceNumber) {
        for (const [, component] of this.components) {
            component.updateMinSequenceNumber(minimumSequenceNumber);
        }
    }
    getComponent(id, wait = true) {
        this.verifyNotClosed();
        if (!this.componentsDeferred.has(id)) {
            if (!wait) {
                return Promise.reject(`Process ${id} does not exist`);
            }
            // Add in a deferred that will resolve once the process ID arrives
            this.componentsDeferred.set(id, new utils_1.Deferred());
        }
        return this.componentsDeferred.get(id).promise;
    }
    createAndAttachComponent(id, pkg) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            const runtimeStorage = new componentStorageService_1.ComponentStorageService(this.storage, new Map());
            const component = yield componentRuntime_1.ComponentRuntime.create(this, id, pkg, runtimeStorage);
            // Generate the attach message
            const message = {
                id,
                snapshot: null,
                type: pkg,
            };
            this.pendingAttach.set(id, message);
            this.submit(container_definitions_1.MessageType.Attach, message);
            // Start the component
            yield component.start();
            // Store off the component
            this.components.set(id, component);
            // Resolve any pending requests for the component
            if (this.componentsDeferred.has(id)) {
                this.componentsDeferred.get(id).resolve(component);
            }
            else {
                const deferred = new utils_1.Deferred();
                deferred.resolve(component);
                this.componentsDeferred.set(id, deferred);
            }
            return component;
        });
    }
    getQuorum() {
        return this.context.quorum;
    }
    error(error) {
        this.context.error(error);
    }
    registerTasks(tasks, version) {
        this.verifyNotClosed();
        this.tasks = tasks;
        this.version = version;
        this.startLeaderElection();
    }
    submit(type, content) {
        this.verifyNotClosed();
        this.submitFn(type, content);
    }
    verifyNotClosed() {
        if (this.closed) {
            throw new Error("Runtime is closed");
        }
    }
    prepareOperation(message, local) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelope = message.contents;
            const component = this.components.get(envelope.address);
            assert(component);
            const innerContents = envelope.contents;
            const transformed = {
                clientId: message.clientId,
                clientSequenceNumber: message.clientSequenceNumber,
                contents: innerContents.content,
                metadata: message.metadata,
                minimumSequenceNumber: message.minimumSequenceNumber,
                origin: message.origin,
                referenceSequenceNumber: message.referenceSequenceNumber,
                sequenceNumber: message.sequenceNumber,
                timestamp: message.timestamp,
                traces: message.traces,
                type: innerContents.type,
            };
            return component.prepare(transformed, local);
        });
    }
    processOperation(message, local, context) {
        const envelope = message.contents;
        const component = this.components.get(envelope.address);
        assert(component);
        const innerContents = envelope.contents;
        const transformed = {
            clientId: message.clientId,
            clientSequenceNumber: message.clientSequenceNumber,
            contents: innerContents.content,
            metadata: message.metadata,
            minimumSequenceNumber: message.minimumSequenceNumber,
            origin: message.origin,
            referenceSequenceNumber: message.referenceSequenceNumber,
            sequenceNumber: message.sequenceNumber,
            timestamp: message.timestamp,
            traces: message.traces,
            type: innerContents.type,
        };
        component.process(transformed, local, context);
    }
    prepareAttach(message, local) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyNotClosed();
            // the local object has already been attached
            if (local) {
                return;
            }
            const attachMessage = message.contents;
            let snapshotTree = null;
            if (attachMessage.snapshot) {
                const flattened = utils_1.flatten(attachMessage.snapshot.entries, new Map());
                snapshotTree = utils_1.buildHierarchy(flattened);
            }
            // create storage service that wraps the attach data
            const runtimeStorage = new componentStorageService_1.ComponentStorageService(this.storage, new Map());
            const component = yield componentRuntime_1.ComponentRuntime.LoadFromSnapshot(this, attachMessage.id, attachMessage.type, runtimeStorage, snapshotTree);
            return component;
        });
    }
    processAttach(message, local, context) {
        this.verifyNotClosed();
        debug_1.debug("processAttach");
    }
    postProcessAttach(message, local, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const attachMessage = message.contents;
            // If a non-local operation then go and create the object - otherwise mark it as officially attached.
            if (local) {
                assert(this.pendingAttach.has(attachMessage.id));
                this.pendingAttach.delete(attachMessage.id);
            }
            else {
                yield context.start();
                this.components.set(attachMessage.id, context);
                // Resolve pending gets and store off any new ones
                if (this.componentsDeferred.has(attachMessage.id)) {
                    this.componentsDeferred.get(attachMessage.id).resolve(context);
                }
                else {
                    const deferred = new utils_1.Deferred();
                    deferred.resolve(context);
                    this.componentsDeferred.set(attachMessage.id, deferred);
                }
            }
        });
    }
    startLeaderElection() {
        if (this.deltaManager && this.deltaManager.clientType === container_definitions_1.Browser) {
            if (this.connected) {
                this.initLeaderElection();
            }
            else {
                this.once("connected", () => this.initLeaderElection());
            }
        }
    }
    initLeaderElection() {
        this.leaderElector = new leaderElection_1.LeaderElector(this.getQuorum(), this.clientId);
        this.leaderElector.on("newLeader", (clientId) => {
            debug_1.debug(`New leader elected: ${clientId}`);
            this.runTaskAnalyzer();
        });
        this.leaderElector.on("leaderLeft", (clientId) => {
            debug_1.debug(`Leader ${clientId} left`);
            this.proposeLeadership();
        });
        this.leaderElector.on("memberLeft", (clientId) => {
            debug_1.debug(`Member ${clientId} left`);
            this.runTaskAnalyzer();
        });
        this.proposeLeadership();
    }
    proposeLeadership() {
        if (taskAnalyzer_1.getLeaderCandidate(this.getQuorum().getMembers()) === this.clientId) {
            this.leaderElector.proposeLeadership().then(() => {
                debug_1.debug(`Proposal accepted`);
            }, (err) => {
                debug_1.debug(`Proposal rejected: ${err}`);
            });
        }
    }
    /**
     * On a client joining/departure, decide whether this client is the new leader.
     * If so, calculate if there are any unhandled tasks for browsers and remote agents.
     * Emit local help message for this browser and submits a remote help message for agents.
     */
    runTaskAnalyzer() {
        if (this.leaderElector.getLeader() === this.clientId) {
            // Analyze the current state and ask for local and remote help seperately.
            const helpTasks = taskAnalyzer_1.analyzeTasks(this.clientId, this.getQuorum().getMembers(), this.tasks);
            if (helpTasks && (helpTasks.browser.length > 0 || helpTasks.robot.length > 0)) {
                if (helpTasks.browser.length > 0) {
                    const localHelpMessage = {
                        tasks: helpTasks.browser,
                        version: this.version,
                    };
                    console.log(`Requesting local help for ${helpTasks.browser}`);
                    this.emit("localHelp", localHelpMessage);
                }
                if (helpTasks.robot.length > 0) {
                    const remoteHelpMessage = {
                        tasks: helpTasks.robot,
                        version: this.version,
                    };
                    console.log(`Requesting remote help for ${helpTasks.robot}`);
                    this.submit(container_definitions_1.MessageType.RemoteHelp, remoteHelpMessage);
                }
            }
        }
    }
}
exports.Runtime = Runtime;
//# sourceMappingURL=runtime.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/taskAnalyzer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/taskAnalyzer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const container_definitions_1 = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
// For a given list of connected clients and tasks to run, this function calculates need for local & remote help.
// Right now only one client (aka leader) is allowed to run tasks and ask for local and remote.
// To become completely distributed, each client should take into account other client permissions
// and calculate help list. Then each client will pick up work independently and only leader will
// ask for help.
// TODO: Make this run on all clients once services are hardened better.
function analyzeTasks(runnerClientId, clients, tasks) {
    const robotClients = [...clients].filter((client) => isRobot(client[1]));
    const handledTasks = robotClients.map((robot) => robot[1].client.type);
    const unhandledTasks = tasks.filter((task) => handledTasks.indexOf(task) === -1);
    if (unhandledTasks.length > 0) {
        const runnerClient = clients.get(runnerClientId);
        /* tslint:disable:strict-boolean-expressions */
        const permission = runnerClient.client && runnerClient.client.permission ? runnerClient.client.permission : [];
        const allowedTasks = unhandledTasks.filter((task) => permission && permission.indexOf(task) !== -1);
        const robotNeeded = unhandledTasks.filter((task) => permission && permission.indexOf(task) === -1);
        return {
            browser: allowedTasks,
            robot: robotNeeded,
        };
    }
}
exports.analyzeTasks = analyzeTasks;
function getLeaderCandidate(clients) {
    const browserClients = [...clients].filter((client) => !isRobot(client[1]));
    if (browserClients.length > 0) {
        const candidate = browserClients.reduce((prev, curr) => {
            return prev[1].sequenceNumber < curr[1].sequenceNumber ? prev : curr;
        });
        return candidate[0];
    }
}
exports.getLeaderCandidate = getLeaderCandidate;
function isRobot(client) {
    return client.client && client.client.type && client.client.type !== container_definitions_1.Browser;
}
//# sourceMappingURL=taskAnalyzer.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/dist/webPlatform.js":
/*!**********************************************************!*\
  !*** ./node_modules/@prague/runtime/dist/webPlatform.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
class DefinitionGuide extends events_1.EventEmitter {
    constructor() {
        super();
        this.counter = 0;
        this.dts = "";
        setInterval(() => {
            let dts = "declare class Facts {\n";
            for (let i = 0; i < this.counter; i++) {
                dts += `    static next${i}(): string;\n`;
            }
            dts += "}";
            this.dts = dts;
            this.counter++;
            this.emit("definitionsChanged");
        }, 5000);
    }
    getDefinition() {
        return this.dts;
    }
}
class WebPlatform extends events_1.EventEmitter {
    constructor(div) {
        super();
        this.div = div;
        this.definitions = new DefinitionGuide();
    }
    queryInterface(id) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (id) {
                case "dom":
                    return document;
                case "div":
                    return this.div;
                case "dts":
                    return this.definitions;
                default:
                    return null;
            }
        });
    }
    // Temporary measure to indicate the UI changed
    update() {
        this.emit("update");
    }
    detach() {
        return;
    }
}
exports.WebPlatform = WebPlatform;
class WebPlatformFactory {
    constructor(div) {
        this.div = div;
    }
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            return new WebPlatform(this.div);
        });
    }
}
exports.WebPlatformFactory = WebPlatformFactory;
//# sourceMappingURL=webPlatform.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/batchManager.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/batchManager.js ***!
  \*************************************************************************************/
/*! exports provided: BatchManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchManager", function() { return BatchManager; });
const MaxBatchSize = 100;
class BatchManager {
    constructor(process) {
        this.process = process;
        this.pendingWork = new Map();
    }
    add(id, work) {
        if (!this.pendingWork.has(id)) {
            this.pendingWork.set(id, []);
        }
        this.pendingWork.get(id)
            .push(work);
        if (this.pendingWork.get(id).length >= MaxBatchSize) {
            clearTimeout(this.pendingTimer);
            this.pendingTimer = undefined;
            this.startWork();
        }
        else if (this.pendingTimer === undefined) {
            this.pendingTimer = setTimeout(() => {
                this.pendingTimer = undefined;
                this.startWork();
            }, 0);
        }
    }
    /**
     * Resolves once all pending work is complete
     */
    drain() {
        this.startWork();
    }
    startWork() {
        // Clear the internal flags first to avoid issues in case any of the pending work calls back into
        // the batch manager. We could also do this with a second setImmediate call but avodiing in order
        // to process the work quicker.
        const pendingWork = this.pendingWork;
        this.pendingWork = new Map();
        // TODO log to influx how much pending work there is. We want to limit the size of a batch
        for (const [id, batch] of pendingWork) {
            this.process(id, batch);
        }
    }
}
//# sourceMappingURL=batchManager.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/blobs.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/blobs.js ***!
  \******************************************************************************/
/*! exports provided: gitHashFile, flatten, readAndParse, buildHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gitHashFile", function() { return gitHashFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readAndParse", function() { return readAndParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildHierarchy", function() { return buildHierarchy; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sha.js/sha1 */ "./node_modules/sha.js/sha1.js");
/* harmony import */ var sha_js_sha1__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// tslint:disable-next-line:no-submodule-imports

/**
 * Create Hash (Github hashes the string with blob and size)
 * @param file The contents of the file in a buffer
 */
function gitHashFile(file) {
    const size = file.byteLength;
    const filePrefix = "blob " + size.toString() + String.fromCharCode(0);
    /* tslint:disable:no-unsafe-any */
    const engine = new sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__();
    return engine.update(filePrefix)
        .update(file)
        .digest("hex");
}
function flatten(tree, blobMap) {
    const entries = flattenCore("", tree, blobMap);
    return {
        sha: null,
        tree: entries,
        url: null,
    };
}
function readAndParse(storage, sha) {
    return __awaiter(this, void 0, void 0, function* () {
        const encoded = yield storage.read(sha);
        const decoded = Buffer
            .from(encoded, "base64")
            .toString();
        return JSON.parse(decoded);
    });
}
function flattenCore(path, treeEntries, blobMap) {
    const entries = new Array();
    for (const treeEntry of treeEntries) {
        const subPath = `${path}${treeEntry.path}`;
        if (treeEntry.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob]) {
            const blob = treeEntry.value;
            const buffer = Buffer.from(blob.contents, blob.encoding);
            const sha = gitHashFile(buffer);
            blobMap.set(sha, buffer.toString("base64"));
            const entry = {
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"][treeEntry.mode],
                path: subPath,
                sha,
                size: buffer.length,
                type: "blob",
                url: "",
            };
            entries.push(entry);
        }
        else {
            const t = treeEntry.value;
            const entry = {
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"][treeEntry.mode],
                path: subPath,
                sha: null,
                size: -1,
                type: "tree",
                url: "",
            };
            entries.push(entry);
            const subTreeEntries = flattenCore(subPath + "/", t.entries, blobMap);
            entries.push(...subTreeEntries);
        }
    }
    return entries;
}
function buildHierarchy(flatTree) {
    if (!flatTree) {
        return null;
    }
    const lookup = {};
    const root = { sha: flatTree.sha, blobs: {}, commits: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.tree) {
        const lastIndex = entry.path.lastIndexOf("/");
        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entry.path.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { sha: entry.sha, blobs: {}, commits: {}, trees: {} };
            node.trees[entryPathBase] = newTree;
            lookup[entry.path] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[entryPathBase] = entry.sha;
        }
        else if (entry.type === "commit") {
            node.commits[entryPathBase] = entry.sha;
        }
    }
    return root;
}
//# sourceMappingURL=blobs.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/heap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/heap.js ***!
  \*****************************************************************************/
/*! exports provided: NumberComparer, Heap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberComparer", function() { return NumberComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return Heap; });
// tslint:disable:no-bitwise
// tslint:disable:no-increment-decrement
// tslint:disable:no-parameter-reassignment
const NumberComparer = {
    compare: (a, b) => a - b,
    min: Number.MIN_VALUE,
};
class Heap {
    constructor(comp) {
        this.comp = comp;
        this.L = [{ value: comp.min, position: 0 }];
    }
    peek() {
        return this.L[1];
    }
    get() {
        this.swap(1, this.count());
        const x = this.L.pop();
        this.fixdown(1);
        return x.value;
    }
    add(x) {
        const node = { value: x, position: this.L.length };
        this.L.push(node);
        this.fixup(this.count());
        return node;
    }
    /**
     * Allows for heap to be updated after a node's value changes
     */
    update(node) {
        const k = node.position;
        if (this.isGreaterThanParent(k)) {
            this.fixup(k);
        }
        else {
            this.fixdown(k);
        }
    }
    /**
     * Removes the given node from the heap
     */
    remove(node) {
        // Move the node we want to remove to the end of the array
        const position = node.position;
        this.swap(node.position, this.L.length - 1);
        this.L.splice(this.L.length - 1);
        // Update the swapped node assuming we didn't remove the end of the list
        if (position !== this.L.length) {
            this.update(this.L[position]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    fixup(k) {
        while (this.isGreaterThanParent(k)) {
            const parent = k >> 1;
            this.swap(k, parent);
            k = parent;
        }
    }
    isGreaterThanParent(k) {
        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);
    }
    fixdown(k) {
        while ((k << 1) <= this.count()) {
            let j = k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {
                break;
            }
            this.swap(k, j);
            k = j;
        }
    }
    swap(k, j) {
        const tmp = this.L[k];
        this.L[k] = this.L[j];
        this.L[k].position = k;
        this.L[j] = tmp;
        this.L[j].position = j;
    }
}
//# sourceMappingURL=heap.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/index.js ***!
  \******************************************************************************/
/*! exports provided: BatchManager, gitHashFile, flatten, readAndParse, buildHierarchy, NumberComparer, Heap, Deferred, assertNotRejected, RangeTracker, RateLimitter, safelyParseJSON, isSystemType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _batchManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batchManager */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/batchManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchManager", function() { return _batchManager__WEBPACK_IMPORTED_MODULE_0__["BatchManager"]; });

/* harmony import */ var _blobs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blobs */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/blobs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gitHashFile", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["gitHashFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["flatten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readAndParse", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["readAndParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildHierarchy", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["buildHierarchy"]; });

/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./heap */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/heap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberComparer", function() { return _heap__WEBPACK_IMPORTED_MODULE_2__["NumberComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return _heap__WEBPACK_IMPORTED_MODULE_2__["Heap"]; });

/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./promises */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/promises.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Deferred", function() { return _promises__WEBPACK_IMPORTED_MODULE_3__["Deferred"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertNotRejected", function() { return _promises__WEBPACK_IMPORTED_MODULE_3__["assertNotRejected"]; });

/* harmony import */ var _rangeTracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rangeTracker */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rangeTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RangeTracker", function() { return _rangeTracker__WEBPACK_IMPORTED_MODULE_4__["RangeTracker"]; });

/* harmony import */ var _rateLimitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rateLimitter */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rateLimitter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RateLimitter", function() { return _rateLimitter__WEBPACK_IMPORTED_MODULE_5__["RateLimitter"]; });

/* harmony import */ var _safeParser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./safeParser */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/safeParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "safelyParseJSON", function() { return _safeParser__WEBPACK_IMPORTED_MODULE_6__["safelyParseJSON"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSystemType", function() { return _utils__WEBPACK_IMPORTED_MODULE_7__["isSystemType"]; });









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/promises.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/promises.js ***!
  \*********************************************************************************/
/*! exports provided: Deferred, assertNotRejected */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deferred", function() { return Deferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertNotRejected", function() { return assertNotRejected; });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_0__);

/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        /* tslint:disable:promise-must-complete */
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Retrieves the underlying promise for the deferred
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     */
    resolve(value) {
        this.res(value);
    }
    /**
     * Rejects the promise
     */
    reject(error) {
        this.rej(error);
    }
}
/**
 * Helper function that asserts that the given promise only resolves
 */
/* tslint:disable:promise-function-async */
function assertNotRejected(promise) {
    // Assert that the given promise only resolves
    promise.catch((error) => {
        assert__WEBPACK_IMPORTED_MODULE_0__["ok"](false);
    });
    return promise;
}
//# sourceMappingURL=promises.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rangeTracker.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rangeTracker.js ***!
  \*************************************************************************************/
/*! exports provided: RangeTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeTracker", function() { return RangeTracker; });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_0__);

// tslint:disable:no-var-requires
// tslint:disable-next-line:no-submodule-imports
const cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/**
 * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary
 * is continuous and always maps to a single value in secondary above the base value. The range
 * defines an increasing step function.
 */
class RangeTracker {
    get base() {
        return this.ranges[0].primary;
    }
    get primaryHead() {
        return this.lastPrimary;
    }
    get secondaryHead() {
        return this.lastSecondary;
    }
    constructor(primary, secondary) {
        if (typeof primary === "number") {
            this.ranges = [{ length: 0, primary, secondary }];
            this.lastPrimary = primary;
            this.lastSecondary = secondary;
        }
        else {
            /* tslint:disable:no-unsafe-any */
            this.ranges = cloneDeep(primary.ranges);
            this.lastPrimary = primary.lastPrimary;
            this.lastSecondary = primary.lastSecondary;
        }
    }
    /**
     * Returns a serialized form of the RangeTracker
     */
    serialize() {
        return {
            lastPrimary: this.lastPrimary,
            lastSecondary: this.lastSecondary,
            ranges: cloneDeep(this.ranges),
        };
    }
    // primary is time - secondary is the MSN
    add(primary, secondary) {
        // Both values must continuously be increasing - we won't always track the last value we saw so we do so
        // below to check invariants
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.lastPrimary);
        assert__WEBPACK_IMPORTED_MODULE_0__(secondary >= this.lastSecondary);
        this.lastPrimary = primary;
        this.lastSecondary = secondary;
        // Get quicker references to the head of the range
        const head = this.ranges[this.ranges.length - 1];
        const primaryHead = head.primary + head.length;
        const secondaryHead = head.secondary + head.length;
        // Same secondary indicates this is not a true inflection point - we can ignore it
        if (secondary === secondaryHead) {
            return;
        }
        // New secondary - need to update the ranges
        if (primary === primaryHead) {
            // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to
            // preserve 1:N since you can only lookup from the primary to a secondary
            if (head.length === 0) {
                // No range represented - we can simply update secondary with the overwritten value
                head.secondary = secondary;
            }
            else {
                // The values in the range before this one are valid - but we need to create a new one for this update
                // tslint:disable-next-line:no-increment-decrement
                head.length--;
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
        else {
            if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {
                // extend the length if both increase by the same amount
                // tslint:disable-next-line:no-increment-decrement
                head.length++;
            }
            else {
                // Insert a new node
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
    }
    get(primary) {
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[0].primary);
        // Find the first range where the starting position is greater than the primary. Our target range is
        // the one before it.
        let index = 1;
        // tslint:disable-next-line:no-increment-decrement
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[index - 1].primary);
        // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest
        // stored secondary value to use.
        const closestRange = this.ranges[index - 1];
        return Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary;
    }
    updateBase(primary) {
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[0].primary);
        // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the
        // previous index by definition (since it's less than the current index's primary but greather than the
        // previous index's primary) and we know primary must be greater than the base.
        let index = 1;
        // tslint:disable-next-line:no-increment-decrement
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[index - 1].primary);
        // Update the last range values
        const range = this.ranges[index - 1];
        const delta = primary - range.primary;
        range.secondary = range.secondary + Math.min(delta, range.length);
        range.length = Math.max(range.length - delta, 0);
        range.primary = primary;
        // And remove unnecessary ranges
        this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;
        // assert that the lowest value is now the input to this method
        assert__WEBPACK_IMPORTED_MODULE_0__["equal"](primary, this.ranges[0].primary);
    }
}
//# sourceMappingURL=rangeTracker.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rateLimitter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/rateLimitter.js ***!
  \*************************************************************************************/
/*! exports provided: RateLimitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RateLimitter", function() { return RateLimitter; });
// A rate limiter to make sure that a client can only request help for one task within a time window.
class RateLimitter {
    constructor(windowMSec) {
        this.windowMSec = windowMSec;
        this.requestMap = new Map();
    }
    filter(clientId, messages) {
        const approvedList = [];
        const currentTime = Date.now();
        for (const message of messages) {
            const key = `${clientId}/${message}`;
            if (!this.requestMap.has(key)) {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
            else if (this.requestMap.get(key) + this.windowMSec > currentTime) {
                continue;
            }
            else {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
        }
        return approvedList;
    }
}
//# sourceMappingURL=rateLimitter.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/safeParser.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/safeParser.js ***!
  \***********************************************************************************/
/*! exports provided: safelyParseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safelyParseJSON", function() { return safelyParseJSON; });
function safelyParseJSON(json) {
    let parsed;
    try {
        parsed = JSON.parse(json);
    }
    catch (e) {
        //
    }
    return parsed;
}
//# sourceMappingURL=safeParser.js.map

/***/ }),

/***/ "./node_modules/@prague/runtime/node_modules/@prague/utils/lib/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@prague/runtime/node_modules/@prague/utils/lib/utils.js ***!
  \******************************************************************************/
/*! exports provided: isSystemType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSystemType", function() { return isSystemType; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);

function isSystemType(type) {
    return (type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].RemoteHelp ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Integrate ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].ClientJoin ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].ClientLeave ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Fork);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/lib/extension.js":
/*!********************************************************!*\
  !*** ./node_modules/@prague/sequence/lib/extension.js ***!
  \********************************************************/
/*! exports provided: SharedStringExtension, SharedObjectSequenceExtension, SharedNumberSequenceExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedStringExtension", function() { return SharedStringExtension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedObjectSequenceExtension", function() { return SharedObjectSequenceExtension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedNumberSequenceExtension", function() { return SharedNumberSequenceExtension; });
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sequence */ "./node_modules/@prague/sequence/lib/sequence.js");
/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sharedString */ "./node_modules/@prague/sequence/lib/sharedString.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class SharedStringExtension {
    constructor() {
        this.type = SharedStringExtension.Type;
    }
    load(document, id, minimumSequenceNumber, services, headerOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_1__["SharedString"](document, id, services);
            yield sharedString.load(minimumSequenceNumber, headerOrigin, services);
            return sharedString;
        });
    }
    create(document, id) {
        const sharedString = new _sharedString__WEBPACK_IMPORTED_MODULE_1__["SharedString"](document, id);
        sharedString.initializeLocal();
        return sharedString;
    }
}
// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically
// load code
SharedStringExtension.Type = "https://graph.microsoft.com/types/mergeTree";
class SharedObjectSequenceExtension {
    constructor() {
        this.type = SharedObjectSequenceExtension.Type;
    }
    load(document, id, minimumSequenceNumber, services, headerOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedSeq = new _sequence__WEBPACK_IMPORTED_MODULE_0__["SharedObjectSequence"](document, id, services);
            yield sharedSeq.load(minimumSequenceNumber, headerOrigin, services);
            return sharedSeq;
        });
    }
    create(document, id) {
        const sharedString = new _sequence__WEBPACK_IMPORTED_MODULE_0__["SharedObjectSequence"](document, id);
        sharedString.initializeLocal();
        return sharedString;
    }
}
SharedObjectSequenceExtension.Type = "https://graph.microsoft.com/types/mergeTree/object-sequence";
class SharedNumberSequenceExtension {
    constructor() {
        this.type = SharedNumberSequenceExtension.Type;
    }
    load(document, id, minimumSequenceNumber, services, headerOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedSeq = new _sequence__WEBPACK_IMPORTED_MODULE_0__["SharedNumberSequence"](document, id, services);
            yield sharedSeq.load(minimumSequenceNumber, headerOrigin, services);
            return sharedSeq;
        });
    }
    create(document, id) {
        const sharedString = new _sequence__WEBPACK_IMPORTED_MODULE_0__["SharedNumberSequence"](document, id);
        sharedString.initializeLocal();
        return sharedString;
    }
}
SharedNumberSequenceExtension.Type = "https://graph.microsoft.com/types/mergeTree/number-sequence";
//# sourceMappingURL=extension.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@prague/sequence/lib/index.js ***!
  \****************************************************/
/*! exports provided: SharedStringInterval, Interval, SharedIntervalCollection, SharedIntervalCollectionView, SharedIntervalCollectionValueType, SharedStringIntervalCollectionValueType, SharedString, SegmentSequence, SharedSequence, SharedObjectSequence, SharedNumberSequence, SharedStringExtension, SharedObjectSequenceExtension, SharedNumberSequenceExtension, SequenceDeltaEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./intervalCollection */ "./node_modules/@prague/sequence/lib/intervalCollection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedStringInterval", function() { return _intervalCollection__WEBPACK_IMPORTED_MODULE_0__["SharedStringInterval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return _intervalCollection__WEBPACK_IMPORTED_MODULE_0__["Interval"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedIntervalCollection", function() { return _intervalCollection__WEBPACK_IMPORTED_MODULE_0__["SharedIntervalCollection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedIntervalCollectionView", function() { return _intervalCollection__WEBPACK_IMPORTED_MODULE_0__["SharedIntervalCollectionView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedIntervalCollectionValueType", function() { return _intervalCollection__WEBPACK_IMPORTED_MODULE_0__["SharedIntervalCollectionValueType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedStringIntervalCollectionValueType", function() { return _intervalCollection__WEBPACK_IMPORTED_MODULE_0__["SharedStringIntervalCollectionValueType"]; });

/* harmony import */ var _sharedString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sharedString */ "./node_modules/@prague/sequence/lib/sharedString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedString", function() { return _sharedString__WEBPACK_IMPORTED_MODULE_1__["SharedString"]; });

/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sequence */ "./node_modules/@prague/sequence/lib/sequence.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SegmentSequence", function() { return _sequence__WEBPACK_IMPORTED_MODULE_2__["SegmentSequence"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedSequence", function() { return _sequence__WEBPACK_IMPORTED_MODULE_2__["SharedSequence"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedObjectSequence", function() { return _sequence__WEBPACK_IMPORTED_MODULE_2__["SharedObjectSequence"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedNumberSequence", function() { return _sequence__WEBPACK_IMPORTED_MODULE_2__["SharedNumberSequence"]; });

/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/sequence/lib/extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedStringExtension", function() { return _extension__WEBPACK_IMPORTED_MODULE_3__["SharedStringExtension"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedObjectSequenceExtension", function() { return _extension__WEBPACK_IMPORTED_MODULE_3__["SharedObjectSequenceExtension"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SharedNumberSequenceExtension", function() { return _extension__WEBPACK_IMPORTED_MODULE_3__["SharedNumberSequenceExtension"]; });

/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sequenceDeltaEvent */ "./node_modules/@prague/sequence/lib/sequenceDeltaEvent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SequenceDeltaEvent", function() { return _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_4__["SequenceDeltaEvent"]; });






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/lib/intervalCollection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@prague/sequence/lib/intervalCollection.js ***!
  \*****************************************************************/
/*! exports provided: Interval, SharedStringInterval, defaultIntervalConflictResolver, createIntervalIndex, LocalIntervalCollection, SharedStringIntervalCollectionValueType, SharedIntervalCollectionValueType, SharedIntervalCollectionView, SharedIntervalCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return Interval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedStringInterval", function() { return SharedStringInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultIntervalConflictResolver", function() { return defaultIntervalConflictResolver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIntervalIndex", function() { return createIntervalIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocalIntervalCollection", function() { return LocalIntervalCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedStringIntervalCollectionValueType", function() { return SharedStringIntervalCollectionValueType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedIntervalCollectionValueType", function() { return SharedIntervalCollectionValueType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedIntervalCollectionView", function() { return SharedIntervalCollectionView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedIntervalCollection", function() { return SharedIntervalCollection; });
/* harmony import */ var _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/merge-tree */ "./node_modules/@prague/merge-tree/lib/index.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class Interval {
    constructor(start, end, props) {
        this.start = start;
        this.end = end;
        if (props) {
            this.addProperties(props);
        }
    }
    getAdditionalPropertySets() {
        return this.auxProps;
    }
    addPropertySet(props) {
        if (this.auxProps === undefined) {
            this.auxProps = [];
        }
        this.auxProps.push(props);
    }
    serialize(client) {
        let seq = 0;
        if (client) {
            seq = client.getCurrentSeq();
        }
        /* tslint:disable:no-object-literal-type-assertion */
        const serializedInterval = {
            end: this.end,
            intervalType: 0,
            sequenceNumber: seq,
            start: this.start,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new Interval(this.start, this.end, this.properties);
    }
    compare(b) {
        const startResult = this.start - b.start;
        if (startResult === 0) {
            return (this.end - b.end);
        }
        else {
            return startResult;
        }
    }
    overlaps(b) {
        const result = (this.start < b.end) &&
            (this.end >= b.start);
        return result;
    }
    union(b) {
        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);
    }
    getProperties() {
        return this.properties;
    }
    addProperties(newProps, op) {
        this.properties = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["addProperties"](this.properties, newProps, op);
    }
}
class SharedStringInterval {
    constructor(start, end, intervalType, props) {
        this.start = start;
        this.end = end;
        this.intervalType = intervalType;
        if (props) {
            this.addProperties(props);
        }
    }
    serialize(client) {
        const startPosition = this.start.toPosition(client.mergeTree, client.getCurrentSeq(), client.getClientId());
        const endPosition = this.end.toPosition(client.mergeTree, client.getCurrentSeq(), client.getClientId());
        const serializedInterval = {
            end: endPosition,
            intervalType: this.intervalType,
            sequenceNumber: client.getCurrentSeq(),
            start: startPosition,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new SharedStringInterval(this.start, this.end, this.intervalType);
    }
    compare(b) {
        const startResult = this.start.compare(b.start);
        if (startResult === 0) {
            return (this.end.compare(b.end));
        }
        else {
            return startResult;
        }
    }
    overlaps(b) {
        const result = (this.start.compare(b.end) < 0) &&
            (this.end.compare(b.start) >= 0);
        if (this.checkMergeTree) {
            this.checkOverlaps(b, result);
        }
        return result;
    }
    union(b) {
        return new SharedStringInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);
    }
    addProperties(newProps, op) {
        this.properties = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["addProperties"](this.properties, newProps, op);
    }
    overlapsPos(mergeTree, bstart, bend) {
        const startPos = this.start.toPosition(mergeTree, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], mergeTree.collabWindow.clientId);
        const endPos = this.start.toPosition(mergeTree, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], mergeTree.collabWindow.clientId);
        return (endPos > bstart) && (startPos < bend);
    }
    checkOverlaps(b, result) {
        const astart = this.start.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);
        const bstart = b.start.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);
        const aend = this.end.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);
        const bend = b.end.toPosition(this.checkMergeTree, this.checkMergeTree.collabWindow.currentSeq, this.checkMergeTree.collabWindow.clientId);
        const checkResult = ((astart < bend) && (bstart < aend));
        if (checkResult !== result) {
            // tslint:disable-next-line:max-line-length
            console.log(`check mismatch: res ${result} ${this.start.segment === b.end.segment} ${b.start.segment === this.end.segment}`);
            console.log(`as ${astart} ae ${aend} bs ${bstart} be ${bend}`);
            console.log(`as ${_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ordinalToArray"](this.start.segment.ordinal)}@${this.start.offset}`);
            console.log(`ae ${_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ordinalToArray"](this.end.segment.ordinal)}@${this.end.offset}`);
            console.log(`bs ${_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ordinalToArray"](b.start.segment.ordinal)}@${b.start.offset}`);
            console.log(`be ${_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ordinalToArray"](b.end.segment.ordinal)}@${b.end.offset}`);
            console.log(this.checkMergeTree.nodeToString(b.start.segment.parent, ""));
        }
    }
}
function createPositionReference(client, pos, refType, refSeq = client.getCurrentSeq(), clientId = client.getClientId()) {
    const segoff = client.mergeTree.getContainingSegment(pos, refSeq, client.getClientId());
    if (segoff && segoff.segment) {
        const baseSegment = segoff.segment;
        const lref = new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["LocalReference"](baseSegment, segoff.offset, refType);
        if (refType !== _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].Transient) {
            client.mergeTree.addLocalReference(lref);
        }
        return lref;
    }
}
function createSharedStringInterval(label, start, end, client, intervalType) {
    let beginRefType = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].RangeBegin;
    let endRefType = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].RangeEnd;
    if (intervalType === _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalType"].Nest) {
        beginRefType = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].NestBegin;
        endRefType = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].NestEnd;
    }
    else if (intervalType === _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalType"].Transient) {
        beginRefType = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].Transient;
        endRefType = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["ReferenceType"].Transient;
    }
    const startLref = createPositionReference(client, start, beginRefType);
    const endLref = createPositionReference(client, end, endRefType);
    if (startLref && endLref) {
        startLref.pairedRef = endLref;
        endLref.pairedRef = startLref;
        const rangeProp = {
            [_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["reservedRangeLabelsKey"]]: [label],
        };
        startLref.addProperties(rangeProp);
        endLref.addProperties(rangeProp);
        const ival = new SharedStringInterval(startLref, endLref, intervalType, rangeProp);
        // ival.checkMergeTree = sharedString.client.mergeTree;
        return ival;
    }
    else {
        return null;
    }
}
function defaultIntervalConflictResolver(a, b) {
    a.addPropertySet(b.properties);
    return a;
}
function createIntervalIndex(conflict) {
    const helpers = {
        compareEnds: compareIntervalEnds,
        create: createInterval,
    };
    const lc = new LocalIntervalCollection(undefined, "", helpers);
    if (conflict) {
        lc.addConflictResolver(conflict);
    }
    else {
        lc.addConflictResolver(defaultIntervalConflictResolver);
    }
    return lc;
}
class LocalIntervalCollection {
    constructor(client, label, helpers) {
        this.client = client;
        this.label = label;
        this.helpers = helpers;
        this.intervalTree = new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalTree"]();
        this.endIntervalTree =
            new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["RedBlackTree"](helpers.compareEnds);
    }
    addConflictResolver(conflictResolver) {
        this.conflictResolver = conflictResolver;
        this.endConflictResolver =
            (key, currentKey) => {
                const ival = this.conflictResolver(key, currentKey);
                return {
                    data: ival,
                    key: ival,
                };
            };
    }
    map(fn) {
        this.intervalTree.map(fn);
    }
    findOverlappingIntervals(startPosition, endPosition) {
        if (!this.intervalTree.intervals.isEmpty()) {
            const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalType"].Transient);
            const overlappingIntervalNodes = this.intervalTree.match(transientInterval);
            return overlappingIntervalNodes.map((node) => node.key);
        }
        else {
            return [];
        }
    }
    previousInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalType"].Transient);
        const rbNode = this.endIntervalTree.floor(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    nextInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalType"].Transient);
        const rbNode = this.endIntervalTree.ceil(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    removeInterval(startPosition, endPosition) {
        const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["IntervalType"].Transient);
        this.intervalTree.remove(transientInterval);
        this.endIntervalTree.remove(transientInterval);
    }
    createInterval(start, end, intervalType) {
        return this.helpers.create(this.label, start, end, this.client, intervalType);
    }
    // TODO: remove interval, handle duplicate intervals
    addInterval(start, end, intervalType, props) {
        const interval = this.createInterval(start, end, intervalType);
        if (interval) {
            interval.addProperties(props);
            if (this.label && (this.label.length > 0)) {
                interval.properties[_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["reservedRangeLabelsKey"]] = [this.label];
            }
            this.intervalTree.put(interval, this.conflictResolver);
            this.endIntervalTree.put(interval, interval, this.endConflictResolver);
        }
        return interval;
    }
    serialize() {
        const client = this.client;
        const intervals = this.intervalTree.intervals.keys();
        // tslint:disable-next-line
        return intervals.map((interval) => interval.serialize(client));
    }
}
function compareSharedStringIntervalEnds(a, b) {
    return a.end.compare(b.end);
}
class SharedStringIntervalCollectionFactory {
    load(emitter, raw) {
        const helpers = {
            compareEnds: compareSharedStringIntervalEnds,
            create: createSharedStringInterval,
        };
        return new SharedIntervalCollection(helpers, true, emitter, raw || []);
    }
    store(value) {
        return value.serializeInternal();
    }
}
class SharedStringIntervalCollectionValueType {
    // tslint:enable:variable-name
    constructor() {
        this._factory = new SharedStringIntervalCollectionFactory();
        this._ops = new Map([[
                "add",
                {
                    /* tslint:disable:promise-function-async */
                    prepare: (value, params, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        /* tslint:disable:no-unsafe-any */
                        return value.prepareAddInternal(params, local, op);
                    },
                    process: (value, params, context, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        value.addInternal(params, context, local, op);
                    },
                },
            ]]);
    }
    get name() {
        return SharedStringIntervalCollectionValueType.Name;
    }
    get factory() {
        return this._factory;
    }
    get ops() {
        return this._ops;
    }
}
SharedStringIntervalCollectionValueType.Name = "sharedStringIntervalCollection";
function compareIntervalEnds(a, b) {
    return a.end - b.end;
}
function createInterval(label, start, end, client) {
    let rangeProp;
    if (label && (label.length > 0)) {
        rangeProp = {
            [_prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["reservedRangeLabelsKey"]]: [label],
        };
    }
    return new Interval(start, end, rangeProp);
}
class SharedIntervalCollectionFactory {
    load(emitter, raw) {
        const helpers = {
            compareEnds: compareIntervalEnds,
            create: createInterval,
        };
        const collection = new SharedIntervalCollection(helpers, false, emitter, raw || []);
        collection.attach(undefined, "");
        return collection;
    }
    store(value) {
        return value.serializeInternal();
    }
}
class SharedIntervalCollectionValueType {
    // tslint:enable:variable-name
    constructor() {
        this._factory = new SharedIntervalCollectionFactory();
        this._ops = new Map([[
                "add",
                {
                    prepare: (value, params, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        return value.prepareAddInternal(params, local, op);
                    },
                    process: (value, params, context, local, op) => {
                        // Local ops were applied when the message was created
                        if (local) {
                            return;
                        }
                        value.addInternal(params, context, local, op);
                    },
                },
            ]]);
    }
    get name() {
        return SharedIntervalCollectionValueType.Name;
    }
    get factory() {
        return this._factory;
    }
    get ops() {
        return this._ops;
    }
}
SharedIntervalCollectionValueType.Name = "sharedIntervalCollection";
class SharedIntervalCollectionView extends events__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"] {
    constructor(client, savedSerializedIntervals, label, helpers, emitter) {
        super();
        this.client = client;
        this.emitter = emitter;
        this.attachingP = Promise.resolve();
        // Instantiate the local interval collection based on the saved intervals
        this.localCollection = new LocalIntervalCollection(client, label, helpers);
        if (savedSerializedIntervals) {
            for (const serializedInterval of savedSerializedIntervals) {
                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);
            }
        }
    }
    attachDeserializer(onDeserialize, onPrepareDeserialize) {
        return __awaiter(this, void 0, void 0, function* () {
            this.attachingP = this.attachDeserializerCore(onDeserialize, onPrepareDeserialize);
            return this.attachingP;
        });
    }
    findOverlappingIntervals(startPosition, endPosition) {
        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);
    }
    map(fn) {
        this.localCollection.map(fn);
    }
    previousInterval(pos) {
        return this.localCollection.previousInterval(pos);
    }
    nextInterval(pos) {
        return this.localCollection.nextInterval(pos);
    }
    /* tslint:disable:no-unnecessary-override */
    on(event, listener) {
        return super.on(event, listener);
    }
    add(start, end, intervalType, props) {
        let seq = 0;
        if (this.client) {
            seq = this.client.getCurrentSeq();
        }
        const serializedInterval = {
            end,
            intervalType,
            properties: props,
            sequenceNumber: seq,
            start,
        };
        this.addInternal(serializedInterval, null, true, null);
    }
    // TODO: error cases
    addInternal(serializedInterval, context, local, op) {
        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);
        if (interval) {
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            if (local) {
                this.emitter.emit("add", serializedInterval);
            }
            else {
                if (this.onDeserialize) {
                    this.onDeserialize(interval, context);
                }
            }
        }
        this.emit("addInterval", interval, local, op);
        return this;
    }
    prepareAdd(interval, local, message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.attachingP;
            return this.onPrepareDeserialize ? this.onPrepareDeserialize(interval.properties) : null;
        });
    }
    serializeInternal() {
        return this.localCollection.serialize();
    }
    attachDeserializerCore(onDeserialize, onPrepareDeserialize) {
        return __awaiter(this, void 0, void 0, function* () {
            // If no deserializer is specified can skip all processing work
            if (!onDeserialize && !onPrepareDeserialize) {
                return;
            }
            // Start by storing the callbacks so that any subsequent modifications make use of them
            this.onDeserialize = onDeserialize;
            this.onPrepareDeserialize = onPrepareDeserialize;
            // Trigger the async prepare work across all values in the collection
            const preparedIntervalsP = [];
            this.localCollection.map((interval) => {
                const preparedIntervalP = onPrepareDeserialize(interval.properties)
                    .then((context) => ({ context, interval }));
                preparedIntervalsP.push(preparedIntervalP);
            });
            const preparedIntervals = yield Promise.all(preparedIntervalsP);
            for (const preparedInterval of preparedIntervals) {
                this.onDeserialize(preparedInterval.interval, preparedInterval.context);
            }
        });
    }
}
class SharedIntervalCollection {
    constructor(helpers, requiresClient, emitter, serializedIntervals) {
        this.helpers = helpers;
        this.requiresClient = requiresClient;
        this.emitter = emitter;
        this.savedSerializedIntervals = serializedIntervals;
    }
    get attached() {
        return !!this.view;
    }
    attach(client, label) {
        if (this.view) {
            throw new Error("Only supports one SharedString attach");
        }
        if ((client === undefined) && (this.requiresClient)) {
            throw new Error("Client required for this collection");
        }
        this.view = new SharedIntervalCollectionView(client, this.savedSerializedIntervals, label, this.helpers, this.emitter);
        this.savedSerializedIntervals = undefined;
    }
    add(startPosition, endPosition, intervalType, props) {
        if (!this.view) {
            return Promise.reject("attach must be called prior to adding intervals");
        }
        this.view.add(startPosition, endPosition, intervalType, props);
    }
    getView(onDeserialize, onPrepareDeserialize) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.view) {
                return Promise.reject("attachSharedString must be called prior to retrieving the view");
            }
            // Attach custom deserializers if specified
            if (onDeserialize || onPrepareDeserialize) {
                yield this.view.attachDeserializer(onDeserialize, onPrepareDeserialize);
            }
            return this.view;
        });
    }
    prepareAddInternal(interval, local, message) {
        if (!this.view) {
            return Promise.reject("attachSharedString must be called");
        }
        return this.view.prepareAdd(interval, local, message);
    }
    addInternal(serializedInterval, context, local, op) {
        if (!this.view) {
            throw new Error("attachSharedString must be called");
        }
        return this.view.addInternal(serializedInterval, context, local, op);
    }
    serializeInternal() {
        if (!this.view) {
            throw new Error("attachSharedString must be called");
        }
        return this.view.serializeInternal();
    }
}
//# sourceMappingURL=intervalCollection.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/lib/sequence.js":
/*!*******************************************************!*\
  !*** ./node_modules/@prague/sequence/lib/sequence.js ***!
  \*******************************************************/
/*! exports provided: SegmentSequence, SharedSequence, SharedObjectSequence, SharedNumberSequence */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentSequence", function() { return SegmentSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedSequence", function() { return SharedSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedObjectSequence", function() { return SharedObjectSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedNumberSequence", function() { return SharedNumberSequence; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prague_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/map */ "./node_modules/@prague/map/lib/index.js");
/* harmony import */ var _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @prague/merge-tree */ "./node_modules/@prague/merge-tree/lib/index.js");
/* harmony import */ var _prague_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prague/utils */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/index.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js");
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(uuid_v4__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/sequence/lib/extension.js");
/* harmony import */ var _intervalCollection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./intervalCollection */ "./node_modules/@prague/sequence/lib/intervalCollection.js");
/* harmony import */ var _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sequenceDeltaEvent */ "./node_modules/@prague/sequence/lib/sequenceDeltaEvent.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// tslint:disable:whitespace align no-bitwise





// tslint:disable-next-line:no-submodule-imports no-var-requires no-require-imports
const cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
// tslint:disable-next-line:no-submodule-imports




class SegmentSequence extends _prague_map__WEBPACK_IMPORTED_MODULE_1__["SharedMap"] {
    constructor(document, id, extensionType, services) {
        super(id, document, extensionType);
        this.id = id;
        this.isLoaded = false;
        this.collabStarted = false;
        this.pendingMinSequenceNumber = 0;
        // Deferred that triggers once the object is loaded
        this.loadedDeferred = new _prague_utils__WEBPACK_IMPORTED_MODULE_3__["Deferred"]();
        this.messagesSinceMSNChange = new Array();
        /* tslint:disable:no-unsafe-any */
        this.client = new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["Client"]("", document.options);
        super.on("newListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (!this.client.mergeTree.mergeTreeDeltaCallback) {
                        this.client.mergeTree.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {
                            this.emit("sequenceDelta", this, new _sequenceDeltaEvent__WEBPACK_IMPORTED_MODULE_8__["SequenceDeltaEvent"](opArgs, this.client, deltaArgs));
                        };
                    }
                    break;
                default:
            }
        });
        super.on("removeListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTree.mergeTreeDeltaCallback = undefined;
                    }
                    break;
                default:
            }
        });
    }
    get loaded() {
        return this.loadedDeferred.promise;
    }
    // tslint:disable-next-line:no-unnecessary-override
    on(event, listener) {
        return super.on(event, listener);
    }
    removeRange(start, end) {
        const removeMessage = {
            pos1: start,
            pos2: end,
            type: 1 /* REMOVE */,
        };
        this.client.removeSegmentLocal(start, end, { op: removeMessage });
        this.submitIfAttached(removeMessage);
    }
    cut(register, start, end) {
        const removeMessage = {
            pos1: start,
            pos2: end,
            register,
            type: 1 /* REMOVE */,
        };
        this.client.copy(start, end, register, this.client.getCurrentSeq(), this.client.getClientId(), this.client.longClientId);
        this.client.removeSegmentLocal(start, end, { op: removeMessage });
        this.submitIfAttached(removeMessage);
    }
    paste(register, pos) {
        const insertMessage = {
            pos1: pos,
            register,
            type: 0 /* INSERT */,
        };
        // tslint:disable-next-line:no-parameter-reassignment
        pos = this.client.pasteLocal(register, pos, { op: insertMessage });
        this.submitIfAttached(insertMessage);
        return pos;
    }
    copy(register, start, end) {
        const insertMessage = {
            pos1: start,
            pos2: end,
            register,
            type: 0 /* INSERT */,
        };
        this.client.copy(start, end, register, this.client.getCurrentSeq(), this.client.getClientId(), this.client.longClientId);
        this.submitIfAttached(insertMessage);
    }
    groupOperation(groupOp) {
        const segmentGroup = this.client.localTransaction(groupOp);
        this.submitIfAttached(groupOp);
        return segmentGroup;
    }
    annotateRange(props, start, end, op) {
        const annotateMessage = {
            pos1: start,
            pos2: end,
            props,
            type: 2 /* ANNOTATE */,
        };
        if (op) {
            annotateMessage.combiningOp = op;
        }
        this.client.annotateSegmentLocal(props, start, end, op, { op: annotateMessage });
        this.submitIfAttached(annotateMessage);
    }
    getPropertiesAtPosition(pos) {
        return this.client.getPropertiesAtPosition(pos);
    }
    getRangeExtentsOfPosition(pos) {
        return this.client.getRangeExtentsOfPosition(pos);
    }
    setLocalMinSeq(lmseq) {
        this.client.mergeTree.updateLocalMinSeq(lmseq);
    }
    createPositionReference(pos, refType, refSeq = this.client.getCurrentSeq(), clientId = this.client.getClientId()) {
        const segoff = this.client.mergeTree.getContainingSegment(pos, refSeq, this.client.getClientId());
        if (segoff && segoff.segment) {
            const lref = new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["LocalReference"](segoff.segment, segoff.offset, refType);
            if (refType !== _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["ReferenceType"].Transient) {
                this.client.mergeTree.addLocalReference(lref);
            }
            return lref;
        }
    }
    localRefToPos(localRef) {
        if (localRef.segment) {
            return localRef.offset + this.client.mergeTree.getOffset(localRef.segment, this.client.getCurrentSeq(), this.client.getClientId());
        }
        else {
            return -1;
        }
    }
    getIntervalCollections() {
        return this.intervalCollections;
    }
    // TODO: fix race condition on creation by putting type on every operation
    getSharedIntervalCollection(label) {
        if (!this.intervalCollections.has(label)) {
            this.intervalCollections.set(label, undefined, _intervalCollection__WEBPACK_IMPORTED_MODULE_7__["SharedStringIntervalCollectionValueType"].Name);
        }
        const sharedCollection = this.intervalCollections.get(label);
        return sharedCollection;
    }
    sendNACKed() {
        const orderedSegments = [];
        while (!this.client.mergeTree.pendingSegments.empty()) {
            const NACKedSegmentGroup = this.client.mergeTree.pendingSegments.dequeue();
            for (const segment of NACKedSegmentGroup.segments) {
                orderedSegments.push(segment);
            }
        }
        orderedSegments.sort((a, b) => {
            if (a === b) {
                return 0;
            }
            else if (a.ordinal < b.ordinal) {
                return -1;
            }
            else {
                return 1;
            }
        });
        /* tslint:disable:no-object-literal-type-assertion */
        const segmentGroup = {
            segments: [],
        };
        const opList = [];
        let prevSeg;
        for (const segment of orderedSegments) {
            if (prevSeg !== segment) {
                segment.segmentGroups.clear();
                segment.segmentGroups.enqueue(segmentGroup);
                this.client.segmentToOps(segment, opList);
                prevSeg = segment;
            }
        }
        const groupOp = {
            ops: opList,
            type: 3 /* GROUP */,
        };
        if (groupOp.ops.length > 0) {
            this.client.mergeTree.pendingSegments.enqueue(segmentGroup);
            this.submitIfAttached(groupOp);
        }
    }
    loadContent(minimumSequenceNumber, headerOrigin, storage) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield storage.read("header");
            return this.initialize(minimumSequenceNumber, header, true, headerOrigin, storage);
        });
    }
    initializeContent() {
        const intervalCollections = this.runtime.createChannel(uuid_v4__WEBPACK_IMPORTED_MODULE_5__(), _prague_map__WEBPACK_IMPORTED_MODULE_1__["MapExtension"].Type);
        this.set("intervalCollections", intervalCollections);
        // TODO will want to update initialize to operate synchronously
        this.initialize(0, null, false, this.id, null)
            .catch((error) => {
            console.error("initializeContent", error);
        });
    }
    snapshotContent() {
        // debug(`Transforming up to ${this.deltaManager.minimumSequenceNumber}`);
        const transformedMessages = [];
        for (const message of this.messagesSinceMSNChange) {
            transformedMessages.push(this.transform(message, this.runtime.deltaManager.minimumSequenceNumber));
        }
        this.client.mergeTree.commitGlobalMin();
        const snap = new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["Snapshot"](this.client.mergeTree);
        snap.extractSync();
        const mtSnap = snap.emit();
        mtSnap.entries.push({
            mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"].File,
            path: "tardis",
            type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob],
            value: {
                contents: JSON.stringify(transformedMessages),
                encoding: "utf-8",
            },
        });
        return mtSnap;
    }
    /* tslint:disable:promise-function-async */
    prepareContent() {
        return this.loadedDeferred.promise;
    }
    processContent(message) {
        this.messagesSinceMSNChange.push(message);
        this.processMessage(message);
    }
    processMinSequenceNumberChangedContent(value) {
        let index = 0;
        for (; index < this.messagesSinceMSNChange.length; index++) {
            if (this.messagesSinceMSNChange[index].sequenceNumber > value) {
                break;
            }
        }
        if (index !== 0) {
            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);
        }
        // Apply directly once loaded - otherwise track so we can update later
        if (this.isLoaded) {
            this.client.updateMinSeq(value);
        }
        else {
            this.pendingMinSequenceNumber = value;
        }
    }
    attachContent() {
        this.client.startCollaboration(this.runtime.clientId, 0);
        this.collabStarted = true;
    }
    onConnectContent(pending) {
        // Update merge tree collaboration information with new client ID and then resend pending ops
        if (this.collabStarted) {
            this.client.updateCollaboration(this.runtime.clientId);
        }
        this.sendNACKed();
        return;
    }
    readyContent() {
        return this.loaded;
    }
    submitIfAttached(message) {
        if (this.isLocal()) {
            return;
        }
        this.submitLocalMessage(message);
    }
    processMessage(message) {
        this.client.applyMsg(message);
        if (this.client.mergeTree.minSeqPending) {
            this.client.mergeTree.notifyMinSeqListeners();
        }
    }
    transform(originalMessage, sequenceNumber) {
        let message = originalMessage;
        // Allow the distributed data types to perform custom transformations
        if (message.referenceSequenceNumber < sequenceNumber) {
            // Make a copy of original message since we will be modifying in place
            message = cloneDeep(message);
            message.contents = this.client.transform(message.contents, message.referenceSequenceNumber, sequenceNumber);
            message.referenceSequenceNumber = sequenceNumber;
        }
        return message;
    }
    loadHeader(minimumSequenceNumber, header, shared, originBranch) {
        if (!header) {
            return;
        }
        const chunk = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["Snapshot"].processChunk(header);
        const segs = this.segmentsFromSpecs(chunk.segmentTexts);
        this.client.mergeTree.reloadFromSegments(segs);
        if (shared) {
            // TODO currently only assumes two levels of branching
            const branchId = originBranch === this.runtime.documentId ? 0 : 1;
            this.collabStarted = true;
            this.client.startCollaboration(this.runtime.clientId, minimumSequenceNumber, branchId);
        }
    }
    loadBody(header, originBranch, services) {
        return __awaiter(this, void 0, void 0, function* () {
            // If loading from a snapshot load in the body and tardis messages
            if (header) {
                const [chunk, rawMessages] = yield Promise.all([
                    yield _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["Snapshot"].loadChunk(services, "body"),
                    services.read("tardis"),
                ]);
                for (const segSpec of chunk.segmentTexts) {
                    this.appendSegment(segSpec);
                }
                const messages = JSON.parse(Buffer.from(rawMessages, "base64").toString());
                if (originBranch !== this.runtime.documentId) {
                    for (const message of messages) {
                        // Append branch information when transforming for the case of messages stashed with the snapshot
                        message.origin = {
                            id: originBranch,
                            minimumSequenceNumber: message.minimumSequenceNumber,
                            sequenceNumber: message.sequenceNumber,
                        };
                    }
                }
                // Apply all pending messages
                for (const message of messages) {
                    this.processMessage(message);
                }
            }
            // And initialize the interval collections
            this.initializeIntervalCollections();
        });
    }
    initialize(minimumSequenceNumber, header, shared, originBranch, services) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!header) {
                assert__WEBPACK_IMPORTED_MODULE_4__["equal"](minimumSequenceNumber, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["Snapshot"].EmptyChunk.chunkSequenceNumber);
            }
            this.loadHeader(minimumSequenceNumber, header, shared, originBranch);
            this.loadBody(header, originBranch, services)
                .then(() => {
                this.loadFinished();
            }, (error) => {
                this.loadFinished(error);
            });
        });
    }
    initializeIntervalCollections() {
        this.intervalCollections = this.get("intervalCollections");
        // Listen and initialize new SharedIntervalCollections
        this.intervalCollections.on("valueChanged", (ev) => {
            const intervalCollection = this.intervalCollections.get(ev.key);
            if (!intervalCollection.attached) {
                intervalCollection.attach(this.client, ev.key);
            }
        });
        // Initialize existing SharedIntervalCollections
        for (const key of this.intervalCollections.keys()) {
            const intervalCollection = this.intervalCollections.get(key);
            intervalCollection.attach(this.client, key);
        }
    }
    loadFinished(error) {
        if (error) {
            this.loadedDeferred.reject(error);
        }
        else {
            this.isLoaded = true;
            this.loadedDeferred.resolve();
            // Update the MSN if larger than the set value
            if (this.pendingMinSequenceNumber > this.client.mergeTree.getCollabWindow().minSeq) {
                this.client.updateMinSeq(this.pendingMinSequenceNumber);
            }
        }
    }
}
class SharedSequence extends SegmentSequence {
    constructor(document, id, extensionType, services) {
        super(document, id, extensionType, services);
        this.id = id;
        if (extensionType === _extension__WEBPACK_IMPORTED_MODULE_6__["SharedNumberSequenceExtension"].Type) {
            this.isNumeric = true;
        }
    }
    appendSegment(segSpec) {
        const mergeTree = this.client.mergeTree;
        const pos = mergeTree.root.cachedLength;
        mergeTree.insertSegment(pos, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["UniversalSequenceNumber"], mergeTree.collabWindow.clientId, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["UniversalSequenceNumber"], _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["runToSeg"](segSpec), undefined);
    }
    insert(pos, items, props) {
        const insertMessage = {
            items,
            pos1: pos,
            props,
            type: 0 /* INSERT */,
        };
        if (this.isNumeric) {
            insertMessage.isNumberSequence = true;
        }
        const segment = new _prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["SubSequence"](items);
        this.client.insertSegmentLocal(pos, segment, props, { op: insertMessage });
        this.submitIfAttached(insertMessage);
    }
    remove(start, end) {
        this.removeRange(start, end);
    }
    getItemCount() {
        return this.client.mergeTree.getLength(this.client.getCurrentSeq(), this.client.getClientId());
    }
    // tslint:disable: no-parameter-reassignment
    getItems(start, end) {
        if (end === undefined) {
            end = this.getItemCount();
        }
        return this.client.mergeTree.getItems(this.client.getCurrentSeq(), this.client.getClientId(), start, end);
    }
    segmentsFromSpecs(segSpecs) {
        return segSpecs.map(_prague_merge_tree__WEBPACK_IMPORTED_MODULE_2__["runToSeg"]);
    }
}
class SharedObjectSequence extends SharedSequence {
    constructor(document, id, services) {
        super(document, id, _extension__WEBPACK_IMPORTED_MODULE_6__["SharedObjectSequenceExtension"].Type, services);
        this.id = id;
    }
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
class SharedNumberSequence extends SharedSequence {
    constructor(document, id, services) {
        super(document, id, _extension__WEBPACK_IMPORTED_MODULE_6__["SharedNumberSequenceExtension"].Type, services);
        this.id = id;
    }
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
//# sourceMappingURL=sequence.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/sequence/lib/sequenceDeltaEvent.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@prague/sequence/lib/sequenceDeltaEvent.js ***!
  \*****************************************************************/
/*! exports provided: SequenceDeltaEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SequenceDeltaEvent", function() { return SequenceDeltaEvent; });
/**
 * The event object returned on sequenceDelta events.
 *
 * The properties of this object and it's sub-objects represent a point in time state
 * at the time the operation was applied. They will not take into any future modifications
 *  performed to the undlying sequence and merge tree.
 *
 * For group ops, each op will get it's own event, and the group op property will be set on the op args.
 *
 * Ops may get multiple events. For instance, as insert-replace will get a remove then an insert event.
 */
class SequenceDeltaEvent {
    constructor(opArgs, mergeTreeClient, deltaArgs) {
        this.opArgs = opArgs;
        this.mergeTreeClient = mergeTreeClient;
        this.deltaArgs = deltaArgs;
        this.isLocal =
            this.deltaArgs.mergeTreeClientId ===
                this.deltaArgs.mergeTree.collabWindow.clientId;
        this.isEmpty = deltaArgs.segments.length === 0;
        this.deltaOperation = deltaArgs.operation;
        this.sortedRanges = new Lazy(() => this.deltaArgs.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : (a.ordinal > b.ordinal ? 1 : 0))
            .map((segment) => new Lazy(() => {
            const start = this.deltaArgs.mergeTree.getOffset(segment, this.deltaArgs.mergeTree.collabWindow.currentSeq, this.deltaArgs.mergeTree.collabWindow.clientId);
            return {
                segment,
                start,
            };
        })));
        this.pStart = new Lazy(() => {
            if (this.isEmpty) {
                return undefined;
            }
            return this.sortedRanges.value[0].value.start;
        });
        this.pEnd = new Lazy(() => {
            if (this.isEmpty) {
                return undefined;
            }
            const lastRange = this.sortedRanges.value[this.sortedRanges.value.length - 1].value;
            return lastRange.start + lastRange.segment.cachedLength;
        });
        this.pClientId = new Lazy(() => this.mergeTreeClient.getLongClientId(this.deltaArgs.mergeTreeClientId));
        this.pRanges = new Lazy(() => {
            const ranges = [];
            if (this.isEmpty) {
                return ranges;
            }
            let segments;
            let start;
            let length;
            let type;
            for (const segment of this.sortedRanges.value) {
                const nextStart = segment.value.start;
                const nextLength = segment.value.segment.cachedLength;
                const nextType = segment.value.segment.getType();
                let currentPosition = start;
                // for remove don't add the length, since getOffset won't include it
                if (this.deltaArgs.operation !== 1 /* REMOVE */) {
                    currentPosition += length;
                }
                if (type !== nextType || currentPosition !== nextStart) {
                    // don't push if the first segment
                    if (segments) {
                        ranges.push({
                            length,
                            segments,
                            start,
                            type,
                        });
                    }
                    segments = [segment.value.segment];
                    start = nextStart;
                    length = nextLength;
                    type = nextType;
                }
                else {
                    segments.push(segment.value.segment);
                    length += nextLength;
                }
            }
            ranges.push({
                length,
                segments,
                start,
                type,
            });
            return ranges;
        });
    }
    get start() {
        return this.pStart.value;
    }
    get end() {
        return this.pEnd.value;
    }
    get clientId() {
        return this.pClientId.value;
    }
    get ranges() {
        return this.pRanges.value;
    }
}
class Lazy {
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this.pEvaluated = false;
    }
    get evaluated() {
        return this.pEvaluated;
    }
    get value() {
        if (!this.pEvaluated) {
            this.pEvaluated = true;
            this.pValue = this.valueGenerator();
        }
        return this.pValue;
    }
}
//# sourceMappingURL=sequenceDeltaEvent.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/lib/sharedString.js":
/*!***********************************************************!*\
  !*** ./node_modules/@prague/sequence/lib/sharedString.js ***!
  \***********************************************************/
/*! exports provided: SharedString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedString", function() { return SharedString; });
/* harmony import */ var _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/merge-tree */ "./node_modules/@prague/merge-tree/lib/index.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/sequence/lib/extension.js");
/* harmony import */ var _sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sequence */ "./node_modules/@prague/sequence/lib/sequence.js");
// tslint:disable:whitespace align no-bitwise



function textsToSegments(texts) {
    const segments = [];
    for (const ptext of texts) {
        let segment;
        if (ptext.text !== undefined) {
            segment = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["TextSegment"].make(ptext.text, ptext.props, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["LocalClientId"]);
        }
        else {
            // for now assume marker
            segment = _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["Marker"].make(ptext.marker.refType, ptext.props, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["LocalClientId"]);
        }
        segments.push(segment);
    }
    return segments;
}
class SharedString extends _sequence__WEBPACK_IMPORTED_MODULE_2__["SegmentSequence"] {
    constructor(document, id, services) {
        super(document, id, _extension__WEBPACK_IMPORTED_MODULE_1__["SharedStringExtension"].Type, services);
        this.id = id;
    }
    appendSegment(segSpec) {
        const mergeTree = this.client.mergeTree;
        const pos = mergeTree.root.cachedLength;
        if (segSpec.text) {
            mergeTree.insertText(pos, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], mergeTree.collabWindow.clientId, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], segSpec.text, segSpec.props, undefined);
        }
        else {
            // assume marker for now
            mergeTree.insertMarker(pos, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], mergeTree.collabWindow.clientId, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], segSpec.marker.refType, segSpec.props, undefined);
        }
    }
    segmentsFromSpecs(segSpecs) {
        return textsToSegments(segSpecs);
    }
    insertMarkerRelative(relativePos1, refType, props) {
        const insertMessage = {
            marker: { refType },
            props,
            relativePos1,
            type: 0 /* INSERT */,
        };
        const pos = this.client.mergeTree.posFromRelativePos(relativePos1);
        this.client.insertMarkerLocal(pos, refType, props, { op: insertMessage });
        this.submitIfAttached(insertMessage);
    }
    insertMarker(pos, refType, props) {
        const insertMessage = {
            marker: { refType },
            pos1: pos,
            props,
            type: 0 /* INSERT */,
        };
        this.client.insertMarkerLocal(pos, refType, props, { op: insertMessage });
        this.submitIfAttached(insertMessage);
    }
    getText(start, end) {
        return this.client.getText(start, end);
    }
    insertTextRelative(relativePos1, text, props) {
        const insertMessage = {
            props,
            relativePos1,
            text,
            type: 0 /* INSERT */,
        };
        const pos = this.client.mergeTree.posFromRelativePos(relativePos1);
        this.client.insertTextLocal(text, pos, props, { op: insertMessage });
        this.submitIfAttached(insertMessage);
    }
    insertText(text, pos, props) {
        const insertMessage = {
            pos1: pos,
            props,
            text,
            type: 0 /* INSERT */,
        };
        this.client.insertTextLocal(text, pos, props, { op: insertMessage });
        this.submitIfAttached(insertMessage);
    }
    replaceText(text, start, end, props) {
        const insertMessage = {
            pos1: start,
            pos2: end,
            props,
            text,
            type: 0 /* INSERT */,
        };
        this.client.mergeTree.startGroupOperation();
        this.client.removeSegmentLocal(start, end, { op: insertMessage });
        this.client.insertTextLocal(text, start, props, { op: insertMessage });
        this.client.mergeTree.endGroupOperation();
        this.submitIfAttached(insertMessage);
    }
    removeNest(nestStart, nestEnd) {
        const start = this.client.mergeTree.getOffset(nestStart, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], this.client.getClientId());
        const end = nestEnd.cachedLength + this.client.mergeTree.getOffset(nestEnd, _prague_merge_tree__WEBPACK_IMPORTED_MODULE_0__["UniversalSequenceNumber"], this.client.getClientId());
        console.log(`removing nest ${nestStart.getId()} from [${start},${end})`);
        const removeMessage = {
            checkNest: { id1: nestStart.getId(), id2: nestEnd.getId() },
            pos1: start,
            pos2: end,
            type: 1 /* REMOVE */,
        };
        this.client.removeSegmentLocal(start, end, { op: removeMessage });
        this.submitIfAttached(removeMessage);
    }
    removeText(start, end) {
        this.removeRange(start, end);
    }
    annotateRangeFromPast(props, start, end, fromSeq) {
        const ranges = this.client.mergeTree.tardisRange(start, end, fromSeq, this.client.getCurrentSeq(), this.client.getClientId());
        ranges.map((range) => {
            this.annotateRange(props, range.start, range.end);
        });
    }
    annotateMarkerNotifyConsensus(marker, props, callback) {
        const id = marker.getId();
        const annotateMessage = {
            combiningOp: { name: "consensus" },
            props,
            relativePos1: { id, before: true },
            relativePos2: { id },
            type: 2 /* ANNOTATE */,
        };
        this.client.annotateMarkerNotifyConsensus(marker, props, callback, { op: annotateMessage });
        this.submitIfAttached(annotateMessage);
    }
    annotateMarker(props, marker, op) {
        const id = marker.getId();
        const annotateMessage = {
            props,
            relativePos1: { id, before: true },
            relativePos2: { id },
            type: 2 /* ANNOTATE */,
        };
        if (op) {
            annotateMessage.combiningOp = op;
        }
        this.client.annotateMarker(props, marker, op, { op: annotateMessage });
        this.submitIfAttached(annotateMessage);
    }
    findTile(startPos, tileLabel, preceding = true) {
        return this.client.findTile(startPos, tileLabel, preceding);
    }
}
//# sourceMappingURL=sharedString.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/batchManager.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/batchManager.js ***!
  \**************************************************************************************/
/*! exports provided: BatchManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchManager", function() { return BatchManager; });
const MaxBatchSize = 100;
class BatchManager {
    constructor(process) {
        this.process = process;
        this.pendingWork = new Map();
    }
    add(id, work) {
        if (!this.pendingWork.has(id)) {
            this.pendingWork.set(id, []);
        }
        this.pendingWork.get(id)
            .push(work);
        if (this.pendingWork.get(id).length >= MaxBatchSize) {
            clearTimeout(this.pendingTimer);
            this.pendingTimer = undefined;
            this.startWork();
        }
        else if (this.pendingTimer === undefined) {
            this.pendingTimer = setTimeout(() => {
                this.pendingTimer = undefined;
                this.startWork();
            }, 0);
        }
    }
    /**
     * Resolves once all pending work is complete
     */
    drain() {
        this.startWork();
    }
    startWork() {
        // Clear the internal flags first to avoid issues in case any of the pending work calls back into
        // the batch manager. We could also do this with a second setImmediate call but avodiing in order
        // to process the work quicker.
        const pendingWork = this.pendingWork;
        this.pendingWork = new Map();
        // TODO log to influx how much pending work there is. We want to limit the size of a batch
        for (const [id, batch] of pendingWork) {
            this.process(id, batch);
        }
    }
}
//# sourceMappingURL=batchManager.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/blobs.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/blobs.js ***!
  \*******************************************************************************/
/*! exports provided: gitHashFile, flatten, readAndParse, buildHierarchy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gitHashFile", function() { return gitHashFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readAndParse", function() { return readAndParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildHierarchy", function() { return buildHierarchy; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sha.js/sha1 */ "./node_modules/sha.js/sha1.js");
/* harmony import */ var sha_js_sha1__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

// tslint:disable-next-line:no-submodule-imports

/**
 * Create Hash (Github hashes the string with blob and size)
 * @param file The contents of the file in a buffer
 */
function gitHashFile(file) {
    const size = file.byteLength;
    const filePrefix = "blob " + size.toString() + String.fromCharCode(0);
    /* tslint:disable:no-unsafe-any */
    const engine = new sha_js_sha1__WEBPACK_IMPORTED_MODULE_1__();
    return engine.update(filePrefix)
        .update(file)
        .digest("hex");
}
function flatten(tree, blobMap) {
    const entries = flattenCore("", tree, blobMap);
    return {
        sha: null,
        tree: entries,
        url: null,
    };
}
function readAndParse(storage, sha) {
    return __awaiter(this, void 0, void 0, function* () {
        const encoded = yield storage.read(sha);
        const decoded = Buffer
            .from(encoded, "base64")
            .toString();
        return JSON.parse(decoded);
    });
}
function flattenCore(path, treeEntries, blobMap) {
    const entries = new Array();
    for (const treeEntry of treeEntries) {
        const subPath = `${path}${treeEntry.path}`;
        if (treeEntry.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob]) {
            const blob = treeEntry.value;
            const buffer = Buffer.from(blob.contents, blob.encoding);
            const sha = gitHashFile(buffer);
            blobMap.set(sha, buffer.toString("base64"));
            const entry = {
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"][treeEntry.mode],
                path: subPath,
                sha,
                size: buffer.length,
                type: "blob",
                url: "",
            };
            entries.push(entry);
        }
        else {
            const t = treeEntry.value;
            const entry = {
                mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"][treeEntry.mode],
                path: subPath,
                sha: null,
                size: -1,
                type: "tree",
                url: "",
            };
            entries.push(entry);
            const subTreeEntries = flattenCore(subPath + "/", t.entries, blobMap);
            entries.push(...subTreeEntries);
        }
    }
    return entries;
}
function buildHierarchy(flatTree) {
    if (!flatTree) {
        return null;
    }
    const lookup = {};
    const root = { sha: flatTree.sha, blobs: {}, commits: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.tree) {
        const lastIndex = entry.path.lastIndexOf("/");
        const entryPathDir = entry.path.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entry.path.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { sha: entry.sha, blobs: {}, commits: {}, trees: {} };
            node.trees[entryPathBase] = newTree;
            lookup[entry.path] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[entryPathBase] = entry.sha;
        }
        else if (entry.type === "commit") {
            node.commits[entryPathBase] = entry.sha;
        }
    }
    return root;
}
//# sourceMappingURL=blobs.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/heap.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/heap.js ***!
  \******************************************************************************/
/*! exports provided: NumberComparer, Heap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberComparer", function() { return NumberComparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return Heap; });
// tslint:disable:no-bitwise
// tslint:disable:no-increment-decrement
// tslint:disable:no-parameter-reassignment
const NumberComparer = {
    compare: (a, b) => a - b,
    min: Number.MIN_VALUE,
};
class Heap {
    constructor(comp) {
        this.comp = comp;
        this.L = [{ value: comp.min, position: 0 }];
    }
    peek() {
        return this.L[1];
    }
    get() {
        this.swap(1, this.count());
        const x = this.L.pop();
        this.fixdown(1);
        return x.value;
    }
    add(x) {
        const node = { value: x, position: this.L.length };
        this.L.push(node);
        this.fixup(this.count());
        return node;
    }
    /**
     * Allows for heap to be updated after a node's value changes
     */
    update(node) {
        const k = node.position;
        if (this.isGreaterThanParent(k)) {
            this.fixup(k);
        }
        else {
            this.fixdown(k);
        }
    }
    /**
     * Removes the given node from the heap
     */
    remove(node) {
        // Move the node we want to remove to the end of the array
        const position = node.position;
        this.swap(node.position, this.L.length - 1);
        this.L.splice(this.L.length - 1);
        // Update the swapped node assuming we didn't remove the end of the list
        if (position !== this.L.length) {
            this.update(this.L[position]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    fixup(k) {
        while (this.isGreaterThanParent(k)) {
            const parent = k >> 1;
            this.swap(k, parent);
            k = parent;
        }
    }
    isGreaterThanParent(k) {
        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);
    }
    fixdown(k) {
        while ((k << 1) <= this.count()) {
            let j = k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {
                break;
            }
            this.swap(k, j);
            k = j;
        }
    }
    swap(k, j) {
        const tmp = this.L[k];
        this.L[k] = this.L[j];
        this.L[k].position = k;
        this.L[j] = tmp;
        this.L[j].position = j;
    }
}
//# sourceMappingURL=heap.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/index.js ***!
  \*******************************************************************************/
/*! exports provided: BatchManager, gitHashFile, flatten, readAndParse, buildHierarchy, NumberComparer, Heap, Deferred, assertNotRejected, RangeTracker, RateLimitter, safelyParseJSON, isSystemType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _batchManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batchManager */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/batchManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchManager", function() { return _batchManager__WEBPACK_IMPORTED_MODULE_0__["BatchManager"]; });

/* harmony import */ var _blobs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blobs */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/blobs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gitHashFile", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["gitHashFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["flatten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readAndParse", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["readAndParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildHierarchy", function() { return _blobs__WEBPACK_IMPORTED_MODULE_1__["buildHierarchy"]; });

/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./heap */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/heap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberComparer", function() { return _heap__WEBPACK_IMPORTED_MODULE_2__["NumberComparer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heap", function() { return _heap__WEBPACK_IMPORTED_MODULE_2__["Heap"]; });

/* harmony import */ var _promises__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./promises */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/promises.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Deferred", function() { return _promises__WEBPACK_IMPORTED_MODULE_3__["Deferred"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertNotRejected", function() { return _promises__WEBPACK_IMPORTED_MODULE_3__["assertNotRejected"]; });

/* harmony import */ var _rangeTracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rangeTracker */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/rangeTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RangeTracker", function() { return _rangeTracker__WEBPACK_IMPORTED_MODULE_4__["RangeTracker"]; });

/* harmony import */ var _rateLimitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rateLimitter */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/rateLimitter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RateLimitter", function() { return _rateLimitter__WEBPACK_IMPORTED_MODULE_5__["RateLimitter"]; });

/* harmony import */ var _safeParser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./safeParser */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/safeParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "safelyParseJSON", function() { return _safeParser__WEBPACK_IMPORTED_MODULE_6__["safelyParseJSON"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSystemType", function() { return _utils__WEBPACK_IMPORTED_MODULE_7__["isSystemType"]; });









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/promises.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/promises.js ***!
  \**********************************************************************************/
/*! exports provided: Deferred, assertNotRejected */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deferred", function() { return Deferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertNotRejected", function() { return assertNotRejected; });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_0__);

/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        /* tslint:disable:promise-must-complete */
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Retrieves the underlying promise for the deferred
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     */
    resolve(value) {
        this.res(value);
    }
    /**
     * Rejects the promise
     */
    reject(error) {
        this.rej(error);
    }
}
/**
 * Helper function that asserts that the given promise only resolves
 */
/* tslint:disable:promise-function-async */
function assertNotRejected(promise) {
    // Assert that the given promise only resolves
    promise.catch((error) => {
        assert__WEBPACK_IMPORTED_MODULE_0__["ok"](false);
    });
    return promise;
}
//# sourceMappingURL=promises.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/rangeTracker.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/rangeTracker.js ***!
  \**************************************************************************************/
/*! exports provided: RangeTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeTracker", function() { return RangeTracker; });
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_0__);

// tslint:disable:no-var-requires
// tslint:disable-next-line:no-submodule-imports
const cloneDeep = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/**
 * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary
 * is continuous and always maps to a single value in secondary above the base value. The range
 * defines an increasing step function.
 */
class RangeTracker {
    get base() {
        return this.ranges[0].primary;
    }
    get primaryHead() {
        return this.lastPrimary;
    }
    get secondaryHead() {
        return this.lastSecondary;
    }
    constructor(primary, secondary) {
        if (typeof primary === "number") {
            this.ranges = [{ length: 0, primary, secondary }];
            this.lastPrimary = primary;
            this.lastSecondary = secondary;
        }
        else {
            /* tslint:disable:no-unsafe-any */
            this.ranges = cloneDeep(primary.ranges);
            this.lastPrimary = primary.lastPrimary;
            this.lastSecondary = primary.lastSecondary;
        }
    }
    /**
     * Returns a serialized form of the RangeTracker
     */
    serialize() {
        return {
            lastPrimary: this.lastPrimary,
            lastSecondary: this.lastSecondary,
            ranges: cloneDeep(this.ranges),
        };
    }
    // primary is time - secondary is the MSN
    add(primary, secondary) {
        // Both values must continuously be increasing - we won't always track the last value we saw so we do so
        // below to check invariants
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.lastPrimary);
        assert__WEBPACK_IMPORTED_MODULE_0__(secondary >= this.lastSecondary);
        this.lastPrimary = primary;
        this.lastSecondary = secondary;
        // Get quicker references to the head of the range
        const head = this.ranges[this.ranges.length - 1];
        const primaryHead = head.primary + head.length;
        const secondaryHead = head.secondary + head.length;
        // Same secondary indicates this is not a true inflection point - we can ignore it
        if (secondary === secondaryHead) {
            return;
        }
        // New secondary - need to update the ranges
        if (primary === primaryHead) {
            // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to
            // preserve 1:N since you can only lookup from the primary to a secondary
            if (head.length === 0) {
                // No range represented - we can simply update secondary with the overwritten value
                head.secondary = secondary;
            }
            else {
                // The values in the range before this one are valid - but we need to create a new one for this update
                // tslint:disable-next-line:no-increment-decrement
                head.length--;
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
        else {
            if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {
                // extend the length if both increase by the same amount
                // tslint:disable-next-line:no-increment-decrement
                head.length++;
            }
            else {
                // Insert a new node
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
    }
    get(primary) {
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[0].primary);
        // Find the first range where the starting position is greater than the primary. Our target range is
        // the one before it.
        let index = 1;
        // tslint:disable-next-line:no-increment-decrement
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[index - 1].primary);
        // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest
        // stored secondary value to use.
        const closestRange = this.ranges[index - 1];
        return Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary;
    }
    updateBase(primary) {
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[0].primary);
        // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the
        // previous index by definition (since it's less than the current index's primary but greather than the
        // previous index's primary) and we know primary must be greater than the base.
        let index = 1;
        // tslint:disable-next-line:no-increment-decrement
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert__WEBPACK_IMPORTED_MODULE_0__(primary >= this.ranges[index - 1].primary);
        // Update the last range values
        const range = this.ranges[index - 1];
        const delta = primary - range.primary;
        range.secondary = range.secondary + Math.min(delta, range.length);
        range.length = Math.max(range.length - delta, 0);
        range.primary = primary;
        // And remove unnecessary ranges
        this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;
        // assert that the lowest value is now the input to this method
        assert__WEBPACK_IMPORTED_MODULE_0__["equal"](primary, this.ranges[0].primary);
    }
}
//# sourceMappingURL=rangeTracker.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/rateLimitter.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/rateLimitter.js ***!
  \**************************************************************************************/
/*! exports provided: RateLimitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RateLimitter", function() { return RateLimitter; });
// A rate limiter to make sure that a client can only request help for one task within a time window.
class RateLimitter {
    constructor(windowMSec) {
        this.windowMSec = windowMSec;
        this.requestMap = new Map();
    }
    filter(clientId, messages) {
        const approvedList = [];
        const currentTime = Date.now();
        for (const message of messages) {
            const key = `${clientId}/${message}`;
            if (!this.requestMap.has(key)) {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
            else if (this.requestMap.get(key) + this.windowMSec > currentTime) {
                continue;
            }
            else {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
        }
        return approvedList;
    }
}
//# sourceMappingURL=rateLimitter.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/safeParser.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/safeParser.js ***!
  \************************************************************************************/
/*! exports provided: safelyParseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "safelyParseJSON", function() { return safelyParseJSON; });
function safelyParseJSON(json) {
    let parsed;
    try {
        parsed = JSON.parse(json);
    }
    catch (e) {
        //
    }
    return parsed;
}
//# sourceMappingURL=safeParser.js.map

/***/ }),

/***/ "./node_modules/@prague/sequence/node_modules/@prague/utils/lib/utils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@prague/sequence/node_modules/@prague/utils/lib/utils.js ***!
  \*******************************************************************************/
/*! exports provided: isSystemType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSystemType", function() { return isSystemType; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);

function isSystemType(type) {
    return (type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].RemoteHelp ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Integrate ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].ClientJoin ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].ClientLeave ||
        type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Fork);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@prague/stream/lib/extension.js":
/*!******************************************************!*\
  !*** ./node_modules/@prague/stream/lib/extension.js ***!
  \******************************************************/
/*! exports provided: StreamExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamExtension", function() { return StreamExtension; });
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stream */ "./node_modules/@prague/stream/lib/stream.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class StreamExtension {
    constructor() {
        this.type = StreamExtension.Type;
    }
    load(runtime, id, minimumSequenceNumber, services, headerOrigin) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = new _stream__WEBPACK_IMPORTED_MODULE_0__["Stream"](runtime, id);
            yield stream.load(minimumSequenceNumber, headerOrigin, services);
            return stream;
        });
    }
    create(runtime, id) {
        const stream = new _stream__WEBPACK_IMPORTED_MODULE_0__["Stream"](runtime, id);
        stream.initializeLocal();
        return stream;
    }
}
StreamExtension.Type = "https://graph.microsoft.com/types/stream";
//# sourceMappingURL=extension.js.map

/***/ }),

/***/ "./node_modules/@prague/stream/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@prague/stream/lib/index.js ***!
  \**************************************************/
/*! exports provided: StreamExtension, Delta, getActionType, getStylusAction, getStylusId, ActionType, Snapshot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/stream/lib/extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StreamExtension", function() { return _extension__WEBPACK_IMPORTED_MODULE_0__["StreamExtension"]; });

/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interfaces */ "./node_modules/@prague/stream/lib/interfaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Delta", function() { return _interfaces__WEBPACK_IMPORTED_MODULE_1__["Delta"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getActionType", function() { return _interfaces__WEBPACK_IMPORTED_MODULE_1__["getActionType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStylusAction", function() { return _interfaces__WEBPACK_IMPORTED_MODULE_1__["getStylusAction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStylusId", function() { return _interfaces__WEBPACK_IMPORTED_MODULE_1__["getStylusId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActionType", function() { return _interfaces__WEBPACK_IMPORTED_MODULE_1__["ActionType"]; });

/* harmony import */ var _snapshot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./snapshot */ "./node_modules/@prague/stream/lib/snapshot.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snapshot", function() { return _snapshot__WEBPACK_IMPORTED_MODULE_2__["Snapshot"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@prague/stream/lib/interfaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/@prague/stream/lib/interfaces.js ***!
  \*******************************************************/
/*! exports provided: Delta, getActionType, getStylusAction, getStylusId, ActionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Delta", function() { return Delta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionType", function() { return getActionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStylusAction", function() { return getStylusAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStylusId", function() { return getStylusId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionType", function() { return ActionType; });
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js");
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid_v4__WEBPACK_IMPORTED_MODULE_0__);
// tslint:disable-next-line:no-submodule-imports

/**
 * Fluent implementation of the IDelta interface to make creation the underlying operation easier.
 * Only one operation per delta is currently supported but it's expected this will expand to multiple in
 * the future
 */
class Delta {
    constructor(operations = []) {
        this.operations = operations;
    }
    /**
     * Composes two ink delta streams together - which is as simple as appending their operation
     * logs
     */
    compose(delta) {
        this.operations = this.operations.concat(delta.operations);
    }
    push(operation) {
        this.operations.push(operation);
    }
    clear(time = new Date().getTime()) {
        const clear = {};
        this.operations.push({ clear, time });
        return this;
    }
    stylusUp(point, pressure, id = uuid_v4__WEBPACK_IMPORTED_MODULE_0__(), time = new Date().getTime()) {
        const stylusUp = {
            id,
            point,
            pressure,
        };
        this.operations.push({ stylusUp, time });
        return this;
    }
    stylusDown(point, pressure, pen, layer = 0, id = uuid_v4__WEBPACK_IMPORTED_MODULE_0__(), time = new Date().getTime()) {
        const stylusDown = {
            id,
            layer,
            pen,
            point,
            pressure,
        };
        this.operations.push({ stylusDown, time });
        return this;
    }
    stylusMove(point, pressure, id = uuid_v4__WEBPACK_IMPORTED_MODULE_0__(), time = new Date().getTime()) {
        const stylusMove = {
            id,
            point,
            pressure,
        };
        this.operations.push({ stylusMove, time });
        return this;
    }
}
/**
 * Retrieves the type of action contained within the operation
 */
function getActionType(operation) {
    if (operation.clear) {
        return ActionType.Clear;
    }
    else if (operation.stylusDown) {
        return ActionType.StylusDown;
    }
    else if (operation.stylusUp) {
        return ActionType.StylusUp;
    }
    else if (operation.stylusMove) {
        return ActionType.StylusMove;
    }
    else {
        throw new Error("Unknown action");
    }
}
/**
 * Extracts the IStylusAction contained in the operation
 */
function getStylusAction(operation) {
    if (operation.stylusDown) {
        return operation.stylusDown;
    }
    else if (operation.stylusUp) {
        return operation.stylusUp;
    }
    else if (operation.stylusMove) {
        return operation.stylusMove;
    }
    else {
        throw new Error("Unknown action");
    }
}
/**
 * Helper function to retrieve the ID of the stylus operation
 */
function getStylusId(operation) {
    const type = getActionType(operation);
    switch (type) {
        case ActionType.StylusDown:
            return operation.stylusDown.id;
        case ActionType.StylusUp:
            return operation.stylusUp.id;
        case ActionType.StylusMove:
            return operation.stylusMove.id;
        default:
            throw new Error("Non-stylus event");
    }
}
var ActionType;
(function (ActionType) {
    // Action of placing the stylus on the canvas
    ActionType[ActionType["StylusDown"] = 0] = "StylusDown";
    // Action of picking the stylus up from the canvas
    ActionType[ActionType["StylusUp"] = 1] = "StylusUp";
    // Stylus has moved on the canvas
    ActionType[ActionType["StylusMove"] = 2] = "StylusMove";
    // Canvas has been cleared
    ActionType[ActionType["Clear"] = 3] = "Clear";
})(ActionType || (ActionType = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ "./node_modules/@prague/stream/lib/snapshot.js":
/*!*****************************************************!*\
  !*** ./node_modules/@prague/stream/lib/snapshot.js ***!
  \*****************************************************/
/*! exports provided: Snapshot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Snapshot", function() { return Snapshot; });
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interfaces */ "./node_modules/@prague/stream/lib/interfaces.js");

class Snapshot {
    constructor(layers = [], layerIndex = {}) {
        this.layers = layers;
        this.layerIndex = layerIndex;
    }
    static Clone(snapshot) {
        return new Snapshot(snapshot.layers, snapshot.layerIndex);
    }
    apply(delta) {
        for (const operation of delta.operations) {
            this.applyOperation(operation);
        }
    }
    applyOperation(operation) {
        const actionType = Object(_interfaces__WEBPACK_IMPORTED_MODULE_0__["getActionType"])(operation);
        switch (actionType) {
            case _interfaces__WEBPACK_IMPORTED_MODULE_0__["ActionType"].Clear:
                this.processClearAction(operation);
                break;
            case _interfaces__WEBPACK_IMPORTED_MODULE_0__["ActionType"].StylusUp:
                this.processStylusUpAction(operation);
                break;
            case _interfaces__WEBPACK_IMPORTED_MODULE_0__["ActionType"].StylusDown:
                this.processStylusDownAction(operation);
                break;
            case _interfaces__WEBPACK_IMPORTED_MODULE_0__["ActionType"].StylusMove:
                this.processStylusMoveAction(operation);
                break;
            default:
                throw new Error("Unknown action type");
        }
    }
    processClearAction(operation) {
        this.layers = [];
        this.layerIndex = {};
    }
    processStylusUpAction(operation) {
        // TODO - longer term on ink up - or possibly earlier - we can attempt to smooth the provided ink
        this.addOperationToLayer(operation.stylusUp.id, operation);
    }
    processStylusDownAction(operation) {
        const layer = {
            id: operation.stylusDown.id,
            operations: [],
        };
        // Push if we are isnerting at the end - otherwise splice to insert at the specified location
        if (operation.stylusDown.layer === 0) {
            this.layers.push(layer);
        }
        else {
            this.layers.splice(this.layers.length - operation.stylusDown.layer, 0, layer);
        }
        // Create a reference to the specified layer
        let layerIndex = this.layers.length - 1 - operation.stylusDown.layer;
        this.layerIndex[layer.id] = layerIndex;
        // And move any after it down by one
        // tslint:disable-next-line:no-increment-decrement
        for (layerIndex = layerIndex + 1; layerIndex < this.layers.length; layerIndex++) {
            const layerId = this.layers[layerIndex].id;
            this.layerIndex[layerId] = this.layerIndex[layerId] + 1;
        }
        // And save the stylus down
        this.addOperationToLayer(operation.stylusDown.id, operation);
    }
    processStylusMoveAction(operation) {
        this.addOperationToLayer(operation.stylusMove.id, operation);
    }
    addOperationToLayer(id, operation) {
        // TODO: Why is this operation sometimes undefined?
        if (this.layerIndex[id] !== undefined) {
            const layerIndex = this.layerIndex[id];
            if (this.layers[layerIndex].operations === undefined) {
                this.layers[layerIndex].operations = [];
            }
            this.layers[layerIndex].operations.push(operation);
        }
    }
}
//# sourceMappingURL=snapshot.js.map

/***/ }),

/***/ "./node_modules/@prague/stream/lib/stream.js":
/*!***************************************************!*\
  !*** ./node_modules/@prague/stream/lib/stream.js ***!
  \***************************************************/
/*! exports provided: Stream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stream", function() { return Stream; });
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/container-definitions */ "./node_modules/@prague/container-definitions/dist/index.js");
/* harmony import */ var _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _prague_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/map */ "./node_modules/@prague/map/lib/index.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extension */ "./node_modules/@prague/stream/lib/extension.js");
/* harmony import */ var _snapshot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./snapshot */ "./node_modules/@prague/stream/lib/snapshot.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




const snapshotFileName = "header";
const emptySnapshot = { layers: [], layerIndex: {} };
class Stream extends _prague_map__WEBPACK_IMPORTED_MODULE_1__["SharedMap"] {
    constructor(runtime, id) {
        super(id, runtime, _extension__WEBPACK_IMPORTED_MODULE_2__["StreamExtension"].Type);
    }
    getLayers() {
        return this.inkSnapshot.layers;
    }
    getLayer(key) {
        return this.inkSnapshot.layers[this.inkSnapshot.layerIndex[key]];
    }
    submitOp(op) {
        this.submitLocalMessage(op);
        this.inkSnapshot.apply(op);
    }
    loadContent(minimumSequenceNumber, headerOrigin, storage) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield storage.read(snapshotFileName);
            /* tslint:disable:no-unsafe-any */
            const data = header
                ? JSON.parse(Buffer.from(header, "base64")
                    .toString("utf-8"))
                : emptySnapshot;
            this.initialize(data);
        });
    }
    initializeContent() {
        this.initialize(emptySnapshot);
    }
    snapshotContent() {
        const tree = {
            entries: [
                {
                    mode: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["FileMode"].File,
                    path: snapshotFileName,
                    type: _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"][_prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["TreeEntry"].Blob],
                    value: {
                        contents: JSON.stringify(this.inkSnapshot),
                        encoding: "utf-8",
                    },
                },
            ],
            sha: null,
        };
        return tree;
    }
    processContent(message, local) {
        if (message.type === _prague_container_definitions__WEBPACK_IMPORTED_MODULE_0__["MessageType"].Operation && !local) {
            this.inkSnapshot.apply(message.contents);
        }
    }
    onConnectContent(pending) {
        // Stream can resend messages under new client id
        for (const message of pending) {
            this.submitLocalMessage(message);
        }
        return;
    }
    initialize(data) {
        this.inkSnapshot = _snapshot__WEBPACK_IMPORTED_MODULE_3__["Snapshot"].Clone(data);
    }
}
//# sourceMappingURL=stream.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/buffer/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;



/***/ }),

/***/ "./node_modules/double-ended-queue/js/deque.js":
/*!*****************************************************!*\
  !*** ./node_modules/double-ended-queue/js/deque.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

function Deque(capacity) {
    this._capacity = getCapacity(capacity);
    this._length = 0;
    this._front = 0;
    if (isArray(capacity)) {
        var len = capacity.length;
        for (var i = 0; i < len; ++i) {
            this[i] = capacity[i];
        }
        this._length = len;
    }
}

Deque.prototype.toArray = function Deque$toArray() {
    var len = this._length;
    var ret = new Array(len);
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        ret[j] = this[(front + j) & (capacity - 1)];
    }
    return ret;
};

Deque.prototype.push = function Deque$push(item) {
    var argsLength = arguments.length;
    var length = this._length;
    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = (this._front + length) & (this._capacity - 1);
                this[j] = arguments[i];
                length++;
                this._length = length;
            }
            return length;
        }
        else {
            var j = this._front;
            for (var i = 0; i < argsLength; ++i) {
                this[(j + length) & (capacity - 1)] = arguments[i];
                j++;
            }
            this._length = length + argsLength;
            return length + argsLength;
        }

    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = item;
    this._length = length + 1;
    return length + 1;
};

Deque.prototype.pop = function Deque$pop() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var i = (this._front + length - 1) & (this._capacity - 1);
    var ret = this[i];
    this[i] = void 0;
    this._length = length - 1;
    return ret;
};

Deque.prototype.shift = function Deque$shift() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var front = this._front;
    var ret = this[front];
    this[front] = void 0;
    this._front = (front + 1) & (this._capacity - 1);
    this._length = length - 1;
    return ret;
};

Deque.prototype.unshift = function Deque$unshift(item) {
    var length = this._length;
    var argsLength = arguments.length;


    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (((( this._front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
            }
            return length;
        }
        else {
            var front = this._front;
            for (var i = argsLength - 1; i >= 0; i--) {
                var j = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                front = j;
            }
            this._front = front;
            this._length = length + argsLength;
            return length + argsLength;
        }
    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var capacity = this._capacity;
    var i = (((( this._front - 1 ) &
        ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = item;
    this._length = length + 1;
    this._front = i;
    return length + 1;
};

Deque.prototype.peekBack = function Deque$peekBack() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var index = (this._front + length - 1) & (this._capacity - 1);
    return this[index];
};

Deque.prototype.peekFront = function Deque$peekFront() {
    if (this._length === 0) {
        return void 0;
    }
    return this[this._front];
};

Deque.prototype.get = function Deque$get(index) {
    var i = index;
    if ((i !== (i | 0))) {
        return void 0;
    }
    var len = this._length;
    if (i < 0) {
        i = i + len;
    }
    if (i < 0 || i >= len) {
        return void 0;
    }
    return this[(this._front + i) & (this._capacity - 1)];
};

Deque.prototype.isEmpty = function Deque$isEmpty() {
    return this._length === 0;
};

Deque.prototype.clear = function Deque$clear() {
    var len = this._length;
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        this[(front + j) & (capacity - 1)] = void 0;
    }
    this._length = 0;
    this._front = 0;
};

Deque.prototype.toString = function Deque$toString() {
    return this.toArray().toString();
};

Deque.prototype.valueOf = Deque.prototype.toString;
Deque.prototype.removeFront = Deque.prototype.shift;
Deque.prototype.removeBack = Deque.prototype.pop;
Deque.prototype.insertFront = Deque.prototype.unshift;
Deque.prototype.insertBack = Deque.prototype.push;
Deque.prototype.enqueue = Deque.prototype.push;
Deque.prototype.dequeue = Deque.prototype.shift;
Deque.prototype.toJSON = Deque.prototype.toArray;

Object.defineProperty(Deque.prototype, "length", {
    get: function() {
        return this._length;
    },
    set: function() {
        throw new RangeError("");
    }
});

Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
    if (this._capacity < size) {
        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
    }
};

Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    if (front + length > oldCapacity) {
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    }
};


var isArray = Array.isArray;

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}

function getCapacity(capacity) {
    if (typeof capacity !== "number") {
        if (isArray(capacity)) {
            capacity = capacity.length;
        }
        else {
            return 16;
        }
    }
    return pow2AtLeast(
        Math.min(
            Math.max(16, capacity), 1073741824)
    );
}

module.exports = Deque;


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: Clicker, instantiateRuntime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clicker", function() { return Clicker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instantiateRuntime", function() { return instantiateRuntime; });
/* harmony import */ var _prague_app_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prague/app-component */ "./node_modules/@prague/app-component/lib/index.js");
/* harmony import */ var _prague_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @prague/map */ "./node_modules/@prague/map/lib/index.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


class Clicker extends _prague_app_component__WEBPACK_IMPORTED_MODULE_0__["Document"] {
    // Create the component's schema and perform other initialization tasks
    // (only called when document is initially created).
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            this.root.set("clicks", 0, _prague_map__WEBPACK_IMPORTED_MODULE_1__["CounterValueType"].Name);
        });
    }
    render(host) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the distributed Counter
            const counter = yield this.root.wait("clicks");
            // Create a <span> that displays the current value of 'clicks'.
            const span = document.createElement("span");
            const update = () => {
                span.textContent = counter.value.toString();
            };
            this.root.on("valueChanged", update);
            update();
            // Create a button that increments the value of 'clicks' when pressed.
            const btn = document.createElement("button");
            btn.textContent = "+";
            btn.addEventListener("click", () => {
                counter.increment(1);
            });
            // Add both to the <div> provided by the host:
            host.appendChild(span);
            host.appendChild(btn);
        });
    }
    // The component has been loaded. Attempt to get a div from the host. TODO explain this better.
    opened() {
        return __awaiter(this, void 0, void 0, function* () {
            // If the host provided a <div>, render the component into that Div
            const maybeDiv = yield this.platform.queryInterface("div");
            if (maybeDiv) {
                this.render(maybeDiv);
            }
            else {
                return;
            }
        });
    }
}
function instantiateRuntime(context) {
    return __awaiter(this, void 0, void 0, function* () {
        return _prague_app_component__WEBPACK_IMPORTED_MODULE_0__["Component"].instantiateRuntime(context, "@chaincode/counter", [
            ["@chaincode/counter", Clicker]
        ]);
    });
}


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9hcHAtY29tcG9uZW50L2xpYi9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9hcHAtY29tcG9uZW50L2xpYi9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2FwcC1jb21wb25lbnQvbGliL2RvY3VtZW50LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvYXBwLWNvbXBvbmVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jZWxsL2xpYi9jZWxsLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY2VsbC9saWIvZGVidWcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jZWxsL2xpYi9leHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jZWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NlbGwvbm9kZV9tb2R1bGVzL0BwcmFndWUvYXBpLWRlZmluaXRpb25zL2Rpc3QvZGVidWcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jZWxsL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2FwaS1kZWZpbml0aW9ucy9kaXN0L2V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NlbGwvbm9kZV9tb2R1bGVzL0BwcmFndWUvYXBpLWRlZmluaXRpb25zL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jZWxsL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2FwaS1kZWZpbml0aW9ucy9kaXN0L3NoYXJlZE9iamVjdC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NlbGwvbm9kZV9tb2R1bGVzL0BwcmFndWUvYXBpLWRlZmluaXRpb25zL2Rpc3QvdmFsdWVUeXBlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29tcG9uZW50L2Rpc3QvY2hhbm5lbERlbHRhQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbXBvbmVudC9kaXN0L2NoYW5uZWxTdG9yYWdlU2VydmljZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbXBvbmVudC9kaXN0L2NvbXBvbmVudEhvc3QuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jb21wb25lbnQvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbXBvbmVudC9kaXN0L2xvY2FsQ2hhbm5lbFN0b3JhZ2VTZXJ2aWNlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29tcG9uZW50L25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9iYXRjaE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jb21wb25lbnQvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL2Jsb2JzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29tcG9uZW50L25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9oZWFwLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29tcG9uZW50L25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbXBvbmVudC9ub2RlX21vZHVsZXMvQHByYWd1ZS91dGlscy9saWIvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jb21wb25lbnQvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL3JhbmdlVHJhY2tlci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbXBvbmVudC9ub2RlX21vZHVsZXMvQHByYWd1ZS91dGlscy9saWIvcmF0ZUxpbWl0dGVyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29tcG9uZW50L25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9zYWZlUGFyc2VyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29tcG9uZW50L25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9ucy9kaXN0L2Jsb2JzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zL2Rpc3QvY2hhaW5jb2RlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zL2Rpc3QvY2xpZW50cy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9ucy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zL2Rpc3QvcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9jb250YWluZXItZGVmaW5pdGlvbnMvZGlzdC9zdG9yYWdlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWFwL2xpYi9jb3VudGVyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWFwL2xpYi9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL21hcC9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWFwL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL21hcC9saWIvbWFwLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWFwL2xpYi9zZXQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9tYXAvbGliL3ZpZXcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9tYXAvbm9kZV9tb2R1bGVzL0BwcmFndWUvYXBpLWRlZmluaXRpb25zL2Rpc3QvZGVidWcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9tYXAvbm9kZV9tb2R1bGVzL0BwcmFndWUvYXBpLWRlZmluaXRpb25zL2Rpc3QvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWFwL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2FwaS1kZWZpbml0aW9ucy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWFwL25vZGVfbW9kdWxlcy9AcHJhZ3VlL2FwaS1kZWZpbml0aW9ucy9kaXN0L3NoYXJlZE9iamVjdC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL21hcC9ub2RlX21vZHVsZXMvQHByYWd1ZS9hcGktZGVmaW5pdGlvbnMvZGlzdC92YWx1ZVR5cGUuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9tZXJnZS10cmVlL2xpYi9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9tZXJnZS10cmVlL2xpYi9jb2xsZWN0aW9ucy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL21lcmdlLXRyZWUvbGliL2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWVyZ2UtdHJlZS9saWIvbWVyZ2VUcmVlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWVyZ2UtdHJlZS9saWIvb3BzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvbWVyZ2UtdHJlZS9saWIvcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL21lcmdlLXRyZWUvbGliL3NlZ21lbnRHcm91cENvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9tZXJnZS10cmVlL2xpYi9zbmFwc2hvdC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL21lcmdlLXRyZWUvbGliL3RleHQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9ydW50aW1lL2Rpc3QvY29tcG9uZW50UnVudGltZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvZGlzdC9jb21wb25lbnRTdG9yYWdlU2VydmljZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvZGlzdC9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvZGlzdC9sZWFkZXJFbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvZGlzdC9ydW50aW1lLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvcnVudGltZS9kaXN0L3Rhc2tBbmFseXplci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvZGlzdC93ZWJQbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL2JhdGNoTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL2Jsb2JzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvcnVudGltZS9ub2RlX21vZHVsZXMvQHByYWd1ZS91dGlscy9saWIvaGVhcC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3J1bnRpbWUvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvcnVudGltZS9ub2RlX21vZHVsZXMvQHByYWd1ZS91dGlscy9saWIvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9ydW50aW1lL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9yYW5nZVRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9ydW50aW1lL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9yYXRlTGltaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9ydW50aW1lL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9zYWZlUGFyc2VyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvcnVudGltZS9ub2RlX21vZHVsZXMvQHByYWd1ZS91dGlscy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9zZXF1ZW5jZS9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc2VxdWVuY2UvbGliL2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc2VxdWVuY2UvbGliL2ludGVydmFsQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3NlcXVlbmNlL2xpYi9zZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3NlcXVlbmNlL2xpYi9zZXF1ZW5jZURlbHRhRXZlbnQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9zZXF1ZW5jZS9saWIvc2hhcmVkU3RyaW5nLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc2VxdWVuY2Uvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL2JhdGNoTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3NlcXVlbmNlL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9ibG9icy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3NlcXVlbmNlL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9oZWFwLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc2VxdWVuY2Uvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc2VxdWVuY2Uvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL3Byb21pc2VzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc2VxdWVuY2Uvbm9kZV9tb2R1bGVzL0BwcmFndWUvdXRpbHMvbGliL3JhbmdlVHJhY2tlci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3NlcXVlbmNlL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi9yYXRlTGltaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9zZXF1ZW5jZS9ub2RlX21vZHVsZXMvQHByYWd1ZS91dGlscy9saWIvc2FmZVBhcnNlci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3NlcXVlbmNlL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3V0aWxzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3N0cmVhbS9saWIvZXh0ZW5zaW9uLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL0BwcmFndWUvc3RyZWFtL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3N0cmVhbS9saWIvaW50ZXJmYWNlcy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9AcHJhZ3VlL3N0cmVhbS9saWIvc25hcHNob3QuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvQHByYWd1ZS9zdHJlYW0vbGliL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvZG91YmxlLWVuZGVkLXF1ZXVlL2pzL2RlcXVlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZURlZXAuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLy4vbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJ3ZWJwYWNrOi8vY2hhaW5jb2RlL2NvdW50ZXIvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL2NoYWluY29kZS9jb3VudGVyLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9jaGFpbmNvZGUvY291bnRlci8uL3NyYy9pbmRl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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0VBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QixhQUFhLFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQixhQUFhLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7Ozs7QUN6R0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUN5QztBQUNsQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEI7QUFDTjtBQUNPO0FBQ0Y7QUFDRztBQUNRO0FBQ2I7QUFDZ0I7QUFDekMsaUM7Ozs7Ozs7Ozs7OztBQ1JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQkFBK0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscURBQW9CO0FBQzNELHNDQUFzQyxxREFBb0I7QUFDMUQ7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1C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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LHVFQUFTLENBQUMsdUVBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQVksd0JBQXdCLDJEQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDOzs7Ozs7Ozs7Ozs7QUN0RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQjtBQUNQO0FBQ0Q7QUFDSTtBQUNJO0FBQ0E7QUFDRjtBQUNMO0FBQ3hCLGlDOzs7Ozs7Ozs7Ozs7QUNSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFR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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3U0E7QUFDQTtB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QUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QVM7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QVMsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUU7WUFDakUsQ0FBQyxvQkFBb0IsRUFBRSxPQUFPLENBQUM7U0FDaEMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUFBIiwiZmlsZSI6Im1haW4uYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibWFpblwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtYWluXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgQ29tcG9uZW50SG9zdCB9IGZyb20gXCJAcHJhZ3VlL2NvbXBvbmVudFwiO1xuaW1wb3J0IHsgTWFwRXh0ZW5zaW9uIH0gZnJvbSBcIkBwcmFndWUvbWFwXCI7XG5pbXBvcnQgeyBSdW50aW1lIH0gZnJvbSBcIkBwcmFndWUvcnVudGltZVwiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50c1wiO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tIFwiLi9kZWJ1Z1wiO1xuY29uc3QgdHlwZVRvRmFjdG9yeVN5bSA9IFN5bWJvbChcIkNvbXBvbmVudC50eXBlVG9GYWN0b3J5KClcIik7XG4vLyBJbnRlcm5hbCBJUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gdXNlZCB0byBkZWZlciByZXR1cm5pbmcgdGhlIGNvbXBvbmVudFxuLy8gZnJvbSBEYXRhU3RvcmUub3BlbigpIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQncyBhc3luYyAnb3BlbmVkKCknIG1ldGhvZCBoYXNcbi8vIGNvbXBsZXRlZC4gIChTZWUgJ0NoYWluY29kZS5ydW4oKScgYmVsb3cuKVxuY2xhc3MgQ29tcG9uZW50UGxhdGZvcm0gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB9XG4gICAgcXVlcnlJbnRlcmZhY2UoaWQpIHtcbiAgICAgICAgZGVidWcoYENvbXBvbmVudFBsYXRmb3JtLnF1ZXJ5SW50ZXJmYWNlKCR7aWR9KWApO1xuICAgICAgICByZXR1cm4gaWQgPT09IFwiY29tcG9uZW50XCJcbiAgICAgICAgICAgID8gdGhpcy5jb21wb25lbnRcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZWplY3QoYFVua25vd24gJ2lkJzogJHtpZH1gKTtcbiAgICB9XG4gICAgZGV0YWNoKCkge1xuICAgICAgICBkZWJ1ZyhgQ29tcG9uZW50UGxhdGZvcm0uZGV0YWNoKClgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbi8vIEludGVybmFsL3JldXNhYmxlIElDaGFpbmNvZGUgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYnkgRGF0YVN0b3JlLmluc3RhbnRpYXRlKCkuXG5jbGFzcyBMZWdhY3lDaGFpbmNvZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgU2hhcmVkT2JqZWN0IGZhY3RvcnkgZm9yIHRoZSBnaXZlbiB0eXBlIGlkLlxuICAgIGdldE1vZHVsZSh0eXBlKSB7XG4gICAgICAgIGRlYnVnKGBDaGFpbmNvZGUuZ2V0TW9kdWxlKCR7dHlwZX0pYCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFt0eXBlVG9GYWN0b3J5U3ltXS5nZXQodHlwZSkgfHwgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgIH1cbiAgICAvLyBOWUk/XG4gICAgY2xvc2UoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiQ2hhaW5jb2RlLnJ1bigpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRQbGF0Zm9ybShQcm9taXNlLnJlc29sdmUodGhpcy5jb21wb25lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjaGFpbmxvYWRhYmxlIFByYWd1ZSBjb21wb25lbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICAgICAgICB0aGlzLl9ob3N0ID0gbnVsbDtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBudWxsO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludm9rZWQgYnkgJ2F0dGFjaCcgdG8gZW5zdXJlIHRoYXQgY3JlYXRlL29wZW5lZCBhcmUgY2FsbGVkIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAqIGEgY29tcG9uZW50IGlzIGF0dGFjaGVkLiAgU3Vic2VxdWVudCBjYWxscyBpZ25vcmUgYXJlIGEgbm8tb3AuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuc3VyZU9wZW5lZCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSAnX3Jvb3QnIG1hcCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCB0aGFuIHRoaXMgaXMgY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgIC8vIHByZXBhcmVkLiAgUHJvbXB0bHkgcmV0dXJuICd0aGlzJy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5lbnN1cmVPcGVuZWQoKSAtIGFscmVhZHkgb3BlbmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaG9zdC5leGlzdGluZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKGAke3RoaXMuZGJnTmFtZX0uZW5zdXJlT3BlbmVkKCkgLSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgYWxyZWFkeSBleGlzdHMsIG9wZW4gaXQncyByb290IG1hcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gKHlpZWxkIHRoaXMuaG9zdC5nZXRDaGFubmVsKENvbXBvbmVudC5yb290TWFwSWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKGAke3RoaXMuZGJnTmFtZX0uZW5zdXJlT3BlbmVkKCkgLSBuZXcgY29tcG9uZW50YCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgY2xpZW50IHRvIGF0dGVtcHQgb3BlbmluZyB0aGUgY29tcG9uZW50LCBjcmVhdGUgdGhlIGNvbXBvbmVudCdzXG4gICAgICAgICAgICAgICAgLy8gcm9vdCBtYXAgYW5kIGNhbGwgJ2NyZWF0ZSgpJyB0byBnaXZlIHRoZSBjb21wb25lbnQgYXV0aG9yIGEgY2hhbmNlIHRvIGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50J3Mgc2hhcmVkIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5ob3N0LmNyZWF0ZUNoYW5uZWwoQ29tcG9uZW50LnJvb3RNYXBJZCwgTWFwRXh0ZW5zaW9uLlR5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QuYXR0YWNoKCk7XG4gICAgICAgICAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5jcmVhdGUoKSAtIGJlZ2luYCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgJHt0aGlzLmRiZ05hbWV9LmNyZWF0ZSgpIC0gZW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhgJHt0aGlzLmRiZ05hbWV9Lm9wZW5lZCgpIC0gYmVnaW5gKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMub3BlbmVkKCk7XG4gICAgICAgICAgICBkZWJ1ZyhgJHt0aGlzLmRiZ05hbWV9Lm9wZW5lZCgpIC0gZW5kYCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhIG1hcCBvZiBleHRlbnNpb24gdHlwZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBmYWN0b3J5LlxuICAgICAgICBjb25zdCB0eXBlVG9GYWN0b3J5ID0gbmV3IE1hcCh0eXBlcyk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBtYXAgaW5jbHVkZXMgdGhlIHNoYXJlZCBtYXAgdHlwZS4gIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2VcbiAgICAgICAgLy8gYWxsIGNvbXBvbmVudHMgY29uc3RydWN0IGEgc2hhcmVkIG1hcCB0byBiZSB0aGVpciByb290LlxuICAgICAgICBpZiAoIXR5cGVUb0ZhY3RvcnkuaGFzKE1hcEV4dGVuc2lvbi5UeXBlKSkge1xuICAgICAgICAgICAgdHlwZVRvRmFjdG9yeS5zZXQoTWFwRXh0ZW5zaW9uLlR5cGUsIG5ldyBNYXBFeHRlbnNpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZXJuYWxseSBleHBvc2UgdGhlICd0eXBlVG9GYWN0b3J5JyBtYXAgdG8gJ0NoYWluY29kZS5nZXRNb2R1bGUoKScuXG4gICAgICAgIHRoaXNbdHlwZVRvRmFjdG9yeVN5bV0gPSB0eXBlVG9GYWN0b3J5O1xuICAgIH1cbiAgICBnZXQgZGJnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0ke3RoaXMuaG9zdCA/IGA6JyR7dGhpcy5ob3N0LmlkfSdgIDogXCJcIn1gO1xuICAgIH1cbiAgICBnZXQgcnVudGltZSgpIHsgcmV0dXJuIHRoaXMuX2hvc3Q7IH1cbiAgICBnZXQgcGxhdGZvcm0oKSB7IHJldHVybiB0aGlzLl9wbGF0Zm9ybTsgfVxuICAgIGdldCBob3N0KCkgeyByZXR1cm4gdGhpcy5faG9zdDsgfVxuICAgIGdldCByb290KCkgeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgY29tcG9uZW50IGlzIHN5bmNocm9uaXplZCB3aXRoIGl0cyBkYXRlIHN0b3JlLlxuICAgICAqIElmIHRoZSBjb21wb25lbnQgaXMgYWxyZWFkeSBjb25uZWN0ZWQsIHJldHVybnMgYSByZXNvbHZlZCBwcm9taXNlLlxuICAgICAqL1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhvc3QuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgJHt0aGlzLmRiZ05hbWV9LmNvbm5lY3RlZDogQWxyZWFkeSBjb25uZWN0ZWQuYCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5jb25uZWN0ZWQ6IFdhaXRpbmcuLi5gKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChhY2NlcHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5vbihcImNvbm5lY3RlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5jb25uZWN0ZWQ6IE5vdyBjb25uZWN0ZWQuYCk7XG4gICAgICAgICAgICAgICAgYWNjZXB0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gSUNoYWluY29kZSBmcm9tIGEgQ29tcG9uZW50IGluc3RhbmNlLiAgQWxsIGNoYWluY29kZSBjb21wb25lbnRzIG11c3RcbiAgICAgKiBleHBvcnQgYW4gJ2luc3RhbnRpYXRlKCknIGZ1bmN0aW9uIGZyb20gdGhlaXIgbW9kdWxlIHRoYXQgcmV0dXJucyBhbiBJQ2hhaW5jb2RlIGFzXG4gICAgICogc2hvd24gaW4gdGhlIGZvbGxvd2luZyBleGFtcGxlOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBwa2cgPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpXG4gICAgICpcbiAgICAgKiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5zdGFudGlhdGVSdW50aW1lKGNvbnRleHQ6IElDb250YWluZXJDb250ZXh0KSB7XG4gICAgICogICAgIHJldHVybiBDb21wb25lbnQuaW5zdGFudGlhdGVSdW50aW1lKGNvbnRleHQsIHBrZy5uYW1lLFxuICAgICAqICAgICAgICAgIFtbcGtnLm5hbWUsIFByb21pc2UucmVzb2x2ZSh7IGluc3RhbnRpYXRlQ29tcG9uZW50IH0pXV0pO1xuICAgICAqIH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnN0YW50aWF0ZVJ1bnRpbWUoY29udGV4dCwgY2hhaW5jb2RlLCByZWdpc3RyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcnVudGltZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KGNoYWluY29kZSk7XG4gICAgICAgICAgICBkZWJ1ZyhgaW5zdGFudGlhdGVSdW50aW1lKGNoYWluY29kZT0ke2NoYWluY29kZX0scmVnaXN0cnk9JHtKU09OLnN0cmluZ2lmeShyZWdpc3RyeSl9KWApO1xuICAgICAgICAgICAgY29uc3QgcnVudGltZSA9IHlpZWxkIFJ1bnRpbWUuTG9hZChuZXcgTWFwKHJlZ2lzdHJ5Lm1hcCgoW25hbWUsIGN0b3JGbl0pID0+IFtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh7IGluc3RhbnRpYXRlQ29tcG9uZW50OiAoKSA9PiBQcm9taXNlLnJlc29sdmUobmV3IGN0b3JGbigpKSB9KSxcbiAgICAgICAgICAgIF0pKSwgY29udGV4dCk7XG4gICAgICAgICAgICBkZWJ1ZyhcInJ1bnRpbWUgbG9hZGVkLlwiKTtcbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHBhdGggaGFuZGxlciBmb3IgaW5ib3VuZCBtZXNzYWdlc1xuICAgICAgICAgICAgcnVudGltZS5yZWdpc3RlclJlcXVlc3RIYW5kbGVyKChyZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoYHJlcXVlc3QodXJsPSR7cmVxdWVzdC51cmx9KWApO1xuICAgICAgICAgICAgICAgIGRlYnVnKGBhd2FpdGluZyByb290IGNvbXBvbmVudGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJ1bnRpbWUgPSB5aWVsZCBydW50aW1lLmdldENvbXBvbmVudChydW50aW1lSWQsIC8qIHdhaXQ6ICovIHRydWUpO1xuICAgICAgICAgICAgICAgIGRlYnVnKGBoYXZlIHJvb3QgY29tcG9uZW50YCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudXJsICYmIHJlcXVlc3QudXJsICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgZGVsZWdhdGluZyB0byAke3JlcXVlc3QudXJsfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRSdW50aW1lLmNoYWluY29kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5yZXF1ZXN0KGNvbXBvbmVudFJ1bnRpbWUsIHsgdXJsOiByZXF1ZXN0LnVybCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGByZXNvbHZlZCAke3J1bnRpbWVJZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIG1pbWVUeXBlOiBcInByYWd1ZS9jb21wb25lbnRcIiwgdmFsdWU6IGNvbXBvbmVudFJ1bnRpbWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBPbiBmaXJzdCBib290IGNyZWF0ZSB0aGUgYmFzZSBjb21wb25lbnRcbiAgICAgICAgICAgIGlmICghcnVudGltZS5leGlzdGluZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBjcmVhdGVBbmRBdHRhY2hDb21wb25lbnQoY2hhaW5jb2RlPSR7Y2hhaW5jb2RlfSlgKTtcbiAgICAgICAgICAgICAgICBydW50aW1lLmNyZWF0ZUFuZEF0dGFjaENvbXBvbmVudChydW50aW1lSWQsIGNoYWluY29kZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bnRpbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGRlYnVnKGAke3RoaXMuZGJnTmFtZX0uY2xvc2UoKWApO1xuICAgICAgICAgICAgdGhpcy5ob3N0LmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW4ocnVudGltZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5ydW4oKWApO1xuICAgICAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5Mb2FkRnJvbVNuYXBzaG90KCkgLSBiZWdpbmApO1xuICAgICAgICAgICAgdGhpcy5faG9zdCA9IHlpZWxkIENvbXBvbmVudEhvc3QuTG9hZEZyb21TbmFwc2hvdChydW50aW1lLCBuZXcgTGVnYWN5Q2hhaW5jb2RlKHRoaXMpKTtcbiAgICAgICAgICAgIGRlYnVnKGAke3RoaXMuZGJnTmFtZX0uTG9hZEZyb21TbmFwc2hvdCgpIC0gZW5kYCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaChwbGF0Zm9ybSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5hdHRhY2goKWApO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50UGxhdGZvcm0odGhpcy5lbnN1cmVPcGVuZWQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzbmFwc2hvdCgpIHtcbiAgICAgICAgZGVidWcoYCR7dGhpcy5kYmdOYW1lfS5zbmFwc2hvdCgpYCk7XG4gICAgICAgIHJldHVybiB7IGVudHJpZXM6IHRoaXMuX2hvc3Quc25hcHNob3RJbnRlcm5hbCgpLCBzaGE6IG51bGwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgcmVxdWVzdCB0byBpbnRlcm5hbGx5IHJvdXRlIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIHJlcXVlc3QocnVudGltZSwgcmVxdWVzdCkge1xuICAgICAgICBkZWJ1ZyhgJHt0aGlzLmRiZ05hbWV9LnJlcXVlc3QoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0KX0pYCk7XG4gICAgICAgIHJldHVybiBydW50aW1lLnJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxufVxuQ29tcG9uZW50LnJvb3RNYXBJZCA9IFwicm9vdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50LmpzLm1hcCIsImltcG9ydCAqIGFzIHJlZ2lzdGVyRGVidWcgZnJvbSBcImRlYnVnXCI7XG5leHBvcnQgY29uc3QgZGVidWcgPSByZWdpc3RlckRlYnVnKFwicHJhZ3VlOmNvbXBvbmVudFwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLmpzLm1hcCIsImltcG9ydCAqIGFzIGNlbGwgZnJvbSBcIkBwcmFndWUvY2VsbFwiO1xuaW1wb3J0IHsgQ291bnRlclZhbHVlVHlwZSwgRGlzdHJpYnV0ZWRTZXRWYWx1ZVR5cGUsIE1hcEV4dGVuc2lvbiwgcmVnaXN0ZXJEZWZhdWx0VmFsdWVUeXBlLCB9IGZyb20gXCJAcHJhZ3VlL21hcFwiO1xuaW1wb3J0ICogYXMgc2VxdWVuY2UgZnJvbSBcIkBwcmFndWUvc2VxdWVuY2VcIjtcbmltcG9ydCAqIGFzIHN0cmVhbSBmcm9tIFwiQHByYWd1ZS9zdHJlYW1cIjtcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWQvdjRcIjtcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuL2NvbXBvbmVudFwiO1xuZXhwb3J0IGNsYXNzIERvY3VtZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCBtYXAgdmFsdWUgdHlwZXNcbiAgICAgICAgcmVnaXN0ZXJEZWZhdWx0VmFsdWVUeXBlKG5ldyBEaXN0cmlidXRlZFNldFZhbHVlVHlwZSgpKTtcbiAgICAgICAgcmVnaXN0ZXJEZWZhdWx0VmFsdWVUeXBlKG5ldyBDb3VudGVyVmFsdWVUeXBlKCkpO1xuICAgICAgICByZWdpc3RlckRlZmF1bHRWYWx1ZVR5cGUobmV3IHNlcXVlbmNlLlNoYXJlZFN0cmluZ0ludGVydmFsQ29sbGVjdGlvblZhbHVlVHlwZSgpKTtcbiAgICAgICAgcmVnaXN0ZXJEZWZhdWx0VmFsdWVUeXBlKG5ldyBzZXF1ZW5jZS5TaGFyZWRJbnRlcnZhbENvbGxlY3Rpb25WYWx1ZVR5cGUoKSk7XG4gICAgICAgIC8vIENyZWF0ZSBjaGFubmVsIGV4dGVuc2lvbnNcbiAgICAgICAgY29uc3QgbWFwRXh0ZW5zaW9uID0gbmV3IE1hcEV4dGVuc2lvbigpO1xuICAgICAgICBjb25zdCBzaGFyZWRTdHJpbmdFeHRlbnNpb24gPSBuZXcgc2VxdWVuY2UuU2hhcmVkU3RyaW5nRXh0ZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IHN0cmVhbUV4dGVuc2lvbiA9IG5ldyBzdHJlYW0uU3RyZWFtRXh0ZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IGNlbGxFeHRlbnNpb24gPSBuZXcgY2VsbC5DZWxsRXh0ZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IG9iamVjdFNlcXVlbmNlRXh0ZW5zaW9uID0gbmV3IHNlcXVlbmNlLlNoYXJlZE9iamVjdFNlcXVlbmNlRXh0ZW5zaW9uKCk7XG4gICAgICAgIGNvbnN0IG51bWJlclNlcXVlbmNlRXh0ZW5zaW9uID0gbmV3IHNlcXVlbmNlLlNoYXJlZE51bWJlclNlcXVlbmNlRXh0ZW5zaW9uKCk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGNoYW5uZWwgZXh0ZW5zaW9uc1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICBbbWFwRXh0ZW5zaW9uLnR5cGUsIG1hcEV4dGVuc2lvbl0sXG4gICAgICAgICAgICBbc2hhcmVkU3RyaW5nRXh0ZW5zaW9uLnR5cGUsIHNoYXJlZFN0cmluZ0V4dGVuc2lvbl0sXG4gICAgICAgICAgICBbc3RyZWFtRXh0ZW5zaW9uLnR5cGUsIHN0cmVhbUV4dGVuc2lvbl0sXG4gICAgICAgICAgICBbY2VsbEV4dGVuc2lvbi50eXBlLCBjZWxsRXh0ZW5zaW9uXSxcbiAgICAgICAgICAgIFtvYmplY3RTZXF1ZW5jZUV4dGVuc2lvbi50eXBlLCBvYmplY3RTZXF1ZW5jZUV4dGVuc2lvbl0sXG4gICAgICAgICAgICBbbnVtYmVyU2VxdWVuY2VFeHRlbnNpb24udHlwZSwgbnVtYmVyU2VxdWVuY2VFeHRlbnNpb25dLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3ViY2xhc3MgaW1wbGVtZW50cyAnb3BlbmVkKCknIHRvIGZpbmlzaCBpbml0aWFsaXphdGlvbiBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG9wZW5lZC9jcmVhdGVkLlxuICAgICAqL1xuICAgIG9wZW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNoYXJlZCBtYXBcbiAgICAgKi9cbiAgICBjcmVhdGVNYXAoaWQgPSB1dWlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZS5jcmVhdGVDaGFubmVsKGlkLCBNYXBFeHRlbnNpb24uVHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2hhcmVkIGNlbGwuXG4gICAgICovXG4gICAgY3JlYXRlQ2VsbChpZCA9IHV1aWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lLmNyZWF0ZUNoYW5uZWwoaWQsIGNlbGwuQ2VsbEV4dGVuc2lvbi5UeXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzaGFyZWQgc3RyaW5nXG4gICAgICovXG4gICAgY3JlYXRlU3RyaW5nKGlkID0gdXVpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY3JlYXRlQ2hhbm5lbChpZCwgc2VxdWVuY2UuU2hhcmVkU3RyaW5nRXh0ZW5zaW9uLlR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluayBzaGFyZWQgb2JqZWN0XG4gICAgICovXG4gICAgY3JlYXRlU3RyZWFtKGlkID0gdXVpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY3JlYXRlQ2hhbm5lbChpZCwgc3RyZWFtLlN0cmVhbUV4dGVuc2lvbi5UeXBlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudC5qcy5tYXAiLCJleHBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi9jb21wb25lbnRcIjtcbmV4cG9ydCB7IERvY3VtZW50IH0gZnJvbSBcIi4vZG9jdW1lbnRcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU2hhcmVkT2JqZWN0IH0gZnJvbSBcIkBwcmFndWUvYXBpLWRlZmluaXRpb25zXCI7XG5pbXBvcnQgeyBGaWxlTW9kZSwgTWVzc2FnZVR5cGUsIFRyZWVFbnRyeSwgfSBmcm9tIFwiQHByYWd1ZS9jb250YWluZXItZGVmaW5pdGlvbnNcIjtcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSBcIi4vZGVidWdcIjtcbmltcG9ydCB7IENlbGxFeHRlbnNpb24gfSBmcm9tIFwiLi9leHRlbnNpb25cIjtcbmV4cG9ydCB2YXIgQ2VsbFZhbHVlVHlwZTtcbihmdW5jdGlvbiAoQ2VsbFZhbHVlVHlwZSkge1xuICAgIC8vIFRoZSB2YWx1ZSBpcyBhbm90aGVyIHNoYXJlZCBvYmplY3RcbiAgICBDZWxsVmFsdWVUeXBlW0NlbGxWYWx1ZVR5cGVbXCJTaGFyZWRcIl0gPSAwXSA9IFwiU2hhcmVkXCI7XG4gICAgLy8gVGhlIHZhbHVlIGlzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcbiAgICBDZWxsVmFsdWVUeXBlW0NlbGxWYWx1ZVR5cGVbXCJQbGFpblwiXSA9IDFdID0gXCJQbGFpblwiO1xufSkoQ2VsbFZhbHVlVHlwZSB8fCAoQ2VsbFZhbHVlVHlwZSA9IHt9KSk7XG5jb25zdCBzbmFwc2hvdEZpbGVOYW1lID0gXCJoZWFkZXJcIjtcbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBjZWxsIHNoYXJlZCBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIENlbGwgZXh0ZW5kcyBTaGFyZWRPYmplY3Qge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgc2hhcmVkIGNlbGwuIElmIHRoZSBvYmplY3QgaXMgbm9uLWxvY2FsIGFuIGlkIGFuZCBzZXJ2aWNlIGludGVyZmFjZXMgd2lsbFxuICAgICAqIGJlIHByb3ZpZGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIHJ1bnRpbWUpIHtcbiAgICAgICAgc3VwZXIoaWQsIHJ1bnRpbWUsIENlbGxFeHRlbnNpb24uVHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIGNlbGwuXG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG9wZXJhdGlvblZhbHVlO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhbnkgbG9jYWwgc2hhcmVkIG9iamVjdHMgdG8gb3VyIGludGVybmFsIHN0b3JhZ2UgZm9ybWF0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hdHRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IENlbGxWYWx1ZVR5cGVbQ2VsbFZhbHVlVHlwZS5TaGFyZWRdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDZWxsVmFsdWVUeXBlW0NlbGxWYWx1ZVR5cGUuUGxhaW5dLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRDZWxsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wZXJhdGlvblZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29yZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQob3ApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRGVsZXRlcyB0aGUgdmFsdWUgZnJvbSB0aGUgY2VsbC5cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRlbGV0ZUNlbGxcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUNvcmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0SWZBdHRhY2hlZChvcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgY2VsbCBpcyBlbXB0eSBvciBub3QuXG4gICAgICovXG4gICAgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzbmFwc2hvdCgpIHtcbiAgICAgICAgLy8gR2V0IGEgc2VyaWFsaXphYmxlIGZvcm0gb2YgZGF0YVxuICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSBpbnN0YW5jZW9mIFNoYXJlZE9iamVjdCkge1xuICAgICAgICAgICAgY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDZWxsVmFsdWVUeXBlW0NlbGxWYWx1ZVR5cGUuU2hhcmVkXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogQ2VsbFZhbHVlVHlwZVtDZWxsVmFsdWVUeXBlLlBsYWluXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmQgdGhlbiBjb25zdHJ1Y3QgdGhlIHRyZWUgZm9yIGl0XG4gICAgICAgIGNvbnN0IHRyZWUgPSB7XG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiBGaWxlTW9kZS5GaWxlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBzbmFwc2hvdEZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUcmVlRW50cnlbVHJlZUVudHJ5LkJsb2JdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwidXRmLThcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNoYTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIGxvYWRDb3JlKG1pbmltdW1TZXF1ZW5jZU51bWJlciwgaGVhZGVyT3JpZ2luLCBzdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByYXdDb250ZW50ID0geWllbGQgc3RvcmFnZS5yZWFkKHNuYXBzaG90RmlsZU5hbWUpO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnN0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmF3Q29udGVudFxuICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShyYXdDb250ZW50LCBcImJhc2U2NFwiKVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoXCJ1dGYtOFwiKSlcbiAgICAgICAgICAgICAgICA6IHsgdHlwZTogQ2VsbFZhbHVlVHlwZVtDZWxsVmFsdWVUeXBlLlBsYWluXSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gY29udGVudC50eXBlID09PSBDZWxsVmFsdWVUeXBlW0NlbGxWYWx1ZVR5cGUuU2hhcmVkXVxuICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5ydW50aW1lLmdldENoYW5uZWwoY29udGVudC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IGNvbnRlbnQudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplTG9jYWxDb3JlKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGF0dGFjaENvcmUoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25EaXNjb25uZWN0KCkge1xuICAgICAgICBkZWJ1ZyhgQ2VsbCAke3RoaXMuaWR9IGlzIG5vdyBkaXNjb25uZWN0ZWRgKTtcbiAgICB9XG4gICAgb25Db25uZWN0KHBlbmRpbmcpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0TG9jYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlcGFyZUNvcmUobWVzc2FnZSwgbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IE1lc3NhZ2VUeXBlLk9wZXJhdGlvbiAmJiAhbG9jYWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IG1lc3NhZ2UuY29udGVudHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwic2V0Q2VsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXJldHVybi1hd2FpdCAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AudmFsdWUudHlwZSA9PT0gQ2VsbFZhbHVlVHlwZVtDZWxsVmFsdWVUeXBlLlNoYXJlZF1cbiAgICAgICAgICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5ydW50aW1lLmdldENoYW5uZWwob3AudmFsdWUudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NDb3JlKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IE1lc3NhZ2VUeXBlLk9wZXJhdGlvbiAmJiAhbG9jYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wID0gbWVzc2FnZS5jb250ZW50cztcbiAgICAgICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZXRDZWxsXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29yZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNlbGxcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVDb3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNaW5TZXF1ZW5jZU51bWJlckNoYW5nZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdWJtaXRJZkF0dGFjaGVkKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJtaXRMb2NhbE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuICAgIHNldENvcmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZW1pdChcInZhbHVlQ2hhbmdlZFwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZUNvcmUoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVsZXRlXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlbGwuanMubWFwIiwiaW1wb3J0ICogYXMgcmVnaXN0ZXJEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IHJlZ2lzdGVyRGVidWcoXCJwcmFndWU6Y2VsbFwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gXCIuL2NlbGxcIjtcbi8qKlxuICogVGhlIGV4dGVuc2lvbiB0aGF0IGRlZmluZXMgdGhlIG1hcFxuICovXG5leHBvcnQgY2xhc3MgQ2VsbEV4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IENlbGxFeHRlbnNpb24uVHlwZTtcbiAgICB9XG4gICAgbG9hZChkb2N1bWVudCwgaWQsIG1pbmltdW1TZXF1ZW5jZU51bWJlciwgc2VydmljZXMsIGhlYWRlck9yaWdpbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IG5ldyBDZWxsKGlkLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB5aWVsZCBjZWxsLmxvYWQobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXJPcmlnaW4sIHNlcnZpY2VzKTtcbiAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlKGRvY3VtZW50LCBpZCkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGwoaWQsIGRvY3VtZW50KTtcbiAgICAgICAgY2VsbC5pbml0aWFsaXplTG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxufVxuQ2VsbEV4dGVuc2lvbi5UeXBlID0gXCJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdHlwZXMvY2VsbFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZW5zaW9uLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gXCIuL2NlbGxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2V4dGVuc2lvblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWdpc3RlckRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xuZXhwb3J0cy5kZWJ1ZyA9IHJlZ2lzdGVyRGVidWcoXCJwcmFndWU6YXBpLWRlZmluaXRpb25zXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENsYXNzIHRoYXQgY29udGFpbnMgYSBjb2xsZWN0aW9uIG9mIGNvbGxhYm9yYXRpb24gZXh0ZW5zaW9uc1xuICovXG5jbGFzcyBSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnNNYXAgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGV4dGVuc2lvblxuICAgICAqIEBwYXJhbSBleHRlbnNpb24gVGhlIGV4dGVuc2lvbiB0byByZWdpc3RlclxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGV4dGVuc2lvbikge1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMucHVzaChleHRlbnNpb24pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnNNYXBbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSBpZCBJRCBmb3IgdGhlIGV4dGVuc2lvbiB0byByZXRyaWV2ZVxuICAgICAqL1xuICAgIGdldEV4dGVuc2lvbih0eXBlKSB7XG4gICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5leHRlbnNpb25zTWFwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5zaW9uIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zTWFwW3R5cGVdO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVnaXN0cnkgPSBSZWdpc3RyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zaGFyZWRPYmplY3RcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vZXh0ZW5zaW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbHVlVHlwZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udGFpbmVyX2RlZmluaXRpb25zXzEgPSByZXF1aXJlKFwiQHByYWd1ZS9jb250YWluZXItZGVmaW5pdGlvbnNcIik7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgRGVxdWUgPSByZXF1aXJlKFwiZG91YmxlLWVuZGVkLXF1ZXVlXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCIuL2RlYnVnXCIpO1xuY29uc3QgdmFsdWVUeXBlXzEgPSByZXF1aXJlKFwiLi92YWx1ZVR5cGVcIik7XG5jbGFzcyBTaGFyZWRPYmplY3QgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBydW50aW1lLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgdGhpcy5fX3NoYXJlZE9iamVjdF9fID0gdHJ1ZTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWUgcHJpdmF0ZSBmaWVsZHMgZXhwb3NlZCB2aWEgZ2V0dGVyc1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLkNvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIC8vIExvY2FsbHkgYXBwbGllZCBvcGVyYXRpb25zIG5vdCB5ZXQgQUNLJ2QgYnkgdGhlIHNlcnZlclxuICAgICAgICB0aGlzLnBlbmRpbmdPcHMgPSBuZXcgRGVxdWUoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlVHlwZV8xLlZhbHVlVHlwZVt2YWx1ZVR5cGVfMS5WYWx1ZVR5cGUuU2hhcmVkXSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNoYXJlZCBvYmplY3QsIGFmdGVyIGNvbnN0cnVjdGlvbiwgY2FuIGVpdGhlciBiZSBsb2FkZWQgaW4gdGhlIGNhc2UgdGhhdCBpdCBpcyBhbHJlYWR5IHBhcnQgb2ZcbiAgICAgKiBhIHNoYXJlZCBkb2N1bWVudC4gT3IgbGF0ZXIgYXR0YWNoZWQgaWYgaXQgaXMgYmVpbmcgbmV3bHkgYWRkZWQuXG4gICAgICovXG4gICAgbG9hZChtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIGhlYWRlck9yaWdpbiwgc2VydmljZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubG9hZENvcmUobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXJPcmlnaW4sIHNlcnZpY2VzLm9iamVjdFN0b3JhZ2UpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hEZWx0YUhhbmRsZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBvYmplY3QgYXMgYSBsb2NhbCwgbm9uLXNoYXJlZCBvYmplY3QuIFRoaXMgb2JqZWN0IGNhbiBiZWNvbWUgc2hhcmVkIGFmdGVyXG4gICAgICogaXQgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGluaXRpYWxpemVMb2NhbCgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTG9jYWxDb3JlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBnaXZlbiBzaGFyZWQgb2JqZWN0IHRvIGl0cyBjb250YWluaW5nIGRvY3VtZW50XG4gICAgICovXG4gICAgYXR0YWNoKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGxvdyBkZXJpdmVkIGNsYXNzZXMgdG8gcGVyZm9ybSBjdXN0b20gcHJvY2Vzc2luZyBwcmlvciB0byBhdHRhY2hpbmcgdGhpcyBvYmplY3RcbiAgICAgICAgdGhpcy5hdHRhY2hDb3JlKCk7XG4gICAgICAgIC8vIE5vdGlmeSB0aGUgZG9jdW1lbnQgb2YgdGhlIGF0dGFjaG1lbnRcbiAgICAgICAgdGhpcy5zZXJ2aWNlcyA9IHRoaXMucnVudGltZS5hdHRhY2hDaGFubmVsKHRoaXMpO1xuICAgICAgICB0aGlzLmF0dGFjaERlbHRhSGFuZGxlcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzaGFyZWQgb2JqZWN0IGlzIGxvY2FsXG4gICAgICovXG4gICAgaXNMb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNlcnZpY2VzO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bm5lY2Vzc2FyeS1vdmVycmlkZSAqL1xuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgbWVzc2FnZSBieSB0aGUgbG9jYWwgY2xpZW50XG4gICAgICovXG4gICAgc3VibWl0TG9jYWxNZXNzYWdlKGNvbnRlbnQpIHtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmlzTG9jYWwoKSk7XG4gICAgICAgIC8vIFNlbmQgaWYgd2UgYXJlIGNvbm5lY3RlZCAtIG90aGVyd2lzZSBqdXN0IGFkZCB0byB0aGUgc2VudCBsaXN0XG4gICAgICAgIGxldCBjbGllbnRTZXF1ZW5jZU51bWJlciA9IC0xO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgY2xpZW50U2VxdWVuY2VOdW1iZXIgPSB0aGlzLnNlcnZpY2VzLmRlbHRhQ29ubmVjdGlvbi5zdWJtaXQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1Z18xLmRlYnVnKGAke3RoaXMuaWR9IE5vdCBmdWxseSBjb25uZWN0ZWQgLSBhZGRpbmcgdG8gcGVuZGluZyBsaXN0YCwgY29udGVudCk7XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgbWVzc2FnZSBmb3Igd2hlbiBpdCBpcyBBQ0tlZCBhbmQgdGhlbiBzdWJtaXQgdG8gdGhlIHNlcnZlciBpZiBjb25uZWN0ZWRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdPcHMucHVzaCh7IGNsaWVudFNlcXVlbmNlTnVtYmVyLCBjb250ZW50IH0pO1xuICAgICAgICByZXR1cm4gY2xpZW50U2VxdWVuY2VOdW1iZXI7XG4gICAgfVxuICAgIGF0dGFjaERlbHRhSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5kZWx0YUNvbm5lY3Rpb24uYXR0YWNoKHtcbiAgICAgICAgICAgIG1pblNlcXVlbmNlTnVtYmVyQ2hhbmdlZDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTWluU2VxdWVuY2VOdW1iZXJDaGFuZ2VkKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVwYXJlOiAobWVzc2FnZSwgbG9jYWwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlKG1lc3NhZ2UsIGxvY2FsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiAobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENvbm5lY3Rpb25TdGF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uU3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBzdGF0ZVxuICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0ZSh0aGlzLnNlcnZpY2VzLmRlbHRhQ29ubmVjdGlvbi5zdGF0ZSk7XG4gICAgfVxuICAgIHByZXBhcmUobWVzc2FnZSwgbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZUNvcmUobWVzc2FnZSwgbG9jYWwpO1xuICAgIH1cbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgLy8gU2hvdWxkIEkgY2hhbmdlIHRoZSBzdGF0ZSBhdCB0aGUgZW5kPyBTbyB0aGF0IHdlICpjYW4ndCogc2VuZCBuZXcgc3R1ZmYgYmVmb3JlIHdlIHNlbmQgb2xkP1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLkNvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gVGhpbmdzIHRoYXQgYXJlIHRydWUgbm93Li4uXG4gICAgICAgICAgICAgICAgLy8gLSBpZiB3ZSBoYWQgYSBjb25uZWN0aW9uIHdlIGNhbiBubyBsb25nZXIgc2VuZCBtZXNzYWdlcyBvdmVyIGl0XG4gICAgICAgICAgICAgICAgLy8gLSBpZiB3ZSBoYWQgb3V0Ym91bmQgbWVzc2FnZXMgc29tZSBtYXkgb3IgbWF5IG5vdCBiZSBBQ0snZC4gV29uJ3Qga25vdyB1bnRpbCBuZXh0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIC0gbmFjayBjb3VsZCBnZXQgYSBuZXcgbXNuIC0gYnV0IG1pZ2h0IGFzIHdlbGwgZG8gaXQgaW4gdGhlIGpvaW4/XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkNvbm5lY3Rpbmc6XG4gICAgICAgICAgICAgICAgLy8gVGhpbmdzIHRoYXQgYXJlIG5vdyB0cnVlLi4uXG4gICAgICAgICAgICAgICAgLy8gLSB3ZSB3aWxsIGJlZ2luIHRvIHJlY2VpdmUgaW5ib3VuZCBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIC8vIC0gd2Uga25vdyB3aGF0IG91ciBuZXcgY2xpZW50IGlkIGlzLlxuICAgICAgICAgICAgICAgIC8vIC0gc3RpbGwgbm90IHNhZmUgdG8gc2VuZCBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIC8vIFdoaWxlIGNvbm5lY3Rpbmcgd2UgYXJlIHN0aWxsIHRpY2tpbmcgb2ZmIHRoZSBwcmV2aW91cyBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVidWcoYCR7dGhpcy5pZH0gaXMgbm93IGNvbm5lY3RpbmdgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZDpcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGFsbCB1bi1hY2snZCBwYXlsb2FkIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdPcHMgPSB0aGlzLnBlbmRpbmdPcHMudG9BcnJheSgpLm1hcCgodmFsdWUpID0+IHZhbHVlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ09wcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIC8vIEFuZCBub3cgd2UgYXJlIGZ1bGx5IGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgIC8vIC0gd2UgaGF2ZSBhIGNsaWVudCBJRFxuICAgICAgICAgICAgICAgIC8vIC0gd2UgYXJlIGNhdWdodCB1cCBlbm91Z2ggdG8gYXR0ZW1wdCB0byBzZW5kIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3QocGVuZGluZ09wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGFzc2VydC5vayhmYWxzZSwgYFVua25vd24gQ29ubmVjdGlvblN0YXRlICR7c3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIG1lc3NhZ2UgYmVpbmcgcmVjZWl2ZWQgZnJvbSB0aGUgcmVtb3RlIGRlbHRhIHNlcnZlclxuICAgICAqL1xuICAgIHByb2Nlc3MobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuT3BlcmF0aW9uICYmIGxvY2FsKSB7XG4gICAgICAgICAgICAvLyBkaXNjb25uZWN0ZWQgb3BzIHNob3VsZCBuZXZlciBiZSBwcm9jZXNzZWQuIFRoZXkgc2hvdWxkIGhhdmUgYmVlbiBmdWxseSBzZW50IG9uIGNvbm5lY3RlZFxuICAgICAgICAgICAgYXNzZXJ0KHRoaXMucGVuZGluZ09wcy5sZW5ndGggPT09IDAgfHwgdGhpcy5wZW5kaW5nT3BzLnBlZWtGcm9udCgpLmNsaWVudFNlcXVlbmNlTnVtYmVyICE9PSAtMSwgYHByb2Nlc3MgZm9yIGRpc2Nvbm5lY3RlZCBvcCAke3RoaXMucGVuZGluZ09wcy5wZWVrRnJvbnQoKS5jbGllbnRTZXF1ZW5jZU51bWJlcn1gKTtcbiAgICAgICAgICAgIC8vIE9uZSBvZiBvdXIgbWVzc2FnZXMgd2FzIHNlcXVlbmNlZC4gV2UgY2FuIHJlbW92ZSBpdCBmcm9tIHRoZSBsb2NhbCBtZXNzYWdlIGxpc3QuIEdpdmVuIHRoZXNlIGFycml2ZVxuICAgICAgICAgICAgLy8gaW4gb3JkZXIgd2Ugb25seSBuZWVkIHRvIGNoZWNrIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxvY2FsIGxpc3QuXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nT3BzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdPcHMucGVla0Zyb250KCkuY2xpZW50U2VxdWVuY2VOdW1iZXIgPT09IG1lc3NhZ2UuY2xpZW50U2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdPcHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nT3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9jZXNzZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWdfMS5kZWJ1ZyhgRHVwbGljYXRlIGFjayByZWNlaXZlZCAke21lc3NhZ2UuY2xpZW50U2VxdWVuY2VOdW1iZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwicHJlLW9wXCIsIG1lc3NhZ2UsIGxvY2FsKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29yZShtZXNzYWdlLCBsb2NhbCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMuZW1pdChcIm9wXCIsIG1lc3NhZ2UsIGxvY2FsKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZE9iamVjdCA9IFNoYXJlZE9iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZE9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFRPRE8gdGhpcyBpcyBwcm9iYWJseSB0b28gbWFwIHNwZWNpZmljIC0gYnV0IGlzIHVzZWQgdG8gc2VyYWlsaXplIG9iamVjdHMgaW4gY2VydGFpbiBjYXNlc1xudmFyIFZhbHVlVHlwZTtcbihmdW5jdGlvbiAoVmFsdWVUeXBlKSB7XG4gICAgLy8gVGhlIHZhbHVlIGlzIGEgc2hhcmVkIG9iamVjdFxuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJTaGFyZWRcIl0gPSAwXSA9IFwiU2hhcmVkXCI7XG4gICAgLy8gVGhlIHZhbHVlIGlzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiUGxhaW5cIl0gPSAxXSA9IFwiUGxhaW5cIjtcbiAgICAvLyBUaGUgdmFsdWUgaXMgYSBjb3VudGVyXG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkNvdW50ZXJcIl0gPSAyXSA9IFwiQ291bnRlclwiO1xuICAgIC8vIFRoZSB2YWx1ZSBpcyBhIHNldFxuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJTZXRcIl0gPSAzXSA9IFwiU2V0XCI7XG59KShWYWx1ZVR5cGUgPSBleHBvcnRzLlZhbHVlVHlwZSB8fCAoZXhwb3J0cy5WYWx1ZVR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsdWVUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNsYXNzIENoYW5uZWxEZWx0YUNvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9iamVjdElkLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICAgIF9zdGF0ZSwgc3VibWl0Rm4pIHtcbiAgICAgICAgdGhpcy5vYmplY3RJZCA9IG9iamVjdElkO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZTtcbiAgICAgICAgdGhpcy5zdWJtaXRGbiA9IHN1Ym1pdEZuO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgYXR0YWNoKGhhbmRsZXIpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6c3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgYXNzZXJ0KCF0aGlzLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBzZXRDb25uZWN0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyLnNldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSk7XG4gICAgfVxuICAgIHByZXBhcmUobWVzc2FnZSwgbG9jYWwpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIucHJlcGFyZShtZXNzYWdlLCBsb2NhbCk7XG4gICAgfVxuICAgIHByb2Nlc3MobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGFuZGxlci5wcm9jZXNzKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdXBkYXRlTWluU2VxdWVuY2VOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGFuZGxlci5taW5TZXF1ZW5jZU51bWJlckNoYW5nZWQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIG5ldyBtZXNzYWdlcyB0byB0aGUgc2VydmVyXG4gICAgICovXG4gICAgc3VibWl0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VibWl0Rm4obWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsRGVsdGFDb25uZWN0aW9uID0gQ2hhbm5lbERlbHRhQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWxEZWx0YUNvbm5lY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDaGFubmVsU3RvcmFnZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyZWUsIHN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRUcmVlID0ge307XG4gICAgICAgIC8vIENyZWF0ZSBhIG1hcCBmcm9tIHBhdGhzIHRvIGJsb2JzXG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOnN0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zICovXG4gICAgICAgIGlmICh0cmVlKSB7XG4gICAgICAgICAgICBDaGFubmVsU3RvcmFnZVNlcnZpY2UuZmxhdHRlblRyZWUoXCJcIiwgdHJlZSwgdGhpcy5mbGF0dGVuZWRUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZmxhdHRlblRyZWUoYmFzZSwgdHJlZSwgcmVzdWx0cykge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgICAgICAgZm9yIChjb25zdCBwYXRoIGluIHRyZWUudHJlZXMpIHtcbiAgICAgICAgICAgIENoYW5uZWxTdG9yYWdlU2VydmljZS5mbGF0dGVuVHJlZShgJHtiYXNlfSR7cGF0aH0vYCwgdHJlZS50cmVlc1twYXRoXSwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgICAgIGZvciAoY29uc3QgYmxvYiBpbiB0cmVlLmJsb2JzKSB7XG4gICAgICAgICAgICByZXN1bHRzW2Ake2Jhc2V9JHtibG9ifWBdID0gdHJlZS5ibG9ic1tibG9iXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpwcm9taXNlLWZ1bmN0aW9uLWFzeW5jICovXG4gICAgcmVhZChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHNoYSA9IHRoaXMuZ2V0U2hhRm9yUGF0aChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZWFkKHNoYSk7XG4gICAgfVxuICAgIGdldFNoYUZvclBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuZWRUcmVlW3BhdGhdO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbFN0b3JhZ2VTZXJ2aWNlID0gQ2hhbm5lbFN0b3JhZ2VTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbFN0b3JhZ2VTZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb250YWluZXJfZGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQHByYWd1ZS91dGlsc1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBjaGFubmVsRGVsdGFDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsRGVsdGFDb25uZWN0aW9uXCIpO1xuY29uc3QgY2hhbm5lbFN0b3JhZ2VTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsU3RvcmFnZVNlcnZpY2VcIik7XG5jb25zdCBsb2NhbENoYW5uZWxTdG9yYWdlU2VydmljZV8xID0gcmVxdWlyZShcIi4vbG9jYWxDaGFubmVsU3RvcmFnZVNlcnZpY2VcIik7XG5jbGFzcyBTZXJ2aWNlUGxhdGZvcm0gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucWkgPSBuZXcgTWFwKHNlcnZpY2VzKTtcbiAgICB9XG4gICAgcXVlcnlJbnRlcmZhY2UoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucWkuZ2V0KGlkKSB8fCBQcm9taXNlLnJlamVjdChgcXVlcnlJbnRlcmZhY2UoKSBmYWlsZWQgLSBVbmtub3duIGlkICcke2lkfScuYCk7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjb21wb25lbnQgY2xhc3NcbiAqL1xuY2xhc3MgQ29tcG9uZW50SG9zdCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLy8gdHNsaW50OmVuYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudFJ1bnRpbWUsIHRlbmFudElkLCBkb2N1bWVudElkLCBpZCwgcGFyZW50QnJhbmNoLCBleGlzdGluZywgb3B0aW9ucywgYmxvYk1hbmFnZXIsIGRlbHRhTWFuYWdlciwgcXVvcnVtLCBjaGFpbmNvZGUsIHN0b3JhZ2VTZXJ2aWNlLCBzbmFwc2hvdEZuLCBjbG9zZUZuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UnVudGltZSA9IGNvbXBvbmVudFJ1bnRpbWU7XG4gICAgICAgIHRoaXMudGVuYW50SWQgPSB0ZW5hbnRJZDtcbiAgICAgICAgdGhpcy5kb2N1bWVudElkID0gZG9jdW1lbnRJZDtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnBhcmVudEJyYW5jaCA9IHBhcmVudEJyYW5jaDtcbiAgICAgICAgdGhpcy5leGlzdGluZyA9IGV4aXN0aW5nO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmJsb2JNYW5hZ2VyID0gYmxvYk1hbmFnZXI7XG4gICAgICAgIHRoaXMuZGVsdGFNYW5hZ2VyID0gZGVsdGFNYW5hZ2VyO1xuICAgICAgICB0aGlzLnF1b3J1bSA9IHF1b3J1bTtcbiAgICAgICAgdGhpcy5jaGFpbmNvZGUgPSBjaGFpbmNvZGU7XG4gICAgICAgIHRoaXMuc3RvcmFnZVNlcnZpY2UgPSBzdG9yYWdlU2VydmljZTtcbiAgICAgICAgdGhpcy5zbmFwc2hvdEZuID0gc25hcHNob3RGbjtcbiAgICAgICAgdGhpcy5jbG9zZUZuID0gY2xvc2VGbjtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jaGFubmVsc0RlZmVycmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdBdHRhY2ggPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBMb2FkRnJvbVNuYXBzaG90KGNvbXBvbmVudFJ1bnRpbWUsIGNoYWluY29kZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHJlZSA9IGNvbXBvbmVudFJ1bnRpbWUuYmFzZVNuYXBzaG90O1xuICAgICAgICAgICAgY29uc3QgcnVudGltZSA9IG5ldyBDb21wb25lbnRIb3N0KGNvbXBvbmVudFJ1bnRpbWUsIGNvbXBvbmVudFJ1bnRpbWUudGVuYW50SWQsIGNvbXBvbmVudFJ1bnRpbWUuZG9jdW1lbnRJZCwgY29tcG9uZW50UnVudGltZS5pZCwgY29tcG9uZW50UnVudGltZS5wYXJlbnRCcmFuY2gsIGNvbXBvbmVudFJ1bnRpbWUuZXhpc3RpbmcsIGNvbXBvbmVudFJ1bnRpbWUub3B0aW9ucywgY29tcG9uZW50UnVudGltZS5ibG9iTWFuYWdlciwgY29tcG9uZW50UnVudGltZS5kZWx0YU1hbmFnZXIsIGNvbXBvbmVudFJ1bnRpbWUuZ2V0UXVvcnVtKCksIGNoYWluY29kZSwgY29tcG9uZW50UnVudGltZS5zdG9yYWdlLCBjb21wb25lbnRSdW50aW1lLnNuYXBzaG90Rm4sIGNvbXBvbmVudFJ1bnRpbWUuY2xvc2VGbik7XG4gICAgICAgICAgICAvLyBNdXN0IGFsd2F5cyByZWNlaXZlIHRoZSBjb21wb25lbnQgdHlwZSBpbnNpZGUgb2YgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICh0cmVlICYmIHRyZWUudHJlZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0cmVlLnRyZWVzKS5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2VydmUgc3BhY2UgZm9yIHRoZSBjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUucmVzZXJ2ZShwYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpwcm9taXNlLWZ1bmN0aW9uLWFzeW5jICovXG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZFNuYXBzaG90c1AgPSBPYmplY3Qua2V5cyh0cmVlLnRyZWVzKS5tYXAoKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bnRpbWUubG9hZFNuYXBzaG90Q2hhbm5lbChwYXRoLCB0cmVlLnRyZWVzW3BhdGhdLCBjb21wb25lbnRSdW50aW1lLnN0b3JhZ2UsIGNvbXBvbmVudFJ1bnRpbWUuYnJhbmNoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsb2FkU25hcHNob3RzUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgcnVudGltZVxuICAgICAgICAgICAgeWllbGQgcnVudGltZS5zdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bnRpbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSdW50aW1lLmNvbm5lY3RlZDtcbiAgICB9XG4gICAgLy8gSW50ZXJmYWNlIHVzZWQgdG8gYWNjZXNzIHRoZSBydW50aW1lIGNvZGVcbiAgICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybTtcbiAgICB9XG4gICAgZ2V0IGNsaWVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSdW50aW1lLmNsaWVudElkO1xuICAgIH1cbiAgICBjcmVhdGVBbmRBdHRhY2hDb21wb25lbnQoaWQsIHBrZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRSdW50aW1lLmNyZWF0ZUFuZEF0dGFjaENvbXBvbmVudChpZCwgcGtnKTtcbiAgICB9XG4gICAgZ2V0Q29tcG9uZW50KGlkLCB3YWl0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJ1bnRpbWUuZ2V0Q29tcG9uZW50KGlkLCB3YWl0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlbiAnaWQnLiAgT25jZSB0aGUgY29tcG9uZW50IGlzIHJldHJpZXZlZCwgaXQgaXMgYXR0YWNoZWRcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBsaXN0IG9mIHNlcnZpY2VzLlxuICAgICAqL1xuICAgIG9wZW5Db21wb25lbnQoaWQsIHdhaXQsIHNlcnZpY2VzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBydW50aW1lID0geWllbGQgdGhpcy5jb21wb25lbnRSdW50aW1lLmdldENvbXBvbmVudChpZCwgd2FpdCk7XG4gICAgICAgICAgICBjb25zdCBwbGF0Zm9ybSA9IHlpZWxkIHJ1bnRpbWUuYXR0YWNoKG5ldyBTZXJ2aWNlUGxhdGZvcm0oc2VydmljZXMpKTtcbiAgICAgICAgICAgIHJldHVybiBwbGF0Zm9ybS5xdWVyeUludGVyZmFjZShcImNvbXBvbmVudFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSByZXF1ZXN0LnVybC5zdWJzdHIoMSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHlpZWxkIHRoaXMuZ2V0Q2hhbm5lbChpZCk7XG4gICAgICAgICAgICByZXR1cm4geyBtaW1lVHlwZTogXCJwcmFndWUvZGF0YVR5cGVcIiwgc3RhdHVzOiAyMDAsIHZhbHVlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDaGFubmVsKGlkKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIC8vIFRPRE8gd2UgZG9uJ3QgYXNzdW1lIGFueSBjaGFubmVscyAoZXZlbiByb290KSBpbiB0aGUgcnVudGltZS4gSWYgeW91IHJlcXVlc3QgYSBjaGFubmVsIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAvLyB3ZSB3aWxsIG5ldmVyIHJlc29sdmUgdGhlIHByb21pc2UuIE1heSB3YW50IGEgZmxhZyB0byBnZXRDaGFubmVsIHRoYXQgZG9lc24ndCB3YWl0IGZvciB0aGUgcHJvbWlzZSBpZlxuICAgICAgICAvLyBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgIGlmICghdGhpcy5jaGFubmVsc0RlZmVycmVkLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNEZWZlcnJlZC5zZXQoaWQsIG5ldyB1dGlsc18xLkRlZmVycmVkKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzRGVmZXJyZWQuZ2V0KGlkKS5wcm9taXNlO1xuICAgIH1cbiAgICBjcmVhdGVDaGFubmVsKGlkLCB0eXBlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuY2hhaW5jb2RlLmdldE1vZHVsZSh0eXBlKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IGV4dGVuc2lvbi5jcmVhdGUodGhpcywgaWQpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzLnNldChpZCwgeyBiYXNlU2hhOiBudWxsLCBvYmplY3Q6IGNoYW5uZWwsIGNvbm5lY3Rpb246IG51bGwsIHN0b3JhZ2U6IG51bGwgfSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzRGVmZXJyZWQuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc0RlZmVycmVkLmdldChpZCkucmVzb2x2ZShjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IHV0aWxzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoY2hhbm5lbCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzRGVmZXJyZWQuc2V0KGlkLCBkZWZlcnJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIGF0dGFjaENoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICAvLyBHZXQgdGhlIG9iamVjdCBzbmFwc2hvdCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgaW5pdGlhbCBhdHRhY2hcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBjaGFubmVsLnNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpZDogY2hhbm5lbC5pZCxcbiAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgdHlwZTogY2hhbm5lbC50eXBlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlbmRpbmdBdHRhY2guc2V0KGNoYW5uZWwuaWQsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN1Ym1pdChjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5BdHRhY2gsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IGluIG91ciBsaXN0IG9mIG9iamVjdHMgYW5kIHRoZW4gZ2V0IHRoZSBzZXJ2aWNlc1xuICAgICAgICAvLyB1c2VkIHRvIGF0dGFjaCBpdCB0byB0aGUgc3RyZWFtXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5nZXRPYmplY3RTZXJ2aWNlcyhjaGFubmVsLmlkLCBudWxsLCB0aGlzLnN0b3JhZ2VTZXJ2aWNlKTtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmNoYW5uZWxzLmdldChjaGFubmVsLmlkKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGVudHJ5Lm9iamVjdCwgY2hhbm5lbCk7XG4gICAgICAgIGVudHJ5LmNvbm5lY3Rpb24gPSBzZXJ2aWNlcy5kZWx0YUNvbm5lY3Rpb247XG4gICAgICAgIGVudHJ5LnN0b3JhZ2UgPSBzZXJ2aWNlcy5vYmplY3RTdG9yYWdlO1xuICAgICAgICByZXR1cm4gc2VydmljZXM7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtID0geWllbGQgdGhpcy5jaGFpbmNvZGUucnVuKHRoaXMsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hhbmdlQ29ubmVjdGlvblN0YXRlKHZhbHVlLCBjbGllbnRJZCkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICAvLyBSZXNlbmQgYWxsIHBlbmRpbmcgYXR0YWNoIG1lc3NhZ2VzIHByaW9yIHRvIG5vdGlmeWluZyBjbGllbnRzXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBtZXNzYWdlXSBvZiB0aGlzLnBlbmRpbmdBdHRhY2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdChjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5BdHRhY2gsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgWywgb2JqZWN0XSBvZiB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuY29ubmVjdGlvbi5zZXRDb25uZWN0aW9uU3RhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGVkXCIsIGNsaWVudElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRRdW9ydW0oKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1b3J1bTtcbiAgICB9XG4gICAgc25hcHNob3QobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zbmFwc2hvdEZuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzYXZlKHRhZykge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICB0aGlzLnN1Ym1pdChjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5TYXZlLCB0YWcpO1xuICAgIH1cbiAgICB1cGxvYWRCbG9iKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgICAgICBjb25zdCBzaGEgPSB1dGlsc18xLmdpdEhhc2hGaWxlKGZpbGUuY29udGVudCk7XG4gICAgICAgICAgICBmaWxlLnNoYSA9IHNoYTtcbiAgICAgICAgICAgIGZpbGUudXJsID0gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSYXdVcmwoc2hhKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYmxvYk1hbmFnZXIuY3JlYXRlQmxvYihmaWxlKTtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0KGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLk1lc3NhZ2VUeXBlLkJsb2JVcGxvYWRlZCwgeWllbGQgdGhpcy5ibG9iTWFuYWdlci5jcmVhdGVCbG9iKGZpbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvYihzaGEpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYk1hbmFnZXIuZ2V0QmxvYihzaGEpO1xuICAgIH1cbiAgICBnZXRCbG9iTWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iTWFuYWdlci5nZXRCbG9iTWV0YWRhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc25hcHNob3RJbnRlcm5hbCgpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUZuKCk7XG4gICAgfVxuICAgIHByZXBhcmUobWVzc2FnZSwgbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5BdHRhY2g6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXBhcmVBdHRhY2gobWVzc2FnZSwgbG9jYWwpO1xuICAgICAgICAgICAgICAgIGNhc2UgY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuT3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlT3AobWVzc2FnZSwgbG9jYWwpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3MobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLk1lc3NhZ2VUeXBlLkF0dGFjaDpcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnByb2Nlc3NBdHRhY2gobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5PcGVyYXRpb246XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5wcm9jZXNzT3AobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJvcFwiLCBtZXNzYWdlLCB0YXJnZXQpO1xuICAgIH1cbiAgICB1cGRhdGVNaW5TZXF1ZW5jZU51bWJlcihtc24pIHtcbiAgICAgICAgZm9yIChjb25zdCBbLCBvYmplY3RdIG9mIHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0Lm9iamVjdC5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuY29ubmVjdGlvbi51cGRhdGVNaW5TZXF1ZW5jZU51bWJlcihtc24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNuYXBzaG90SW50ZXJuYWwoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVNaW5TZXF1ZW5jZU51bWJlcih0aGlzLmRlbHRhTWFuYWdlci5taW5pbXVtU2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICAvLyBDcmFmdCB0aGUgLmF0dHJpYnV0ZXMgZmlsZSBmb3IgZWFjaCBkaXN0cmlidXRlZCBvYmplY3RcbiAgICAgICAgZm9yIChjb25zdCBbb2JqZWN0SWQsIG9iamVjdF0gb2YgdGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBpc24ndCBsb2NhbCAtIGFuZCB3ZSBoYXZlIHJlY2VpdmVkIHRoZSBzZXF1ZW5jZWQgb3AgY3JlYXRpbmcgdGhlIG9iamVjdCAoaS5lLiBpdCBoYXMgYVxuICAgICAgICAgICAgLy8gYmFzZSBtYXBwaW5nKSAtIHRoZW4gd2UgZ28gYWhlYWQgYW5kIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIW9iamVjdC5vYmplY3QuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBvYmplY3Qub2JqZWN0LnNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGluIHRoZSBvYmplY3QgYXR0cmlidXRlcyB0byB0aGUgcmV0dXJuZWQgdHJlZVxuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9iamVjdC5vYmplY3QudHlwZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNuYXBzaG90LmVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLkZpbGVNb2RlLkZpbGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiLmF0dHJpYnV0ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY29udGFpbmVyX2RlZmluaXRpb25zXzEuVHJlZUVudHJ5W2NvbnRhaW5lcl9kZWZpbml0aW9uc18xLlRyZWVFbnRyeS5CbG9iXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBKU09OLnN0cmluZ2lmeShvYmplY3RBdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYmFzZVNoYSBleGlzdHMgdGhlbiB0aGUgcHJldmlvdXMgc25hcHNob3QgaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmJhc2VTaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3Quc2hhID0gb2JqZWN0LmJhc2VTaGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFuZCB0aGVuIHN0b3JlIHRoZSB0cmVlXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogY29udGFpbmVyX2RlZmluaXRpb25zXzEuRmlsZU1vZGUuRGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBvYmplY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY29udGFpbmVyX2RlZmluaXRpb25zXzEuVHJlZUVudHJ5W2NvbnRhaW5lcl9kZWZpbml0aW9uc18xLlRyZWVFbnRyeS5UcmVlXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNuYXBzaG90LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgIH1cbiAgICBzdWJtaXRNZXNzYWdlKHR5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zdWJtaXQodHlwZSwgY29udGVudCk7XG4gICAgfVxuICAgIHN1Ym1pdCh0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJ1bnRpbWUuc3VibWl0TWVzc2FnZSh0eXBlLCBjb250ZW50KTtcbiAgICB9XG4gICAgcmVzZXJ2ZShpZCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbm5lbHNEZWZlcnJlZC5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzRGVmZXJyZWQuc2V0KGlkLCBuZXcgdXRpbHNfMS5EZWZlcnJlZCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlT3AobWVzc2FnZSwgbG9jYWwpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBtZXNzYWdlLmNvbnRlbnRzO1xuICAgICAgICBjb25zdCBvYmplY3REZXRhaWxzID0gdGhpcy5jaGFubmVscy5nZXQoZW52ZWxvcGUuYWRkcmVzcyk7XG4gICAgICAgIGFzc2VydChvYmplY3REZXRhaWxzKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB7XG4gICAgICAgICAgICBjbGllbnRJZDogbWVzc2FnZS5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudFNlcXVlbmNlTnVtYmVyOiBtZXNzYWdlLmNsaWVudFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgY29udGVudHM6IGVudmVsb3BlLmNvbnRlbnRzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UubWV0YWRhdGEsXG4gICAgICAgICAgICBtaW5pbXVtU2VxdWVuY2VOdW1iZXI6IG1lc3NhZ2UubWluaW11bVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgb3JpZ2luOiBtZXNzYWdlLm9yaWdpbixcbiAgICAgICAgICAgIHJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyOiBtZXNzYWdlLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IG1lc3NhZ2Uuc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG1lc3NhZ2UudGltZXN0YW1wLFxuICAgICAgICAgICAgdHJhY2VzOiBtZXNzYWdlLnRyYWNlcyxcbiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9iamVjdERldGFpbHMuY29ubmVjdGlvbi5wcmVwYXJlKHRyYW5zZm9ybWVkLCBsb2NhbCk7XG4gICAgfVxuICAgIHByb2Nlc3NPcChtZXNzYWdlLCBsb2NhbCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICBjb25zdCBlbnZlbG9wZSA9IG1lc3NhZ2UuY29udGVudHM7XG4gICAgICAgIGNvbnN0IG9iamVjdERldGFpbHMgPSB0aGlzLmNoYW5uZWxzLmdldChlbnZlbG9wZS5hZGRyZXNzKTtcbiAgICAgICAgYXNzZXJ0KG9iamVjdERldGFpbHMpO1xuICAgICAgICAvLyBDbGVhciBiYXNlIHNoYSBzaW5jZSB0aGUgY2hhbm5lbCBpcyBub3cgZGlydHlcbiAgICAgICAgb2JqZWN0RGV0YWlscy5iYXNlU2hhID0gbnVsbDtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB7XG4gICAgICAgICAgICBjbGllbnRJZDogbWVzc2FnZS5jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudFNlcXVlbmNlTnVtYmVyOiBtZXNzYWdlLmNsaWVudFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgY29udGVudHM6IGVudmVsb3BlLmNvbnRlbnRzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UubWV0YWRhdGEsXG4gICAgICAgICAgICBtaW5pbXVtU2VxdWVuY2VOdW1iZXI6IG1lc3NhZ2UubWluaW11bVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgb3JpZ2luOiBtZXNzYWdlLm9yaWdpbixcbiAgICAgICAgICAgIHJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyOiBtZXNzYWdlLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IG1lc3NhZ2Uuc2VxdWVuY2VOdW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG1lc3NhZ2UudGltZXN0YW1wLFxuICAgICAgICAgICAgdHJhY2VzOiBtZXNzYWdlLnRyYWNlcyxcbiAgICAgICAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgb2JqZWN0RGV0YWlscy5jb25uZWN0aW9uLnByb2Nlc3ModHJhbnNmb3JtZWQsIGxvY2FsLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdERldGFpbHMub2JqZWN0O1xuICAgIH1cbiAgICBwcm9jZXNzQXR0YWNoKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIGNvbnN0IGF0dGFjaE1lc3NhZ2UgPSBtZXNzYWdlLmNvbnRlbnRzO1xuICAgICAgICAvLyBJZiBhIG5vbi1sb2NhbCBvcGVyYXRpb24gdGhlbiBnbyBhbmQgY3JlYXRlIHRoZSBvYmplY3QgLSBvdGhlcndpc2UgbWFyayBpdCBhcyBvZmZpY2lhbGx5IGF0dGFjaGVkLlxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLnBlbmRpbmdBdHRhY2guaGFzKGF0dGFjaE1lc3NhZ2UuaWQpKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0F0dGFjaC5kZWxldGUoYXR0YWNoTWVzc2FnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsU3RhdGUgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5zZXQoY2hhbm5lbFN0YXRlLm9iamVjdC5pZCwgY2hhbm5lbFN0YXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzRGVmZXJyZWQuaGFzKGNoYW5uZWxTdGF0ZS5vYmplY3QuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc0RlZmVycmVkLmdldChjaGFubmVsU3RhdGUub2JqZWN0LmlkKS5yZXNvbHZlKGNoYW5uZWxTdGF0ZS5vYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgdXRpbHNfMS5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoY2hhbm5lbFN0YXRlLm9iamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsc0RlZmVycmVkLnNldChjaGFubmVsU3RhdGUub2JqZWN0LmlkLCBkZWZlcnJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuZ2V0KGF0dGFjaE1lc3NhZ2UuaWQpLm9iamVjdDtcbiAgICB9XG4gICAgcHJlcGFyZUF0dGFjaChtZXNzYWdlLCBsb2NhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dGFjaE1lc3NhZ2UgPSBtZXNzYWdlLmNvbnRlbnRzO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHN0b3JhZ2Ugc2VydmljZSB0aGF0IHdyYXBzIHRoZSBhdHRhY2ggZGF0YVxuICAgICAgICAgICAgY29uc3QgbG9jYWxTdG9yYWdlID0gbmV3IGxvY2FsQ2hhbm5lbFN0b3JhZ2VTZXJ2aWNlXzEuTG9jYWxDaGFubmVsU3RvcmFnZVNlcnZpY2UoYXR0YWNoTWVzc2FnZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IGNoYW5uZWxEZWx0YUNvbm5lY3Rpb25fMS5DaGFubmVsRGVsdGFDb25uZWN0aW9uKGF0dGFjaE1lc3NhZ2UuaWQsIHRoaXMuY29tcG9uZW50UnVudGltZS5jb25uZWN0aW9uU3RhdGUsIChzdWJtaXRNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VibWl0RW52ZWxvcGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGF0dGFjaE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBzdWJtaXRNZXNzYWdlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VibWl0KGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLk1lc3NhZ2VUeXBlLk9wZXJhdGlvbiwgc3VibWl0RW52ZWxvcGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHtcbiAgICAgICAgICAgICAgICBiYXNlU2hhOiBudWxsLFxuICAgICAgICAgICAgICAgIGRlbHRhQ29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvYmplY3RTdG9yYWdlOiBsb2NhbFN0b3JhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gbWVzc2FnZS5vcmlnaW4gPyBtZXNzYWdlLm9yaWdpbi5pZCA6IHRoaXMuaWQ7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHlpZWxkIHRoaXMubG9hZENoYW5uZWwoYXR0YWNoTWVzc2FnZS5pZCwgYXR0YWNoTWVzc2FnZS50eXBlLCBtZXNzYWdlLm1pbmltdW1TZXF1ZW5jZU51bWJlciwgc2VydmljZXMsIG9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkU25hcHNob3RDaGFubmVsKGlkLCB0cmVlLCBzdG9yYWdlLCBicmFuY2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxBdHRyaWJ1dGVzID0geWllbGQgdXRpbHNfMS5yZWFkQW5kUGFyc2Uoc3RvcmFnZSwgdHJlZS5ibG9ic1tcIi5hdHRyaWJ1dGVzXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5nZXRPYmplY3RTZXJ2aWNlcyhpZCwgdHJlZSwgc3RvcmFnZSk7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRGV0YWlscyA9IHlpZWxkIHRoaXMubG9hZENoYW5uZWwoaWQsIGNoYW5uZWxBdHRyaWJ1dGVzLnR5cGUsIHRoaXMuZGVsdGFNYW5hZ2VyLm1pbmltdW1TZXF1ZW5jZU51bWJlciwgc2VydmljZXMsIGJyYW5jaCk7XG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMuY2hhbm5lbHMuaGFzKGlkKSk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLnNldChpZCwgY2hhbm5lbERldGFpbHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc0RlZmVycmVkLmdldChpZCkucmVzb2x2ZShjaGFubmVsRGV0YWlscy5vYmplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZENoYW5uZWwoaWQsIHR5cGUsIG1pblNlcXVlbmNlTnVtYmVyLCBzZXJ2aWNlcywgb3JpZ2luQnJhbmNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBQYXNzIHRoZSB0cmFuc2Zvcm1lZE1lc3NhZ2VzIC0gYnV0IHRoZSBvYmplY3QgcmVhbGx5IHNob3VsZCBiZSBzdG9yaW5nIHRoaXNcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuY2hhaW5jb2RlLmdldE1vZHVsZSh0eXBlKTtcbiAgICAgICAgICAgIC8vIFRPRE8gbmVlZCB0byBmaXggdXAgdGhlIFNOIHZzLiBNU04gc3R1ZmYgaGVyZS4gSWYgd2FudCB0byBwdXNoIG1lc3NhZ2VzIHRvIG9iamVjdCBhbHNvIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHN0b3JlIHRoZSBtYXBwaW5ncyBmcm9tIGNoYW5uZWwgSUQgdG8gZG9jIElELlxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB5aWVsZCBleHRlbnNpb24ubG9hZCh0aGlzLCBpZCwgbWluU2VxdWVuY2VOdW1iZXIsIHNlcnZpY2VzLCBvcmlnaW5CcmFuY2gpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYXNlU2hhOiBzZXJ2aWNlcy5iYXNlU2hhLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IHNlcnZpY2VzLmRlbHRhQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHNlcnZpY2VzLm9iamVjdFN0b3JhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T2JqZWN0U2VydmljZXMoaWQsIHRyZWUsIHN0b3JhZ2UpIHtcbiAgICAgICAgY29uc3QgZGVsdGFDb25uZWN0aW9uID0gbmV3IGNoYW5uZWxEZWx0YUNvbm5lY3Rpb25fMS5DaGFubmVsRGVsdGFDb25uZWN0aW9uKGlkLCB0aGlzLmNvbXBvbmVudFJ1bnRpbWUuY29ubmVjdGlvblN0YXRlLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSB7IGFkZHJlc3M6IGlkLCBjb250ZW50czogbWVzc2FnZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VibWl0KGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLk1lc3NhZ2VUeXBlLk9wZXJhdGlvbiwgZW52ZWxvcGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmFnZSA9IG5ldyBjaGFubmVsU3RvcmFnZVNlcnZpY2VfMS5DaGFubmVsU3RvcmFnZVNlcnZpY2UodHJlZSwgc3RvcmFnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlU2hhOiB0cmVlID8gdHJlZS5zaGEgOiBudWxsLFxuICAgICAgICAgICAgZGVsdGFDb25uZWN0aW9uLFxuICAgICAgICAgICAgb2JqZWN0U3RvcmFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmVyaWZ5Tm90Q2xvc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bnRpbWUgaXMgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db21wb25lbnRIb3N0ID0gQ29tcG9uZW50SG9zdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudEhvc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tcG9uZW50SG9zdFwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xID0gcmVxdWlyZShcIkBwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zXCIpO1xuY2xhc3MgTG9jYWxDaGFubmVsU3RvcmFnZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyZWUpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGU6cHJvbWlzZS1mdW5jdGlvbi1hc3luYyAqL1xuICAgIHJlYWQocGF0aCkge1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMucmVhZFN5bmMocGF0aCk7XG4gICAgICAgIHJldHVybiBjb250ZW50cyAhPT0gdW5kZWZpbmVkID8gUHJvbWlzZS5yZXNvbHZlKGNvbnRlbnRzKSA6IFByb21pc2UucmVqZWN0KFwiTm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHN5bmNocm9ub3VzIGFjY2VzcyBwb2ludCB0byBsb2NhbGx5IHN0b3JlZCBkYXRhXG4gICAgICovXG4gICAgcmVhZFN5bmMocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkU3luY0ludGVybmFsKHBhdGgsIHRoaXMudHJlZSk7XG4gICAgfVxuICAgIHJlYWRTeW5jSW50ZXJuYWwocGF0aCwgdHJlZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRyZWUuZW50cmllcykge1xuICAgICAgICAgICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5UcmVlRW50cnlbY29udGFpbmVyX2RlZmluaXRpb25zXzEuVHJlZUVudHJ5LkJsb2JdOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gZW50cnkucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2IuZW5jb2RpbmcgPT09IFwidXRmLThcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlcihibG9iLmNvbnRlbnRzKS50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYmxvYi5jb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLlRyZWVFbnRyeVtjb250YWluZXJfZGVmaW5pdGlvbnNfMS5UcmVlRW50cnkuVHJlZV06XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoZW50cnkucGF0aCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRTeW5jSW50ZXJuYWwocGF0aC5zdWJzdHIoZW50cnkucGF0aC5sZW5ndGggKyAxKSwgZW50cnkudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkxvY2FsQ2hhbm5lbFN0b3JhZ2VTZXJ2aWNlID0gTG9jYWxDaGFubmVsU3RvcmFnZVNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbENoYW5uZWxTdG9yYWdlU2VydmljZS5qcy5tYXAiLCJjb25zdCBNYXhCYXRjaFNpemUgPSAxMDA7XG5leHBvcnQgY2xhc3MgQmF0Y2hNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgICAgIHRoaXMucGVuZGluZ1dvcmsgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFkZChpZCwgd29yaykge1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1dvcmsuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nV29yay5zZXQoaWQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdXb3JrLmdldChpZClcbiAgICAgICAgICAgIC5wdXNoKHdvcmspO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nV29yay5nZXQoaWQpLmxlbmd0aCA+PSBNYXhCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0V29yaygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgb25jZSBhbGwgcGVuZGluZyB3b3JrIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgZHJhaW4oKSB7XG4gICAgICAgIHRoaXMuc3RhcnRXb3JrKCk7XG4gICAgfVxuICAgIHN0YXJ0V29yaygpIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGludGVybmFsIGZsYWdzIGZpcnN0IHRvIGF2b2lkIGlzc3VlcyBpbiBjYXNlIGFueSBvZiB0aGUgcGVuZGluZyB3b3JrIGNhbGxzIGJhY2sgaW50b1xuICAgICAgICAvLyB0aGUgYmF0Y2ggbWFuYWdlci4gV2UgY291bGQgYWxzbyBkbyB0aGlzIHdpdGggYSBzZWNvbmQgc2V0SW1tZWRpYXRlIGNhbGwgYnV0IGF2b2RpaW5nIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIHdvcmsgcXVpY2tlci5cbiAgICAgICAgY29uc3QgcGVuZGluZ1dvcmsgPSB0aGlzLnBlbmRpbmdXb3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmdXb3JrID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUT0RPIGxvZyB0byBpbmZsdXggaG93IG11Y2ggcGVuZGluZyB3b3JrIHRoZXJlIGlzLiBXZSB3YW50IHRvIGxpbWl0IHRoZSBzaXplIG9mIGEgYmF0Y2hcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGJhdGNoXSBvZiBwZW5kaW5nV29yaykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGlkLCBiYXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaE1hbmFnZXIuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGaWxlTW9kZSwgVHJlZUVudHJ5LCB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN1Ym1vZHVsZS1pbXBvcnRzXG5pbXBvcnQgKiBhcyBzaGExIGZyb20gXCJzaGEuanMvc2hhMVwiO1xuLyoqXG4gKiBDcmVhdGUgSGFzaCAoR2l0aHViIGhhc2hlcyB0aGUgc3RyaW5nIHdpdGggYmxvYiBhbmQgc2l6ZSlcbiAqIEBwYXJhbSBmaWxlIFRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBpbiBhIGJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2l0SGFzaEZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHNpemUgPSBmaWxlLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZmlsZVByZWZpeCA9IFwiYmxvYiBcIiArIHNpemUudG9TdHJpbmcoKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBzaGExKCk7XG4gICAgcmV0dXJuIGVuZ2luZS51cGRhdGUoZmlsZVByZWZpeClcbiAgICAgICAgLnVwZGF0ZShmaWxlKVxuICAgICAgICAuZGlnZXN0KFwiaGV4XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4odHJlZSwgYmxvYk1hcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmbGF0dGVuQ29yZShcIlwiLCB0cmVlLCBibG9iTWFwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaGE6IG51bGwsXG4gICAgICAgIHRyZWU6IGVudHJpZXMsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRBbmRQYXJzZShzdG9yYWdlLCBzaGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0geWllbGQgc3RvcmFnZS5yZWFkKHNoYSk7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBCdWZmZXJcbiAgICAgICAgICAgIC5mcm9tKGVuY29kZWQsIFwiYmFzZTY0XCIpXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuQ29yZShwYXRoLCB0cmVlRW50cmllcywgYmxvYk1hcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IHRyZWVFbnRyeSBvZiB0cmVlRW50cmllcykge1xuICAgICAgICBjb25zdCBzdWJQYXRoID0gYCR7cGF0aH0ke3RyZWVFbnRyeS5wYXRofWA7XG4gICAgICAgIGlmICh0cmVlRW50cnkudHlwZSA9PT0gVHJlZUVudHJ5W1RyZWVFbnRyeS5CbG9iXSkge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IHRyZWVFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJsb2IuY29udGVudHMsIGJsb2IuZW5jb2RpbmcpO1xuICAgICAgICAgICAgY29uc3Qgc2hhID0gZ2l0SGFzaEZpbGUoYnVmZmVyKTtcbiAgICAgICAgICAgIGJsb2JNYXAuc2V0KHNoYSwgYnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlW3RyZWVFbnRyeS5tb2RlXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIHNoYSxcbiAgICAgICAgICAgICAgICBzaXplOiBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgICAgICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRyZWVFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlW3RyZWVFbnRyeS5tb2RlXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIHNoYTogbnVsbCxcbiAgICAgICAgICAgICAgICBzaXplOiAtMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRyZWVcIixcbiAgICAgICAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlRyZWVFbnRyaWVzID0gZmxhdHRlbkNvcmUoc3ViUGF0aCArIFwiL1wiLCB0LmVudHJpZXMsIGJsb2JNYXApO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKC4uLnN1YlRyZWVFbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEhpZXJhcmNoeShmbGF0VHJlZSkge1xuICAgIGlmICghZmxhdFRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cCA9IHt9O1xuICAgIGNvbnN0IHJvb3QgPSB7IHNoYTogZmxhdFRyZWUuc2hhLCBibG9iczoge30sIGNvbW1pdHM6IHt9LCB0cmVlczoge30gfTtcbiAgICBsb29rdXBbXCJcIl0gPSByb290O1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZmxhdFRyZWUudHJlZSkge1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBlbnRyeS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZW50cnlQYXRoRGlyID0gZW50cnkucGF0aC5zbGljZSgwLCBNYXRoLm1heCgwLCBsYXN0SW5kZXgpKTtcbiAgICAgICAgY29uc3QgZW50cnlQYXRoQmFzZSA9IGVudHJ5LnBhdGguc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICAgIC8vIFRoZSBmbGF0IG91dHB1dCBpcyBicmVhZHRoLWZpcnN0IHNvIHdlIGNhbiBhc3N1bWUgd2Ugc2VlIHRyZWUgbm9kZXMgcHJpb3IgdG8gdGhlaXIgY29udGVudHNcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxvb2t1cFtlbnRyeVBhdGhEaXJdO1xuICAgICAgICAvLyBBZGQgaW4gZWl0aGVyIHRoZSBibG9iIG9yIHRyZWVcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09IFwidHJlZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0geyBzaGE6IGVudHJ5LnNoYSwgYmxvYnM6IHt9LCBjb21taXRzOiB7fSwgdHJlZXM6IHt9IH07XG4gICAgICAgICAgICBub2RlLnRyZWVzW2VudHJ5UGF0aEJhc2VdID0gbmV3VHJlZTtcbiAgICAgICAgICAgIGxvb2t1cFtlbnRyeS5wYXRoXSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gXCJibG9iXCIpIHtcbiAgICAgICAgICAgIG5vZGUuYmxvYnNbZW50cnlQYXRoQmFzZV0gPSBlbnRyeS5zaGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gXCJjb21taXRcIikge1xuICAgICAgICAgICAgbm9kZS5jb21taXRzW2VudHJ5UGF0aEJhc2VdID0gZW50cnkuc2hhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYnMuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxuLy8gdHNsaW50OmRpc2FibGU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuLy8gdHNsaW50OmRpc2FibGU6bm8tcGFyYW1ldGVyLXJlYXNzaWdubWVudFxuZXhwb3J0IGNvbnN0IE51bWJlckNvbXBhcmVyID0ge1xuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBtaW46IE51bWJlci5NSU5fVkFMVUUsXG59O1xuZXhwb3J0IGNsYXNzIEhlYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXApIHtcbiAgICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgICAgdGhpcy5MID0gW3sgdmFsdWU6IGNvbXAubWluLCBwb3NpdGlvbjogMCB9XTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTFsxXTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICB0aGlzLnN3YXAoMSwgdGhpcy5jb3VudCgpKTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuTC5wb3AoKTtcbiAgICAgICAgdGhpcy5maXhkb3duKDEpO1xuICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICB9XG4gICAgYWRkKHgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IHgsIHBvc2l0aW9uOiB0aGlzLkwubGVuZ3RoIH07XG4gICAgICAgIHRoaXMuTC5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmZpeHVwKHRoaXMuY291bnQoKSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIGhlYXAgdG8gYmUgdXBkYXRlZCBhZnRlciBhIG5vZGUncyB2YWx1ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgdXBkYXRlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgayA9IG5vZGUucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmlzR3JlYXRlclRoYW5QYXJlbnQoaykpIHtcbiAgICAgICAgICAgIHRoaXMuZml4dXAoayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpeGRvd24oayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBoZWFwXG4gICAgICovXG4gICAgcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgbm9kZSB3ZSB3YW50IHRvIHJlbW92ZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XG4gICAgICAgIHRoaXMuc3dhcChub2RlLnBvc2l0aW9uLCB0aGlzLkwubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuTC5zcGxpY2UodGhpcy5MLmxlbmd0aCAtIDEpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN3YXBwZWQgbm9kZSBhc3N1bWluZyB3ZSBkaWRuJ3QgcmVtb3ZlIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSB0aGlzLkwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLkxbcG9zaXRpb25dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTC5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBmaXh1cChrKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzR3JlYXRlclRoYW5QYXJlbnQoaykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGsgPj4gMTtcbiAgICAgICAgICAgIHRoaXMuc3dhcChrLCBwYXJlbnQpO1xuICAgICAgICAgICAgayA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0dyZWF0ZXJUaGFuUGFyZW50KGspIHtcbiAgICAgICAgcmV0dXJuIGsgPiAxICYmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxbayA+PiAxXS52YWx1ZSwgdGhpcy5MW2tdLnZhbHVlKSA+IDApO1xuICAgIH1cbiAgICBmaXhkb3duKGspIHtcbiAgICAgICAgd2hpbGUgKChrIDw8IDEpIDw9IHRoaXMuY291bnQoKSkge1xuICAgICAgICAgICAgbGV0IGogPSBrIDw8IDE7XG4gICAgICAgICAgICBpZiAoKGogPCB0aGlzLmNvdW50KCkpICYmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxbal0udmFsdWUsIHRoaXMuTFtqICsgMV0udmFsdWUpID4gMCkpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wLmNvbXBhcmUodGhpcy5MW2tdLnZhbHVlLCB0aGlzLkxbal0udmFsdWUpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3dhcChrLCBqKTtcbiAgICAgICAgICAgIGsgPSBqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3YXAoaywgaikge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLkxba107XG4gICAgICAgIHRoaXMuTFtrXSA9IHRoaXMuTFtqXTtcbiAgICAgICAgdGhpcy5MW2tdLnBvc2l0aW9uID0gaztcbiAgICAgICAgdGhpcy5MW2pdID0gdG1wO1xuICAgICAgICB0aGlzLkxbal0ucG9zaXRpb24gPSBqO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYXAuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vYmF0Y2hNYW5hZ2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ibG9ic1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVhcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvbWlzZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JhbmdlVHJhY2tlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmF0ZUxpbWl0dGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zYWZlUGFyc2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91dGlsc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbi8qKlxuICogQSBkZWZlcnJlZCBjcmVhdGVzIGEgcHJvbWlzZSBhbmQgdGhlIGFiaWxpdHkgdG8gcmVzb2x2ZSBvciByZWplY3QgaXRcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6cHJvbWlzZS1tdXN0LWNvbXBsZXRlICovXG4gICAgICAgIHRoaXMucCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1bmRlcmx5aW5nIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZFxuICAgICAqL1xuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgcHJvbWlzZVxuICAgICAqL1xuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXModmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlXG4gICAgICovXG4gICAgcmVqZWN0KGVycm9yKSB7XG4gICAgICAgIHRoaXMucmVqKGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gcHJvbWlzZSBvbmx5IHJlc29sdmVzXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOnByb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RSZWplY3RlZChwcm9taXNlKSB7XG4gICAgLy8gQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHByb21pc2Ugb25seSByZXNvbHZlc1xuICAgIHByb21pc2UuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFzc2VydC5vayhmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlcy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuLy8gdHNsaW50OmRpc2FibGU6bm8tdmFyLXJlcXVpcmVzXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3VibW9kdWxlLWltcG9ydHNcbmNvbnN0IGNsb25lRGVlcCA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiB0aGUgcmVsYXRpb24gYmV0d2VlbiB0d28gcmFuZ2VzIGluIGEgMTpOIGZhc2hpb24uIFByaW1hcnlcbiAqIGlzIGNvbnRpbnVvdXMgYW5kIGFsd2F5cyBtYXBzIHRvIGEgc2luZ2xlIHZhbHVlIGluIHNlY29uZGFyeSBhYm92ZSB0aGUgYmFzZSB2YWx1ZS4gVGhlIHJhbmdlXG4gKiBkZWZpbmVzIGFuIGluY3JlYXNpbmcgc3RlcCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlVHJhY2tlciB7XG4gICAgZ2V0IGJhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS5wcmltYXJ5O1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeUhlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RQcmltYXJ5O1xuICAgIH1cbiAgICBnZXQgc2Vjb25kYXJ5SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlY29uZGFyeTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbWFyeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBbeyBsZW5ndGg6IDAsIHByaW1hcnksIHNlY29uZGFyeSB9XTtcbiAgICAgICAgICAgIHRoaXMubGFzdFByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICAgICAgdGhpcy5sYXN0U2Vjb25kYXJ5ID0gc2Vjb25kYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBjbG9uZURlZXAocHJpbWFyeS5yYW5nZXMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0UHJpbWFyeSA9IHByaW1hcnkubGFzdFByaW1hcnk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWNvbmRhcnkgPSBwcmltYXJ5Lmxhc3RTZWNvbmRhcnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgUmFuZ2VUcmFja2VyXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFzdFByaW1hcnk6IHRoaXMubGFzdFByaW1hcnksXG4gICAgICAgICAgICBsYXN0U2Vjb25kYXJ5OiB0aGlzLmxhc3RTZWNvbmRhcnksXG4gICAgICAgICAgICByYW5nZXM6IGNsb25lRGVlcCh0aGlzLnJhbmdlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHByaW1hcnkgaXMgdGltZSAtIHNlY29uZGFyeSBpcyB0aGUgTVNOXG4gICAgYWRkKHByaW1hcnksIHNlY29uZGFyeSkge1xuICAgICAgICAvLyBCb3RoIHZhbHVlcyBtdXN0IGNvbnRpbnVvdXNseSBiZSBpbmNyZWFzaW5nIC0gd2Ugd29uJ3QgYWx3YXlzIHRyYWNrIHRoZSBsYXN0IHZhbHVlIHdlIHNhdyBzbyB3ZSBkbyBzb1xuICAgICAgICAvLyBiZWxvdyB0byBjaGVjayBpbnZhcmlhbnRzXG4gICAgICAgIGFzc2VydChwcmltYXJ5ID49IHRoaXMubGFzdFByaW1hcnkpO1xuICAgICAgICBhc3NlcnQoc2Vjb25kYXJ5ID49IHRoaXMubGFzdFNlY29uZGFyeSk7XG4gICAgICAgIHRoaXMubGFzdFByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICB0aGlzLmxhc3RTZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gICAgICAgIC8vIEdldCBxdWlja2VyIHJlZmVyZW5jZXMgdG8gdGhlIGhlYWQgb2YgdGhlIHJhbmdlXG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcHJpbWFyeUhlYWQgPSBoZWFkLnByaW1hcnkgKyBoZWFkLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2Vjb25kYXJ5SGVhZCA9IGhlYWQuc2Vjb25kYXJ5ICsgaGVhZC5sZW5ndGg7XG4gICAgICAgIC8vIFNhbWUgc2Vjb25kYXJ5IGluZGljYXRlcyB0aGlzIGlzIG5vdCBhIHRydWUgaW5mbGVjdGlvbiBwb2ludCAtIHdlIGNhbiBpZ25vcmUgaXRcbiAgICAgICAgaWYgKHNlY29uZGFyeSA9PT0gc2Vjb25kYXJ5SGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBzZWNvbmRhcnkgLSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2VzXG4gICAgICAgIGlmIChwcmltYXJ5ID09PSBwcmltYXJ5SGVhZCkge1xuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBjb2RlIHBhdGggaGFzIHVzIHN1cHBvcnRpbmcgTjpOIHJhbmdlcy4gQnV0IHdlIHNpbXBseSBvdmVyd3JpdGUgZHVwbGljYXRlIHZhbHVlcyB0b1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgMTpOIHNpbmNlIHlvdSBjYW4gb25seSBsb29rdXAgZnJvbSB0aGUgcHJpbWFyeSB0byBhIHNlY29uZGFyeVxuICAgICAgICAgICAgaWYgKGhlYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcmFuZ2UgcmVwcmVzZW50ZWQgLSB3ZSBjYW4gc2ltcGx5IHVwZGF0ZSBzZWNvbmRhcnkgd2l0aCB0aGUgb3ZlcndyaXR0ZW4gdmFsdWVcbiAgICAgICAgICAgICAgICBoZWFkLnNlY29uZGFyeSA9IHNlY29uZGFyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZXMgaW4gdGhlIHJhbmdlIGJlZm9yZSB0aGlzIG9uZSBhcmUgdmFsaWQgLSBidXQgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lIGZvciB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmNyZW1lbnQtZGVjcmVtZW50XG4gICAgICAgICAgICAgICAgaGVhZC5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlcy5wdXNoKHsgbGVuZ3RoOiAwLCBwcmltYXJ5LCBzZWNvbmRhcnkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJpbWFyeUhlYWQgKyAxID09PSBwcmltYXJ5ICYmIHNlY29uZGFyeUhlYWQgKyAxID09PSBzZWNvbmRhcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgdGhlIGxlbmd0aCBpZiBib3RoIGluY3JlYXNlIGJ5IHRoZSBzYW1lIGFtb3VudFxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmNyZW1lbnQtZGVjcmVtZW50XG4gICAgICAgICAgICAgICAgaGVhZC5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZXMucHVzaCh7IGxlbmd0aDogMCwgcHJpbWFyeSwgc2Vjb25kYXJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldChwcmltYXJ5KSB7XG4gICAgICAgIGFzc2VydChwcmltYXJ5ID49IHRoaXMucmFuZ2VzWzBdLnByaW1hcnkpO1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByYW5nZSB3aGVyZSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBwcmltYXJ5LiBPdXIgdGFyZ2V0IHJhbmdlIGlzXG4gICAgICAgIC8vIHRoZSBvbmUgYmVmb3JlIGl0LlxuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuICAgICAgICBmb3IgKDsgaW5kZXggPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5IDwgdGhpcy5yYW5nZXNbaW5kZXhdLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdLnByaW1hcnkpO1xuICAgICAgICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBpcyB3aXRoaW4gdGhlIHN0b3JlZCByYW5nZSB1c2UgaXQgLSBvdGhlcndpc2UgYWRkIGluIHRoZSBsZW5ndGggLSAxIGFzIHRoZSBoaWdoZXN0XG4gICAgICAgIC8vIHN0b3JlZCBzZWNvbmRhcnkgdmFsdWUgdG8gdXNlLlxuICAgICAgICBjb25zdCBjbG9zZXN0UmFuZ2UgPSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJpbWFyeSAtIGNsb3Nlc3RSYW5nZS5wcmltYXJ5LCBjbG9zZXN0UmFuZ2UubGVuZ3RoKSArIGNsb3Nlc3RSYW5nZS5zZWNvbmRhcnk7XG4gICAgfVxuICAgIHVwZGF0ZUJhc2UocHJpbWFyeSkge1xuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1swXS5wcmltYXJ5KTtcbiAgICAgICAgLy8gV2FsayB0aGUgcmFuZ2VzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhlIHByaW1hcnkuIFByaW1hcnkgaXMgdGhlbiB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHByZXZpb3VzIGluZGV4IGJ5IGRlZmluaXRpb24gKHNpbmNlIGl0J3MgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4J3MgcHJpbWFyeSBidXQgZ3JlYXRoZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgaW5kZXgncyBwcmltYXJ5KSBhbmQgd2Uga25vdyBwcmltYXJ5IG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBiYXNlLlxuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuICAgICAgICBmb3IgKDsgaW5kZXggPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5IDwgdGhpcy5yYW5nZXNbaW5kZXhdLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdLnByaW1hcnkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgcmFuZ2UgdmFsdWVzXG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZXNbaW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwcmltYXJ5IC0gcmFuZ2UucHJpbWFyeTtcbiAgICAgICAgcmFuZ2Uuc2Vjb25kYXJ5ID0gcmFuZ2Uuc2Vjb25kYXJ5ICsgTWF0aC5taW4oZGVsdGEsIHJhbmdlLmxlbmd0aCk7XG4gICAgICAgIHJhbmdlLmxlbmd0aCA9IE1hdGgubWF4KHJhbmdlLmxlbmd0aCAtIGRlbHRhLCAwKTtcbiAgICAgICAgcmFuZ2UucHJpbWFyeSA9IHByaW1hcnk7XG4gICAgICAgIC8vIEFuZCByZW1vdmUgdW5uZWNlc3NhcnkgcmFuZ2VzXG4gICAgICAgIHRoaXMucmFuZ2VzID0gaW5kZXggLSAxID4gMCA/IHRoaXMucmFuZ2VzLnNsaWNlKGluZGV4IC0gMSkgOiB0aGlzLnJhbmdlcztcbiAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIGxvd2VzdCB2YWx1ZSBpcyBub3cgdGhlIGlucHV0IHRvIHRoaXMgbWV0aG9kXG4gICAgICAgIGFzc2VydC5lcXVhbChwcmltYXJ5LCB0aGlzLnJhbmdlc1swXS5wcmltYXJ5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZVRyYWNrZXIuanMubWFwIiwiLy8gQSByYXRlIGxpbWl0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgYSBjbGllbnQgY2FuIG9ubHkgcmVxdWVzdCBoZWxwIGZvciBvbmUgdGFzayB3aXRoaW4gYSB0aW1lIHdpbmRvdy5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdpbmRvd01TZWMpIHtcbiAgICAgICAgdGhpcy53aW5kb3dNU2VjID0gd2luZG93TVNlYztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmaWx0ZXIoY2xpZW50SWQsIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7Y2xpZW50SWR9LyR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RNYXAuc2V0KGtleSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGFwcHJvdmVkTGlzdC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXF1ZXN0TWFwLmdldChrZXkpICsgdGhpcy53aW5kb3dNU2VjID4gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdE1hcC5zZXQoa2V5LCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgYXBwcm92ZWRMaXN0LnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcHJvdmVkTGlzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRlTGltaXR0ZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHNhZmVseVBhcnNlSlNPTihqc29uKSB7XG4gICAgbGV0IHBhcnNlZDtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvL1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZVBhcnNlci5qcy5tYXAiLCJpbXBvcnQgeyBNZXNzYWdlVHlwZSB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3lzdGVtVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBNZXNzYWdlVHlwZS5SZW1vdGVIZWxwIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkludGVncmF0ZSB8fFxuICAgICAgICB0eXBlID09PSBNZXNzYWdlVHlwZS5DbGllbnRKb2luIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkNsaWVudExlYXZlIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkZvcmspO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRGaWxlQmxvYlR5cGUobWltZVR5cGUpIHtcbiAgICBzd2l0Y2ggKG1pbWVUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbWFnZS9qcGVnXCI6XG4gICAgICAgIGNhc2UgXCJpbWFnZS9wbmdcIjpcbiAgICAgICAgY2FzZSBcImltYWdlL2dpZlwiOlxuICAgICAgICBjYXNlIFwiaW1hZ2UvYm1wXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBcImltYWdlXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInZpZGVvL21wNFwiOiB7XG4gICAgICAgICAgICByZXR1cm4gXCJ2aWRlb1wiO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0ZXh0L3BsYWluXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBcInRleHRcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gXCJnZW5lcmljXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmdldEZpbGVCbG9iVHlwZSA9IGdldEZpbGVCbG9iVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50IGlzIG5vIGxvbmdlciBjb25uZWN0ZWQgdG8gdGhlIGRlbHRhIHNlcnZlclxuICAgICAqL1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSAwXSA9IFwiRGlzY29ubmVjdGVkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50IGhhcyBhbiBpbmJvdW5kIGNvbm5lY3Rpb24gYnV0IGlzIHN0aWxsIHBlbmRpbmcgZm9yIG91dGJvdW5kIGRlbHRhc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0aW5nXCJdID0gMV0gPSBcIkNvbm5lY3RpbmdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZG9jdW1lbnQgaXMgZnVsbHkgY29ubmVjdGVkXG4gICAgICovXG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDJdID0gXCJDb25uZWN0ZWRcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0YXRlIHx8IChleHBvcnRzLkNvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFpbmNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXIgPSBcImJyb3dzZXJcIjtcbmV4cG9ydHMuUm9ib3QgPSBcInJvYm90XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Jsb2JzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NoYWluY29kZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jbGllbnRzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Byb3RvY29sXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0b3JhZ2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlKSB7XG4gICAgLy8gRW1wdHkgb3BlcmF0aW9uIG1lc3NhZ2UuIFVzZWQgdG8gc2VuZCBhbiB1cGRhdGVkIHJlZmVyZW5jZSBzZXF1ZW5jZSBudW1iZXIuXG4gICAgTWVzc2FnZVR5cGVbXCJOb09wXCJdID0gXCJub29wXCI7XG4gICAgLy8gU3lzdGVtIG1lc3NhZ2Ugc2VudCB0byBpbmRpY2F0ZSBhIG5ldyBjbGllbnQgaGFzIGpvaW5lZCB0aGUgY29sbGFib3JhdGlvblxuICAgIE1lc3NhZ2VUeXBlW1wiQ2xpZW50Sm9pblwiXSA9IFwiam9pblwiO1xuICAgIC8vIFN5c3RlbSBtZXNzYWdlIHNlbnQgdG8gaW5kaWNhdGUgYSBjbGllbnQgaGFzIGxlZnQgdGhlIGNvbGxhYm9yYXRpb25cbiAgICBNZXNzYWdlVHlwZVtcIkNsaWVudExlYXZlXCJdID0gXCJsZWF2ZVwiO1xuICAgIC8vIFByb3Bvc2VzIGEgbmV3IGNvbnNlbnN1cyB2YWx1ZVxuICAgIE1lc3NhZ2VUeXBlW1wiUHJvcG9zZVwiXSA9IFwicHJvcG9zZVwiO1xuICAgIC8vIE1lc3NhZ2UgdXNlZCB0byByZWplY3QgYSBwZW5kaW5nIHByb3Bvc2FsXG4gICAgTWVzc2FnZVR5cGVbXCJSZWplY3RcIl0gPSBcInJlamVjdFwiO1xuICAgIC8vIEJsb2IgdXBsb2FkZWRcbiAgICBNZXNzYWdlVHlwZVtcIkJsb2JVcGxvYWRlZFwiXSA9IFwiYmxvYlVwbG9hZGVkXCI7XG4gICAgLy8gVE9ETyB0aGUgYXR0YWNoIGFuZCBvcGVyYXRpb24gbmFtZXMgYXJlIHBhcnRpYWxseSBoaXN0b3JpY2FuLiBXZSBtYXkgd2FudCB0byByZW5hbWUgdG8gYWxpZ24gd2l0aCBjaGFuZ2VzXG4gICAgLy8gY29taW5nIGZyb20gY29kZSBsb2FkaW5nLlxuICAgIC8vIENyZWF0ZXMgYSBuZXcgY2hhbm5lbCBhbmQgYXR0YWNoZXMgY2hhaW5jb2RlIHRvIGl0XG4gICAgTWVzc2FnZVR5cGVbXCJBdHRhY2hcIl0gPSBcImF0dGFjaFwiO1xuICAgIC8vIENoYW5uZWwgb3BlcmF0aW9uLlxuICAgIE1lc3NhZ2VUeXBlW1wiT3BlcmF0aW9uXCJdID0gXCJvcFwiO1xuICAgIC8vIENodW5rZWQgb3BlcmF0aW9uLlxuICAgIE1lc3NhZ2VUeXBlW1wiQ2h1bmtlZE9wXCJdID0gXCJjaHVua2VkT3BcIjtcbiAgICAvLyBGb3JjZWQgc25hcHNob3RcbiAgICBNZXNzYWdlVHlwZVtcIlNhdmVcIl0gPSBcInNhdmVPcFwiO1xuICAgIC8vIFN5c3RlbSBtZXNzYWdlIHRvIGluZGljYXRlIHRoZSBjcmVhdGlvbiBvZiBhIG5ldyBmb3JrXG4gICAgTWVzc2FnZVR5cGVbXCJGb3JrXCJdID0gXCJmb3JrXCI7XG4gICAgLy8gTWVzc2FnZSBzZW50IHdoZW4gZm9yd2FyZGluZyBhIHNlcXVlbmNlZCBtZXNzYWdlIHRvIGFuIHVwc3RyZWFtIGJyYW5jaFxuICAgIE1lc3NhZ2VUeXBlW1wiSW50ZWdyYXRlXCJdID0gXCJpbnRlZ3JhdGVcIjtcbiAgICAvLyBNZXNzYWdlIHRvIGluZGljYXRlIHRoZSBuZWVkIG9mIGEgcmVtb3RlIGFnZW50IGZvciBhIGRvY3VtZW50LlxuICAgIE1lc3NhZ2VUeXBlW1wiUmVtb3RlSGVscFwiXSA9IFwicmVtb3RlSGVscFwiO1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvY29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEZpbGVNb2RlO1xuKGZ1bmN0aW9uIChGaWxlTW9kZSkge1xuICAgIEZpbGVNb2RlW1wiRmlsZVwiXSA9IFwiMTAwNjQ0XCI7XG4gICAgRmlsZU1vZGVbXCJFeGVjdXRhYmxlXCJdID0gXCIxMDA3NTVcIjtcbiAgICBGaWxlTW9kZVtcIkRpcmVjdG9yeVwiXSA9IFwiMDQwMDAwXCI7XG4gICAgRmlsZU1vZGVbXCJDb21taXRcIl0gPSBcIjE2MDAwMFwiO1xuICAgIEZpbGVNb2RlW1wiU3ltbGlua1wiXSA9IFwiMTIwMDAwXCI7XG59KShGaWxlTW9kZSA9IGV4cG9ydHMuRmlsZU1vZGUgfHwgKGV4cG9ydHMuRmlsZU1vZGUgPSB7fSkpO1xuLyoqXG4gKiBUeXBlIG9mIGVudHJpZXMgdGhhdCBjYW4gYmUgc3RvcmVkIGluIGEgdHJlZVxuICovXG52YXIgVHJlZUVudHJ5O1xuKGZ1bmN0aW9uIChUcmVlRW50cnkpIHtcbiAgICBUcmVlRW50cnlbVHJlZUVudHJ5W1wiQmxvYlwiXSA9IDBdID0gXCJCbG9iXCI7XG4gICAgVHJlZUVudHJ5W1RyZWVFbnRyeVtcIkNvbW1pdFwiXSA9IDFdID0gXCJDb21taXRcIjtcbiAgICBUcmVlRW50cnlbVHJlZUVudHJ5W1wiVHJlZVwiXSA9IDJdID0gXCJUcmVlXCI7XG59KShUcmVlRW50cnkgPSBleHBvcnRzLlRyZWVFbnRyeSB8fCAoZXhwb3J0cy5UcmVlRW50cnkgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmFnZS5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQ291bnRlckZhY3Rvcnkge1xuICAgIGxvYWQoZW1pdHRlciwgcmF3KSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICByZXR1cm4gbmV3IENvdW50ZXIoZW1pdHRlciwgcmF3IHx8IDApO1xuICAgIH1cbiAgICBzdG9yZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvdW50ZXIge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byByZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3Igd2hlbiB0aGUgY291bnRlciBpcyBpbmNyZW1lbnRlZC4gVGhlIGNhbGxiYWNrIGluZGljYXRlcyB0aGVcbiAgICAgICAgICogYW1vdW50IHRoZSBjb3VudGVyIHdhcyBpbmNyZW1lbnRlZCBieS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25JbmNyZW1lbnQgPSAodmFsdWUpID0+IHsgcmV0dXJuOyB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgaW5jcmVtZW50KHZhbHVlLCBzdWJtaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fdmFsdWUgKyB2YWx1ZTtcbiAgICAgICAgaWYgKHN1Ym1pdCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJpbmNyZW1lbnRcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25JbmNyZW1lbnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ291bnRlclZhbHVlVHlwZSB7XG4gICAgLy8gdHNsaW50OmVuYWJsZTp2YXJpYWJsZS1uYW1lXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBuZXcgQ291bnRlckZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fb3BzID0gbmV3IE1hcChbW1xuICAgICAgICAgICAgICAgIFwiaW5jcmVtZW50XCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlOiAodmFsdWUsIHBhcmFtcywgbG9jYWwsIG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6ICh2YWx1ZSwgcGFyYW1zLCBjb250ZXh0LCBsb2NhbCwgb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIG9wcyB3ZXJlIGFwcGxpZWQgd2hlbiB0aGUgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuaW5jcmVtZW50KHBhcmFtcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gQ291bnRlclZhbHVlVHlwZS5OYW1lO1xuICAgIH1cbiAgICBnZXQgZmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3Rvcnk7XG4gICAgfVxuICAgIGdldCBvcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHM7XG4gICAgfVxufVxuQ291bnRlclZhbHVlVHlwZS5OYW1lID0gXCJjb3VudGVyXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudGVyLmpzLm1hcCIsImltcG9ydCAqIGFzIHJlZ2lzdGVyRGVidWcgZnJvbSBcImRlYnVnXCI7XG5leHBvcnQgY29uc3QgZGVidWcgPSByZWdpc3RlckRlYnVnKFwicHJhZ3VlOm1hcFwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU2hhcmVkTWFwIH0gZnJvbSBcIi4vbWFwXCI7XG4vLyByZWdpc3RlciBkZWZhdWx0IHR5cGVzXG5jb25zdCBkZWZhdWx0VmFsdWVUeXBlcyA9IG5ldyBBcnJheSgpO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdFZhbHVlVHlwZSh0eXBlKSB7XG4gICAgZGVmYXVsdFZhbHVlVHlwZXMucHVzaCh0eXBlKTtcbn1cbi8qKlxuICogVGhlIGV4dGVuc2lvbiB0aGF0IGRlZmluZXMgdGhlIG1hcFxuICovXG5leHBvcnQgY2xhc3MgTWFwRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50eXBlID0gTWFwRXh0ZW5zaW9uLlR5cGU7XG4gICAgfVxuICAgIGxvYWQocnVudGltZSwgaWQsIG1pbmltdW1TZXF1ZW5jZU51bWJlciwgc2VydmljZXMsIGhlYWRlck9yaWdpbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwID0gbmV3IFNoYXJlZE1hcChpZCwgcnVudGltZSwgTWFwRXh0ZW5zaW9uLlR5cGUpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclZhbHVlVHlwZXMobWFwLCBkZWZhdWx0VmFsdWVUeXBlcyk7XG4gICAgICAgICAgICB5aWVsZCBtYXAubG9hZChtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIGhlYWRlck9yaWdpbiwgc2VydmljZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZShkb2N1bWVudCwgaWQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IFNoYXJlZE1hcChpZCwgZG9jdW1lbnQsIE1hcEV4dGVuc2lvbi5UeXBlKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclZhbHVlVHlwZXMobWFwLCBkZWZhdWx0VmFsdWVUeXBlcyk7XG4gICAgICAgIG1hcC5pbml0aWFsaXplTG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgcmVnaXN0ZXJWYWx1ZVR5cGVzKG1hcCwgdmFsdWVUeXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdmFsdWVUeXBlcykge1xuICAgICAgICAgICAgbWFwLnJlZ2lzdGVyVmFsdWVUeXBlKHR5cGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuTWFwRXh0ZW5zaW9uLlR5cGUgPSBcImh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS90eXBlcy9tYXBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9jb3VudGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9leHRlbnNpb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL21hcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2V0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi92aWV3XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IFNoYXJlZE9iamVjdCB9IGZyb20gXCJAcHJhZ3VlL2FwaS1kZWZpbml0aW9uc1wiO1xuaW1wb3J0IHsgRmlsZU1vZGUsIE1lc3NhZ2VUeXBlLCBUcmVlRW50cnksIH0gZnJvbSBcIkBwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zXCI7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gXCIuL2RlYnVnXCI7XG5pbXBvcnQgeyBNYXBFeHRlbnNpb24gfSBmcm9tIFwiLi9leHRlbnNpb25cIjtcbmltcG9ydCB7IE1hcFZpZXcgfSBmcm9tIFwiLi92aWV3XCI7XG5jb25zdCBzbmFwc2hvdEZpbGVOYW1lID0gXCJoZWFkZXJcIjtcbmNvbnN0IGNvbnRlbnRQYXRoID0gXCJjb250ZW50XCI7XG4vKipcbiAqIENvcGllcyBhbGwgdmFsdWVzIGZyb20gdGhlIHByb3ZpZGVkIFNoYXJlZE1hcCB0byB0aGUgZ2l2ZW4gTWFwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5TWFwKGZyb20sIHRvKSB7XG4gICAgZnJvbS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVuc2FmZS1hbnkgKi9cbiAgICAgICAgdG8uc2V0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xufVxuY2xhc3MgQ29udGVudE9iamVjdFN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGU6cHJvbWlzZS1mdW5jdGlvbi1hc3luYyAqL1xuICAgIHJlYWQocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlYWQoYGNvbnRlbnQvJHtwYXRofWApO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYSBtYXAgc2hhcmVkIG9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgU2hhcmVkTWFwIGV4dGVuZHMgU2hhcmVkT2JqZWN0IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHNoYXJlZCBtYXAuIElmIHRoZSBvYmplY3QgaXMgbm9uLWxvY2FsIGFuIGlkIGFuZCBzZXJ2aWNlIGludGVyZmFjZXMgd2lsbFxuICAgICAqIGJlIHByb3ZpZGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIHJ1bnRpbWUsIHR5cGUgPSBNYXBFeHRlbnNpb24uVHlwZSkge1xuICAgICAgICBzdXBlcihpZCwgcnVudGltZSwgdHlwZSk7XG4gICAgICAgIHRoaXMudmFsdWVUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVGaWx0ZXIgPSAoa2V5LCB2YWx1ZSwgdmFsdWVUeXBlKSA9PiB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nS2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xlYXJDbGllbnRTZXF1ZW5jZU51bWJlciA9IC0xO1xuICAgICAgICB0aGlzLnNldE1lc3NhZ2VIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVWaWV3KCk7XG4gICAgICAgIHRoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IHRoaXMudmlldy5kYXRhW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgfVxuICAgIGludGVybmFsVmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5rZXlzKCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGVudHJpZXMgYW5kIHZhbHVlcyB3aWxsIGhhdmUgaW5jb3JyZWN0IGNvbnRlbnQgdW50aWxcbiAgICAvLyBtYXAgY29udGFpbnMgcGxhaW4gdmFsdWVzIGFuZCBtZXRhLWRhdGEgaXMgc2VncmVnYXRlZCBpbnRvXG4gICAgLy8gc2VwYXJhdGUgbWFwXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kYXRhLmVudHJpZXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRhdGEudmFsdWVzKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5kYXRhLnNpemU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tGbikge1xuICAgICAgICB0aGlzLnZpZXcuZm9yRWFjaChjYWxsYmFja0ZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBrZXkgZnJvbSB0aGUgbWFwLlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXQoa2V5KTtcbiAgICB9XG4gICAgd2FpdChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXcud2FpdChrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICB0aGlzLnZpZXcuc2V0KGtleSwgdmFsdWUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5jbGVhcigpO1xuICAgIH1cbiAgICBzbmFwc2hvdCgpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IHtcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlLkZpbGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHNuYXBzaG90RmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRyZWVFbnRyeVtUcmVlRW50cnkuQmxvYl0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50czogdGhpcy52aWV3LnNlcmlhbGl6ZSh0aGlzLnNlcmlhbGl6ZUZpbHRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc2hhOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgdGhlIHNuYXBzaG90IG9mIHRoZSBjb250ZW50IHRvIHRoZSB0cmVlXG4gICAgICAgIGNvbnN0IGNvbnRlbnRTbmFwc2hvdCA9IHRoaXMuc25hcHNob3RDb250ZW50KCk7XG4gICAgICAgIGlmIChjb250ZW50U25hcHNob3QpIHtcbiAgICAgICAgICAgIHRyZWUuZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtb2RlOiBGaWxlTW9kZS5EaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgcGF0aDogY29udGVudFBhdGgsXG4gICAgICAgICAgICAgICAgdHlwZTogVHJlZUVudHJ5W1RyZWVFbnRyeS5UcmVlXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29udGVudFNuYXBzaG90LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIHN1Ym1pdE1hcENsZWFyTWVzc2FnZShvcCkge1xuICAgICAgICBjb25zdCBjbGllbnRTZXF1ZW5jZU51bWJlciA9IHRoaXMuc3VibWl0TWFwTWVzc2FnZShvcCk7XG4gICAgICAgIGlmIChjbGllbnRTZXF1ZW5jZU51bWJlciAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NsZWFyQ2xpZW50U2VxdWVuY2VOdW1iZXIgPSBjbGllbnRTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJtaXRNYXBLZXlNZXNzYWdlKG9wKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudFNlcXVlbmNlTnVtYmVyID0gdGhpcy5zdWJtaXRNYXBNZXNzYWdlKG9wKTtcbiAgICAgICAgaWYgKGNsaWVudFNlcXVlbmNlTnVtYmVyICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nS2V5cy5zZXQob3Aua2V5LCBjbGllbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VibWl0TWFwTWVzc2FnZShvcCkge1xuICAgICAgICAvLyBMb2NhbCBvcGVyYXRpb25zIGRvIG5vdCByZXF1aXJlIGFueSBleHRyYSBwcm9jZXNzaW5nXG4gICAgICAgIGlmICh0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uY2Ugd2UgaGF2ZSBwZXJmb3JtZWQgdGhlIGF0dGFjaCBzdWJtaXQgdGhlIGxvY2FsIG9wZXJhdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5zdWJtaXRMb2NhbE1lc3NhZ2Uob3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgdmFsdWUgdHlwZSBvbiB0aGUgbWFwXG4gICAgICovXG4gICAgcmVnaXN0ZXJWYWx1ZVR5cGUodHlwZSkge1xuICAgICAgICB0aGlzLnZhbHVlVHlwZXMuc2V0KHR5cGUubmFtZSwgdHlwZSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldE9wSGFuZGxlcihvcCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHR5cGUub3BzLmdldChvcC52YWx1ZS50eXBlKTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlTWVzc2FnZUhhbmRsZXIgPSB7XG4gICAgICAgICAgICBwcmVwYXJlOiAob3AsIGxvY2FsLCBtZXNzYWdlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGdldE9wSGFuZGxlcihvcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0KG9wLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIucHJlcGFyZSh2YWx1ZSwgb3AudmFsdWUudmFsdWUsIGxvY2FsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvY2VzczogKG9wLCBjb250ZXh0LCBsb2NhbCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBnZXRPcEhhbmRsZXIob3ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldChvcC5rZXkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIucHJvY2Vzcyh2YWx1ZSwgb3AudmFsdWUudmFsdWUsIGNvbnRleHQsIGxvY2FsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ2YWx1ZUNoYW5nZWRcIiwgeyBrZXk6IG9wLmtleSB9LCBsb2NhbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VibWl0OiAob3ApID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdExvY2FsTWVzc2FnZShvcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldCh0eXBlLm5hbWUsIHZhbHVlVHlwZU1lc3NhZ2VIYW5kbGVyKTtcbiAgICB9XG4gICAgaGFzVmFsdWVUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUeXBlcy5oYXModHlwZSk7XG4gICAgfVxuICAgIGdldFZhbHVlVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVHlwZXMuZ2V0KHR5cGUpO1xuICAgIH1cbiAgICByZWdpc3RlclNlcmlhbGl6ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVubmVjZXNzYXJ5LW92ZXJyaWRlICovXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKGBNYXAgJHt0aGlzLmlkfSBpcyBub3cgZGlzY29ubmVjdGVkYCk7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0Q29udGVudCgpO1xuICAgIH1cbiAgICBvbkNvbm5lY3QocGVuZGluZykge1xuICAgICAgICBkZWJ1ZyhgTWFwICR7dGhpcy5pZH0gaXMgbm93IGNvbm5lY3RlZGApO1xuICAgICAgICAvLyBSRVZJRVc6IERvZXMgaXQgbWF0dGVyIHRoYXQgdGhlIG1hcCBhbmQgY29udGVudCBtZXNzYWdlIGdldCBvdXQgb2Ygb3JkZXI/XG4gICAgICAgIC8vIEZpbHRlciB0aGUgbm9uQWNrIGFuZCBwZW5kaW5nIG1lc3NhZ2VzIGludG8gYSBtYXAgc2V0IGFuZCBhIGNvbnRlbnQgc2V0LlxuICAgICAgICBjb25zdCBtYXBNZXNzYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCBjb250ZW50TWVzc2FnZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBlbmRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWFwTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIG1hcE1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50TWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWFsIHdpdGggdGhlIG1hcCBtZXNzYWdlcyAtIGZvciB0aGUgbWFwIGl0J3MgYWx3YXlzIGxhc3Qgb25lIHdpbnMgc28gd2UganVzdCByZXNlbmRcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1hcE1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5tZXNzYWdlSGFuZGxlci5nZXQobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgIGhhbmRsZXIuc3VibWl0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGNvbnRlbnQgdG8gY2F0Y2ggdXBcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RDb250ZW50KGNvbnRlbnRNZXNzYWdlcyk7XG4gICAgfVxuICAgIGxvYWRDb3JlKG1pbmltdW1TZXF1ZW5jZU51bWJlciwgaGVhZGVyT3JpZ2luLCBzdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB5aWVsZCBzdG9yYWdlLnJlYWQoc25hcHNob3RGaWxlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gaGVhZGVyID8gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShoZWFkZXIsIFwiYmFzZTY0XCIpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKFwidXRmLThcIikpIDoge307XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnZpZXcucG9wdWxhdGUoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50U3RvcmFnZSA9IG5ldyBDb250ZW50T2JqZWN0U3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubG9hZENvbnRlbnQobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXJPcmlnaW4sIGNvbnRlbnRTdG9yYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRpYWxpemVMb2NhbENvcmUoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbnRlbnQoKTtcbiAgICB9XG4gICAgcHJvY2Vzc01pblNlcXVlbmNlTnVtYmVyQ2hhbmdlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NNaW5TZXF1ZW5jZU51bWJlckNoYW5nZWRDb250ZW50KHZhbHVlKTtcbiAgICB9XG4gICAgbG9hZENvbnRlbnQobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXJPcmlnaW4sIHNlcnZpY2VzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmVwYXJlQ29yZShtZXNzYWdlLCBsb2NhbCkge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBNZXNzYWdlVHlwZS5PcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wID0gbWVzc2FnZS5jb250ZW50cztcbiAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhcyhvcC50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLmdldChvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAucHJlcGFyZShvcCwgbG9jYWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZXBhcmVDb250ZW50KG1lc3NhZ2UsIGxvY2FsKTtcbiAgICB9XG4gICAgcHJvY2Vzc0NvcmUobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gTWVzc2FnZVR5cGUuT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvcCA9IG1lc3NhZ2UuY29udGVudHM7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlci5oYXMob3AudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmdldChvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICAucHJvY2VzcyhvcCwgY29udGV4dCwgbG9jYWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29udGVudChtZXNzYWdlLCBsb2NhbCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoQ29yZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LmF0dGFjaEFsbCgpO1xuICAgICAgICB0aGlzLmF0dGFjaENvbnRlbnQoKTtcbiAgICB9XG4gICAgLy8gVGhlIGZvbGxvd2luZyB0aHJlZSBtZXRob2RzIGVuYWJsZSBkZXJpdmVkIGNsYXNzZXMgdG8gcHJvdmlkZSBjdXN0b20gY29udGVudCB0aGF0IGlzIHN0b3JlZFxuICAgIC8vIHdpdGggdGhlIG1hcFxuICAgIGF0dGFjaENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlcGFyZUNvbnRlbnQobWVzc2FnZSwgbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhIGNvbnRlbnQgbWVzc2FnZVxuICAgICAqL1xuICAgIHByb2Nlc3NDb250ZW50KG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBzZW50IHRvIG5vdGlmeSBkZXJpdmVkIGNvbnRlbnQgb2YgZGlzY29ubmVjdGlvblxuICAgICAqL1xuICAgIG9uRGlzY29ubmVjdENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBzZW50IHVwb24gcmVjb25uZWN0aW5nIHRvIHRoZSBkZWx0YSBzdHJlYW1cbiAgICAgKi9cbiAgICBvbkNvbm5lY3RDb250ZW50KHBlbmRpbmcpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0TG9jYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU25hcHNob3RzIHRoZSBjb250ZW50XG4gICAgICovXG4gICAgc25hcHNob3RDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIGNvbnRlbnQgdGhhdCB0aGUgbWluaW11bSBzZXF1ZW5jZSBudW1iZXIgaGFzIGNoYW5nZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzTWluU2VxdWVuY2VOdW1iZXJDaGFuZ2VkQ29udGVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG5lZWRQcm9jZXNzS2V5T3BlcmF0aW9ucyhvcCwgbG9jYWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsZWFyQ2xpZW50U2VxdWVuY2VOdW1iZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJZiBJIGhhdmUgYSBOQUNLIGNsZWFyLCB3ZSBjYW4gaWdub3JlIGFsbCBvcHMuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLnBlbmRpbmdLZXlzLnNpemUgIT09IDAgJiYgdGhpcy5wZW5kaW5nS2V5cy5oYXMob3Aua2V5KSkpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIE5BQ0sgb3AsIGNsZWFyIGl0IGZyb20gdGhlIG1hcCBpZiB0aGUgbGF0ZXN0IHNlcXVlbmNlIG51bWJlciBpbiB0aGUgbWFwIG1hdGNoIHRoZSBtZXNzYWdlJ3NcbiAgICAgICAgICAgIC8vIGFuZCBkb24ndCBwcm9jZXNzIHRoZSBvcC5cbiAgICAgICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdLZXlDbGllbnRTZXF1ZW5jZU51bWJlciA9IHRoaXMucGVuZGluZ0tleXMuZ2V0KG9wLmtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdLZXlDbGllbnRTZXF1ZW5jZU51bWJlciA9PT0gbWVzc2FnZS5jbGllbnRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdLZXlzLmRlbGV0ZShvcC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgTkFDSyBvcCBvbiB0aGUga2V5LCB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIHJlbW90ZSBvcHMuXG4gICAgICAgIHJldHVybiAhbG9jYWw7XG4gICAgfVxuICAgIGluaXRpYWxpemVWaWV3KCkge1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgTWFwVmlldyh0aGlzLCB0aGlzLnJ1bnRpbWUsIHRoaXMuaWQpO1xuICAgIH1cbiAgICBzZXRNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmVwYXJlID0gKG9wLCBsb2NhbCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWJhY2tib25lLWdldC1zZXQtb3V0c2lkZS1tb2RlbFxuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldChcImNsZWFyXCIsIHtcbiAgICAgICAgICAgIHByZXBhcmU6IGRlZmF1bHRQcmVwYXJlLFxuICAgICAgICAgICAgcHJvY2VzczogKG9wLCBjb250ZXh0LCBsb2NhbCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xlYXJDbGllbnRTZXF1ZW5jZU51bWJlciA9PT0gbWVzc2FnZS5jbGllbnRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2xlYXJDbGllbnRTZXF1ZW5jZU51bWJlciA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0tleXMuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuY2xlYXJFeGNlcHRQZW5kaW5nS2V5cyh0aGlzLnBlbmRpbmdLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuY2xlYXJDb3JlKGxvY2FsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJtaXQ6IChvcCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibWl0TWFwQ2xlYXJNZXNzYWdlKG9wKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldChcImRlbGV0ZVwiLCB7XG4gICAgICAgICAgICBwcmVwYXJlOiBkZWZhdWx0UHJlcGFyZSxcbiAgICAgICAgICAgIHByb2Nlc3M6IChvcCwgY29udGV4dCwgbG9jYWwsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmVlZFByb2Nlc3NLZXlPcGVyYXRpb25zKG9wLCBsb2NhbCwgbWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRlbGV0ZUNvcmUob3Aua2V5LCBsb2NhbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VibWl0OiAob3ApID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdE1hcEtleU1lc3NhZ2Uob3ApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuc2V0KFwic2V0XCIsIHtcbiAgICAgICAgICAgIHByZXBhcmU6IChvcCwgbG9jYWwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWwgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiB0aGlzLnZpZXcucHJlcGFyZVNldENvcmUob3Aua2V5LCBvcC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogKG9wLCBjb250ZXh0LCBsb2NhbCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZWVkUHJvY2Vzc0tleU9wZXJhdGlvbnMob3AsIGxvY2FsLCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRDb3JlKG9wLmtleSwgY29udGV4dCwgbG9jYWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Ym1pdDogKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXRNYXBLZXlNZXNzYWdlKG9wKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc01hcE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS50eXBlO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5oYXModHlwZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIERpc3RyaWJ1dGVkU2V0RmFjdG9yeSB7XG4gICAgbG9hZChlbWl0dGVyLCByYXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXN0cmlidXRlZFNldChlbWl0dGVyLCByYXcgfHwgW10pO1xuICAgIH1cbiAgICBzdG9yZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuZW50cmllcygpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEaXN0cmlidXRlZFNldCB7XG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiBiZSBzZXQgdG8gcmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHdoZW4gdmFsdWVzIGFyZSBhZGRlZCBvciBkZWxldGVkIGZyb20gdGhlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25BZGQgPSAodmFsdWUpID0+IHsgcmV0dXJuOyB9O1xuICAgICAgICB0aGlzLm9uRGVsZXRlID0gKHZhbHVlKSA9PiB7IHJldHVybjsgfTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldCA9IG5ldyBTZXQodmFsdWUpO1xuICAgIH1cbiAgICBhZGQodmFsdWUsIHN1Ym1pdEV2ZW50ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJtaXRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJhZGRcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25BZGQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKHZhbHVlLCBzdWJtaXRFdmVudCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFNldC5kZWxldGUodmFsdWUpO1xuICAgICAgICBpZiAoc3VibWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwiZGVsZXRlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRGVsZXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaW50ZXJuYWxTZXQudmFsdWVzKCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEaXN0cmlidXRlZFNldFZhbHVlVHlwZSB7XG4gICAgLy8gdHNsaW50OmVuYWJsZTp2YXJpYWJsZS1uYW1lXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ZhY3RvcnkgPSBuZXcgRGlzdHJpYnV0ZWRTZXRGYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX29wcyA9IG5ldyBNYXAoW1tcbiAgICAgICAgICAgICAgICBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZTogKHZhbHVlLCBwYXJhbXMsIGxvY2FsLCBvcCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzczogKHZhbHVlLCBwYXJhbXMsIGNvbnRleHQsIGxvY2FsLCBvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgb3BzIHdlcmUgYXBwbGllZCB3aGVuIHRoZSBtZXNzYWdlIHdhcyBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQocGFyYW1zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJkZWxldGVcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmU6ICh2YWx1ZSwgcGFyYW1zLCBsb2NhbCwgb3ApID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6ICh2YWx1ZSwgcGFyYW1zLCBjb250ZXh0LCBsb2NhbCwgb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIG9wcyB3ZXJlIGFwcGxpZWQgd2hlbiB0aGUgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuZGVsZXRlKHBhcmFtcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gRGlzdHJpYnV0ZWRTZXRWYWx1ZVR5cGUuTmFtZTtcbiAgICB9XG4gICAgZ2V0IGZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3J5O1xuICAgIH1cbiAgICBnZXQgb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BzO1xuICAgIH1cbn1cbkRpc3RyaWJ1dGVkU2V0VmFsdWVUeXBlLk5hbWUgPSBcImRpc3RyaWJ1dGVkU2V0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vLyB0c2xpbnQ6ZGlzYWJsZTphbGlnblxuaW1wb3J0IHsgU2hhcmVkT2JqZWN0LCBWYWx1ZVR5cGUgfSBmcm9tIFwiQHByYWd1ZS9hcGktZGVmaW5pdGlvbnNcIjtcbmNsYXNzIFZhbHVlT3BFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBrZXksIG1hcCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIGVtaXQobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyYW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYXAuc3VibWl0TWFwTWVzc2FnZShvcCk7XG4gICAgICAgIHRoaXMubWFwLmVtaXQoXCJ2YWx1ZUNoYW5nZWRcIiwgeyBrZXk6IHRoaXMua2V5IH0sIHRydWUsIG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNYXBWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXAsIHJ1bnRpbWUsIGlkKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHBvcHVsYXRlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFsdWVzUCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxWYWx1ZVAgPSB0aGlzLmZpbGwoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGZpbGxlZFZhbHVlKSA9PiAoeyBrZXksIHZhbHVlOiBmaWxsZWRWYWx1ZSB9KSk7XG4gICAgICAgICAgICAgICAgbG9jYWxWYWx1ZXNQLnB1c2gobG9jYWxWYWx1ZVApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYWx1ZXMgPSB5aWVsZCBQcm9taXNlLmFsbChsb2NhbFZhbHVlc1ApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbFZhbHVlIG9mIGxvY2FsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNldChsb2NhbFZhbHVlLmtleSwgbG9jYWxWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBmaXggdG8gcGFzcy10aHJvdWdoIHdoZW4gbWV0YS1kYXRhIG1vdmVkIHRvIHNlcGFyYXRlIG1hcFxuICAgIGZvckVhY2goY2FsbGJhY2tGbikge1xuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSwgbSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2tGbih2YWx1ZS5sb2NhbFZhbHVlLCBrZXksIG0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBMZXQncyBzdGFzaCB0aGUgKnR5cGUqIG9mIHRoZSBvYmplY3Qgb24gdGhlIGtleVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGF0YS5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxvY2FsVmFsdWU7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwO1xuICAgIH1cbiAgICB3YWl0KGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnNhZmUtYW55ICovXG4gICAgICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tb2JqZWN0LWxpdGVyYWwtdHlwZS1hc3NlcnRpb24gKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB2YWx1ZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5nZXQodmFsdWUua2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5yZW1vdmVMaXN0ZW5lcihcInZhbHVlQ2hhbmdlZFwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9uKFwidmFsdWVDaGFuZ2VkXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhcyhrZXkpO1xuICAgIH1cbiAgICBhdHRhY2hBbGwoKSB7XG4gICAgICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxvY2FsVmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5sb2NhbFZhbHVlLmF0dGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVPcGVyYXRpb25WYWx1ZShrZXksIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGxldCBvcGVyYXRpb25WYWx1ZTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMubWFwLmdldFZhbHVlVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIGlmICghdmFsdWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgJyR7dHlwZX0nIHNwZWNpZmllZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IG9wZXJhdGlvblZhbHVlIGZpcnN0IHdpdGggdGhlIHJhdyB2YWx1ZSBwYXJhbXMgcHJpb3IgdG8gZG9pbmcgdGhlIGxvYWRcbiAgICAgICAgICAgIG9wZXJhdGlvblZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXBhcmFtZXRlci1yZWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVUeXBlLmZhY3RvcnkubG9hZChuZXcgVmFsdWVPcEVtaXR0ZXIodHlwZSwga2V5LCB0aGlzLm1hcCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkT2JqZWN0XG4gICAgICAgICAgICAgICAgPyBWYWx1ZVR5cGVbVmFsdWVUeXBlLlNoYXJlZF1cbiAgICAgICAgICAgICAgICA6IFZhbHVlVHlwZVtWYWx1ZVR5cGUuUGxhaW5dO1xuICAgICAgICAgICAgb3BlcmF0aW9uVmFsdWUgPSB0aGlzLnNwaWxsKHsgbG9jYWxUeXBlOiB2YWx1ZVR5cGUsIGxvY2FsVmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG9wZXJhdGlvblZhbHVlLCBsb2NhbFZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnByZXBhcmVPcGVyYXRpb25WYWx1ZShrZXksIHZhbHVlLCB0eXBlKTtcbiAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlcy5vcGVyYXRpb25WYWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDb3JlKG9wLmtleSwge1xuICAgICAgICAgICAgbG9jYWxUeXBlOiB2YWx1ZXMub3BlcmF0aW9uVmFsdWUudHlwZSxcbiAgICAgICAgICAgIGxvY2FsVmFsdWU6IHZhbHVlcy5sb2NhbFZhbHVlLFxuICAgICAgICB9LCB0cnVlLCBudWxsKTtcbiAgICAgICAgdGhpcy5tYXAuc3VibWl0TWFwS2V5TWVzc2FnZShvcCk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzZnVsbHlSZW1vdmVkID0gdGhpcy5kZWxldGVDb3JlKG9wLmtleSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgIHRoaXMubWFwLnN1Ym1pdE1hcEtleU1lc3NhZ2Uob3ApO1xuICAgICAgICByZXR1cm4gc3VjY2Vzc2Z1bGx5UmVtb3ZlZDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5rZXlzKCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBjb25zdCBvcCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2xlYXJcIixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhckNvcmUodHJ1ZSwgbnVsbCk7XG4gICAgICAgIHRoaXMubWFwLnN1Ym1pdE1hcENsZWFyTWVzc2FnZShvcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIHNoYXJlZCBtYXAgdG8gYSBKU09OIHN0cmluZ1xuICAgICAqL1xuICAgIHNlcmlhbGl6ZShmaWx0ZXIpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHt9O1xuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3BpbGxlZFZhbHVlID0gdGhpcy5zcGlsbCh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFZhbHVlID0gZmlsdGVyKGtleSwgc3BpbGxlZFZhbHVlLnZhbHVlLCBzcGlsbGVkVmFsdWUudHlwZSk7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSB7IHR5cGU6IHNwaWxsZWRWYWx1ZS50eXBlLCB2YWx1ZTogZmlsdGVyZWRWYWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICBzZXRDb3JlKGtleSwgdmFsdWUsIGxvY2FsLCBvcCkge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLm1hcC5lbWl0KFwidmFsdWVDaGFuZ2VkXCIsIHsga2V5IH0sIGxvY2FsLCBvcCk7XG4gICAgfVxuICAgIHByZXBhcmVTZXRDb3JlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY2xlYXJDb3JlKGxvY2FsLCBvcCkge1xuICAgICAgICB0aGlzLmRhdGEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5tYXAuZW1pdChcImNsZWFyXCIsIGxvY2FsLCBvcCk7XG4gICAgfVxuICAgIGRlbGV0ZUNvcmUoa2V5LCBsb2NhbCwgb3ApIHtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc2Z1bGx5UmVtb3ZlZCA9IHRoaXMuZGF0YS5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5tYXAuZW1pdChcInZhbHVlQ2hhbmdlZFwiLCB7IGtleSB9LCBsb2NhbCwgb3ApO1xuICAgICAgICByZXR1cm4gc3VjY2Vzc2Z1bGx5UmVtb3ZlZDtcbiAgICB9XG4gICAgY2xlYXJFeGNlcHRQZW5kaW5nS2V5cyhwZW5kaW5nS2V5cykge1xuICAgICAgICAvLyBBc3N1bWluZyB0aGUgcGVuZGluZ0tleXMgaXMgc21hbGwgYW5kIHRoZSBtYXAgaXMgbGFyZ2VcbiAgICAgICAgLy8gd2Ugd2lsbCBnZXQgdGhlIHZhbHVlIGZvciB0aGUgcGVuZGluZ0tleXMgYW5kIGNsZWFyIHRoZSBtYXBcbiAgICAgICAgY29uc3QgdGVtcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcGVuZGluZ0tleXMuZm9yRWFjaCgodmFsdWUsIGtleSwgbWFwKSA9PiB7XG4gICAgICAgICAgICB0ZW1wLnNldChrZXksIHRoaXMuZGF0YS5nZXQoa2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGEuY2xlYXIoKTtcbiAgICAgICAgdGVtcC5mb3JFYWNoKCh2YWx1ZSwga2V5LCBtYXApID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWxsKGtleSwgcmVtb3RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdHJhbnNsYXRlZFZhbHVlO1xuICAgICAgICAgICAgaWYgKHJlbW90ZS50eXBlID09PSBWYWx1ZVR5cGVbVmFsdWVUeXBlLlNoYXJlZF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0cmlidXRlZE9iamVjdCA9IHlpZWxkIHRoaXMucnVudGltZS5nZXRDaGFubmVsKHJlbW90ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZFZhbHVlID0gZGlzdHJpYnV0ZWRPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZW1vdGUudHlwZSA9PT0gVmFsdWVUeXBlW1ZhbHVlVHlwZS5QbGFpbl0pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVmFsdWUgPSByZW1vdGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hcC5oYXNWYWx1ZVR5cGUocmVtb3RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5tYXAuZ2V0VmFsdWVUeXBlKHJlbW90ZS50eXBlKTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVmFsdWUgPSB2YWx1ZVR5cGUuZmFjdG9yeS5sb2FkKG5ldyBWYWx1ZU9wRW1pdHRlcihyZW1vdGUudHlwZSwga2V5LCB0aGlzLm1hcCksIHJlbW90ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbmtub3duIHZhbHVlIHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvY2FsVHlwZTogcmVtb3RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbG9jYWxWYWx1ZTogdHJhbnNsYXRlZFZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNwaWxsKGxvY2FsKSB7XG4gICAgICAgIGlmIChsb2NhbC5sb2NhbFR5cGUgPT09IFZhbHVlVHlwZVtWYWx1ZVR5cGUuU2hhcmVkXSkge1xuICAgICAgICAgICAgY29uc3QgZGlzdHJpYnV0ZWRPYmplY3QgPSBsb2NhbC5sb2NhbFZhbHVlO1xuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBjb2xsYWIgb2JqZWN0IHRvIHRoZSBkb2N1bWVudC4gSWYgYWxyZWFkeSBhdHRhY2hlZCB0aGUgYXR0YWNoIGNhbGwgd2lsbCBub29wLlxuICAgICAgICAgICAgLy8gVGhpcyBmZWVscyBzbGlnaHRseSBvdXQgb2YgcGxhY2UgaGVyZSBzaW5jZSBpdCBoYXMgYSBzaWRlIGVmZmVjdC4gQnV0IGlzIHBhcnQgb2Ygc3BpbGxpbmcgYSBkb2N1bWVudC5cbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIGlmIHRoZXJlIGlzIHNvbWUga2luZCBvZiBwcmVwIGNhbGwgdG8gc2VwYXJhdGUgdGhlIG9wIGNyZWF0aW9uIGZyb20gdGhpbmdzIG5lZWRlZCB0byBtYWtlIGl0XG4gICAgICAgICAgICAvLyAobGlrZSBhdHRhY2hpbmcpXG4gICAgICAgICAgICBpZiAoIXRoaXMubWFwLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGVkT2JqZWN0LmF0dGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBWYWx1ZVR5cGVbVmFsdWVUeXBlLlNoYXJlZF0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRpc3RyaWJ1dGVkT2JqZWN0LmlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1hcC5oYXNWYWx1ZVR5cGUobG9jYWwubG9jYWxUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5tYXAuZ2V0VmFsdWVUeXBlKGxvY2FsLmxvY2FsVHlwZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGxvY2FsLmxvY2FsVHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLmZhY3Rvcnkuc3RvcmUobG9jYWwubG9jYWxWYWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBWYWx1ZVR5cGVbVmFsdWVUeXBlLlBsYWluXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9jYWwubG9jYWxWYWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlyZWN0b3J5VmlldyBleHRlbmRzIE1hcFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGRpcmVjdG9yeSwgcnVudGltZSwgaWQpIHtcbiAgICAgICAgc3VwZXIoZGlyZWN0b3J5LCBydW50aW1lLCBpZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZ2lzdGVyRGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5leHBvcnRzLmRlYnVnID0gcmVnaXN0ZXJEZWJ1ZyhcInByYWd1ZTphcGktZGVmaW5pdGlvbnNcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Zy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2xhc3MgdGhhdCBjb250YWlucyBhIGNvbGxlY3Rpb24gb2YgY29sbGFib3JhdGlvbiBleHRlbnNpb25zXG4gKi9cbmNsYXNzIFJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gW107XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uc01hcCA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgZXh0ZW5zaW9uXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbiBUaGUgZXh0ZW5zaW9uIHRvIHJlZ2lzdGVyXG4gICAgICovXG4gICAgcmVnaXN0ZXIoZXh0ZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5wdXNoKGV4dGVuc2lvbik7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uc01hcFtleHRlbnNpb24udHlwZV0gPSBleHRlbnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGlkXG4gICAgICogQHBhcmFtIGlkIElEIGZvciB0aGUgZXh0ZW5zaW9uIHRvIHJldHJpZXZlXG4gICAgICovXG4gICAgZ2V0RXh0ZW5zaW9uKHR5cGUpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmV4dGVuc2lvbnNNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNNYXBbdHlwZV07XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyeSA9IFJlZ2lzdHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZW5zaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NoYXJlZE9iamVjdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9leHRlbnNpb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdmFsdWVUeXBlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb250YWluZXJfZGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBEZXF1ZSA9IHJlcXVpcmUoXCJkb3VibGUtZW5kZWQtcXVldWVcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5jb25zdCB2YWx1ZVR5cGVfMSA9IHJlcXVpcmUoXCIuL3ZhbHVlVHlwZVwiKTtcbmNsYXNzIFNoYXJlZE9iamVjdCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoaWQsIHJ1bnRpbWUsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICAgICAgICB0aGlzLl9fc2hhcmVkT2JqZWN0X18gPSB0cnVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZSBwcml2YXRlIGZpZWxkcyBleHBvc2VkIHZpYSBnZXR0ZXJzXG4gICAgICAgIHRoaXMuX3N0YXRlID0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAgICAgLy8gTG9jYWxseSBhcHBsaWVkIG9wZXJhdGlvbnMgbm90IHlldCBBQ0snZCBieSB0aGUgc2VydmVyXG4gICAgICAgIHRoaXMucGVuZGluZ09wcyA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWVUeXBlXzEuVmFsdWVUeXBlW3ZhbHVlVHlwZV8xLlZhbHVlVHlwZS5TaGFyZWRdLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuaWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2hhcmVkIG9iamVjdCwgYWZ0ZXIgY29uc3RydWN0aW9uLCBjYW4gZWl0aGVyIGJlIGxvYWRlZCBpbiB0aGUgY2FzZSB0aGF0IGl0IGlzIGFscmVhZHkgcGFydCBvZlxuICAgICAqIGEgc2hhcmVkIGRvY3VtZW50LiBPciBsYXRlciBhdHRhY2hlZCBpZiBpdCBpcyBiZWluZyBuZXdseSBhZGRlZC5cbiAgICAgKi9cbiAgICBsb2FkKG1pbmltdW1TZXF1ZW5jZU51bWJlciwgaGVhZGVyT3JpZ2luLCBzZXJ2aWNlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5sb2FkQ29yZShtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIGhlYWRlck9yaWdpbiwgc2VydmljZXMub2JqZWN0U3RvcmFnZSk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaERlbHRhSGFuZGxlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG9iamVjdCBhcyBhIGxvY2FsLCBub24tc2hhcmVkIG9iamVjdC4gVGhpcyBvYmplY3QgY2FuIGJlY29tZSBzaGFyZWQgYWZ0ZXJcbiAgICAgKiBpdCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUxvY2FsKCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVMb2NhbENvcmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIGdpdmVuIHNoYXJlZCBvYmplY3QgdG8gaXRzIGNvbnRhaW5pbmcgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBhdHRhY2goKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IGRlcml2ZWQgY2xhc3NlcyB0byBwZXJmb3JtIGN1c3RvbSBwcm9jZXNzaW5nIHByaW9yIHRvIGF0dGFjaGluZyB0aGlzIG9iamVjdFxuICAgICAgICB0aGlzLmF0dGFjaENvcmUoKTtcbiAgICAgICAgLy8gTm90aWZ5IHRoZSBkb2N1bWVudCBvZiB0aGUgYXR0YWNobWVudFxuICAgICAgICB0aGlzLnNlcnZpY2VzID0gdGhpcy5ydW50aW1lLmF0dGFjaENoYW5uZWwodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0YWNoRGVsdGFIYW5kbGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIHNoYXJlZCBvYmplY3QgaXMgbG9jYWxcbiAgICAgKi9cbiAgICBpc0xvY2FsKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2VydmljZXM7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVubmVjZXNzYXJ5LW92ZXJyaWRlICovXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBtZXNzYWdlIGJ5IHRoZSBsb2NhbCBjbGllbnRcbiAgICAgKi9cbiAgICBzdWJtaXRMb2NhbE1lc3NhZ2UoY29udGVudCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuaXNMb2NhbCgpKTtcbiAgICAgICAgLy8gU2VuZCBpZiB3ZSBhcmUgY29ubmVjdGVkIC0gb3RoZXJ3aXNlIGp1c3QgYWRkIHRvIHRoZSBzZW50IGxpc3RcbiAgICAgICAgbGV0IGNsaWVudFNlcXVlbmNlTnVtYmVyID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5Db25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjbGllbnRTZXF1ZW5jZU51bWJlciA9IHRoaXMuc2VydmljZXMuZGVsdGFDb25uZWN0aW9uLnN1Ym1pdChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnXzEuZGVidWcoYCR7dGhpcy5pZH0gTm90IGZ1bGx5IGNvbm5lY3RlZCAtIGFkZGluZyB0byBwZW5kaW5nIGxpc3RgLCBjb250ZW50KTtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBtZXNzYWdlIGZvciB3aGVuIGl0IGlzIEFDS2VkIGFuZCB0aGVuIHN1Ym1pdCB0byB0aGUgc2VydmVyIGlmIGNvbm5lY3RlZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ09wcy5wdXNoKHsgY2xpZW50U2VxdWVuY2VOdW1iZXIsIGNvbnRlbnQgfSk7XG4gICAgICAgIHJldHVybiBjbGllbnRTZXF1ZW5jZU51bWJlcjtcbiAgICB9XG4gICAgYXR0YWNoRGVsdGFIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmRlbHRhQ29ubmVjdGlvbi5hdHRhY2goe1xuICAgICAgICAgICAgbWluU2VxdWVuY2VOdW1iZXJDaGFuZ2VkOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNaW5TZXF1ZW5jZU51bWJlckNoYW5nZWQodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXBhcmU6IChtZXNzYWdlLCBsb2NhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXBhcmUobWVzc2FnZSwgbG9jYWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IChtZXNzYWdlLCBsb2NhbCwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhtZXNzYWdlLCBsb2NhbCwgY29udGV4dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpZ2dlciBpbml0aWFsIHN0YXRlXG4gICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXRlKHRoaXMuc2VydmljZXMuZGVsdGFDb25uZWN0aW9uLnN0YXRlKTtcbiAgICB9XG4gICAgcHJlcGFyZShtZXNzYWdlLCBsb2NhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlQ29yZShtZXNzYWdlLCBsb2NhbCk7XG4gICAgfVxuICAgIHNldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgICAvLyBTaG91bGQgSSBjaGFuZ2UgdGhlIHN0YXRlIGF0IHRoZSBlbmQ/IFNvIHRoYXQgd2UgKmNhbid0KiBzZW5kIG5ldyBzdHVmZiBiZWZvcmUgd2Ugc2VuZCBvbGQ/XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29udGFpbmVyX2RlZmluaXRpb25zXzEuQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDpcbiAgICAgICAgICAgICAgICAvLyBUaGluZ3MgdGhhdCBhcmUgdHJ1ZSBub3cuLi5cbiAgICAgICAgICAgICAgICAvLyAtIGlmIHdlIGhhZCBhIGNvbm5lY3Rpb24gd2UgY2FuIG5vIGxvbmdlciBzZW5kIG1lc3NhZ2VzIG92ZXIgaXRcbiAgICAgICAgICAgICAgICAvLyAtIGlmIHdlIGhhZCBvdXRib3VuZCBtZXNzYWdlcyBzb21lIG1heSBvciBtYXkgbm90IGJlIEFDSydkLiBXb24ndCBrbm93IHVudGlsIG5leHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gLSBuYWNrIGNvdWxkIGdldCBhIG5ldyBtc24gLSBidXQgbWlnaHQgYXMgd2VsbCBkbyBpdCBpbiB0aGUgam9pbj9cbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5Db25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICAvLyBUaGluZ3MgdGhhdCBhcmUgbm93IHRydWUuLi5cbiAgICAgICAgICAgICAgICAvLyAtIHdlIHdpbGwgYmVnaW4gdG8gcmVjZWl2ZSBpbmJvdW5kIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgLy8gLSB3ZSBrbm93IHdoYXQgb3VyIG5ldyBjbGllbnQgaWQgaXMuXG4gICAgICAgICAgICAgICAgLy8gLSBzdGlsbCBub3Qgc2FmZSB0byBzZW5kIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgY29ubmVjdGluZyB3ZSBhcmUgc3RpbGwgdGlja2luZyBvZmYgdGhlIHByZXZpb3VzIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgZGVidWdfMS5kZWJ1ZyhgJHt0aGlzLmlkfSBpcyBub3cgY29ubmVjdGluZ2ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5Db25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkOlxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgYWxsIHVuLWFjaydkIHBheWxvYWQgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ09wcyA9IHRoaXMucGVuZGluZ09wcy50b0FycmF5KCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUuY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nT3BzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgLy8gQW5kIG5vdyB3ZSBhcmUgZnVsbHkgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgLy8gLSB3ZSBoYXZlIGEgY2xpZW50IElEXG4gICAgICAgICAgICAgICAgLy8gLSB3ZSBhcmUgY2F1Z2h0IHVwIGVub3VnaCB0byBhdHRlbXB0IHRvIHNlbmQgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdChwZW5kaW5nT3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCBgVW5rbm93biBDb25uZWN0aW9uU3RhdGUgJHtzdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgbWVzc2FnZSBiZWluZyByZWNlaXZlZCBmcm9tIHRoZSByZW1vdGUgZGVsdGEgc2VydmVyXG4gICAgICovXG4gICAgcHJvY2VzcyhtZXNzYWdlLCBsb2NhbCwgY29udGV4dCkge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5PcGVyYXRpb24gJiYgbG9jYWwpIHtcbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3RlZCBvcHMgc2hvdWxkIG5ldmVyIGJlIHByb2Nlc3NlZC4gVGhleSBzaG91bGQgaGF2ZSBiZWVuIGZ1bGx5IHNlbnQgb24gY29ubmVjdGVkXG4gICAgICAgICAgICBhc3NlcnQodGhpcy5wZW5kaW5nT3BzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnBlbmRpbmdPcHMucGVla0Zyb250KCkuY2xpZW50U2VxdWVuY2VOdW1iZXIgIT09IC0xLCBgcHJvY2VzcyBmb3IgZGlzY29ubmVjdGVkIG9wICR7dGhpcy5wZW5kaW5nT3BzLnBlZWtGcm9udCgpLmNsaWVudFNlcXVlbmNlTnVtYmVyfWApO1xuICAgICAgICAgICAgLy8gT25lIG9mIG91ciBtZXNzYWdlcyB3YXMgc2VxdWVuY2VkLiBXZSBjYW4gcmVtb3ZlIGl0IGZyb20gdGhlIGxvY2FsIG1lc3NhZ2UgbGlzdC4gR2l2ZW4gdGhlc2UgYXJyaXZlXG4gICAgICAgICAgICAvLyBpbiBvcmRlciB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgdGhlIGJlZ2lubmluZyBvZiB0aGUgbG9jYWwgbGlzdC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdPcHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ09wcy5wZWVrRnJvbnQoKS5jbGllbnRTZXF1ZW5jZU51bWJlciA9PT0gbWVzc2FnZS5jbGllbnRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ09wcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdPcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInByb2Nlc3NlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z18xLmRlYnVnKGBEdXBsaWNhdGUgYWNrIHJlY2VpdmVkICR7bWVzc2FnZS5jbGllbnRTZXF1ZW5jZU51bWJlcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJwcmUtb3BcIiwgbWVzc2FnZSwgbG9jYWwpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3JlKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5lbWl0KFwib3BcIiwgbWVzc2FnZSwgbG9jYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkT2JqZWN0ID0gU2hhcmVkT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmVkT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gVE9ETyB0aGlzIGlzIHByb2JhYmx5IHRvbyBtYXAgc3BlY2lmaWMgLSBidXQgaXMgdXNlZCB0byBzZXJhaWxpemUgb2JqZWN0cyBpbiBjZXJ0YWluIGNhc2VzXG52YXIgVmFsdWVUeXBlO1xuKGZ1bmN0aW9uIChWYWx1ZVR5cGUpIHtcbiAgICAvLyBUaGUgdmFsdWUgaXMgYSBzaGFyZWQgb2JqZWN0XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIlNoYXJlZFwiXSA9IDBdID0gXCJTaGFyZWRcIjtcbiAgICAvLyBUaGUgdmFsdWUgaXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdFxuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJQbGFpblwiXSA9IDFdID0gXCJQbGFpblwiO1xuICAgIC8vIFRoZSB2YWx1ZSBpcyBhIGNvdW50ZXJcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiQ291bnRlclwiXSA9IDJdID0gXCJDb3VudGVyXCI7XG4gICAgLy8gVGhlIHZhbHVlIGlzIGEgc2V0XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIlNldFwiXSA9IDNdID0gXCJTZXRcIjtcbn0pKFZhbHVlVHlwZSA9IGV4cG9ydHMuVmFsdWVUeXBlIHx8IChleHBvcnRzLlZhbHVlVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWx1ZVR5cGUuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGVcbmltcG9ydCB7IE1lc3NhZ2VUeXBlIH0gZnJvbSBcIkBwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zXCI7XG5pbXBvcnQgeyBNZXJnZVRyZWUsIGNvbXBhcmVTdHJpbmdzLCBSZWdpc3RlckNvbGxlY3Rpb24sIFVuYXNzaWduZWRTZXF1ZW5jZU51bWJlciwgU3ViU2VxdWVuY2UsIFNlZ21lbnRUeXBlLCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgY2xvY2ssIGVsYXBzZWRNaWNyb3NlY29uZHMgfSBmcm9tIFwiLi9tZXJnZVRyZWVcIjtcbmltcG9ydCAqIGFzIENvbGxlY3Rpb25zIGZyb20gXCIuL2NvbGxlY3Rpb25zXCI7XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0VGV4dCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFjY3VtVGltZSA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sb2NhbE9wcyA9IDA7XG4gICAgICAgIHRoaXMuYWNjdW1XaW5kb3dUaW1lID0gMDtcbiAgICAgICAgdGhpcy5tYXhXaW5kb3dUaW1lID0gMDtcbiAgICAgICAgdGhpcy5hY2N1bVdpbmRvdyA9IDA7XG4gICAgICAgIHRoaXMuYWNjdW1PcHMgPSAwO1xuICAgICAgICB0aGlzLnZlcmJvc2VPcHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub1ZlcmJvc2VSZW1vdGVBbm5vdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZWFzdXJlT3BzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xpZW50U2VxdWVuY2VOdW1iZXIgPSAxO1xuICAgICAgICB0aGlzLmNsaWVudE5hbWVUb0lkcyA9IG5ldyBDb2xsZWN0aW9ucy5SZWRCbGFja1RyZWUoY29tcGFyZVN0cmluZ3MpO1xuICAgICAgICB0aGlzLnNob3J0Q2xpZW50SWRNYXAgPSBbXTtcbiAgICAgICAgdGhpcy5zaG9ydENsaWVudEJyYW5jaElkTWFwID0gW107XG4gICAgICAgIHRoaXMuc2hvcnRDbGllbnRVc2VySW5mb01hcCA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29sbGVjdGlvbiA9IG5ldyBSZWdpc3RlckNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNlcXVlbmNlTnVtYmVyID0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB0aGlzLm9wTWFya2Vyc01vZGlmaWVkID0gW107XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnNlbnN1cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXJnZVRyZWUgPSBuZXcgTWVyZ2VUcmVlKGluaXRUZXh0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuZ2V0TG9uZ0NsaWVudElkID0gaWQgPT4gdGhpcy5nZXRMb25nQ2xpZW50SWQoaWQpO1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5nZXRVc2VySW5mbyA9IGlkID0+IHRoaXMuZ2V0VXNlckluZm8oaWQpO1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5tYXJrZXJNb2RpZmllZEhhbmRsZXIgPSBtYXJrZXIgPT4gdGhpcy5tYXJrZXJNb2RpZmllZChtYXJrZXIpO1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5jbGllbnRJZFRvQnJhbmNoSWQgPSB0aGlzLnNob3J0Q2xpZW50QnJhbmNoSWRNYXA7XG4gICAgICAgIHRoaXMucSA9IENvbGxlY3Rpb25zLkxpc3RNYWtlSGVhZCgpO1xuICAgICAgICB0aGlzLmNoZWNrUSA9IENvbGxlY3Rpb25zLkxpc3RNYWtlSGVhZCgpO1xuICAgIH1cbiAgICByZXNldE1vZGlmaWVkTWFya2VycygpIHtcbiAgICAgICAgdGhpcy5vcE1hcmtlcnNNb2RpZmllZCA9IFtdO1xuICAgIH1cbiAgICBtYXJrZXJNb2RpZmllZChtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5vcE1hcmtlcnNNb2RpZmllZC5wdXNoKG1hcmtlcik7XG4gICAgfVxuICAgIHNldExvY2FsU2VxdWVuY2VOdW1iZXIoc2VxKSB7XG4gICAgICAgIHRoaXMubG9jYWxTZXF1ZW5jZU51bWJlciA9IHNlcTtcbiAgICB9XG4gICAgcmVzZXRMb2NhbFNlcXVlbmNlTnVtYmVyKCkge1xuICAgICAgICB0aGlzLmxvY2FsU2VxdWVuY2VOdW1iZXIgPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXI7XG4gICAgfVxuICAgIHVuZG9TaW5nbGVTZXF1ZW5jZU51bWJlcih1bmRvU2VnbWVudHMsIHJlZG9TZWdtZW50cykge1xuICAgICAgICBsZXQgbGVuID0gdW5kb1NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGluZGV4ID0gbGVuIC0gMTtcbiAgICAgICAgbGV0IHNlcSA9IHVuZG9TZWdtZW50c1tpbmRleF0uc2VxO1xuICAgICAgICBpZiAoc2VxID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGV0IHVuZG9JbmZvID0gdW5kb1NlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzZXEgPT09IHVuZG9JbmZvLnNlcSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VUcmVlLmNoZXJyeVBpY2tlZFVuZG8odW5kb0luZm8pO1xuICAgICAgICAgICAgICAgIHJlZG9TZWdtZW50cy5wdXNoKHVuZG9JbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICB1bmRvU2VnbWVudHMubGVuZ3RoID0gaW5kZXggKyAxO1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgICBoaXN0b3J5VG9QY3QocGN0KSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMudW5kb1NlZ21lbnRzLmxlbmd0aCArIHRoaXMucmVkb1NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGN1clBjdCA9IHRoaXMudW5kb1NlZ21lbnRzLmxlbmd0aCAvIGNvdW50O1xuICAgICAgICBsZXQgc2VxID0gLTE7XG4gICAgICAgIGlmIChjdXJQY3QgPj0gcGN0KSB7XG4gICAgICAgICAgICB3aGlsZSAoY3VyUGN0ID4gcGN0KSB7XG4gICAgICAgICAgICAgICAgc2VxID0gdGhpcy51bmRvU2luZ2xlU2VxdWVuY2VOdW1iZXIodGhpcy51bmRvU2VnbWVudHMsIHRoaXMucmVkb1NlZ21lbnRzKTtcbiAgICAgICAgICAgICAgICBjdXJQY3QgPSB0aGlzLnVuZG9TZWdtZW50cy5sZW5ndGggLyBjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXJQY3QgPCBwY3QpIHtcbiAgICAgICAgICAgICAgICBzZXEgPSB0aGlzLnVuZG9TaW5nbGVTZXF1ZW5jZU51bWJlcih0aGlzLnJlZG9TZWdtZW50cywgdGhpcy51bmRvU2VnbWVudHMpO1xuICAgICAgICAgICAgICAgIGN1clBjdCA9IHRoaXMudW5kb1NlZ21lbnRzLmxlbmd0aCAvIGNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZG9TaW5nbGVTZXF1ZW5jZU51bWJlcih0aGlzLnVuZG9TZWdtZW50cywgdGhpcy5yZWRvU2VnbWVudHMpO1xuICAgIH1cbiAgICByZWRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmRvU2luZ2xlU2VxdWVuY2VOdW1iZXIodGhpcy5yZWRvU2VnbWVudHMsIHRoaXMudW5kb1NlZ21lbnRzKTtcbiAgICB9XG4gICAgY2xvbmVGcm9tU2VnbWVudHMoKSB7XG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBDbGllbnQoXCJcIiwgdGhpcy5tZXJnZVRyZWUub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWdtZW50cyA9IFtdO1xuICAgICAgICBsZXQgbmV3Um9vdCA9IHRoaXMubWVyZ2VUcmVlLmJsb2NrQ2xvbmUodGhpcy5tZXJnZVRyZWUucm9vdCwgc2VnbWVudHMpO1xuICAgICAgICBjbG9uZS5tZXJnZVRyZWUucm9vdCA9IG5ld1Jvb3Q7XG4gICAgICAgIGxldCB1bmRvU2VnID0gW107XG4gICAgICAgIGZvciAobGV0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LnNlcSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHVuZG9TZWcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlcTogc2VnbWVudC5zZXEsXG4gICAgICAgICAgICAgICAgICAgIHNlZzogc2VnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgb3A6IDAgLyogSU5TRVJUICovXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5yZW1vdmVkU2VxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1bmRvU2VnLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZXE6IHNlZ21lbnQucmVtb3ZlZFNlcSxcbiAgICAgICAgICAgICAgICAgICAgc2VnOiBzZWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBvcDogMSAvKiBSRU1PVkUgKi9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bmRvU2VnID0gdW5kb1NlZy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYi5zZXEgPT09IGEuc2VxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLnNlcSA9PT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYS5zZXEgPT09IFVuYXNzaWduZWRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc2VxIC0gYi5zZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbG9uZS51bmRvU2VnbWVudHMgPSB1bmRvU2VnO1xuICAgICAgICBjbG9uZS5yZWRvU2VnbWVudHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICBnZXRPckFkZFNob3J0Q2xpZW50SWQobG9uZ0NsaWVudElkLCBicmFuY2hJZCA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudE5hbWVUb0lkcy5nZXQobG9uZ0NsaWVudElkKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRMb25nQ2xpZW50SWQobG9uZ0NsaWVudElkLCBicmFuY2hJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hvcnRDbGllbnRJZChsb25nQ2xpZW50SWQpO1xuICAgIH1cbiAgICBnZXRTaG9ydENsaWVudElkKGxvbmdDbGllbnRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnROYW1lVG9JZHMuZ2V0KGxvbmdDbGllbnRJZCkuZGF0YS5jbGllbnRJZDtcbiAgICB9XG4gICAgZ2V0TG9uZ0NsaWVudElkKHNob3J0Q2xpZW50SWQpIHtcbiAgICAgICAgaWYgKHNob3J0Q2xpZW50SWQgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRDbGllbnRJZE1hcFtzaG9ydENsaWVudElkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIm9yaWdpbmFsXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXNlckluZm8oc2hvcnRDbGllbnRJZCkge1xuICAgICAgICBpZiAoc2hvcnRDbGllbnRJZCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaG9ydENsaWVudFVzZXJJbmZvTWFwW3Nob3J0Q2xpZW50SWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTG9uZ0NsaWVudElkKGxvbmdDbGllbnRJZCwgYnJhbmNoSWQgPSAwKSB7XG4gICAgICAgIHRoaXMuY2xpZW50TmFtZVRvSWRzLnB1dChsb25nQ2xpZW50SWQsIHtcbiAgICAgICAgICAgIGJyYW5jaElkLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuc2hvcnRDbGllbnRJZE1hcC5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNob3J0Q2xpZW50SWRNYXAucHVzaChsb25nQ2xpZW50SWQpO1xuICAgICAgICB0aGlzLnNob3J0Q2xpZW50QnJhbmNoSWRNYXAucHVzaChicmFuY2hJZCk7XG4gICAgfVxuICAgIGdldEJyYW5jaElkKGNsaWVudElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3J0Q2xpZW50QnJhbmNoSWRNYXBbY2xpZW50SWRdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBwcm9wcywgZW5kXG4gICAgbWFrZUluc2VydE1hcmtlck1zZyhtYXJrZXJUeXBlLCBiZWhhdmlvcnMsIHBvcywgc2VxLCByZWZTZXEsIG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5sb25nQ2xpZW50SWQsXG4gICAgICAgICAgICBtaW5pbXVtU2VxdWVuY2VOdW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNsaWVudFNlcXVlbmNlTnVtYmVyOiB0aGlzLmNsaWVudFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IHNlcSxcbiAgICAgICAgICAgIHJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyOiByZWZTZXEsXG4gICAgICAgICAgICBvYmplY3RJZDogb2JqZWN0SWQsXG4gICAgICAgICAgICB1c2VySWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldDogc2VxLFxuICAgICAgICAgICAgb3JpZ2luOiBudWxsLFxuICAgICAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLywgbWFya2VyOiB7IHR5cGU6IG1hcmtlclR5cGUsIGJlaGF2aW9ycyB9LCBwb3MxOiBwb3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICB0cmFjZXM6IFtdLFxuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuT3BlcmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtYWtlSW5zZXJ0TXNnKHRleHQsIHBvcywgc2VxLCByZWZTZXEsIG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5sb25nQ2xpZW50SWQsXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogc2VxLFxuICAgICAgICAgICAgcmVmZXJlbmNlU2VxdWVuY2VOdW1iZXI6IHJlZlNlcSxcbiAgICAgICAgICAgIGNsaWVudFNlcXVlbmNlTnVtYmVyOiB0aGlzLmNsaWVudFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgbWluaW11bVNlcXVlbmNlTnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvYmplY3RJZDogb2JqZWN0SWQsXG4gICAgICAgICAgICB1c2VySWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldDogc2VxLFxuICAgICAgICAgICAgb3JpZ2luOiBudWxsLFxuICAgICAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLywgdGV4dDogdGV4dCwgcG9zMTogcG9zXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHJhY2VzOiBbXSxcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLk9wZXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVJlbW92ZU1zZyhzdGFydCwgZW5kLCBzZXEsIHJlZlNlcSwgb2JqZWN0SWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmxvbmdDbGllbnRJZCxcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiBzZXEsXG4gICAgICAgICAgICByZWZlcmVuY2VTZXF1ZW5jZU51bWJlcjogcmVmU2VxLFxuICAgICAgICAgICAgY2xpZW50U2VxdWVuY2VOdW1iZXI6IHRoaXMuY2xpZW50U2VxdWVuY2VOdW1iZXIsXG4gICAgICAgICAgICBtaW5pbXVtU2VxdWVuY2VOdW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9iamVjdElkOiBvYmplY3RJZCxcbiAgICAgICAgICAgIHVzZXJJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2Zmc2V0OiBzZXEsXG4gICAgICAgICAgICBvcmlnaW46IG51bGwsXG4gICAgICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogUkVNT1ZFICovLCBwb3MxOiBzdGFydCwgcG9zMjogZW5kLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRyYWNlczogW10sXG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5PcGVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1ha2VBbm5vdGF0ZU1zZyhwcm9wcywgc3RhcnQsIGVuZCwgc2VxLCByZWZTZXEsIG9iamVjdElkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5sb25nQ2xpZW50SWQsXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogc2VxLFxuICAgICAgICAgICAgcmVmZXJlbmNlU2VxdWVuY2VOdW1iZXI6IHJlZlNlcSxcbiAgICAgICAgICAgIG9iamVjdElkOiBvYmplY3RJZCxcbiAgICAgICAgICAgIGNsaWVudFNlcXVlbmNlTnVtYmVyOiB0aGlzLmNsaWVudFNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgdXNlcklkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtaW5pbXVtU2VxdWVuY2VOdW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZnNldDogc2VxLFxuICAgICAgICAgICAgb3JpZ2luOiBudWxsLFxuICAgICAgICAgICAgY29udGVudHM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIEFOTk9UQVRFICovLCBwb3MxOiBzdGFydCwgcG9zMjogZW5kLCBwcm9wc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRyYWNlczogW10sXG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5PcGVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGhhc01lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xLmNvdW50KCkgPiAwO1xuICAgIH1cbiAgICBlbnF1ZXVlTXNnKG1zZykge1xuICAgICAgICB0aGlzLnEuZW5xdWV1ZShtc2cpO1xuICAgIH1cbiAgICBkZXF1ZXVlTXNnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xLmRlcXVldWUoKTtcbiAgICB9XG4gICAgZW5xdWV1ZVRlc3RTdHJpbmcoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tRLmVucXVldWUodGhpcy5nZXRUZXh0KCkpO1xuICAgIH1cbiAgICBzZWdtZW50VG9PcHMoc2VnbWVudCwgb3BMaXN0KSB7XG4gICAgICAgIC8vIFRPRE86IGJyYW5jaGVzXG4gICAgICAgIGlmIChzZWdtZW50LnNlcSA9PT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gdGhpcy5tZXJnZVRyZWUuZ2V0T2Zmc2V0KHNlZ21lbnQsIHRoaXMuZ2V0Q3VycmVudFNlcSgpLCB0aGlzLmdldENsaWVudElkKCkpO1xuICAgICAgICAgICAgbGV0IGluc2VydE9wID0ge1xuICAgICAgICAgICAgICAgIHBvczE6IHBvcyxcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5nZXRUeXBlKCkgPT09IFNlZ21lbnRUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIGluc2VydE9wLnRleHQgPSB0ZXh0U2VnbWVudC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIG1hcmtlclxuICAgICAgICAgICAgICAgIGxldCBtYXJrZXIgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIGluc2VydE9wLm1hcmtlciA9IHsgcmVmVHlwZTogbWFya2VyLnJlZlR5cGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRPcC5wcm9wcyA9IHNlZ21lbnQucHJvcGVydGllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wTGlzdC5wdXNoKGluc2VydE9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudC5yZW1vdmVkU2VxID09PSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMubWVyZ2VUcmVlLmdldE9mZnNldChzZWdtZW50LCB0aGlzLmdldEN1cnJlbnRTZXEoKSwgdGhpcy5nZXRDbGllbnRJZCgpKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVPcCA9IHtcbiAgICAgICAgICAgICAgICBwb3MxOiBzdGFydCxcbiAgICAgICAgICAgICAgICBwb3MyOiBzdGFydCArIHNlZ21lbnQuY2FjaGVkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogUkVNT1ZFICovLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wTGlzdC5wdXNoKHJlbW92ZU9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm1PcChvcCwgcmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIHRvU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgaWYgKChvcC50eXBlID09IDIgLyogQU5OT1RBVEUgKi8pIHx8XG4gICAgICAgICAgICAob3AudHlwZSA9PSAxIC8qIFJFTU9WRSAqLykpIHtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSB0aGlzLm1lcmdlVHJlZS50YXJkaXNSYW5nZShvcC5wb3MxLCBvcC5wb3MyLCByZWZlcmVuY2VTZXF1ZW5jZU51bWJlciwgdG9TZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgb3AucG9zMSA9IHJhbmdlc1swXS5zdGFydDtcbiAgICAgICAgICAgICAgICBvcC5wb3MyID0gcmFuZ2VzWzBdLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBncm91cE9wID0geyB0eXBlOiAzIC8qIEdST1VQICovIH07XG4gICAgICAgICAgICAgICAgZ3JvdXBPcC5vcHMgPSByYW5nZXMubWFwKChyYW5nZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogb3AudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zMTogcmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHBvczI6IHJhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwT3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AudHlwZSA9PSAwIC8qIElOU0VSVCAqLykge1xuICAgICAgICAgICAgb3AucG9zMSA9IHRoaXMubWVyZ2VUcmVlLnRhcmRpc1Bvc2l0aW9uKG9wLnBvczEsIHJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCB0b1NlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcC50eXBlID09PSAzIC8qIEdST1VQICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3Aub3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3Aub3BzW2ldID0gdGhpcy50cmFuc2Zvcm1PcChvcC5vcHNbaV0sIHJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCB0b1NlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3A7XG4gICAgfVxuICAgIHRyYW5zZm9ybShvcCwgcmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIHRvU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyID49IHRvU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1PcChvcCwgcmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIHRvU2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICBjb3B5KHN0YXJ0LCBlbmQsIHJlZ2lzdGVySWQsIHJlZlNlcSwgY2xpZW50SWQsIGxvbmdDbGllbnRJZCkge1xuICAgICAgICBsZXQgc2VncyA9IHRoaXMubWVyZ2VUcmVlLmNsb25lU2VnbWVudHMocmVmU2VxLCBjbGllbnRJZCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb2xsZWN0aW9uLnNldChsb25nQ2xpZW50SWQsIHJlZ2lzdGVySWQsIHNlZ3MpO1xuICAgIH1cbiAgICBwYXN0ZUxvY2FsKHJlZ2lzdGVyLCBwb3MsIG9wQXJncykge1xuICAgICAgICBsZXQgc2VncyA9IHRoaXMucmVnaXN0ZXJDb2xsZWN0aW9uLmdldCh0aGlzLmxvbmdDbGllbnRJZCwgcmVnaXN0ZXIpO1xuICAgICAgICBpZiAoc2Vncykge1xuICAgICAgICAgICAgdGhpcy5tZXJnZVRyZWUuc3RhcnRHcm91cE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgLy8gVE9ETzogYnVpbGQgdHJlZSBmcm9tIHNlZ3MgYW5kIGluc2VydCBhbGwgYXQgb25jZVxuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFNlZ21lbnQgPSBzZWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0VGV4dExvY2FsKHRleHRTZWdtZW50LnRleHQsIHBvcywgdGV4dFNlZ21lbnQucHJvcGVydGllcywgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHRleHRTZWdtZW50LmNhY2hlZExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrZXIgPSBzZWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0TWFya2VyTG9jYWwocG9zLCBtYXJrZXIucmVmVHlwZSwgbWFya2VyLnByb3BlcnRpZXMsIG9wQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtYXJrZXIuY2FjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVyZ2VUcmVlLmVuZEdyb3VwT3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgcGFzdGVSZW1vdGUocG9zLCByZWdpc3RlcklkLCBzZXEsIHJlZlNlcSwgY2xpZW50SWQsIGxvbmdDbGllbnRJZCwgb3BBcmdzKSB7XG4gICAgICAgIGxldCBzZWdzID0gdGhpcy5yZWdpc3RlckNvbGxlY3Rpb24uZ2V0KGxvbmdDbGllbnRJZCwgcmVnaXN0ZXJJZCk7XG4gICAgICAgIGlmIChzZWdzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBidWlsZCB0cmVlIGZyb20gc2VncyBhbmQgaW5zZXJ0IGFsbCBhdCBvbmNlXG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIGlmIChzZWcuZ2V0VHlwZSgpID09PSBTZWdtZW50VHlwZS5UZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0U2VnbWVudCA9IHNlZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRUZXh0UmVtb3RlKHRleHRTZWdtZW50LnRleHQsIHBvcywgdGV4dFNlZ21lbnQucHJvcGVydGllcywgc2VxLCByZWZTZXEsIGNsaWVudElkLCBvcEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gdGV4dFNlZ21lbnQuY2FjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtlciA9IHNlZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRNYXJrZXJSZW1vdGUoeyByZWZUeXBlOiBtYXJrZXIucmVmVHlwZSB9LCBwb3MsIG1hcmtlci5wcm9wZXJ0aWVzLCBzZXEsIHJlZlNlcSwgY2xpZW50SWQsIG9wQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtYXJrZXIuY2FjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBlcnJvciByZXBvcnRpbmdcbiAgICB9XG4gICAgY2hlY2tOZXN0KG9wLCBtc2csIGNsaWQpIHtcbiAgICAgICAgbGV0IGJlZ2luTWFya2VyID0gdGhpcy5tZXJnZVRyZWUuZ2V0U2VnbWVudEZyb21JZChvcC5jaGVja05lc3QuaWQxKTtcbiAgICAgICAgbGV0IGVuZE1hcmtlciA9IHRoaXMubWVyZ2VUcmVlLmdldFNlZ21lbnRGcm9tSWQob3AuY2hlY2tOZXN0LmlkMik7XG4gICAgICAgIGxldCBiZWdpblBvcyA9IHRoaXMubWVyZ2VUcmVlLmdldE9mZnNldChiZWdpbk1hcmtlciwgbXNnLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCBjbGlkKTtcbiAgICAgICAgbGV0IGVuZFBvcyA9IGVuZE1hcmtlci5jYWNoZWRMZW5ndGggKyB0aGlzLm1lcmdlVHJlZS5nZXRPZmZzZXQoZW5kTWFya2VyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQpO1xuICAgICAgICBpZiAoKGJlZ2luUG9zICE9PSBvcC5wb3MxKSB8fCAoZW5kUG9zICE9PSBvcC5wb3MyKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHJlbW92ZSBuZXN0IG1pc21hdGNoICR7YmVnaW5Qb3N9ICR7b3AucG9zMX0gJHtlbmRQb3N9ICR7b3AucG9zMn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseU9wKG9wQXJncykge1xuICAgICAgICBjb25zdCBvcCA9IG9wQXJncy5vcDtcbiAgICAgICAgY29uc3QgbXNnID0gb3BBcmdzLnNlcXVlbmNlZE1lc3NhZ2U7XG4gICAgICAgIGxldCBjbGlkID0gdGhpcy5nZXRPckFkZFNob3J0Q2xpZW50SWQobXNnLmNsaWVudElkKTtcbiAgICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogSU5TRVJUICovOlxuICAgICAgICAgICAgICAgIGlmIChvcC5yZWxhdGl2ZVBvczEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AucG9zMSA9IHRoaXMubWVyZ2VUcmVlLnBvc0Zyb21SZWxhdGl2ZVBvcyhvcC5yZWxhdGl2ZVBvczEsIG1zZy5yZWZlcmVuY2VTZXF1ZW5jZU51bWJlciwgY2xpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5wb3MxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZXZlbnQgd2hlbiBtYXJrZXIgaWQgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AucG9zMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlZ21lbnRSZW1vdGUob3AucG9zMSwgb3AucG9zMiwgbXNnLnNlcXVlbmNlTnVtYmVyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQsIG9wQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRUZXh0UmVtb3RlKG9wLnRleHQsIG9wLnBvczEsIG9wLnByb3BzLCBtc2cuc2VxdWVuY2VOdW1iZXIsIG1zZy5yZWZlcmVuY2VTZXF1ZW5jZU51bWJlciwgY2xpZCwgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3AubWFya2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRNYXJrZXJSZW1vdGUob3AubWFya2VyLCBvcC5wb3MxLCBvcC5wcm9wcywgbXNnLnNlcXVlbmNlTnVtYmVyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQsIG9wQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRJdGVtc1JlbW90ZShvcC5pdGVtcywgb3AuaXNOdW1iZXJTZXF1ZW5jZSwgb3AucG9zMSwgb3AucHJvcHMsIG1zZy5zZXF1ZW5jZU51bWJlciwgbXNnLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCBjbGlkLCBvcEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcC5yZWdpc3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbGF0aXZlIGFkZHJlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnBvczIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5KG9wLnBvczEsIG9wLnBvczIsIG9wLnJlZ2lzdGVyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQsIG1zZy5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXN0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXN0ZVJlbW90ZShvcC5wb3MxLCBvcC5yZWdpc3RlciwgbXNnLnNlcXVlbmNlTnVtYmVyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQsIG1zZy5jbGllbnRJZCwgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBSRU1PVkUgKi86XG4gICAgICAgICAgICAgICAgaWYgKG9wLnJlbGF0aXZlUG9zMSkge1xuICAgICAgICAgICAgICAgICAgICBvcC5wb3MxID0gdGhpcy5tZXJnZVRyZWUucG9zRnJvbVJlbGF0aXZlUG9zKG9wLnJlbGF0aXZlUG9zMSwgbXNnLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCBjbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnBvczEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBldmVudCB3aGVuIG1hcmtlciBpZCBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3AucmVsYXRpdmVQb3MyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLnBvczIgPSB0aGlzLm1lcmdlVHJlZS5wb3NGcm9tUmVsYXRpdmVQb3Mob3AucmVsYXRpdmVQb3MyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AucG9zMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGV2ZW50IHdoZW4gbWFya2VyIGlkIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcC5yZWdpc3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjdXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5KG9wLnBvczEsIG9wLnBvczIsIG9wLnJlZ2lzdGVyLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQsIG1zZy5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcC5jaGVja05lc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05lc3Qob3AsIG1zZywgY2xpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VnbWVudFJlbW90ZShvcC5wb3MxLCBvcC5wb3MyLCBtc2cuc2VxdWVuY2VOdW1iZXIsIG1zZy5yZWZlcmVuY2VTZXF1ZW5jZU51bWJlciwgY2xpZCwgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBBTk5PVEFURSAqLzpcbiAgICAgICAgICAgICAgICBpZiAob3AucmVsYXRpdmVQb3MxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLnBvczEgPSB0aGlzLm1lcmdlVHJlZS5wb3NGcm9tUmVsYXRpdmVQb3Mob3AucmVsYXRpdmVQb3MxLCBtc2cucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsIGNsaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AucG9zMSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGV2ZW50IHdoZW4gbWFya2VyIGlkIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcC5yZWxhdGl2ZVBvczIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AucG9zMiA9IHRoaXMubWVyZ2VUcmVlLnBvc0Zyb21SZWxhdGl2ZVBvcyhvcC5yZWxhdGl2ZVBvczIsIG1zZy5yZWZlcmVuY2VTZXF1ZW5jZU51bWJlciwgY2xpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5wb3MyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZXZlbnQgd2hlbiBtYXJrZXIgaWQgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0ZVNlZ21lbnRSZW1vdGUob3AucHJvcHMsIG9wLnBvczEsIG9wLnBvczIsIG1zZy5zZXF1ZW5jZU51bWJlciwgbXNnLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCBjbGlkLCBvcC5jb21iaW5pbmdPcCwgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBHUk9VUCAqLzoge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG1lbWJlck9wIG9mIG9wLm9wcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5T3Aoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IG1lbWJlck9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBPcDogb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZWRNZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNb2RpZmllZE1hcmtlcnNGb3JPcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BNYXJrZXJzTW9kaWZpZWQ7XG4gICAgfVxuICAgIGNvcmVBcHBseU1zZyhtc2cpIHtcbiAgICAgICAgdGhpcy5yZXNldE1vZGlmaWVkTWFya2VycygpO1xuICAgICAgICB0aGlzLmFwcGx5T3Aoe1xuICAgICAgICAgICAgb3A6IG1zZy5jb250ZW50cyxcbiAgICAgICAgICAgIHNlcXVlbmNlZE1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwbHlNc2cobXNnKSB7XG4gICAgICAgIGlmICgobXNnICE9PSB1bmRlZmluZWQpICYmIChtc2cubWluaW11bVNlcXVlbmNlTnVtYmVyID4gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkubWluU2VxKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNaW5TZXEobXNnLm1pbmltdW1TZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIGNsaWVudCBJRCBpcyByZWdpc3RlcmVkXG4gICAgICAgIC8vIFRPRE8gc3VwcG9ydCBmb3IgbW9yZSB0aGFuIHR3byBicmFuY2ggSURzXG4gICAgICAgIC8vIFRoZSBleGlzdGFuY2Ugb2YgbXNnLm9yaWdpbiBtZWFucyB3ZSBhcmUgYSBicmFuY2ggbWVzc2FnZSAtIGFuZCBzbyBzaG91bGQgYmUgbWFya2VkIGFzIDBcbiAgICAgICAgLy8gVGhlIG5vbi1leGlzdGFuY2Ugb2YgbXNnLm9yaWdpbiBpbmRpY2F0ZXMgd2UgYXJlIGxvY2FsIC0gYW5kIHNob3VsZCBpbmhlcml0IHRoZSBjb2xsYWIgbW9kZSBJRFxuICAgICAgICBjb25zdCBicmFuY2hJZCA9IG1zZy5vcmlnaW4gPyAwIDogdGhpcy5tZXJnZVRyZWUubG9jYWxCcmFuY2hJZDtcbiAgICAgICAgdGhpcy5nZXRPckFkZFNob3J0Q2xpZW50SWQobXNnLmNsaWVudElkLCBicmFuY2hJZCk7XG4gICAgICAgIC8vIEFwcGx5IGlmIGFuIG9wZXJhdGlvbiBtZXNzYWdlXG4gICAgICAgIGlmIChtc2cudHlwZSA9PT0gTWVzc2FnZVR5cGUuT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25NZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgaWYgKG1zZy5jbGllbnRJZCA9PT0gdGhpcy5sb25nQ2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3AgPSBtc2cuY29udGVudHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wLnR5cGUgIT09IDIgLyogQU5OT1RBVEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2tQZW5kaW5nU2VnbWVudChvcGVyYXRpb25NZXNzYWdlLnNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5jb21iaW5pbmdPcCAmJiAob3AuY29tYmluaW5nT3AubmFtZSA9PT0gXCJjb25zZW5zdXNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29uc2Vuc3VzUHJvcGVydHkob3AsIG9wZXJhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JlQXBwbHlNc2cob3BlcmF0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlNZXNzYWdlcyhtc2dDb3VudCkge1xuICAgICAgICB3aGlsZSAobXNnQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbXNnID0gdGhpcy5xLmRlcXVldWUoKTtcbiAgICAgICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TXNnKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZ0NvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldExvY2FsU2VxdWVuY2VOdW1iZXIoKSB7XG4gICAgICAgIGxldCBzZWdXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgaWYgKHNlZ1dpbmRvdy5jb2xsYWJvcmF0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsVHJhbnNhY3Rpb24oZ3JvdXBPcCwgc2VnbWVudEdyb3VwKSB7XG4gICAgICAgIHNlZ21lbnRHcm91cCA9IHRoaXMubWVyZ2VUcmVlLnN0YXJ0R3JvdXBPcGVyYXRpb24oc2VnbWVudEdyb3VwKTtcbiAgICAgICAgZm9yIChsZXQgb3Agb2YgZ3JvdXBPcC5vcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wQXJncyA9IHtcbiAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICBncm91cE9wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBJTlNFUlQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5yZWxhdGl2ZVBvczEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBvczEgPSB0aGlzLm1lcmdlVHJlZS5wb3NGcm9tUmVsYXRpdmVQb3Mob3AucmVsYXRpdmVQb3MxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5wb3MxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJhaXNlIGV4Y2VwdGlvbiBvciBvdGhlciBlcnJvciBmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLm1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRNYXJrZXJMb2NhbChvcC5wb3MxLCBvcC5tYXJrZXIucmVmVHlwZSwgb3AucHJvcHMsIG9wQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydFRleHRMb2NhbChvcC50ZXh0LCBvcC5wb3MxLCBvcC5wcm9wcywgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQU5OT1RBVEUgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5yZWxhdGl2ZVBvczEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBvczEgPSB0aGlzLm1lcmdlVHJlZS5wb3NGcm9tUmVsYXRpdmVQb3Mob3AucmVsYXRpdmVQb3MxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5wb3MxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJhaXNlIGV4Y2VwdGlvbiBvciBvdGhlciBlcnJvciBmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnJlbGF0aXZlUG9zMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AucG9zMiA9IHRoaXMubWVyZ2VUcmVlLnBvc0Zyb21SZWxhdGl2ZVBvcyhvcC5yZWxhdGl2ZVBvczIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnBvczIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmFpc2UgZXhjZXB0aW9uIG9yIG90aGVyIGVycm9yIGZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRlU2VnbWVudExvY2FsKG9wLnByb3BzLCBvcC5wb3MxLCBvcC5wb3MyLCBvcC5jb21iaW5pbmdPcCwgb3BBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFJFTU9WRSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnJlbGF0aXZlUG9zMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AucG9zMSA9IHRoaXMubWVyZ2VUcmVlLnBvc0Zyb21SZWxhdGl2ZVBvcyhvcC5yZWxhdGl2ZVBvczEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnBvczEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmFpc2UgZXhjZXB0aW9uIG9yIG90aGVyIGVycm9yIGZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3AucmVsYXRpdmVQb3MyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5wb3MyID0gdGhpcy5tZXJnZVRyZWUucG9zRnJvbVJlbGF0aXZlUG9zKG9wLnJlbGF0aXZlUG9zMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AucG9zMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByYWlzZSBleGNlcHRpb24gb3Igb3RoZXIgZXJyb3IgZmxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VnbWVudExvY2FsKG9wLnBvczEsIG9wLnBvczIsIG9wQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBHUk9VUCAqLzpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQgbmVzdGVkIGdyb3VwIG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlVHJlZS5lbmRHcm91cE9wZXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gc2VnbWVudEdyb3VwO1xuICAgIH1cbiAgICB1cGRhdGVDb25zZW5zdXNQcm9wZXJ0eShvcCwgbXNnKSB7XG4gICAgICAgIGxldCBtYXJrZXJJZCA9IG9wLnJlbGF0aXZlUG9zMS5pZDtcbiAgICAgICAgbGV0IGNvbnNlbnN1c0luZm8gPSB0aGlzLnBlbmRpbmdDb25zZW5zdXMuZ2V0KG1hcmtlcklkKTtcbiAgICAgICAgaWYgKGNvbnNlbnN1c0luZm8pIHtcbiAgICAgICAgICAgIGNvbnNlbnN1c0luZm8ubWFya2VyLmFkZFByb3BlcnRpZXMob3AucHJvcHMsIG9wLmNvbWJpbmluZ09wLCBtc2cuc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVyZ2VUcmVlLmFkZE1pblNlcUxpc3RlbmVyKG1zZy5zZXF1ZW5jZU51bWJlciwgKG1pblNlcSkgPT4gY29uc2Vuc3VzSW5mby5jYWxsYmFjayhjb25zZW5zdXNJbmZvLm1hcmtlcikpO1xuICAgIH1cbiAgICAvLyBtYXJrZXIgbXVzdCBoYXZlIGFuIGlkXG4gICAgYW5ub3RhdGVNYXJrZXJOb3RpZnlDb25zZW5zdXMobWFya2VyLCBwcm9wcywgY29uc2Vuc3VzQ2FsbGJhY2ssIG9wQXJncykge1xuICAgICAgICBsZXQgY29tYmluaW5nT3AgPSB7XG4gICAgICAgICAgICBuYW1lOiBcImNvbnNlbnN1c1wiXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb25zZW5zdXNJbmZvID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNvbnNlbnN1c0NhbGxiYWNrLFxuICAgICAgICAgICAgbWFya2VyLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaWQgPSBtYXJrZXIuZ2V0SWQoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29uc2Vuc3VzLnNldChpZCwgY29uc2Vuc3VzSW5mbyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGVNYXJrZXIocHJvcHMsIG1hcmtlciwgY29tYmluaW5nT3AsIG9wQXJncyk7XG4gICAgfVxuICAgIGFubm90YXRlTWFya2VyKHByb3BzLCBtYXJrZXIsIG9wLCBvcEFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ1dpbmRvdyA9IHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpO1xuICAgICAgICBsZXQgY2xpZW50SWQgPSBzZWdXaW5kb3cuY2xpZW50SWQ7XG4gICAgICAgIGxldCByZWZTZXEgPSBzZWdXaW5kb3cuY3VycmVudFNlcTtcbiAgICAgICAgbGV0IHNlcSA9IHRoaXMuZ2V0TG9jYWxTZXF1ZW5jZU51bWJlcigpO1xuICAgICAgICB0aGlzLnJlc2V0TW9kaWZpZWRNYXJrZXJzKCk7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm1lcmdlVHJlZS5nZXRPZmZzZXQobWFya2VyLCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgdGhpcy5nZXRDbGllbnRJZCgpKTtcbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuYW5ub3RhdGVSYW5nZShwcm9wcywgc3RhcnQsIHN0YXJ0ICsgbWFya2VyLmNhY2hlZExlbmd0aCwgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBvcCwgb3BBcmdzKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxPcHMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgYW5ub3RhdGUgbG9jYWwgY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQoY2xpZW50SWQpfSByZWYgc2VxICR7cmVmU2VxfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFubm90YXRlU2VnbWVudExvY2FsKHByb3BzLCBzdGFydCwgZW5kLCBvcCwgb3BBcmdzKSB7XG4gICAgICAgIGxldCBzZWdXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgbGV0IGNsaWVudElkID0gc2VnV2luZG93LmNsaWVudElkO1xuICAgICAgICBsZXQgcmVmU2VxID0gc2VnV2luZG93LmN1cnJlbnRTZXE7XG4gICAgICAgIGxldCBzZXEgPSB0aGlzLmdldExvY2FsU2VxdWVuY2VOdW1iZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldE1vZGlmaWVkTWFya2VycygpO1xuICAgICAgICBsZXQgY2xvY2tTdGFydDtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgY2xvY2tTdGFydCA9IGNsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuYW5ub3RhdGVSYW5nZShwcm9wcywgc3RhcnQsIGVuZCwgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBvcCwgb3BBcmdzKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxPcHMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgYW5ub3RhdGUgbG9jYWwgY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQoY2xpZW50SWQpfSByZWYgc2VxICR7cmVmU2VxfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFubm90YXRlU2VnbWVudFJlbW90ZShwcm9wcywgc3RhcnQsIGVuZCwgc2VxLCByZWZTZXEsIGNsaWVudElkLCBjb21iaW5pbmdPcCwgb3BBcmdzKSB7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlVHJlZS5hbm5vdGF0ZVJhbmdlKHByb3BzLCBzdGFydCwgZW5kLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIGNvbWJpbmluZ09wLCBvcEFyZ3MpO1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKS5jdXJyZW50U2VxID0gc2VxO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICB0aGlzLmFjY3VtVGltZSArPSBlbGFwc2VkTWljcm9zZWNvbmRzKGNsb2NrU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hY2N1bU9wcysrO1xuICAgICAgICAgICAgdGhpcy5hY2N1bVdpbmRvdyArPSAodGhpcy5nZXRDdXJyZW50U2VxKCkgLSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKS5taW5TZXEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2VPcHMgJiYgKCF0aGlzLm5vVmVyYm9zZVJlbW90ZUFubm90ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQodGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkuY2xpZW50SWQpfSBzZXEgJHtzZXF9IGFubm90YXRlIHJlbW90ZSBzdGFydCAke3N0YXJ0fSBlbmQgJHtlbmR9IHJlZnNlcSAke3JlZlNlcX0gY2xpICR7Y2xpZW50SWR9IHByb3BzICR7cHJvcHN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlU2VnbWVudExvY2FsKHN0YXJ0LCBlbmQsIG9wQXJncykge1xuICAgICAgICBsZXQgc2VnV2luZG93ID0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCk7XG4gICAgICAgIGxldCBjbGllbnRJZCA9IHNlZ1dpbmRvdy5jbGllbnRJZDtcbiAgICAgICAgbGV0IHJlZlNlcSA9IHNlZ1dpbmRvdy5jdXJyZW50U2VxO1xuICAgICAgICBsZXQgc2VxID0gdGhpcy5nZXRMb2NhbFNlcXVlbmNlTnVtYmVyKCk7XG4gICAgICAgIHRoaXMucmVzZXRNb2RpZmllZE1hcmtlcnMoKTtcbiAgICAgICAgbGV0IGNsb2NrU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVPcHMpIHtcbiAgICAgICAgICAgIGNsb2NrU3RhcnQgPSBjbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVyZ2VUcmVlLm1hcmtSYW5nZVJlbW92ZWQoc3RhcnQsIGVuZCwgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBmYWxzZSwgb3BBcmdzKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxPcHMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgcmVtb3ZlIGxvY2FsIGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKGNsaWVudElkKX0gcmVmIHNlcSAke3JlZlNlcX0gWyR7c3RhcnR9LCR7ZW5kfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVTZWdtZW50UmVtb3RlKHN0YXJ0LCBlbmQsIHNlcSwgcmVmU2VxLCBjbGllbnRJZCwgb3BBcmdzKSB7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlVHJlZS5tYXJrUmFuZ2VSZW1vdmVkKHN0YXJ0LCBlbmQsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgZmFsc2UsIG9wQXJncyk7XG4gICAgICAgIHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpLmN1cnJlbnRTZXEgPSBzZXE7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVPcHMpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjdW1UaW1lICs9IGVsYXBzZWRNaWNyb3NlY29uZHMoY2xvY2tTdGFydCk7XG4gICAgICAgICAgICB0aGlzLmFjY3VtT3BzKys7XG4gICAgICAgICAgICB0aGlzLmFjY3VtV2luZG93ICs9ICh0aGlzLmdldEN1cnJlbnRTZXEoKSAtIHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpLm1pblNlcSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZU9wcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEBjbGkgJHt0aGlzLmdldExvbmdDbGllbnRJZCh0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKS5jbGllbnRJZCl9IHNlcSAke3NlcX0gcmVtb3ZlIHJlbW90ZSBzdGFydCAke3N0YXJ0fSBlbmQgJHtlbmR9IHJlZnNlcSAke3JlZlNlcX0gY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQoY2xpZW50SWQpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc2VydFRleHRMb2NhbCh0ZXh0LCBwb3MsIHByb3BzLCBvcEFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ1dpbmRvdyA9IHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpO1xuICAgICAgICBsZXQgY2xpZW50SWQgPSBzZWdXaW5kb3cuY2xpZW50SWQ7XG4gICAgICAgIGxldCByZWZTZXEgPSBzZWdXaW5kb3cuY3VycmVudFNlcTtcbiAgICAgICAgbGV0IHNlcSA9IHRoaXMuZ2V0TG9jYWxTZXF1ZW5jZU51bWJlcigpO1xuICAgICAgICB0aGlzLnJlc2V0TW9kaWZpZWRNYXJrZXJzKCk7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlVHJlZS5pbnNlcnRUZXh0KHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCB0ZXh0LCBwcm9wcywgb3BBcmdzKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxPcHMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgaW5zZXJ0IGxvY2FsIHRleHQgJHt0ZXh0fSBwb3MgJHtwb3N9IGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKGNsaWVudElkKX0gcmVmIHNlcSAke3JlZlNlcX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRUZXh0TWFya2VyUmVsYXRpdmUodGV4dCwgbWFya2VyUG9zLCBwcm9wcywgb3BBcmdzKSB7XG4gICAgICAgIGxldCBzZWdXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgbGV0IGNsaWVudElkID0gc2VnV2luZG93LmNsaWVudElkO1xuICAgICAgICBsZXQgcmVmU2VxID0gc2VnV2luZG93LmN1cnJlbnRTZXE7XG4gICAgICAgIGxldCBzZXEgPSB0aGlzLmdldExvY2FsU2VxdWVuY2VOdW1iZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldE1vZGlmaWVkTWFya2VycygpO1xuICAgICAgICBsZXQgY2xvY2tTdGFydDtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgY2xvY2tTdGFydCA9IGNsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuaW5zZXJ0VGV4dE1hcmtlclJlbGF0aXZlKG1hcmtlclBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCB0ZXh0LCBwcm9wcywgb3BBcmdzKTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxPcHMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgaW5zZXJ0IGxvY2FsIHRleHQgbWFya2VyIHJlbGF0aXZlICR7dGV4dH0gcG9zICR7bWFya2VyUG9zLmlkfSBjbGkgJHt0aGlzLmdldExvbmdDbGllbnRJZChjbGllbnRJZCl9IHJlZiBzZXEgJHtyZWZTZXF9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0U2VnbWVudExvY2FsKHBvcywgc2VnbWVudCwgcHJvcHMsIG9wQXJncykge1xuICAgICAgICBsZXQgc2VnV2luZG93ID0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCk7XG4gICAgICAgIGxldCBjbGllbnRJZCA9IHNlZ1dpbmRvdy5jbGllbnRJZDtcbiAgICAgICAgbGV0IHJlZlNlcSA9IHNlZ1dpbmRvdy5jdXJyZW50U2VxO1xuICAgICAgICBsZXQgc2VxID0gdGhpcy5nZXRMb2NhbFNlcXVlbmNlTnVtYmVyKCk7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBzZWdtZW50LnNlcSA9IHNlcTtcbiAgICAgICAgc2VnbWVudC5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5pbnNlcnRTZWdtZW50KHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBzZWdtZW50LCBvcEFyZ3MpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsVGltZSArPSBlbGFwc2VkTWljcm9zZWNvbmRzKGNsb2NrU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbE9wcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2VPcHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBpbnNlcnQgbG9jYWwgc2VnbWVudCBwb3MgJHtwb3N9IGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKGNsaWVudElkKX0gJHtzZWdtZW50LnRvU3RyaW5nKCl9IHJlZiBzZXEgJHtyZWZTZXF9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0TWFya2VyTG9jYWwocG9zLCBiZWhhdmlvcnMsIHByb3BzLCBvcEFyZ3MpIHtcbiAgICAgICAgbGV0IHNlZ1dpbmRvdyA9IHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpO1xuICAgICAgICBsZXQgY2xpZW50SWQgPSBzZWdXaW5kb3cuY2xpZW50SWQ7XG4gICAgICAgIGxldCByZWZTZXEgPSBzZWdXaW5kb3cuY3VycmVudFNlcTtcbiAgICAgICAgbGV0IHNlcSA9IHRoaXMuZ2V0TG9jYWxTZXF1ZW5jZU51bWJlcigpO1xuICAgICAgICB0aGlzLnJlc2V0TW9kaWZpZWRNYXJrZXJzKCk7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gdGhpcy5tZXJnZVRyZWUuaW5zZXJ0TWFya2VyKHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBiZWhhdmlvcnMsIHByb3BzLCBvcEFyZ3MpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsVGltZSArPSBlbGFwc2VkTWljcm9zZWNvbmRzKGNsb2NrU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbE9wcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2VPcHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBpbnNlcnQgbG9jYWwgbWFya2VyIHBvcyAke3Bvc30gY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQoY2xpZW50SWQpfSAke21hcmtlci50b1N0cmluZygpfSByZWYgc2VxICR7cmVmU2VxfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc2VydEl0ZW1zUmVtb3RlKGl0ZW1zLCBpc051bWJlclNlcXVlbmNlLCBwb3MsIHByb3BzLCBzZXEsIHJlZlNlcSwgY2xpZW50SWQsIG9wQXJncykge1xuICAgICAgICBjb25zdCB0cmFjZUl0ZW1zID0gZmFsc2U7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VnbWVudDtcbiAgICAgICAgaWYgKGlzTnVtYmVyU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBuZXcgU3ViU2VxdWVuY2UoaXRlbXMsIHNlcSwgY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IG5ldyBTdWJTZXF1ZW5jZShpdGVtcywgc2VxLCBjbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICBzZWdtZW50LmFkZFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgcHJlLWxlbmd0aDogJHt0aGlzLm1lcmdlVHJlZS5nZXRMZW5ndGgoVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIHRoaXMubWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9IHBvczogJHtwb3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuaW5zZXJ0U2VnbWVudChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnbWVudCwgb3BBcmdzKTtcbiAgICAgICAgaWYgKHRyYWNlSXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBwb3N0LWxlbmd0aDogJHt0aGlzLm1lcmdlVHJlZS5nZXRMZW5ndGgoVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIHRoaXMubWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9IHBvczogJHtwb3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkuY3VycmVudFNlcSA9IHNlcTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5hY2N1bVRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW1PcHMrKztcbiAgICAgICAgICAgIHRoaXMuYWNjdW1XaW5kb3cgKz0gKHRoaXMuZ2V0Q3VycmVudFNlcSgpIC0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkubWluU2VxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpLmNsaWVudElkKX0gJHtzZWdtZW50LnRvU3RyaW5nKCl9IHNlcSAke3NlcX0gaW5zZXJ0IHJlbW90ZSBwb3MgJHtwb3N9IHJlZnNlcSAke3JlZlNlcX0gY2xpICR7Y2xpZW50SWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0TWFya2VyUmVtb3RlKG1hcmtlckRlZiwgcG9zLCBwcm9wcywgc2VxLCByZWZTZXEsIGNsaWVudElkLCBvcEFyZ3MpIHtcbiAgICAgICAgbGV0IGNsb2NrU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVPcHMpIHtcbiAgICAgICAgICAgIGNsb2NrU3RhcnQgPSBjbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXJrZXIgPSB0aGlzLm1lcmdlVHJlZS5pbnNlcnRNYXJrZXIocG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIG1hcmtlckRlZi5yZWZUeXBlLCBwcm9wcywgb3BBcmdzKTtcbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkuY3VycmVudFNlcSA9IHNlcTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5hY2N1bVRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW1PcHMrKztcbiAgICAgICAgICAgIHRoaXMuYWNjdW1XaW5kb3cgKz0gKHRoaXMuZ2V0Q3VycmVudFNlcSgpIC0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkubWluU2VxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpLmNsaWVudElkKX0gJHttYXJrZXIudG9TdHJpbmcoKX0gc2VxICR7c2VxfSBpbnNlcnQgcmVtb3RlIHBvcyAke3Bvc30gcmVmc2VxICR7cmVmU2VxfSBjbGkgJHtjbGllbnRJZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRUZXh0UmVtb3RlKHRleHQsIHBvcywgcHJvcHMsIHNlcSwgcmVmU2VxLCBjbGllbnRJZCwgb3BBcmdzKSB7XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICBjbG9ja1N0YXJ0ID0gY2xvY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlVHJlZS5pbnNlcnRUZXh0KHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCB0ZXh0LCBwcm9wcywgb3BBcmdzKTtcbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkuY3VycmVudFNlcSA9IHNlcTtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgdGhpcy5hY2N1bVRpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW1PcHMrKztcbiAgICAgICAgICAgIHRoaXMuYWNjdW1XaW5kb3cgKz0gKHRoaXMuZ2V0Q3VycmVudFNlcSgpIC0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkubWluU2VxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpLmNsaWVudElkKX0gdGV4dCAke3RleHR9IHNlcSAke3NlcX0gaW5zZXJ0IHJlbW90ZSBwb3MgJHtwb3N9IHJlZnNlcSAke3JlZlNlcX0gY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQoY2xpZW50SWQpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFja1BlbmRpbmdTZWdtZW50KHNlcSkge1xuICAgICAgICBsZXQgY2xvY2tTdGFydDtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgY2xvY2tTdGFydCA9IGNsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuYWNrUGVuZGluZ1NlZ21lbnQoc2VxLCB0aGlzLnZlcmJvc2VPcHMpO1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKS5jdXJyZW50U2VxID0gc2VxO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlT3BzKSB7XG4gICAgICAgICAgICB0aGlzLmFjY3VtVGltZSArPSBlbGFwc2VkTWljcm9zZWNvbmRzKGNsb2NrU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hY2N1bU9wcysrO1xuICAgICAgICAgICAgdGhpcy5hY2N1bVdpbmRvdyArPSAodGhpcy5nZXRDdXJyZW50U2VxKCkgLSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKS5taW5TZXEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2VPcHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQodGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkuY2xpZW50SWQpfSBhY2sgc2VxICMgJHtzZXF9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTWluU2VxKG1pblNlcSkge1xuICAgICAgICBsZXQgY2xvY2tTdGFydDtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZU9wcykge1xuICAgICAgICAgICAgY2xvY2tTdGFydCA9IGNsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXJnZVRyZWUudXBkYXRlR2xvYmFsTWluU2VxKG1pblNlcSk7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVPcHMpIHtcbiAgICAgICAgICAgIGxldCBlbGFwc2VkID0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW1XaW5kb3dUaW1lICs9IGVsYXBzZWQ7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IHRoaXMubWF4V2luZG93VGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4V2luZG93VGltZSA9IGVsYXBzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHJvcGVydGllc0F0UG9zaXRpb24ocG9zKSB7XG4gICAgICAgIGxldCBzZWdXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZU9wcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGdldFByb3BlcnRpZXNBdFBvc2l0aW9uIGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKHNlZ1dpbmRvdy5jbGllbnRJZCl9IHJlZiBzZXEgJHtzZWdXaW5kb3cuY3VycmVudFNlcX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvcGVydGllc0F0UG9zaXRpb247XG4gICAgICAgIGxldCBzZWdvZmYgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb250YWluaW5nU2VnbWVudChwb3MsIHNlZ1dpbmRvdy5jdXJyZW50U2VxLCBzZWdXaW5kb3cuY2xpZW50SWQpO1xuICAgICAgICBsZXQgc2VnID0gc2Vnb2ZmLnNlZ21lbnQ7XG4gICAgICAgIGlmIChzZWcpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNBdFBvc2l0aW9uID0gc2VnLnByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXNBdFBvc2l0aW9uO1xuICAgIH1cbiAgICBnZXRSYW5nZUV4dGVudHNPZlBvc2l0aW9uKHBvcykge1xuICAgICAgICBsZXQgc2VnV2luZG93ID0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCk7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2VPcHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBnZXRSYW5nZUV4dGVudHNPZlBvc2l0aW9uIGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKHNlZ1dpbmRvdy5jbGllbnRJZCl9IHJlZiBzZXEgJHtzZWdXaW5kb3cuY3VycmVudFNlcX1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRQb3M7XG4gICAgICAgIGxldCBlbmRQb3M7XG4gICAgICAgIGxldCBzZWdvZmYgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb250YWluaW5nU2VnbWVudChwb3MsIHNlZ1dpbmRvdy5jdXJyZW50U2VxLCBzZWdXaW5kb3cuY2xpZW50SWQpO1xuICAgICAgICBsZXQgc2VnID0gc2Vnb2ZmLnNlZ21lbnQ7XG4gICAgICAgIGlmIChzZWcpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5tZXJnZVRyZWUuZ2V0T2Zmc2V0KHNlZywgc2VnV2luZG93LmN1cnJlbnRTZXEsIHNlZ1dpbmRvdy5jbGllbnRJZCk7XG4gICAgICAgICAgICBlbmRQb3MgPSBzdGFydFBvcyArIHNlZy5jYWNoZWRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnRQb3MsIGVuZFBvcyB9O1xuICAgIH1cbiAgICBnZXRDdXJyZW50U2VxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkuY3VycmVudFNlcTtcbiAgICB9XG4gICAgZ2V0Q2xpZW50SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKS5jbGllbnRJZDtcbiAgICB9XG4gICAgZ2V0VGV4dEFuZE1hcmtlcnMobGFiZWwpIHtcbiAgICAgICAgbGV0IHNlZ21lbnRXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VUcmVlLmdldFRleHRBbmRNYXJrZXJzKHNlZ21lbnRXaW5kb3cuY3VycmVudFNlcSwgc2VnbWVudFdpbmRvdy5jbGllbnRJZCwgbGFiZWwpO1xuICAgIH1cbiAgICBnZXRUZXh0KHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IHNlZ21lbnRXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VUcmVlLmdldFRleHQoc2VnbWVudFdpbmRvdy5jdXJyZW50U2VxLCBzZWdtZW50V2luZG93LmNsaWVudElkLCBcIlwiLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBzcGFjZXMgZm9yIG1hcmtlcnMgYW5kIGNvbXBvbmVudHMsIHNvIHRoYXQgcG9zaXRpb24gY2FsY3VsYXRpb25zIGFjY291bnQgZm9yIHRoZW1cbiAgICAgKi9cbiAgICBnZXRUZXh0V2l0aFBsYWNlaG9sZGVycygpIHtcbiAgICAgICAgbGV0IHNlZ21lbnRXaW5kb3cgPSB0aGlzLm1lcmdlVHJlZS5nZXRDb2xsYWJXaW5kb3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VUcmVlLmdldFRleHQoc2VnbWVudFdpbmRvdy5jdXJyZW50U2VxLCBzZWdtZW50V2luZG93LmNsaWVudElkLCBcIiBcIik7XG4gICAgfVxuICAgIGdldFRleHRSYW5nZVdpdGhQbGFjZWhvbGRlcnMoc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgc2VnbWVudFdpbmRvdyA9IHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVRyZWUuZ2V0VGV4dChzZWdtZW50V2luZG93LmN1cnJlbnRTZXEsIHNlZ21lbnRXaW5kb3cuY2xpZW50SWQsIFwiIFwiLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZ2V0VGV4dFJhbmdlV2l0aE1hcmtlcnMoc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgc2VnbWVudFdpbmRvdyA9IHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVRyZWUuZ2V0VGV4dChzZWdtZW50V2luZG93LmN1cnJlbnRTZXEsIHNlZ21lbnRXaW5kb3cuY2xpZW50SWQsIFwiKlwiLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZ2V0TGVuZ3RoKCkge1xuICAgICAgICBsZXQgc2VnbWVudFdpbmRvdyA9IHRoaXMubWVyZ2VUcmVlLmdldENvbGxhYldpbmRvdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVRyZWUuZ2V0TGVuZ3RoKHNlZ21lbnRXaW5kb3cuY3VycmVudFNlcSwgc2VnbWVudFdpbmRvdy5jbGllbnRJZCk7XG4gICAgfVxuICAgIHJlbFRleHQoY2xpZW50SWQsIHJlZlNlcSkge1xuICAgICAgICByZXR1cm4gYGNsaTogJHt0aGlzLmdldExvbmdDbGllbnRJZChjbGllbnRJZCl9IHJlZlNlcTogJHtyZWZTZXF9OiBgICsgdGhpcy5tZXJnZVRyZWUuZ2V0VGV4dChyZWZTZXEsIGNsaWVudElkKTtcbiAgICB9XG4gICAgcmVsSXRlbXMoY2xpZW50SWQsIHJlZlNlcSkge1xuICAgICAgICByZXR1cm4gYGNsaTogJHt0aGlzLmdldExvbmdDbGllbnRJZChjbGllbnRJZCl9IHJlZlNlcTogJHtyZWZTZXF9OiBgICsgdGhpcy5tZXJnZVRyZWUuZ2V0SXRlbXMocmVmU2VxLCBjbGllbnRJZCkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc3RhcnRDb2xsYWJvcmF0aW9uKGxvbmdDbGllbnRJZCwgbWluU2VxID0gMCwgYnJhbmNoSWQgPSAwKSB7XG4gICAgICAgIHRoaXMubG9uZ0NsaWVudElkID0gbG9uZ0NsaWVudElkO1xuICAgICAgICB0aGlzLmFkZExvbmdDbGllbnRJZChsb25nQ2xpZW50SWQsIGJyYW5jaElkKTtcbiAgICAgICAgdGhpcy5tZXJnZVRyZWUuc3RhcnRDb2xsYWJvcmF0aW9uKHRoaXMuZ2V0U2hvcnRDbGllbnRJZCh0aGlzLmxvbmdDbGllbnRJZCksIG1pblNlcSwgYnJhbmNoSWQpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xsYWJvcmF0aW9uKGxvbmdDbGllbnRJZCkge1xuICAgICAgICBjb25zdCBvbGRDbGllbnRJZCA9IHRoaXMubG9uZ0NsaWVudElkO1xuICAgICAgICBsZXQgb2xkRGF0YSA9IHRoaXMuY2xpZW50TmFtZVRvSWRzLmdldChvbGRDbGllbnRJZCkuZGF0YTtcbiAgICAgICAgdGhpcy5sb25nQ2xpZW50SWQgPSBsb25nQ2xpZW50SWQ7XG4gICAgICAgIHRoaXMuY2xpZW50TmFtZVRvSWRzLnB1dChsb25nQ2xpZW50SWQsIG9sZERhdGEpO1xuICAgICAgICB0aGlzLnNob3J0Q2xpZW50SWRNYXBbb2xkRGF0YS5jbGllbnRJZF0gPSBsb25nQ2xpZW50SWQ7XG4gICAgfVxuICAgIGZpbmRUaWxlKHN0YXJ0UG9zLCB0aWxlTGFiZWwsIHByZWNlZGluZyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmdldENsaWVudElkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlVHJlZS5maW5kVGlsZShzdGFydFBvcywgY2xpZW50SWQsIHRpbGVMYWJlbCwgcHJlY2VkaW5nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGVcbmltcG9ydCAqIGFzIE1lcmdlVHJlZSBmcm9tIFwiLi9tZXJnZVRyZWVcIjtcbmV4cG9ydCBjbGFzcyBTdGFjayB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgcHVzaCh2YWwpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbCk7XG4gICAgfVxuICAgIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPT0gMDtcbiAgICB9XG4gICAgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnBvcCgpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBMaXN0UmVtb3ZlRW50cnkoZW50cnkpIHtcbiAgICBpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbnRyeS5pc0hlYWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudHJ5Lm5leHQucHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIGVudHJ5LnByZXYubmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIHJldHVybiAoZW50cnkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIExpc3RNYWtlRW50cnkoZGF0YSkge1xuICAgIHZhciBlbnRyeSA9IG5ldyBMaXN0KGZhbHNlLCBkYXRhKTtcbiAgICBlbnRyeS5wcmV2ID0gZW50cnk7XG4gICAgZW50cnkubmV4dCA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBMaXN0TWFrZUhlYWQoKSB7XG4gICAgdmFyIGVudHJ5ID0gbmV3IExpc3QodHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICBlbnRyeS5wcmV2ID0gZW50cnk7XG4gICAgZW50cnkubmV4dCA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeTtcbn1cbmV4cG9ydCBjbGFzcyBMaXN0IHtcbiAgICBjb25zdHJ1Y3Rvcihpc0hlYWQsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5pc0hlYWQgPSBpc0hlYWQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0hlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChkYXRhKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IExpc3RNYWtlRW50cnkoZGF0YSk7XG4gICAgICAgIHRoaXMucHJldi5uZXh0ID0gZW50cnk7XG4gICAgICAgIGVudHJ5Lm5leHQgPSB0aGlzO1xuICAgICAgICBlbnRyeS5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICB0aGlzLnByZXYgPSBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSk7XG4gICAgfVxuICAgIGRlcXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBsZXQgcmVtb3ZlZEVudHJ5ID0gTGlzdFJlbW92ZUVudHJ5KHRoaXMubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlZEVudHJ5LmRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5xdWV1ZShkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChkYXRhKTtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgICBmb3IgKHZhciBlbnRyeSA9IHRoaXMubmV4dDsgIShlbnRyeS5pc0hlYWQpOyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcbiAgICAgICAgICAgIGZuKGVudHJ5LmRhdGEsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzb21lKGZuLCByZXYpIHtcbiAgICAgICAgZm9yICh2YXIgZW50cnkgPSB0aGlzOyAhKGVudHJ5LmlzSGVhZCk7IGVudHJ5ID0gcmV2ID8gZW50cnkucHJldiA6IGVudHJ5Lm5leHQpIHtcbiAgICAgICAgICAgIGlmIChmbihlbnRyeS5kYXRhLCBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVudHJ5LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvdW50KCkge1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBlbnRyeSA9IHRoaXMubmV4dDtcbiAgICAgICAgZm9yIChpID0gMDsgIShlbnRyeS5pc0hlYWQpOyBpKyspIHtcbiAgICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGkpO1xuICAgIH1cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uZXh0LmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucHJldi5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5leHQgPT0gdGhpcyk7XG4gICAgfVxuICAgIHB1c2hFbnRyeShlbnRyeSkge1xuICAgICAgICBlbnRyeS5pc0hlYWQgPSBmYWxzZTtcbiAgICAgICAgZW50cnkubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgZW50cnkucHJldiA9IHRoaXM7XG4gICAgICAgIHRoaXMubmV4dCA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5uZXh0LnByZXYgPSBlbnRyeTtcbiAgICB9XG4gICAgcHVzaChkYXRhKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IExpc3RNYWtlRW50cnkoZGF0YSk7XG4gICAgICAgIGVudHJ5LmRhdGEgPSBkYXRhO1xuICAgICAgICBlbnRyeS5pc0hlYWQgPSBmYWxzZTtcbiAgICAgICAgZW50cnkubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgZW50cnkucHJldiA9IHRoaXM7XG4gICAgICAgIHRoaXMubmV4dCA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5uZXh0LnByZXYgPSBlbnRyeTtcbiAgICB9XG4gICAgcG9wRW50cnkoaGVhZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzSGVhZClcbiAgICAgICAgICAgIHJldHVybiAodW5kZWZpbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIChMaXN0UmVtb3ZlRW50cnkodGhpcy5uZXh0KSk7XG4gICAgfVxuICAgIGluc2VydEVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LmlzSGVhZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXYubmV4dCA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5uZXh0ID0gdGhpcztcbiAgICAgICAgZW50cnkucHJldiA9IHRoaXMucHJldjtcbiAgICAgICAgdGhpcy5wcmV2ID0gZW50cnk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgaW5zZXJ0QWZ0ZXIoZGF0YSkge1xuICAgICAgICB2YXIgZW50cnkgPSBMaXN0TWFrZUVudHJ5KGRhdGEpO1xuICAgICAgICBlbnRyeS5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBlbnRyeS5wcmV2ID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGVudHJ5Lm5leHQucHJldiA9IGVudHJ5O1xuICAgICAgICByZXR1cm4gKGVudHJ5KTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlKGRhdGEpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gTGlzdE1ha2VFbnRyeShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RW50cnlCZWZvcmUoZW50cnkpO1xuICAgIH1cbiAgICBpbnNlcnRFbnRyeUJlZm9yZShlbnRyeSkge1xuICAgICAgICB0aGlzLnByZXYubmV4dCA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5uZXh0ID0gdGhpcztcbiAgICAgICAgZW50cnkucHJldiA9IHRoaXMucHJldjtcbiAgICAgICAgdGhpcy5wcmV2ID0gZW50cnk7XG4gICAgICAgIHJldHVybiAoZW50cnkpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgbnVtYmVyQ29tcGFyZXIgPSB7XG4gICAgbWluOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbn07XG5leHBvcnQgY2xhc3MgSGVhcCB7XG4gICAgY29uc3RydWN0b3IoYSwgY29tcCkge1xuICAgICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgICB0aGlzLkwgPSBbY29tcC5taW5dO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGQoYVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkwubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTFsxXTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuTFsxXTtcbiAgICAgICAgdGhpcy5MWzFdID0gdGhpcy5MW3RoaXMuY291bnQoKV07XG4gICAgICAgIHRoaXMuTC5wb3AoKTtcbiAgICAgICAgdGhpcy5maXhkb3duKDEpO1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgYWRkKHgpIHtcbiAgICAgICAgdGhpcy5MLnB1c2goeCk7XG4gICAgICAgIHRoaXMuZml4dXAodGhpcy5jb3VudCgpKTtcbiAgICB9XG4gICAgZml4dXAoaykge1xuICAgICAgICB3aGlsZSAoayA+IDEgJiYgKHRoaXMuY29tcC5jb21wYXJlKHRoaXMuTFtrID4+IDFdLCB0aGlzLkxba10pID4gMCkpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLkxbayA+PiAxXTtcbiAgICAgICAgICAgIHRoaXMuTFtrID4+IDFdID0gdGhpcy5MW2tdO1xuICAgICAgICAgICAgdGhpcy5MW2tdID0gdG1wO1xuICAgICAgICAgICAgayA9IGsgPj4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXhkb3duKGspIHtcbiAgICAgICAgd2hpbGUgKChrIDw8IDEpIDw9ICh0aGlzLmNvdW50KCkpKSB7XG4gICAgICAgICAgICB2YXIgaiA9IGsgPDwgMTtcbiAgICAgICAgICAgIGlmICgoaiA8IHRoaXMuY291bnQoKSkgJiYgKHRoaXMuY29tcC5jb21wYXJlKHRoaXMuTFtqXSwgdGhpcy5MW2ogKyAxXSkgPiAwKSkge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxba10sIHRoaXMuTFtqXSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuTFtrXTtcbiAgICAgICAgICAgIHRoaXMuTFtrXSA9IHRoaXMuTFtqXTtcbiAgICAgICAgICAgIHRoaXMuTFtqXSA9IHRtcDtcbiAgICAgICAgICAgIGsgPSBqO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gZm9yIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBMaW5lYXJEaWN0aW9uYXJ5KGNvbXBhcmVLZXlzKSB7XG4gICAgbGV0IGEgPSBbXTtcbiAgICBmdW5jdGlvbiBjb21wYXJlUHJvcHMoYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZUtleXMoYS5rZXksIGIua2V5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlhZygpIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNpemUgaXMgJHthLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwUmFuZ2UoYWN0aW9uLCBhY2N1bSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBtaW4oKS5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmQgPSBtYXgoKS5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlS2V5cyhzdGFydCwgYVtpXS5rZXkpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZWNtcCA9IGNvbXBhcmVLZXlzKGVuZCwgYVtpXS5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlY21wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb24oYVtpXSwgYWNjdW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXAoYWN0aW9uLCBhY2N1bSkge1xuICAgICAgICBtYXBSYW5nZShhY3Rpb24sIGFjY3VtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXgoKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0ua2V5ID09IGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1dChrZXksIGRhdGEpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goeyBrZXk6IGtleSwgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgICAgICAgICBhLnNvcnQoY29tcGFyZVByb3BzKTsgLy8gZ28gdG8gaW5zZXJ0aW9uIHNvcnQgaWYgdG9vIHNsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXS5rZXkgPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhLmxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICBhLnNvcnQoY29tcGFyZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIG1hcFJhbmdlOiBtYXBSYW5nZSxcbiAgICAgICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgICAgIGdldDogZ2V0LFxuICAgICAgICBwdXQ6IHB1dCxcbiAgICAgICAgZGlhZzogZGlhZ1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgUmVkQmxhY2tUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJlS2V5cywgYXVnKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZUtleXMgPSBjb21wYXJlS2V5cztcbiAgICAgICAgdGhpcy5hdWcgPSBhdWc7XG4gICAgfVxuICAgIG1ha2VOb2RlKGtleSwgZGF0YSwgY29sb3IsIHNpemUpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB7IGtleToga2V5LCBkYXRhOiBkYXRhLCBjb2xvcjogY29sb3IsIHNpemU6IHNpemUgfTtcbiAgICAgICAgaWYgKHRoaXMuYXVnICYmIHRoaXMuYXVnLmluaXQpIHtcbiAgICAgICAgICAgIHRoaXMuYXVnLmluaXQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlzUmVkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUuY29sb3IgPT0gMCAvKiBSRUQgKi8pO1xuICAgIH1cbiAgICBub2RlU2l6ZShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5zaXplIDogMDtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVNpemUodGhpcy5yb290KTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnJvb3Q7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlR2V0KHRoaXMucm9vdCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlR2V0KG5vZGUsIGtleSkge1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgbGV0IGNtcCA9IHRoaXMuY29tcGFyZUtleXMoa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWlucyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdhdGhlcihrZXksIG1hdGNoZXIpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVHYXRoZXIodGhpcy5yb290LCByZXN1bHRzLCBrZXksIG1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBub2RlR2F0aGVyKG5vZGUsIHJlc3VsdHMsIGtleSwgbWF0Y2hlcikge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIuY29udGludWVTdWJ0cmVlKG5vZGUubGVmdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZUdhdGhlcihub2RlLmxlZnQsIHJlc3VsdHMsIGtleSwgbWF0Y2hlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlci5tYXRjaE5vZGUobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVyLmNvbnRpbnVlU3VidHJlZShub2RlLnJpZ2h0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlR2F0aGVyKG5vZGUucmlnaHQsIHJlc3VsdHMsIGtleSwgbWF0Y2hlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0KGtleSwgZGF0YSwgY29uZmxpY3QpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMubm9kZVB1dCh0aGlzLnJvb3QsIGtleSwgZGF0YSwgY29uZmxpY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5jb2xvciA9IDEgLyogQkxBQ0sgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZVB1dChub2RlLCBrZXksIGRhdGEsIGNvbmZsaWN0KSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZU5vZGUoa2V5LCBkYXRhLCAwIC8qIFJFRCAqLywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY21wID0gdGhpcy5jb21wYXJlS2V5cyhrZXksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gdGhpcy5ub2RlUHV0KG5vZGUubGVmdCwga2V5LCBkYXRhLCBjb25mbGljdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMubm9kZVB1dChub2RlLnJpZ2h0LCBrZXksIGRhdGEsIGNvbmZsaWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb25mbGljdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZCA9IGNvbmZsaWN0KGtleSwgbm9kZS5rZXksIGRhdGEsIG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUua2V5ID0ga2Qua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSBrZC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlZChub2RlLnJpZ2h0KSAmJiAoIXRoaXMuaXNSZWQobm9kZS5sZWZ0KSkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5yb3RhdGVMZWZ0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUubGVmdC5sZWZ0KSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwQ29sb3JzKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5zaXplID0gdGhpcy5ub2RlU2l6ZShub2RlLmxlZnQpICsgdGhpcy5ub2RlU2l6ZShub2RlLnJpZ2h0KSArIDE7XG4gICAgICAgICAgICBpZiAodGhpcy5hdWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlTG9jYWwobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5hdWcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVkKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1Zy51cGRhdGUobm9kZS5sZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVkKG5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWcudXBkYXRlKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdWcudXBkYXRlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU1pbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKCghdGhpcy5pc1JlZCh0aGlzLnJvb3QubGVmdCkpICYmICghdGhpcy5pc1JlZCh0aGlzLnJvb3QucmlnaHQpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5jb2xvciA9IDAgLyogUkVEICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5ub2RlUmVtb3ZlTWluKHRoaXMucm9vdCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmNvbG9yID0gMSAvKiBCTEFDSyAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBlcnJvciBvbiBlbXB0eVxuICAgIH1cbiAgICBub2RlUmVtb3ZlTWluKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubGVmdCkge1xuICAgICAgICAgICAgaWYgKCghdGhpcy5pc1JlZChub2RlLmxlZnQpKSAmJiAoIXRoaXMuaXNSZWQobm9kZS5sZWZ0LmxlZnQpKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm1vdmVSZWRMZWZ0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gdGhpcy5ub2RlUmVtb3ZlTWluKG5vZGUubGVmdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU1heCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBpZiAoKCF0aGlzLmlzUmVkKHRoaXMucm9vdC5sZWZ0KSkgJiYgKCF0aGlzLmlzUmVkKHRoaXMucm9vdC5yaWdodCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmNvbG9yID0gMCAvKiBSRUQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGVSZW1vdmVNYXgodGhpcy5yb290KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QuY29sb3IgPSAxIC8qIEJMQUNLICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGVycm9yIG9uIGVtcHR5XG4gICAgfVxuICAgIG5vZGVSZW1vdmVNYXgobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZChub2RlLmxlZnQpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5yb3RhdGVSaWdodChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdGhpcy5pc1JlZChub2RlLnJpZ2h0KSkgJiYgKCF0aGlzLmlzUmVkKG5vZGUucmlnaHQubGVmdCkpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5tb3ZlUmVkUmlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMubm9kZVJlbW92ZU1heChub2RlLnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZShub2RlKTtcbiAgICB9XG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250YWlucyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghdGhpcy5pc1JlZCh0aGlzLnJvb3QubGVmdCkpICYmICghdGhpcy5pc1JlZCh0aGlzLnJvb3QucmlnaHQpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5jb2xvciA9IDAgLyogUkVEICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5ub2RlUmVtb3ZlKHRoaXMucm9vdCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBlcnJvciBvbiB1bmRlZmluZWQga2V5XG4gICAgfVxuICAgIG5vZGVSZW1vdmUobm9kZSwga2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmVLZXlzKGtleSwgbm9kZS5rZXkpIDwgMCkge1xuICAgICAgICAgICAgaWYgKCghdGhpcy5pc1JlZChub2RlLmxlZnQpKSAmJiAoIXRoaXMuaXNSZWQobm9kZS5sZWZ0LmxlZnQpKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm1vdmVSZWRMZWZ0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gdGhpcy5ub2RlUmVtb3ZlKG5vZGUubGVmdCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVkKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5yb3RhdGVSaWdodChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5jb21wYXJlS2V5cyhrZXksIG5vZGUua2V5KSA9PSAwKSAmJiAoIW5vZGUucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoIXRoaXMuaXNSZWQobm9kZS5yaWdodCkpICYmICghdGhpcy5pc1JlZChub2RlLnJpZ2h0LmxlZnQpKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm1vdmVSZWRSaWdodChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVLZXlzKGtleSwgbm9kZS5rZXkpID09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VidHJlZU1pbiA9IHRoaXMubm9kZU1pbihub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IHN1YnRyZWVNaW4ua2V5O1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHN1YnRyZWVNaW4uZGF0YTtcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5ub2RlUmVtb3ZlTWluKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMubm9kZVJlbW92ZShub2RlLnJpZ2h0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2Uobm9kZSk7XG4gICAgfVxuICAgIGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUhlaWdodCh0aGlzLnJvb3QpO1xuICAgIH1cbiAgICBub2RlSGVpZ2h0KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBNYXRoLm1heCh0aGlzLm5vZGVIZWlnaHQobm9kZS5sZWZ0KSwgdGhpcy5ub2RlSGVpZ2h0KG5vZGUucmlnaHQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbG9vcihrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZUZsb29yKHRoaXMucm9vdCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlRmxvb3Iobm9kZSwga2V5KSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgY21wID0gdGhpcy5jb21wYXJlS2V5cyhrZXksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVGbG9vcihub2RlLmxlZnQsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHRGbG9vciA9IHRoaXMubm9kZUZsb29yKG5vZGUucmlnaHQsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Rmxvb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0Rmxvb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VpbChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZUNlaWwodGhpcy5yb290LCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVDZWlsKG5vZGUsIGtleSkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbGV0IGNtcCA9IHRoaXMuY29tcGFyZUtleXMoa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlQ2VpbChub2RlLnJpZ2h0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnRDZWlsID0gdGhpcy5ub2RlQ2VpbChub2RlLmxlZnQsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDZWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0Q2VpbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVNaW4odGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBlcnJvciBvbiBlbXB0eVxuICAgIH1cbiAgICBub2RlTWluKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1pbihub2RlLmxlZnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1heCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGVycm9yIG9uIGVtcHR5XG4gICAgfVxuICAgIG5vZGVNYXgobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1heChub2RlLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByb3RhdGVSaWdodChub2RlKSB7XG4gICAgICAgIGxldCBsZWZ0Q2hpbGQgPSBub2RlLmxlZnQ7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnRDaGlsZC5yaWdodDtcbiAgICAgICAgbGVmdENoaWxkLnJpZ2h0ID0gbm9kZTtcbiAgICAgICAgbGVmdENoaWxkLmNvbG9yID0gbGVmdENoaWxkLnJpZ2h0LmNvbG9yO1xuICAgICAgICBsZWZ0Q2hpbGQucmlnaHQuY29sb3IgPSAwIC8qIFJFRCAqLztcbiAgICAgICAgbGVmdENoaWxkLnNpemUgPSBub2RlLnNpemU7XG4gICAgICAgIG5vZGUuc2l6ZSA9IHRoaXMubm9kZVNpemUobm9kZS5sZWZ0KSArIHRoaXMubm9kZVNpemUobm9kZS5yaWdodCkgKyAxO1xuICAgICAgICBpZiAodGhpcy5hdWcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTG9jYWwobm9kZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsKGxlZnRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnRDaGlsZDtcbiAgICB9XG4gICAgcm90YXRlTGVmdChub2RlKSB7XG4gICAgICAgIGxldCByaWdodENoaWxkID0gbm9kZS5yaWdodDtcbiAgICAgICAgbm9kZS5yaWdodCA9IHJpZ2h0Q2hpbGQubGVmdDtcbiAgICAgICAgcmlnaHRDaGlsZC5sZWZ0ID0gbm9kZTtcbiAgICAgICAgcmlnaHRDaGlsZC5jb2xvciA9IHJpZ2h0Q2hpbGQubGVmdC5jb2xvcjtcbiAgICAgICAgcmlnaHRDaGlsZC5sZWZ0LmNvbG9yID0gMCAvKiBSRUQgKi87XG4gICAgICAgIHJpZ2h0Q2hpbGQuc2l6ZSA9IG5vZGUuc2l6ZTtcbiAgICAgICAgbm9kZS5zaXplID0gdGhpcy5ub2RlU2l6ZShub2RlLmxlZnQpICsgdGhpcy5ub2RlU2l6ZShub2RlLnJpZ2h0KSArIDE7XG4gICAgICAgIGlmICh0aGlzLmF1Zykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMb2NhbChub2RlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTG9jYWwocmlnaHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJpZ2h0Q2hpbGQ7XG4gICAgfVxuICAgIG9wcG9zaXRlQ29sb3IoYykge1xuICAgICAgICByZXR1cm4gKGMgPT0gMSAvKiBCTEFDSyAqLykgPyAwIC8qIFJFRCAqLyA6IDEgLyogQkxBQ0sgKi87XG4gICAgfVxuICAgIGZsaXBDb2xvcnMobm9kZSkge1xuICAgICAgICBub2RlLmNvbG9yID0gdGhpcy5vcHBvc2l0ZUNvbG9yKG5vZGUuY29sb3IpO1xuICAgICAgICBub2RlLmxlZnQuY29sb3IgPSB0aGlzLm9wcG9zaXRlQ29sb3Iobm9kZS5sZWZ0LmNvbG9yKTtcbiAgICAgICAgbm9kZS5yaWdodC5jb2xvciA9IHRoaXMub3Bwb3NpdGVDb2xvcihub2RlLnJpZ2h0LmNvbG9yKTtcbiAgICB9XG4gICAgbW92ZVJlZExlZnQobm9kZSkge1xuICAgICAgICB0aGlzLmZsaXBDb2xvcnMobm9kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVkKG5vZGUucmlnaHQubGVmdCkpIHtcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMucm90YXRlTGVmdChub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZmxpcENvbG9ycyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbW92ZVJlZFJpZ2h0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5mbGlwQ29sb3JzKG5vZGUpO1xuICAgICAgICBpZiAodGhpcy5pc1JlZChub2RlLmxlZnQubGVmdCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvdGF0ZVJpZ2h0KG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGlwQ29sb3JzKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBiYWxhbmNlKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvdGF0ZUxlZnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiB0aGlzLmlzUmVkKG5vZGUubGVmdC5sZWZ0KSkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMucm90YXRlUmlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWQobm9kZS5sZWZ0KSAmJiAodGhpcy5pc1JlZChub2RlLnJpZ2h0KSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmxpcENvbG9ycyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNpemUgPSB0aGlzLm5vZGVTaXplKG5vZGUubGVmdCkgKyB0aGlzLm5vZGVTaXplKG5vZGUucmlnaHQpICsgMTtcbiAgICAgICAgaWYgKHRoaXMuYXVnKSB7XG4gICAgICAgICAgICB0aGlzLmF1Zy51cGRhdGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG1hcFJhbmdlKGFjdGlvbiwgYWNjdW0sIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwKHRoaXMucm9vdCwgYWN0aW9uLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgbWFwKGFjdGlvbiwgYWNjdW0pIHtcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdG8gYXZvaWQgY29tcGFyaXNvbnNcbiAgICAgICAgdGhpcy5ub2RlTWFwKHRoaXMucm9vdCwgYWN0aW9uLCBhY2N1bSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGxldCBrZXlMaXN0ID0gW107XG4gICAgICAgIGxldCBhY3Rpb25zID0ge1xuICAgICAgICAgICAgc2hvd1N0cnVjdHVyZTogdHJ1ZSxcbiAgICAgICAgICAgIGluZml4OiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGtleUxpc3QucHVzaChub2RlLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsayhhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGtleUxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcHRoLWZpcnN0IHRyYXZlcnNhbCB3aXRoIGN1c3RvbSBhY3Rpb247IGlmIGFjdGlvbiByZXR1cm5zXG4gICAgICogZmFsc2UsIHRyYXZlcnNhbCBpcyBoYWx0ZWQuXG4gICAgICogQHBhcmFtIGFjdGlvbiBhY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBub2RlXG4gICAgICovXG4gICAgd2FsayhhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMubm9kZVdhbGsodGhpcy5yb290LCBhY3Rpb25zKTtcbiAgICB9XG4gICAgbm9kZVdhbGsobm9kZSwgYWN0aW9ucykge1xuICAgICAgICBsZXQgZ28gPSB0cnVlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbnMucHJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMuc2hvd1N0cnVjdHVyZSB8fCAobm9kZS5jb2xvciA9PT0gMSAvKiBCTEFDSyAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ28gPSBhY3Rpb25zLnByZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZ28gPSB0aGlzLm5vZGVXYWxrKG5vZGUubGVmdCwgYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28gJiYgYWN0aW9ucy5pbmZpeCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25zLnNob3dTdHJ1Y3R1cmUgfHwgKG5vZGUuY29sb3IgPT09IDEgLyogQkxBQ0sgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvID0gYWN0aW9ucy5pbmZpeChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28pIHtcbiAgICAgICAgICAgICAgICBnbyA9IHRoaXMubm9kZVdhbGsobm9kZS5yaWdodCwgYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28gJiYgYWN0aW9ucy5wb3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMuc2hvd1N0cnVjdHVyZSB8fCAobm9kZS5jb2xvciA9PT0gMSAvKiBCTEFDSyAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ28gPSBhY3Rpb25zLnBvc3Qobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbztcbiAgICB9XG4gICAgbm9kZU1hcChub2RlLCBhY3Rpb24sIGFjY3VtLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5ub2RlTWluKG5vZGUpLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubm9kZU1heChub2RlKS5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNtcFN0YXJ0ID0gdGhpcy5jb21wYXJlS2V5cyhzdGFydCwgbm9kZS5rZXkpO1xuICAgICAgICBsZXQgY21wRW5kID0gdGhpcy5jb21wYXJlS2V5cyhlbmQsIG5vZGUua2V5KTtcbiAgICAgICAgbGV0IGdvID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNtcFN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgZ28gPSB0aGlzLm5vZGVNYXAobm9kZS5sZWZ0LCBhY3Rpb24sIGFjY3VtLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ28gJiYgKGNtcFN0YXJ0IDw9IDApICYmIChjbXBFbmQgPj0gMCkpIHtcbiAgICAgICAgICAgIC8vIFJFVklFVzogdGVzdCBmb3IgYmxhY2sgbm9kZSBoZXJlXG4gICAgICAgICAgICBnbyA9IGFjdGlvbihub2RlLCBhY2N1bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvICYmIChjbXBFbmQgPiAwKSkge1xuICAgICAgICAgICAgZ28gPSB0aGlzLm5vZGVNYXAobm9kZS5yaWdodCwgYWN0aW9uLCBhY2N1bSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdvO1xuICAgIH1cbiAgICBkaWFnKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgSGVpZ2h0IGlzICR7dGhpcy5oZWlnaHQoKX1gKTtcbiAgICB9XG59XG4vKipcbiAqIFVuaW9uIG9mIHR3byByYW5nZXM7IGFzc3VtZXMgZm9yIGJvdGggcmFuZ2VzIHN0YXJ0IDw9IGVuZC5cbiAqIEBwYXJhbSBhIEEgcmFuZ2VcbiAqIEBwYXJhbSBiIEEgcmFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJSYW5nZVVuaW9uKGEsIGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogTWF0aC5taW4oYS5zdGFydCwgYi5zdGFydCksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoYS5lbmQsIGIuZW5kKVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlclJhbmdlT3ZlcmxhcHMoYSwgYikge1xuICAgIHJldHVybiAoYS5zdGFydCA8IGIuZW5kKSAmJiAoYS5lbmQgPiBiLnN0YXJ0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyUmFuZ2VDb21wYXJlcihhLCBiKSB7XG4gICAgaWYgKGEuc3RhcnQgPT09IGIuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGEuZW5kIC0gYi5lbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGludGVnZXJSYW5nZUNvcHkocikge1xuICAgIHJldHVybiB7IHN0YXJ0OiByLnN0YXJ0LCBlbmQ6IHIuZW5kIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlclJhbmdlVG9TdHJpbmcocmFuZ2UpIHtcbiAgICByZXR1cm4gYFske3JhbmdlLnN0YXJ0fSwke3JhbmdlLmVuZH0pYDtcbn1cbi8vIFRPRE86IGhhbmRsZSBkdXBsaWNhdGUga2V5c1xuZXhwb3J0IGNsYXNzIEludGVnZXJSYW5nZVRyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IG5ldyBSZWRCbGFja1RyZWUoaW50ZWdlclJhbmdlQ29tcGFyZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLmRpYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlKHIpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMucmVtb3ZlKHIpO1xuICAgIH1cbiAgICBwdXQocikge1xuICAgICAgICB0aGlzLnJhbmdlcy5wdXQociwgeyBtaW5tYXg6IGludGVnZXJSYW5nZUNvcHkocikgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlVG9TdHJpbmcodGhpcy5yYW5nZXMucm9vdCk7XG4gICAgfVxuICAgIG5vZGVUb1N0cmluZyhub2RlKSB7XG4gICAgICAgIGxldCBidWYgPSBcIlwiO1xuICAgICAgICBsZXQgaW5kZW50QW10ID0gMDtcbiAgICAgICAgbGV0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICBwcmU6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29sb3IgPT09IDAgLyogUkVEICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZCA9IFwiUiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmICs9IE1lcmdlVHJlZS5pbnRlcm5lZFNwYWNlcyhpbmRlbnRBbXQpO1xuICAgICAgICAgICAgICAgIGJ1ZiArPSBgJHtyZWR9a2V5OiAke2ludGVnZXJSYW5nZVRvU3RyaW5nKG5vZGUua2V5KX0gbWlubWF4OiAke2ludGVnZXJSYW5nZVRvU3RyaW5nKG5vZGUuZGF0YS5taW5tYXgpfVxcbmA7XG4gICAgICAgICAgICAgICAgaW5kZW50QW10ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zdDogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpbmRlbnRBbXQgLT0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93U3RydWN0dXJlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmFuZ2VzLm5vZGVXYWxrKG5vZGUsIGFjdGlvbnMpO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBtYXRjaFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goeyBzdGFydDogcG9zLCBlbmQ6IHBvcyArIDEgfSk7XG4gICAgfVxuICAgIG1hdGNoKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmdhdGhlcihyLCB0aGlzKTtcbiAgICB9XG4gICAgbWF0Y2hOb2RlKG5vZGUsIGtleSkge1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBpbnRlZ2VyUmFuZ2VPdmVybGFwcyhub2RlLmtleSwga2V5KTtcbiAgICB9XG4gICAgY29udGludWVTdWJ0cmVlKG5vZGUsIGtleSkge1xuICAgICAgICBsZXQgY29udCA9IG5vZGUgJiYgaW50ZWdlclJhbmdlT3ZlcmxhcHMobm9kZS5kYXRhLm1pbm1heCwga2V5KTtcbiAgICAgICAgaWYgKHRoaXMuZGlhZyAmJiAoIWNvbnQpKSB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBza2lwcGluZyBzdWJ0cmVlIG9mIHNpemUgJHtub2RlLnNpemV9IGtleSAke2ludGVnZXJSYW5nZVRvU3RyaW5nKGtleSl9YCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5ub2RlVG9TdHJpbmcobm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250O1xuICAgIH1cbiAgICB1cGRhdGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWZ0ICYmIG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YS5taW5tYXggPSBpbnRlZ2VyUmFuZ2VVbmlvbihub2RlLmtleSwgaW50ZWdlclJhbmdlVW5pb24obm9kZS5sZWZ0LmRhdGEubWlubWF4LCBub2RlLnJpZ2h0LmRhdGEubWlubWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLm1pbm1heCA9IGludGVnZXJSYW5nZVVuaW9uKG5vZGUua2V5LCBub2RlLmxlZnQuZGF0YS5taW5tYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5taW5tYXggPSBpbnRlZ2VyUmFuZ2VVbmlvbihub2RlLmtleSwgbm9kZS5yaWdodC5kYXRhLm1pbm1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEubWlubWF4ID0gaW50ZWdlclJhbmdlQ29weShub2RlLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJ2YWxDb21wYXJlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29tcGFyZShiKTtcbn1cbmV4cG9ydCBjbGFzcyBJbnRlcnZhbFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmludGVydmFscyA9IG5ldyBSZWRCbGFja1RyZWUoaW50ZXJ2YWxDb21wYXJlciwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlhZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVQdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5wdXRDb3VudCA9IDA7XG4gICAgfVxuICAgIHByaW50VGltaW5nKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgcHV0IHRvdGFsID0gJHt0aGlzLnB1dFRpbWV9IGF2Zz0keyh0aGlzLnB1dFRpbWUgLyB0aGlzLnB1dENvdW50KS50b0ZpeGVkKDIpfWApO1xuICAgIH1cbiAgICByZW1vdmUoeCkge1xuICAgICAgICB0aGlzLmludGVydmFscy5yZW1vdmUoeCk7XG4gICAgfVxuICAgIHB1dCh4LCBjb25mbGljdCkge1xuICAgICAgICBsZXQgcmJDb25mbGljdDtcbiAgICAgICAgaWYgKGNvbmZsaWN0KSB7XG4gICAgICAgICAgICByYkNvbmZsaWN0ID0gKGtleSwgY3VycmVudEtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl2YWwgPSBjb25mbGljdChrZXksIGN1cnJlbnRLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogaXZhbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lUHV0KSB7XG4gICAgICAgICAgICBsZXQgY2xvY2tTdGFydCA9IE1lcmdlVHJlZS5jbG9jaygpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMucHV0KHgsIHsgbWlubWF4OiB4LmNsb25lKCkgfSwgcmJDb25mbGljdCk7XG4gICAgICAgICAgICB0aGlzLnB1dFRpbWUgKz0gTWVyZ2VUcmVlLmVsYXBzZWRNaWNyb3NlY29uZHMoY2xvY2tTdGFydCk7XG4gICAgICAgICAgICB0aGlzLnB1dENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludGVydmFscy5wdXQoeCwgeyBtaW5tYXg6IHguY2xvbmUoKSB9LCByYkNvbmZsaWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXAoZm4pIHtcbiAgICAgICAgbGV0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICBpbmZpeDogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBmbihub2RlLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1N0cnVjdHVyZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbHMud2FsayhhY3Rpb25zKTtcbiAgICB9XG4gICAgLy8gVE9ETzogdG9TdHJpbmcoKVxuICAgIG1hdGNoKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWxzLmdhdGhlcih4LCB0aGlzKTtcbiAgICB9XG4gICAgbWF0Y2hOb2RlKG5vZGUsIGtleSkge1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmtleS5vdmVybGFwcyhrZXkpO1xuICAgIH1cbiAgICBjb250aW51ZVN1YnRyZWUobm9kZSwga2V5KSB7XG4gICAgICAgIGxldCBjb250ID0gbm9kZSAmJiBub2RlLmRhdGEubWlubWF4Lm92ZXJsYXBzKGtleSk7XG4gICAgICAgIGlmICh0aGlzLmRpYWcgJiYgKCFjb250KSkge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgc2tpcHBpbmcgc3VidHJlZSBvZiBzaXplICR7bm9kZS5zaXplfSBrZXkgJHtrZXkudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5vZGVUb1N0cmluZyhub2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmxlZnQgJiYgbm9kZS5yaWdodCkge1xuICAgICAgICAgICAgbm9kZS5kYXRhLm1pbm1heCA9IG5vZGUua2V5LnVuaW9uKG5vZGUubGVmdC5kYXRhLm1pbm1heC51bmlvbihub2RlLnJpZ2h0LmRhdGEubWlubWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLm1pbm1heCA9IG5vZGUua2V5LnVuaW9uKG5vZGUubGVmdC5kYXRhLm1pbm1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLm1pbm1heCA9IG5vZGUua2V5LnVuaW9uKG5vZGUucmlnaHQuZGF0YS5taW5tYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLm1pbm1heCA9IG5vZGUua2V5LmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVFNUIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uID0gMDtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubjtcbiAgICB9XG4gICAgY29udGFpbnMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCB4ID0gdGhpcy5ub2RlR2V0KHRoaXMucm9vdCwga2V5LCAwKTtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geC52YWw7XG4gICAgfVxuICAgIG5vZGVHZXQoeCwga2V5LCBkKSB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGMgPSBrZXkuY2hhckF0KGQpO1xuICAgICAgICBpZiAoYyA8IHguYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZUdldCh4LmxlZnQsIGtleSwgZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+IHguYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZUdldCh4LnJpZ2h0LCBrZXksIGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQgPCAoa2V5Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlR2V0KHgubWlkLCBrZXksIGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcHV0KGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWlucyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm4rKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGVQdXQodGhpcy5yb290LCBrZXksIHZhbCwgMCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBwdXQgJHtrZXl9YCk7XG4gICAgfVxuICAgIG5vZGVQdXQoeCwga2V5LCB2YWwsIGQpIHtcbiAgICAgICAgbGV0IGMgPSBrZXkuY2hhckF0KGQpO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB4ID0geyBjIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCB4LmMpIHtcbiAgICAgICAgICAgIHgubGVmdCA9IHRoaXMubm9kZVB1dCh4LmxlZnQsIGtleSwgdmFsLCBkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID4geC5jKSB7XG4gICAgICAgICAgICB4LnJpZ2h0ID0gdGhpcy5ub2RlUHV0KHgucmlnaHQsIGtleSwgdmFsLCBkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkIDwgKGtleS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgeC5taWQgPSB0aGlzLm5vZGVQdXQoeC5taWQsIGtleSwgdmFsLCBkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4LnZhbCA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgbmVpZ2hib3JzKHRleHQsIGRpc3RhbmNlID0gMikge1xuICAgICAgICBsZXQgcSA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVQcm94aW1pdHkodGhpcy5yb290LCB7IHRleHQ6IFwiXCIgfSwgMCwgdGV4dCwgZGlzdGFuY2UsIHEpO1xuICAgICAgICBxID0gcS5maWx0ZXIodmFsdWUgPT4gKHZhbHVlLnRleHQubGVuZ3RoID4gMCkpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAga2V5c1dpdGhQcmVmaXgodGV4dCkge1xuICAgICAgICBsZXQgcSA9IFtdO1xuICAgICAgICBsZXQgeCA9IHRoaXMubm9kZUdldCh0aGlzLnJvb3QsIHRleHQsIDApO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC52YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcS5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdCh4Lm1pZCwgeyB0ZXh0IH0sIHEpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgY29sbGVjdCh4LCBwcmVmaXgsIHEpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdCh4LmxlZnQsIHByZWZpeCwgcSk7XG4gICAgICAgIGlmICh4LnZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxLnB1c2gocHJlZml4LnRleHQgKyB4LmMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdCh4Lm1pZCwgeyB0ZXh0OiBwcmVmaXgudGV4dCArIHguYyB9LCBxKTtcbiAgICAgICAgdGhpcy5jb2xsZWN0KHgucmlnaHQsIHByZWZpeCwgcSk7XG4gICAgfVxuICAgIHBhaXJzV2l0aFByZWZpeCh0ZXh0KSB7XG4gICAgICAgIGxldCBxID0gW107XG4gICAgICAgIGxldCB4ID0gdGhpcy5ub2RlR2V0KHRoaXMucm9vdCwgdGV4dCwgMCk7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4LnZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxLnB1c2goeyBrZXk6IHRleHQsIHZhbDogeC52YWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsZWN0UGFpcnMoeC5taWQsIHsgdGV4dCB9LCBxKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGNvbGxlY3RQYWlycyh4LCBwcmVmaXgsIHEpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdFBhaXJzKHgubGVmdCwgcHJlZml4LCBxKTtcbiAgICAgICAgaWYgKHgudmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHEucHVzaCh7IGtleTogcHJlZml4LnRleHQgKyB4LmMsIHZhbDogeC52YWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsZWN0UGFpcnMoeC5taWQsIHsgdGV4dDogcHJlZml4LnRleHQgKyB4LmMgfSwgcSk7XG4gICAgICAgIHRoaXMuY29sbGVjdFBhaXJzKHgucmlnaHQsIHByZWZpeCwgcSk7XG4gICAgfVxuICAgIHBhdHRlcm5Db2xsZWN0KHgsIHByZWZpeCwgZCwgcGF0dGVybiwgcSkge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGMgPSBwYXR0ZXJuLmNoYXJBdChkKTtcbiAgICAgICAgaWYgKChjID09PSAnLicpIHx8IChjIDwgeC5jKSkge1xuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuQ29sbGVjdCh4LmxlZnQsIHByZWZpeCwgZCwgcGF0dGVybiwgcSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPT09ICcuJykgfHwgKGMgPT09IHguYykpIHtcbiAgICAgICAgICAgIGlmICgoZCA9PT0gKHBhdHRlcm4ubGVuZ3RoIC0gMSkpICYmICh4LnZhbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHEucHVzaChwcmVmaXgudGV4dCArIHguYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkIDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdHRlcm5Db2xsZWN0KHgubWlkLCB7IHRleHQ6IHByZWZpeC50ZXh0ICsgeC5jIH0sIGQgKyAxLCBwYXR0ZXJuLCBxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGMgPT09ICcuJykgfHwgKGMgPiB4LmMpKSB7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm5Db2xsZWN0KHgucmlnaHQsIHByZWZpeCwgZCwgcGF0dGVybiwgcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZVByb3hpbWl0eSh4LCBwcmVmaXgsIGQsIHBhdHRlcm4sIGRpc3RhbmNlLCBxKSB7XG4gICAgICAgIGlmICgoeCA9PT0gdW5kZWZpbmVkKSB8fCAoZGlzdGFuY2UgPCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjID0gcGF0dGVybi5jaGFyQXQoZCk7XG4gICAgICAgIGlmICgoZGlzdGFuY2UgPiAwKSB8fCAoYyA8IHguYykpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVByb3hpbWl0eSh4LmxlZnQsIHByZWZpeCwgZCwgcGF0dGVybiwgZGlzdGFuY2UsIHEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4LnZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgcmVtRCA9IGRpc3RhbmNlIC0gKHBhdHRlcm4ubGVuZ3RoIC0gZCk7XG4gICAgICAgICAgICBpZiAocmVtRCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGludkQgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPT0geC5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGludkQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcS5wdXNoKHsgdGV4dDogcHJlZml4LnRleHQgKyB4LmMsIHZhbDogeC52YWwsIGludkRpc3RhbmNlOiBpbnZEIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWN1ckQgPSAoZCA8IChwYXR0ZXJuLmxlbmd0aCAtIDEpKSA/IGQgKyAxIDogZDtcbiAgICAgICAgaWYgKGMgPT09IHguYykge1xuICAgICAgICAgICAgdGhpcy5ub2RlUHJveGltaXR5KHgubWlkLCB7IHRleHQ6IHByZWZpeC50ZXh0ICsgeC5jIH0sIHJlY3VyRCwgcGF0dGVybiwgZGlzdGFuY2UsIHEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub2RlUHJveGltaXR5KHgubWlkLCB7IHRleHQ6IHByZWZpeC50ZXh0ICsgeC5jIH0sIHJlY3VyRCwgcGF0dGVybiwgZGlzdGFuY2UgLSAxLCBxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGRpc3RhbmNlID4gMCkgfHwgKGMgPiB4LmMpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVQcm94aW1pdHkoeC5yaWdodCwgcHJlZml4LCBkLCBwYXR0ZXJuLCBkaXN0YW5jZSwgcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2gocGF0dGVybikge1xuICAgICAgICBsZXQgcSA9IFtdO1xuICAgICAgICB0aGlzLnBhdHRlcm5Db2xsZWN0KHRoaXMucm9vdCwgeyB0ZXh0OiBcIlwiIH0sIDAsIHBhdHRlcm4sIHEpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9tZXJnZVRyZWVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL29wc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvcGVydGllc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc25hcHNob3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbGxlY3Rpb25zXCI7XG5leHBvcnQgeyBsb2FkU2VnbWVudHMgfSBmcm9tIFwiLi90ZXh0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jbGllbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NlZ21lbnRHcm91cENvbGxlY3Rpb25cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCAqIGFzIENvbGxlY3Rpb25zIGZyb20gXCIuL2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBvcHMgZnJvbSBcIi4vb3BzXCI7XG5pbXBvcnQgKiBhcyBQcm9wZXJ0aWVzIGZyb20gXCIuL3Byb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XG5pbXBvcnQgeyBTZWdtZW50R3JvdXBDb2xsZWN0aW9uIH0gZnJvbSBcIi4vc2VnbWVudEdyb3VwQ29sbGVjdGlvblwiO1xuZXhwb3J0IGNsYXNzIExvY2FsUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZWdtZW50LCBvZmZzZXQgPSAwLCByZWZUeXBlID0gb3BzLlJlZmVyZW5jZVR5cGUuU2ltcGxlKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnJlZlR5cGUgPSByZWZUeXBlO1xuICAgIH1cbiAgICBtaW4oYikge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlKGIpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXgoYikge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlKGIpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wYXJlKGIpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VnbWVudCA9PT0gYi5zZWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlZ21lbnQub3JkaW5hbCA8IGIuc2VnbWVudC5vcmRpbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9Qb3NpdGlvbihtZXJnZVRyZWUsIHJlZlNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgbWVyZ2VUcmVlLmdldE9mZnNldCh0aGlzLnNlZ21lbnQsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc1RpbGVMYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiByZWZIYXNUaWxlTGFiZWxzKHRoaXMpO1xuICAgIH1cbiAgICBoYXNSYW5nZUxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHJlZkhhc1JhbmdlTGFiZWxzKHRoaXMpO1xuICAgIH1cbiAgICBoYXNUaWxlTGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHJlZkhhc1RpbGVMYWJlbCh0aGlzLCBsYWJlbCk7XG4gICAgfVxuICAgIGhhc1JhbmdlTGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHJlZkhhc1JhbmdlTGFiZWwodGhpcywgbGFiZWwpO1xuICAgIH1cbiAgICBnZXRUaWxlTGFiZWxzKCkge1xuICAgICAgICByZXR1cm4gcmVmR2V0VGlsZUxhYmVscyh0aGlzKTtcbiAgICB9XG4gICAgZ2V0UmFuZ2VMYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiByZWZHZXRSYW5nZUxhYmVscyh0aGlzKTtcbiAgICB9XG4gICAgaXNMZWFmKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkZFByb3BlcnRpZXMobmV3UHJvcHMsIG9wKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFByb3BlcnRpZXMuYWRkUHJvcGVydGllcyh0aGlzLnByb3BlcnRpZXMsIG5ld1Byb3BzLCBvcCk7XG4gICAgfVxuICAgIGdldFNlZ21lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnQ7XG4gICAgfVxuICAgIGdldE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICBnZXRQcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgU2VnbWVudFR5cGU7XG4oZnVuY3Rpb24gKFNlZ21lbnRUeXBlKSB7XG4gICAgU2VnbWVudFR5cGVbU2VnbWVudFR5cGVbXCJCYXNlXCJdID0gMF0gPSBcIkJhc2VcIjtcbiAgICBTZWdtZW50VHlwZVtTZWdtZW50VHlwZVtcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICAgIFNlZ21lbnRUeXBlW1NlZ21lbnRUeXBlW1wiTWFya2VyXCJdID0gMl0gPSBcIk1hcmtlclwiO1xuICAgIFNlZ21lbnRUeXBlW1NlZ21lbnRUeXBlW1wiRXh0ZXJuYWxcIl0gPSAzXSA9IFwiRXh0ZXJuYWxcIjtcbiAgICBTZWdtZW50VHlwZVtTZWdtZW50VHlwZVtcIkN1c3RvbVwiXSA9IDRdID0gXCJDdXN0b21cIjtcbiAgICBTZWdtZW50VHlwZVtTZWdtZW50VHlwZVtcIlJ1blwiXSA9IDVdID0gXCJSdW5cIjtcbn0pKFNlZ21lbnRUeXBlIHx8IChTZWdtZW50VHlwZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgTWVyZ2VOb2RlIHtcbiAgICBpc0xlYWYoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRUaWxlKHRpbGUsIHRpbGVzKSB7XG4gICAgZm9yIChsZXQgdGlsZUxhYmVsIG9mIHRpbGUuZ2V0VGlsZUxhYmVscygpKSB7XG4gICAgICAgIHRpbGVzW3RpbGVMYWJlbF0gPSB0aWxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFRpbGVJZk5vdFByZXNlbnQodGlsZSwgdGlsZXMpIHtcbiAgICBmb3IgKGxldCB0aWxlTGFiZWwgb2YgdGlsZS5nZXRUaWxlTGFiZWxzKCkpIHtcbiAgICAgICAgaWYgKHRpbGVzW3RpbGVMYWJlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGlsZXNbdGlsZUxhYmVsXSA9IHRpbGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrRGVsdGEoY3VycmVudFN0YWNrTWFwLCBkZWx0YVN0YWNrTWFwKSB7XG4gICAgZm9yIChsZXQgbGFiZWwgaW4gZGVsdGFTdGFja01hcCkge1xuICAgICAgICBsZXQgZGVsdGFTdGFjayA9IGRlbHRhU3RhY2tNYXBbbGFiZWxdO1xuICAgICAgICBpZiAoIWRlbHRhU3RhY2suZW1wdHkoKSkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGFjayA9IGN1cnJlbnRTdGFja01hcFtsYWJlbF07XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhY2sgPSBuZXcgQ29sbGVjdGlvbnMuU3RhY2soKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhY2tNYXBbbGFiZWxdID0gY3VycmVudFN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZGVsdGEgb2YgZGVsdGFTdGFjay5pdGVtcykge1xuICAgICAgICAgICAgICAgIGFwcGx5UmFuZ2VSZWZlcmVuY2UoY3VycmVudFN0YWNrLCBkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVJhbmdlUmVmZXJlbmNlKHN0YWNrLCBkZWx0YSkge1xuICAgIGlmIChkZWx0YS5yZWZUeXBlICYgb3BzLlJlZmVyZW5jZVR5cGUuTmVzdEJlZ2luKSB7XG4gICAgICAgIHN0YWNrLnB1c2goZGVsdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGFzc3VtZSBkZWx0YSBpcyBlbmQgcmVmZXJlbmNlXG4gICAgICAgIGxldCB0b3AgPSBzdGFjay50b3AoKTtcbiAgICAgICAgLy8gVE9ETzogbWF0Y2ggZW5kIHdpdGggYmVnaW5cbiAgICAgICAgaWYgKHRvcCAmJiAodG9wLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5OZXN0QmVnaW4pKSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGROb2RlUmVmZXJlbmNlcyhtZXJnZVRyZWUsIG5vZGUsIHJpZ2h0bW9zdFRpbGVzLCBsZWZ0bW9zdFRpbGVzLCByYW5nZVN0YWNrcykge1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlSW5mbyhsYWJlbCwgcmVmUG9zKSB7XG4gICAgICAgIGxldCBzdGFjayA9IHJhbmdlU3RhY2tzW2xhYmVsXTtcbiAgICAgICAgaWYgKHN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrID0gbmV3IENvbGxlY3Rpb25zLlN0YWNrKCk7XG4gICAgICAgICAgICByYW5nZVN0YWNrc1tsYWJlbF0gPSBzdGFjaztcbiAgICAgICAgfVxuICAgICAgICBhcHBseVJhbmdlUmVmZXJlbmNlKHN0YWNrLCByZWZQb3MpO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc0xlYWYoKSkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IG5vZGU7XG4gICAgICAgIGlmIChtZXJnZVRyZWUubG9jYWxOZXRMZW5ndGgoc2VnbWVudCkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5nZXRUeXBlKCkgPT0gU2VnbWVudFR5cGUuTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtlciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtlcklkID0gbWFya2VyLmdldElkKCk7XG4gICAgICAgICAgICAgICAgLy8gYWxzbyBpbiBpbnNlcnRNYXJrZXIgYnV0IG5lZWQgZm9yIHJlbG9hZCBzZWdzIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBjYW4gYWRkIG9wdGlvbiBmb3IgdGhpcyBvbmx5IGZyb20gcmVsb2FkIHNlZ3NcbiAgICAgICAgICAgICAgICBpZiAobWFya2VySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUcmVlLm1hcElkVG9TZWdtZW50KG1hcmtlcklkLCBtYXJrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5UaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRpbGUobWFya2VyLCByaWdodG1vc3RUaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRpbGVJZk5vdFByZXNlbnQobWFya2VyLCBsZWZ0bW9zdFRpbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5yZWZUeXBlICYgKG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RCZWdpbiB8IG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGxhYmVsIG9mIG1hcmtlci5nZXRSYW5nZUxhYmVscygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZUluZm8obGFiZWwsIG1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBnZW5lcmFsaXplIHRvIG90aGVyIHNlZ21lbnQgdHlwZXNcbiAgICAgICAgICAgICAgICBsZXQgdGV4dFNlZ21lbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0U2VnbWVudC5sb2NhbFJlZnMgJiYgKHRleHRTZWdtZW50LmhpZXJSZWZDb3VudCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAodGV4dFNlZ21lbnQuaGllclJlZkNvdW50ID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbHJlZiBvZiB0ZXh0U2VnbWVudC5sb2NhbFJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChscmVmLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5UaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVGlsZShscmVmLCByaWdodG1vc3RUaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVGlsZUlmTm90UHJlc2VudChscmVmLCBsZWZ0bW9zdFRpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChscmVmLnJlZlR5cGUgJiAob3BzLlJlZmVyZW5jZVR5cGUuTmVzdEJlZ2luIHwgb3BzLlJlZmVyZW5jZVR5cGUuTmVzdEVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBsYWJlbCBvZiBscmVmLmdldFJhbmdlTGFiZWxzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VJbmZvKGxhYmVsLCBscmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBibG9jayA9IG5vZGU7XG4gICAgICAgIGFwcGx5U3RhY2tEZWx0YShyYW5nZVN0YWNrcywgYmxvY2sucmFuZ2VTdGFja3MpO1xuICAgICAgICBQcm9wZXJ0aWVzLmV4dGVuZChyaWdodG1vc3RUaWxlcywgYmxvY2sucmlnaHRtb3N0VGlsZXMpO1xuICAgICAgICBQcm9wZXJ0aWVzLmV4dGVuZElmVW5kZWZpbmVkKGxlZnRtb3N0VGlsZXMsIGJsb2NrLmxlZnRtb3N0VGlsZXMpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsVG9BcnJheShvcmQpIHtcbiAgICBsZXQgYSA9IFtdO1xuICAgIGlmIChvcmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYS5wdXNoKG9yZC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydCBjb25zdCBNYXhOb2Rlc0luQmxvY2sgPSA4O1xuZXhwb3J0IGNsYXNzIE1lcmdlQmxvY2sgZXh0ZW5kcyBNZXJnZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkQ291bnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZENvdW50ID0gY2hpbGRDb3VudDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBBcnJheShNYXhOb2Rlc0luQmxvY2spO1xuICAgIH1cbiAgICBoaWVyQmxvY2soKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldE9yZGluYWwoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGxldCBjaGlsZENvdW50ID0gdGhpcy5jaGlsZENvdW50O1xuICAgICAgICBpZiAoY2hpbGRDb3VudCA9PT0gOCkge1xuICAgICAgICAgICAgY2hpbGRDb3VudCA9IDc7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KChjaGlsZENvdW50ID49IDEpICYmIChjaGlsZENvdW50IDw9IDcpKTtcbiAgICAgICAgbGV0IGxvY2FsT3JkaW5hbDtcbiAgICAgICAgbGV0IG9yZGluYWxXaWR0aCA9IDEgPDwgKE1heE5vZGVzSW5CbG9jayAtIChjaGlsZENvdW50ICsgMSkpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGxvY2FsT3JkaW5hbCA9IG9yZGluYWxXaWR0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJldk9yZCA9IHRoaXMuY2hpbGRyZW5baW5kZXggLSAxXS5vcmRpbmFsO1xuICAgICAgICAgICAgbGV0IHByZXZPcmRDb2RlID0gcHJldk9yZC5jaGFyQ29kZUF0KHByZXZPcmQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsb2NhbE9yZGluYWwgPSBwcmV2T3JkQ29kZSArIG9yZGluYWxXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5vcmRpbmFsID0gdGhpcy5vcmRpbmFsICsgU3RyaW5nLmZyb21DaGFyQ29kZShsb2NhbE9yZGluYWwpO1xuICAgICAgICBpZiAoTWVyZ2VCbG9jay50cmFjZU9yZGluYWxzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgc286IHBybnQgY2hsZCBwcmV2ICR7b3JkaW5hbFRvQXJyYXkodGhpcy5vcmRpbmFsKX0gJHtvcmRpbmFsVG9BcnJheShjaGlsZC5vcmRpbmFsKX0gJHsoaW5kZXggPiAwKSA/IG9yZGluYWxUb0FycmF5KHRoaXMuY2hpbGRyZW5baW5kZXggLSAxXS5vcmRpbmFsKSA6IFwiTkFcIn1gKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoY2hpbGQub3JkaW5hbC5sZW5ndGggPT09ICh0aGlzLm9yZGluYWwubGVuZ3RoICsgMSkpO1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBhc3NlcnQoY2hpbGQub3JkaW5hbCA+IHRoaXMuY2hpbGRyZW5baW5kZXggLSAxXS5vcmRpbmFsKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYCR7b3JkaW5hbFRvQXJyYXkodGhpcy5vcmRpbmFsKX0gJHtvcmRpbmFsVG9BcnJheShjaGlsZC5vcmRpbmFsKX0gJHtvcmRpbmFsVG9BcnJheSh0aGlzLmNoaWxkcmVuW2luZGV4IC0gMV0ub3JkaW5hbCl9YCk7XG4gICAgICAgICAgICAvLyAgICBjb25zb2xlLmxvZyhgb3JkIHdpZHRoICR7b3JkaW5hbFdpZHRofWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2lnbkNoaWxkKGNoaWxkLCBpbmRleCwgdXBkYXRlT3JkaW5hbCA9IHRydWUpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKHVwZGF0ZU9yZGluYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3JkaW5hbChjaGlsZCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baW5kZXhdID0gY2hpbGQ7XG4gICAgfVxufVxuTWVyZ2VCbG9jay50cmFjZU9yZGluYWxzID0gZmFsc2U7XG5jbGFzcyBIaWVyTWVyZ2VCbG9jayBleHRlbmRzIE1lcmdlQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkQ291bnQpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRDb3VudCk7XG4gICAgICAgIHRoaXMucmlnaHRtb3N0VGlsZXMgPSBQcm9wZXJ0aWVzLmNyZWF0ZU1hcCgpO1xuICAgICAgICB0aGlzLmxlZnRtb3N0VGlsZXMgPSBQcm9wZXJ0aWVzLmNyZWF0ZU1hcCgpO1xuICAgICAgICB0aGlzLnJhbmdlU3RhY2tzID0gUHJvcGVydGllcy5jcmVhdGVNYXAoKTtcbiAgICB9XG4gICAgYWRkTm9kZVJlZmVyZW5jZXMobWVyZ2VUcmVlLCBub2RlKSB7XG4gICAgICAgIGFkZE5vZGVSZWZlcmVuY2VzKG1lcmdlVHJlZSwgbm9kZSwgdGhpcy5yaWdodG1vc3RUaWxlcywgdGhpcy5sZWZ0bW9zdFRpbGVzLCB0aGlzLnJhbmdlU3RhY2tzKTtcbiAgICB9XG4gICAgaGllckJsb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaGllclRvU3RyaW5nKGluZGVudENvdW50KSB7XG4gICAgICAgIGxldCBzdHJidWYgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5yYW5nZVN0YWNrcykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5yYW5nZVN0YWNrc1trZXldO1xuICAgICAgICAgICAgc3RyYnVmICs9IGludGVybmVkU3BhY2VzKGluZGVudENvdW50KTtcbiAgICAgICAgICAgIHN0cmJ1ZiArPSBgJHtrZXl9OiBgO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBzdGFjay5pdGVtcykge1xuICAgICAgICAgICAgICAgIHN0cmJ1ZiArPSBgJHtpdGVtLnRvU3RyaW5nKCl9IGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJidWYgKz0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyYnVmO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVUb3RhbExlbmd0aChtZXJnZVRyZWUsIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2FjaGVkTGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlVHJlZS5sb2NhbE5ldExlbmd0aChub2RlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFzZVNlZ21lbnQgZXh0ZW5kcyBNZXJnZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXEgPSBzZXE7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5zZWdtZW50R3JvdXBzID0gbmV3IFNlZ21lbnRHcm91cENvbGxlY3Rpb24odGhpcyk7XG4gICAgfVxuICAgIGFkZExvY2FsUmVmKGxyZWYpIHtcbiAgICAgICAgaWYgKCh0aGlzLmhpZXJSZWZDb3VudCA9PT0gdW5kZWZpbmVkKSB8fCAodGhpcy5oaWVyUmVmQ291bnQgPT09IDApKSB7XG4gICAgICAgICAgICBpZiAobHJlZi5oYXNSYW5nZUxhYmVscygpIHx8IGxyZWYuaGFzVGlsZUxhYmVscygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWVyUmVmQ291bnQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5sb2NhbFJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxSZWZzID0gW2xyZWZdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxvY2FsUmVmcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxSZWZzW2ldLm9mZnNldCA+IGxyZWYub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IGxlbjsgayA+IGk7IGstLSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsUmVmc1trXSA9IHRoaXMubG9jYWxSZWZzW2sgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbFJlZnNbaV0gPSBscmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbFJlZnMucHVzaChscmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVMb2NhbFJlZihscmVmKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsUmVmcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubG9jYWxSZWZzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxyZWYgPT09IHRoaXMubG9jYWxSZWZzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgKGxlbiAtIDEpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxSZWZzW2pdID0gdGhpcy5sb2NhbFJlZnNbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxSZWZzLmxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAobHJlZi5oYXNSYW5nZUxhYmVscygpIHx8IGxyZWYuaGFzVGlsZUxhYmVscygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZXJSZWZDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBscmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGxpdExvY2FsUmVmcyhwb3MsIGxlYWZTZWdtZW50KSB7XG4gICAgICAgIGxldCBhUmVmcyA9IFtdO1xuICAgICAgICBsZXQgYlJlZnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbG9jYWxSZWYgb2YgdGhpcy5sb2NhbFJlZnMpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlZi5vZmZzZXQgPCBwb3MpIHtcbiAgICAgICAgICAgICAgICBhUmVmcy5wdXNoKGxvY2FsUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsUmVmLnNlZ21lbnQgPSBsZWFmU2VnbWVudDtcbiAgICAgICAgICAgICAgICBsb2NhbFJlZi5vZmZzZXQgLT0gcG9zO1xuICAgICAgICAgICAgICAgIGJSZWZzLnB1c2gobG9jYWxSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gYVJlZnM7XG4gICAgICAgIGxlYWZTZWdtZW50LmxvY2FsUmVmcyA9IGJSZWZzO1xuICAgIH1cbiAgICBhZGRQcm9wZXJ0aWVzKG5ld1Byb3BzLCBvcCwgc2VxKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFByb3BlcnRpZXMuYWRkUHJvcGVydGllcyh0aGlzLnByb3BlcnRpZXMsIG5ld1Byb3BzLCBvcCwgc2VxKTtcbiAgICB9XG4gICAgaGFzUHJvcGVydHkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMgJiYgKHRoaXMucHJvcGVydGllc1trZXldICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpc0xlYWYoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbG9uZUludG8oYikge1xuICAgICAgICBiLmNsaWVudElkID0gdGhpcy5jbGllbnRJZDtcbiAgICAgICAgLy8gVE9ETzogZGVlcCBjbG9uZSBwcm9wZXJ0aWVzXG4gICAgICAgIGIucHJvcGVydGllcyA9IFByb3BlcnRpZXMuZXh0ZW5kKFByb3BlcnRpZXMuY3JlYXRlTWFwKCksIHRoaXMucHJvcGVydGllcyk7XG4gICAgICAgIGIucmVtb3ZlZENsaWVudElkID0gdGhpcy5yZW1vdmVkQ2xpZW50SWQ7XG4gICAgICAgIC8vIFRPRE86IGNvcHkgcmVtb3ZlZCBjbGllbnQgb3ZlcmxhcCBhbmQgYnJhbmNoIHJlbW92YWwgaW5mb1xuICAgICAgICBiLnJlbW92ZWRTZXEgPSB0aGlzLnJlbW92ZWRTZXE7XG4gICAgICAgIGIuc2VxID0gdGhpcy5zZXE7XG4gICAgfVxuICAgIGNhbkFwcGVuZChzZWdtZW50LCBtZXJnZVRyZWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGRTZXJpYWxpemVkUHJvcHMoanNlZykge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBqc2VnLnByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTk9iamVjdCgpIHtcbiAgICAgICAgbGV0IG9iaiA9IFByb3BlcnRpZXMuY3JlYXRlTWFwKCk7XG4gICAgICAgIHRoaXMuYWRkU2VyaWFsaXplZFByb3BzKG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8vIFRPRE86IHVzZSBmdW5jdGlvbiBpbiBwcm9wZXJ0aWVzLnRzXG4gICAgbWF0Y2hQcm9wZXJ0aWVzKGIpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKCFiLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYlByb3BzID0gYi5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIC8vIGZvciBub3csIHN0cmFpZ2h0Zm9yd2FyZDsgbGF0ZXIgdXNlIGhhc2hpbmdcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiUHJvcHNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYlByb3BzW2tleV0gIT09IHRoaXMucHJvcGVydGllc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGJQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGIucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5jb25zdCBNYXhSdW4gPSAxMjg7XG5leHBvcnQgY2xhc3MgU3ViU2VxdWVuY2UgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIHNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgc3VwZXIoc2VxLCBjbGllbnRJZCk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5jYWNoZWRMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgfVxuICAgIHRvSlNPTk9iamVjdCgpIHtcbiAgICAgICAgY29uc3Qgb2JqID0geyBpdGVtczogdGhpcy5pdGVtcyB9O1xuICAgICAgICBzdXBlci5hZGRTZXJpYWxpemVkUHJvcHMob2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgc3BsaXRBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0l0ZW1zID0gdGhpcy5pdGVtcy5zbGljZShwb3MpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkTGVuZ3RoID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBsZWFmU2VnbWVudCA9IG5ldyBTdWJTZXF1ZW5jZShyZW1haW5pbmdJdGVtcywgdGhpcy5zZXEsIHRoaXMuY2xpZW50SWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGxlYWZTZWdtZW50LmFkZFByb3BlcnRpZXMoUHJvcGVydGllcy5leHRlbmQoUHJvcGVydGllcy5jcmVhdGVNYXAoKSwgdGhpcy5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50Q29weSh0aGlzLCBsZWFmU2VnbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbFJlZnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0TG9jYWxSZWZzKHBvcywgbGVhZlNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlYWZTZWdtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb25lKHN0YXJ0ID0gMCwgZW5kKSB7XG4gICAgICAgIGxldCBjbG9uZWRJdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvbmVkSXRlbXMgPSBjbG9uZWRJdGVtcy5zbGljZShzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9uZWRJdGVtcyA9IGNsb25lZEl0ZW1zLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGIgPSBuZXcgU3ViU2VxdWVuY2UoY2xvbmVkSXRlbXMsIHRoaXMuc2VxLCB0aGlzLmNsaWVudElkKTtcbiAgICAgICAgdGhpcy5jbG9uZUludG8oYik7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gU2VnbWVudFR5cGUuUnVuO1xuICAgIH1cbiAgICBjYW5BcHBlbmQoc2VnbWVudCwgbWVyZ2VUcmVlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZW1vdmVkU2VxKSB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5nZXRUeXBlKCkgPT09IFNlZ21lbnRUeXBlLlJ1bikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoUHJvcGVydGllcyhzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hJZCA9IG1lcmdlVHJlZS5nZXRCcmFuY2hJZCh0aGlzLmNsaWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnQnJhbmNoSWQgPSBtZXJnZVRyZWUuZ2V0QnJhbmNoSWQoc2VnbWVudC5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2VnQnJhbmNoSWQgPT09IGJyYW5jaElkKSAmJiAobWVyZ2VUcmVlLmxvY2FsTmV0TGVuZ3RoKHNlZ21lbnQpID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMuY2FjaGVkTGVuZ3RoIDw9IE1heFJ1bikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VnbWVudC5jYWNoZWRMZW5ndGggPD0gTWF4UnVuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgYXBwZW5kKHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2V0VHlwZSgpID09PSBTZWdtZW50VHlwZS5SdW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJzZWcgPSBzZWdtZW50O1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQubG9jYWxSZWZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqID0gdGhpcy5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbFJlZiBvZiBzZWdtZW50LmxvY2FsUmVmcykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZi5vZmZzZXQgKz0gYWRqO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZi5zZWdtZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5jb25jYXQocnNlZy5pdGVtcyk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZExlbmd0aCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gb25seSBhcHBlbmQgYW5vdGhlciBydW4gc2VnbWVudFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiByZXRhaW4gcmVtb3ZlZCBpdGVtcyBmb3IgdW5kb1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBlbnRpcmUgcnVuIHJlbW92ZWRcbiAgICByZW1vdmVSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCByZW1uYW50SXRlbXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIHJlbW5hbnRJdGVtcyA9IHJlbW5hbnRJdGVtcy5jb25jYXQodGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCBsZW4pIHtcbiAgICAgICAgICAgIHJlbW5hbnRJdGVtcyA9IHJlbW5hbnRJdGVtcy5jb25jYXQodGhpcy5pdGVtcy5zbGljZShlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zID0gcmVtbmFudEl0ZW1zO1xuICAgICAgICB0aGlzLmNhY2hlZExlbmd0aCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcnVuVG9TZWcoc2VnU3BlYykge1xuICAgIGNvbnN0IHNlZyA9IG5ldyBTdWJTZXF1ZW5jZShzZWdTcGVjLml0ZW1zLCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgTG9jYWxDbGllbnRJZCk7XG4gICAgaWYgKHNlZ1NwZWMucHJvcHMpIHtcbiAgICAgICAgc2VnLmFkZFByb3BlcnRpZXMoc2VnU3BlYy5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWc7XG59XG4vKipcbiAqIEEgbm9uLXNoYXJlZCBwbGFjZWhvbGRlciBmb3IgZXh0ZXJuYWwgY29udGVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV4dGVybmFsU2VnbWVudCBleHRlbmRzIEJhc2VTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclNlcSwgc2VxdWVuY2VMZW5ndGgsIHNlcXVlbmNlSW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlclNlcSA9IHBsYWNlaG9sZGVyU2VxO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IHNlcXVlbmNlSW5kZXg7XG4gICAgfVxuICAgIHRvSlNPTk9iamVjdCgpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgc2VxdWVuY2VJbmRleDogdGhpcy5zZXF1ZW5jZUluZGV4LCBzZXF1ZW5jZUxlbmd0aDogdGhpcy5zZXF1ZW5jZUxlbmd0aCB9O1xuICAgICAgICBzdXBlci5hZGRTZXJpYWxpemVkUHJvcHMob2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgbWVyZ2VUcmVlSW5zZXJ0KG1lcmdlVHJlZSwgcG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIG9wQXJncykge1xuICAgICAgICBtZXJnZVRyZWUuaW5zZXJ0KHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCB0aGlzLCAoYmxvY2ssIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBlc2VnKSA9PiBtZXJnZVRyZWUuYmxvY2tJbnNlcnQoYmxvY2ssIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBlc2VnKSwgb3BBcmdzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2xvbmUgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFwcGVuZChzZWdtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhcHBlbmQgdG8gZXh0ZXJuYWwgc2VnbWVudCcpO1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gU2VnbWVudFR5cGUuRXh0ZXJuYWw7XG4gICAgfVxuICAgIHJlbW92ZVJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBzcGxpdEF0KHBvcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0IGxldCByZXNlcnZlZFRpbGVMYWJlbHNLZXkgPSBcInJlZmVyZW5jZVRpbGVMYWJlbHNcIjtcbmV4cG9ydCBsZXQgcmVzZXJ2ZWRSYW5nZUxhYmVsc0tleSA9IFwicmVmZXJlbmNlUmFuZ2VMYWJlbHNcIjtcbmV4cG9ydCBsZXQgcmVzZXJ2ZWRNYXJrZXJJZEtleSA9IFwibWFya2VySWRcIjtcbmV4cG9ydCBsZXQgcmVzZXJ2ZWRNYXJrZXJTaW1wbGVUeXBlS2V5ID0gXCJtYXJrZXJTaW1wbGVUeXBlXCI7XG5mdW5jdGlvbiByZWZIYXNUaWxlTGFiZWxzKHJlZlBvcykge1xuICAgIHJldHVybiAocmVmUG9zLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5UaWxlKSAmJlxuICAgICAgICByZWZQb3MucHJvcGVydGllcyAmJiByZWZQb3MucHJvcGVydGllc1tyZXNlcnZlZFRpbGVMYWJlbHNLZXldO1xufVxuZnVuY3Rpb24gcmVmSGFzUmFuZ2VMYWJlbHMocmVmUG9zKSB7XG4gICAgcmV0dXJuIChyZWZQb3MucmVmVHlwZSAmIChvcHMuUmVmZXJlbmNlVHlwZS5OZXN0QmVnaW4gfCBvcHMuUmVmZXJlbmNlVHlwZS5OZXN0RW5kKSkgJiZcbiAgICAgICAgcmVmUG9zLnByb3BlcnRpZXMgJiYgcmVmUG9zLnByb3BlcnRpZXNbcmVzZXJ2ZWRSYW5nZUxhYmVsc0tleV07XG59XG5mdW5jdGlvbiByZWZIYXNUaWxlTGFiZWwocmVmUG9zLCBsYWJlbCkge1xuICAgIGlmIChyZWZQb3MuaGFzVGlsZUxhYmVscygpKSB7XG4gICAgICAgIGZvciAobGV0IHJlZkxhYmVsIG9mIHJlZlBvcy5wcm9wZXJ0aWVzW3Jlc2VydmVkVGlsZUxhYmVsc0tleV0pIHtcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PT0gcmVmTGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWZIYXNSYW5nZUxhYmVsKHJlZlBvcywgbGFiZWwpIHtcbiAgICBpZiAocmVmUG9zLmhhc1JhbmdlTGFiZWxzKCkpIHtcbiAgICAgICAgZm9yIChsZXQgcmVmTGFiZWwgb2YgcmVmUG9zLnByb3BlcnRpZXNbcmVzZXJ2ZWRSYW5nZUxhYmVsc0tleV0pIHtcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PT0gcmVmTGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWZHZXRUaWxlTGFiZWxzKHJlZlBvcykge1xuICAgIGlmIChyZWZQb3MuaGFzVGlsZUxhYmVscygpKSB7XG4gICAgICAgIHJldHVybiByZWZQb3MucHJvcGVydGllc1tyZXNlcnZlZFRpbGVMYWJlbHNLZXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZkdldFJhbmdlTGFiZWxzKHJlZlBvcykge1xuICAgIGlmIChyZWZQb3MuaGFzUmFuZ2VMYWJlbHMoKSkge1xuICAgICAgICByZXR1cm4gcmVmUG9zLnByb3BlcnRpZXNbcmVzZXJ2ZWRSYW5nZUxhYmVsc0tleV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1hcmtlciBleHRlbmRzIEJhc2VTZWdtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihyZWZUeXBlLCBzZXEsIGNsaWVudElkKSB7XG4gICAgICAgIHN1cGVyKHNlcSwgY2xpZW50SWQpO1xuICAgICAgICB0aGlzLnJlZlR5cGUgPSByZWZUeXBlO1xuICAgICAgICB0aGlzLmNhY2hlZExlbmd0aCA9IDE7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlKHJlZlR5cGUsIHByb3BzLCBzZXEsIGNsaWVudElkKSB7XG4gICAgICAgIGxldCBtYXJrZXIgPSBuZXcgTWFya2VyKHJlZlR5cGUsIHNlcSwgY2xpZW50SWQpO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIG1hcmtlci5hZGRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICB0b0pTT05PYmplY3QoKSB7XG4gICAgICAgIGxldCBvYmogPSB7IG1hcmtlcjogeyByZWZUeXBlOiB0aGlzLnJlZlR5cGUgfSB9O1xuICAgICAgICBzdXBlci5hZGRTZXJpYWxpemVkUHJvcHMob2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGxldCBiID0gTWFya2VyLm1ha2UodGhpcy5yZWZUeXBlLCB0aGlzLnByb3BlcnRpZXMsIHRoaXMuc2VxLCB0aGlzLmNsaWVudElkKTtcbiAgICAgICAgdGhpcy5jbG9uZUludG8oYik7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBnZXRTZWdtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaGFzU2ltcGxlVHlwZShzaW1wbGVUeXBlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNQcm9wZXJ0eShyZXNlcnZlZE1hcmtlclNpbXBsZVR5cGVLZXkpICYmXG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNbcmVzZXJ2ZWRNYXJrZXJTaW1wbGVUeXBlS2V5XSA9PT0gc2ltcGxlVHlwZU5hbWU7XG4gICAgfVxuICAgIGdldFByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG4gICAgfVxuICAgIGdldElkKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzICYmIHRoaXMucHJvcGVydGllc1tyZXNlcnZlZE1hcmtlcklkS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1tyZXNlcnZlZE1hcmtlcklkS2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNUaWxlTGFiZWxzKCkge1xuICAgICAgICByZXR1cm4gcmVmSGFzVGlsZUxhYmVscyh0aGlzKTtcbiAgICB9XG4gICAgaGFzUmFuZ2VMYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiByZWZIYXNSYW5nZUxhYmVscyh0aGlzKTtcbiAgICB9XG4gICAgaGFzVGlsZUxhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiByZWZIYXNUaWxlTGFiZWwodGhpcywgbGFiZWwpO1xuICAgIH1cbiAgICBoYXNSYW5nZUxhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiByZWZIYXNSYW5nZUxhYmVsKHRoaXMsIGxhYmVsKTtcbiAgICB9XG4gICAgZ2V0VGlsZUxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHJlZkdldFRpbGVMYWJlbHModGhpcyk7XG4gICAgfVxuICAgIGdldFJhbmdlTGFiZWxzKCkge1xuICAgICAgICByZXR1cm4gcmVmR2V0UmFuZ2VMYWJlbHModGhpcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgYmJ1ZiA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5UaWxlKSB7XG4gICAgICAgICAgICBiYnVmICs9IFwiVGlsZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5OZXN0QmVnaW4pIHtcbiAgICAgICAgICAgIGlmIChiYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBiYnVmICs9IFwiOyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJidWYgKz0gXCJSYW5nZUJlZ2luXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVmVHlwZSAmIG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RFbmQpIHtcbiAgICAgICAgICAgIGlmIChiYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBiYnVmICs9IFwiOyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJidWYgKz0gXCJSYW5nZUVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYnVmID0gXCJcIjtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGJidWYgKz0gYCAoJHtpZH0pIGA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzVGlsZUxhYmVscygpKSB7XG4gICAgICAgICAgICBsYnVmICs9IFwidGlsZSAtLSBcIjtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSB0aGlzLnByb3BlcnRpZXNbcmVzZXJ2ZWRUaWxlTGFiZWxzS2V5XTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdGlsZUxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYnVmICs9IFwiOyBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGJ1ZiArPSB0aWxlTGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzUmFuZ2VMYWJlbHMoKSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlS2luZCA9IFwiYmVnaW5cIjtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5OZXN0RW5kKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VLaW5kID0gXCJlbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1RpbGVMYWJlbHMoKSkge1xuICAgICAgICAgICAgICAgIGxidWYgKz0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYnVmICs9IGByYW5nZSAke3JhbmdlS2luZH0gLS0gYDtcbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSB0aGlzLnByb3BlcnRpZXNbcmVzZXJ2ZWRSYW5nZUxhYmVsc0tleV07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlTGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxidWYgKz0gXCI7IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYnVmICs9IHJhbmdlTGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBidWYgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBwYnVmICs9IEpTT04uc3RyaW5naWZ5KHRoaXMucHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBNICR7YmJ1Zn06ICR7bGJ1Zn0gJHtwYnVmfWA7XG4gICAgfVxuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTZWdtZW50VHlwZS5NYXJrZXI7XG4gICAgfVxuICAgIHJlbW92ZVJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZW1vdmUgcmFuZ2UgY2FsbGVkIG9uIG1hcmtlclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzcGxpdEF0KHBvcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYW5BcHBlbmQoc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFwcGVuZChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRleHRTZWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgc3VwZXIoc2VxLCBjbGllbnRJZCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuY2FjaGVkTGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlKHRleHQsIHByb3BzLCBzZXEsIGNsaWVudElkKSB7XG4gICAgICAgIGxldCB0c2VnID0gbmV3IFRleHRTZWdtZW50KHRleHQsIHNlcSwgY2xpZW50SWQpO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRzZWcuYWRkUHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzZWc7XG4gICAgfVxuICAgIHRvSlNPTk9iamVjdCgpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdGV4dDogdGhpcy50ZXh0IH07XG4gICAgICAgIHN1cGVyLmFkZFNlcmlhbGl6ZWRQcm9wcyhvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBzcGxpdEF0KHBvcykge1xuICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZ1RleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZExlbmd0aCA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGVhZlNlZ21lbnQgPSBuZXcgVGV4dFNlZ21lbnQocmVtYWluaW5nVGV4dCwgdGhpcy5zZXEsIHRoaXMuY2xpZW50SWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGxlYWZTZWdtZW50LmFkZFByb3BlcnRpZXMoUHJvcGVydGllcy5leHRlbmQoUHJvcGVydGllcy5jcmVhdGVNYXAoKSwgdGhpcy5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50Q29weSh0aGlzLCBsZWFmU2VnbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbFJlZnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0TG9jYWxSZWZzKHBvcywgbGVhZlNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlYWZTZWdtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb25lKHN0YXJ0ID0gMCwgZW5kKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGIgPSBUZXh0U2VnbWVudC5tYWtlKHRleHQsIHRoaXMucHJvcGVydGllcywgdGhpcy5zZXEsIHRoaXMuY2xpZW50SWQpO1xuICAgICAgICB0aGlzLmNsb25lSW50byhiKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTZWdtZW50VHlwZS5UZXh0O1xuICAgIH1cbiAgICBjYW5BcHBlbmQoc2VnbWVudCwgbWVyZ2VUcmVlKSB7XG4gICAgICAgIGlmICgoIXRoaXMucmVtb3ZlZFNlcSkgJiYgKHRoaXMudGV4dC5jaGFyQXQodGhpcy50ZXh0Lmxlbmd0aCAtIDEpICE9ICdcXG4nKSkge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuZ2V0VHlwZSgpID09PSBTZWdtZW50VHlwZS5UZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hQcm9wZXJ0aWVzKHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBicmFuY2hJZCA9IG1lcmdlVHJlZS5nZXRCcmFuY2hJZCh0aGlzLmNsaWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlZ0JyYW5jaElkID0gbWVyZ2VUcmVlLmdldEJyYW5jaElkKHNlZ21lbnQuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNlZ0JyYW5jaElkID09PSBicmFuY2hJZCkgJiYgKG1lcmdlVHJlZS5sb2NhbE5ldExlbmd0aChzZWdtZW50KSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0aGlzLmNhY2hlZExlbmd0aCA8PSBNZXJnZVRyZWUuVGV4dFNlZ21lbnRHcmFudWxhcml0eSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VnbWVudC5jYWNoZWRMZW5ndGggPD0gTWVyZ2VUcmVlLlRleHRTZWdtZW50R3JhbnVsYXJpdHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbiAgICBhcHBlbmQoc2VnbWVudCkge1xuICAgICAgICBpZiAoc2VnbWVudC5nZXRUeXBlKCkgPT09IFNlZ21lbnRUeXBlLlRleHQpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmxvY2FsUmVmcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGogPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxvY2FsUmVmIG9mIHNlZ21lbnQubG9jYWxSZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmLm9mZnNldCArPSBhZGo7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmLnNlZ21lbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBzZWdtZW50LnRleHQ7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZExlbmd0aCA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBvbmx5IGFwcGVuZCB0ZXh0IHNlZ21lbnRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETzogcmV0YWluIHJlbW92ZWQgdGV4dCBmb3IgdW5kb1xuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBlbnRpcmUgc3RyaW5nIHJlbW92ZWRcbiAgICByZW1vdmVSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCByZW1uYW50U3RyaW5nID0gXCJcIjtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIHJlbW5hbnRTdHJpbmcgKz0gdGhpcy50ZXh0LnN1YnN0cmluZygwLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA8IGxlbikge1xuICAgICAgICAgICAgcmVtbmFudFN0cmluZyArPSB0aGlzLnRleHQuc3Vic3RyaW5nKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0ID0gcmVtbmFudFN0cmluZztcbiAgICAgICAgdGhpcy5jYWNoZWRMZW5ndGggPSByZW1uYW50U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIChyZW1uYW50U3RyaW5nLmxlbmd0aCA9PSAwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2VnbWVudENvcHkoZnJvbSwgdG8pIHtcbiAgICB0by5wYXJlbnQgPSBmcm9tLnBhcmVudDtcbiAgICB0by5yZW1vdmVkQ2xpZW50SWQgPSBmcm9tLnJlbW92ZWRDbGllbnRJZDtcbiAgICB0by5yZW1vdmVkU2VxID0gZnJvbS5yZW1vdmVkU2VxO1xuICAgIGlmIChmcm9tLnJlbW92YWxzQnlCcmFuY2gpIHtcbiAgICAgICAgdG8ucmVtb3ZhbHNCeUJyYW5jaCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZnJvbS5yZW1vdmFsc0J5QnJhbmNoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZnJvbVJlbW92YWxJbmZvID0gZnJvbS5yZW1vdmFsc0J5QnJhbmNoW2ldO1xuICAgICAgICAgICAgaWYgKGZyb21SZW1vdmFsSW5mbykge1xuICAgICAgICAgICAgICAgIHRvLnJlbW92YWxzQnlCcmFuY2hbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRDbGllbnRJZDogZnJvbVJlbW92YWxJbmZvLnJlbW92ZWRDbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFNlcTogZnJvbVJlbW92YWxJbmZvLnJlbW92ZWRTZXEsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRDbGllbnRPdmVybGFwOiBmcm9tUmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudE92ZXJsYXAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0by5zZXEgPSBmcm9tLnNlcTtcbiAgICB0by5jbGllbnRJZCA9IGZyb20uY2xpZW50SWQ7XG4gICAgdG8ucmVtb3ZlZENsaWVudE92ZXJsYXAgPSBmcm9tLnJlbW92ZWRDbGllbnRPdmVybGFwO1xuICAgIGZyb20uc2VnbWVudEdyb3Vwcy5jb3B5VG8odG8pO1xufVxuZnVuY3Rpb24gaW5jcmVtZW50YWxHYXRoZXJUZXh0KHNlZ21lbnQsIHN0YXRlKSB7XG4gICAgaWYgKHNlZ21lbnQuZ2V0VHlwZSgpID09IFNlZ21lbnRUeXBlLlRleHQpIHtcbiAgICAgICAgbGV0IHRleHRTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZUdhdGhlclRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAY2xpICR7dGhpcy5jb2xsYWJXaW5kb3cgPyB0aGlzLmNvbGxhYndpbmRvdy5jbGllbnRJZCA6IC0xfSBnYXRoZXIgc2VnIHNlcSAke3RleHRTZWdtZW50LnNlcX0gcnNlcSAke3RleHRTZWdtZW50LnJlbW92ZWRTZXF9IHRleHQgJHt0ZXh0U2VnbWVudC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RhdGUuc3RhcnQgPD0gMCkgJiYgKHN0YXRlLmVuZCA+PSB0ZXh0U2VnbWVudC50ZXh0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbnRleHQudGV4dCArPSB0ZXh0U2VnbWVudC50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmVuZCA+PSB0ZXh0U2VnbWVudC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbnRleHQudGV4dCArPSB0ZXh0U2VnbWVudC50ZXh0LnN1YnN0cmluZyhzdGF0ZS5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb250ZXh0LnRleHQgKz0gdGV4dFNlZ21lbnQudGV4dC5zdWJzdHJpbmcoc3RhdGUuc3RhcnQsIHN0YXRlLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUub3AgPSBJbmNyZW1lbnRhbEV4ZWNPcC5Hbztcbn1cbmV4cG9ydCB2YXIgSW5jcmVtZW50YWxFeGVjT3A7XG4oZnVuY3Rpb24gKEluY3JlbWVudGFsRXhlY09wKSB7XG4gICAgSW5jcmVtZW50YWxFeGVjT3BbSW5jcmVtZW50YWxFeGVjT3BbXCJHb1wiXSA9IDBdID0gXCJHb1wiO1xuICAgIEluY3JlbWVudGFsRXhlY09wW0luY3JlbWVudGFsRXhlY09wW1wiU3RvcFwiXSA9IDFdID0gXCJTdG9wXCI7XG4gICAgSW5jcmVtZW50YWxFeGVjT3BbSW5jcmVtZW50YWxFeGVjT3BbXCJZaWVsZFwiXSA9IDJdID0gXCJZaWVsZFwiO1xufSkoSW5jcmVtZW50YWxFeGVjT3AgfHwgKEluY3JlbWVudGFsRXhlY09wID0ge30pKTtcbmV4cG9ydCBjbGFzcyBJbmNyZW1lbnRhbE1hcFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihibG9jaywgYWN0aW9ucywgcG9zLCByZWZTZXEsIGNsaWVudElkLCBjb250ZXh0LCBzdGFydCwgZW5kLCBjaGlsZEluZGV4ID0gMCkge1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnJlZlNlcSA9IHJlZlNlcTtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmNoaWxkSW5kZXggPSBjaGlsZEluZGV4O1xuICAgICAgICB0aGlzLm9wID0gSW5jcmVtZW50YWxFeGVjT3AuR287XG4gICAgfVxufVxuLyoqXG4gKiBTZXF1ZW5jZSBudW1iZXJzIGZvciBzaGFyZWQgc2VnbWVudHMgc3RhcnQgYXQgMSBvciBncmVhdGVyLiAgRXZlcnkgc2VnbWVudCBtYXJrZWRcbiAqIHdpdGggc2VxdWVuY2UgbnVtYmVyIHplcm8gd2lsbCBiZSBjb3VudGVkIGFzIHBhcnQgb2YgdGhlIHJlcXVlc3RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciA9IDA7XG5leHBvcnQgY29uc3QgVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyID0gLTE7XG5leHBvcnQgY29uc3QgVHJlZU1haW50ZW5hbmNlU2VxdWVuY2VOdW1iZXIgPSAtMjtcbmV4cG9ydCBjb25zdCBMb2NhbENsaWVudElkID0gLTE7XG5leHBvcnQgY29uc3QgTm9uQ29sbGFiQ2xpZW50ID0gLTI7XG5leHBvcnQgY2xhc3MgQ29sbGFib3JhdGlvbldpbmRvdyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBMb2NhbENsaWVudElkO1xuICAgICAgICB0aGlzLmNvbGxhYm9yYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gbG93ZXN0LW51bWJlcmVkIHNlZ21lbnQgaW4gd2luZG93OyBubyBjbGllbnQgY2FuIHJlZmVyZW5jZSBhIHN0YXRlIGJlZm9yZSB0aGlzIG9uZVxuICAgICAgICB0aGlzLm1pblNlcSA9IDA7XG4gICAgICAgIC8vIGhpZ2hlc3QtbnVtYmVyZWQgc2VnbWVudCBpbiB3aW5kb3cgYW5kIGN1cnJlbnRcbiAgICAgICAgLy8gcmVmZXJlbmNlIHNlZ21lbnQgZm9yIHRoaXMgY2xpZW50XG4gICAgICAgIHRoaXMuY3VycmVudFNlcSA9IDA7XG4gICAgfVxuICAgIGxvYWRGcm9tKGEpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGEuY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuY29sbGFib3JhdGluZyA9IGEuY29sbGFib3JhdGluZztcbiAgICAgICAgdGhpcy5sb2NhbE1pblNlcSA9IGEubG9jYWxNaW5TZXE7XG4gICAgICAgIHRoaXMuZ2xvYmFsTWluU2VxID0gYS5nbG9iYWxNaW5TZXE7XG4gICAgICAgIHRoaXMubWluU2VxID0gYS5taW5TZXE7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcSA9IGEuY3VycmVudFNlcTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBhcnRpYWwgbGVuZ3RoIHdob3NlIHNlcXVlbmNlIG51bWJlciBpc1xuICogdGhlIGdyZWF0ZXN0IHNlcXVlbmNlIG51bWJlciB3aXRoaW4gYSB0aGF0IGlzXG4gKiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ga2V5LlxuICogQHBhcmFtIHtQYXJ0aWFsTGVuZ3RoW119IGEgYXJyYXkgb2YgcGFydGlhbCBzZWdtZW50IGxlbmd0aHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBrZXkgc2VxdWVuY2UgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGxhdGVzdExFUShhLCBrZXkpIHtcbiAgICBsZXQgYmVzdCA9IC0xO1xuICAgIGxldCBsbyA9IDA7XG4gICAgbGV0IGhpID0gYS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsbyA8PSBoaSkge1xuICAgICAgICBsZXQgbWlkID0gbG8gKyBNYXRoLmZsb29yKChoaSAtIGxvKSAvIDIpO1xuICAgICAgICBpZiAoYVttaWRdLnNlcSA8PSBrZXkpIHtcbiAgICAgICAgICAgIGlmICgoYmVzdCA8IDApIHx8IChhW2Jlc3RdLnNlcSA8IGFbbWlkXS5zZXEpKSB7XG4gICAgICAgICAgICAgICAgYmVzdCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpID0gbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdHJpbmdzKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xufVxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIHBhcnRpYWwgc3VtcyBvZiBzZWdtZW50IGxlbmd0aHMgZm9yIGFsbCBzZXF1ZW5jZSBudW1iZXJzXG4gKiBpbiB0aGUgY3VycmVudCBjb2xsYWJvcmF0aW9uIHdpbmRvdyAoaWYgYW55KS4gIE9ubHkgdXNlZCBkdXJpbmcgYWN0aXZlXG4gKiBjb2xsYWJvcmF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgUGFydGlhbFNlcXVlbmNlTGVuZ3RocyB7XG4gICAgY29uc3RydWN0b3IobWluU2VxKSB7XG4gICAgICAgIHRoaXMubWluU2VxID0gbWluU2VxO1xuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2VnbWVudENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTGVuZ3RocyA9IFtdO1xuICAgICAgICB0aGlzLmNsaWVudFNlcU51bWJlcnMgPSBbXTtcbiAgICB9XG4gICAgY2xpTGF0ZXN0TEVRKGNsaWVudElkLCByZWZTZXEpIHtcbiAgICAgICAgbGV0IGNsaVNlcXMgPSB0aGlzLmNsaWVudFNlcU51bWJlcnNbY2xpZW50SWRdO1xuICAgICAgICBpZiAoY2xpU2Vxcykge1xuICAgICAgICAgICAgcmV0dXJuIGxhdGVzdExFUShjbGlTZXFzLCByZWZTZXEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsaUxhdGVzdChjbGllbnRJZCkge1xuICAgICAgICBsZXQgY2xpU2VxcyA9IHRoaXMuY2xpZW50U2VxTnVtYmVyc1tjbGllbnRJZF07XG4gICAgICAgIGlmIChjbGlTZXFzICYmIChjbGlTZXFzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpU2Vxcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBhcmUoYikge1xuICAgICAgICBmdW5jdGlvbiBjb21wYXJlUGFydGlhbExlbmd0aHMoYUxpc3QsIGJMaXN0KSB7XG4gICAgICAgICAgICBsZXQgYUxlbiA9IGFMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBiTGVuID0gYkxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFMZW4gIT0gYkxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFQYXJ0aWFsID0gYUxpc3RbaV07XG4gICAgICAgICAgICAgICAgbGV0IGJQYXJ0aWFsID0gYkxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKChhUGFydGlhbC5zZXEgIT0gYlBhcnRpYWwuc2VxKSB8fCAoYVBhcnRpYWwuY2xpZW50SWQgIT0gYlBhcnRpYWwuY2xpZW50SWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChhUGFydGlhbC5zZWdsZW4gIT0gYlBhcnRpYWwuc2VnbGVuKSB8fCAoYVBhcnRpYWwubGVuICE9IGJQYXJ0aWFsLmxlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGFQYXJ0aWFsLm92ZXJsYXBSZW1vdmVDbGllbnRzICYmICghYlBhcnRpYWwub3ZlcmxhcFJlbW92ZUNsaWVudHMpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wYXJlUGFydGlhbExlbmd0aHModGhpcy5wYXJ0aWFsTGVuZ3RocywgYi5wYXJ0aWFsTGVuZ3RocykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjbGllbnRJZCBpbiB0aGlzLmNsaWVudFNlcU51bWJlcnMpIHtcbiAgICAgICAgICAgIGlmICghYi5jbGllbnRTZXFOdW1iZXJzW2NsaWVudElkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjb21wYXJlUGFydGlhbExlbmd0aHModGhpcy5jbGllbnRTZXFOdW1iZXJzW2NsaWVudElkXSwgYi5jbGllbnRTZXFOdW1iZXJzW2NsaWVudElkXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJyYW5jaFRvU3RyaW5nKGdsYywgYnJhbmNoSWQgPSAwKSB7XG4gICAgICAgIGxldCBidWYgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBwYXJ0aWFsIG9mIHRoaXMucGFydGlhbExlbmd0aHMpIHtcbiAgICAgICAgICAgIGJ1ZiArPSBgKCR7cGFydGlhbC5zZXF9LCR7cGFydGlhbC5sZW59KSBgO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNsaWVudElkIGluIHRoaXMuY2xpZW50U2VxTnVtYmVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50U2VxTnVtYmVyc1tjbGllbnRJZF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGJ1ZiArPSBgQ2xpZW50IGA7XG4gICAgICAgICAgICAgICAgaWYgKGdsYykge1xuICAgICAgICAgICAgICAgICAgICBidWYgKz0gYCR7Z2xjKCtjbGllbnRJZCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiArPSBgJHtjbGllbnRJZH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWYgKz0gJ1snO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBhcnRpYWwgb2YgdGhpcy5jbGllbnRTZXFOdW1iZXJzW2NsaWVudElkXSkge1xuICAgICAgICAgICAgICAgICAgICBidWYgKz0gYCgke3BhcnRpYWwuc2VxfSwke3BhcnRpYWwubGVufSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWYgKz0gJ10nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1ZiA9IGBCciAke2JyYW5jaElkfSwgbWluKHNlcSAke3RoaXMubWluU2VxfSk6ICR7dGhpcy5taW5MZW5ndGh9OyBzYzogJHt0aGlzLnNlZ21lbnRDb3VudH07YCArIGJ1ZjtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgdG9TdHJpbmcoZ2xjLCBpbmRlbnRDb3VudCA9IDApIHtcbiAgICAgICAgbGV0IGJ1ZiA9IHRoaXMuYnJhbmNoVG9TdHJpbmcoZ2xjKTtcbiAgICAgICAgaWYgKHRoaXMuZG93bnN0cmVhbVBhcnRpYWxMZW5ndGhzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5kb3duc3RyZWFtUGFydGlhbExlbmd0aHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWYgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICBidWYgKz0gaW50ZXJuZWRTcGFjZXMoaW5kZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIGJ1ZiArPSB0aGlzLmRvd25zdHJlYW1QYXJ0aWFsTGVuZ3Roc1tpXS5icmFuY2hUb1N0cmluZyhnbGMsIGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBnZXRQYXJ0aWFsTGVuZ3RoKG1lcmdlVHJlZSwgcmVmU2VxLCBjbGllbnRJZCkge1xuICAgICAgICBsZXQgYnJhbmNoSWQgPSBtZXJnZVRyZWUuZ2V0QnJhbmNoSWQoY2xpZW50SWQpO1xuICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgcGxlbiBicmFuY2ggJHticmFuY2hJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoSWQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb3duc3RyZWFtUGFydGlhbExlbmd0aHNbYnJhbmNoSWQgLSAxXS5nZXRCcmFuY2hQYXJ0aWFsTGVuZ3RoKHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnJhbmNoUGFydGlhbExlbmd0aChyZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCcmFuY2hQYXJ0aWFsTGVuZ3RoKHJlZlNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgbGV0IHBMZW4gPSB0aGlzLm1pbkxlbmd0aDtcbiAgICAgICAgbGV0IHNlcUluZGV4ID0gbGF0ZXN0TEVRKHRoaXMucGFydGlhbExlbmd0aHMsIHJlZlNlcSk7XG4gICAgICAgIGxldCBjbGlMYXRlc3RpbmRleCA9IHRoaXMuY2xpTGF0ZXN0KGNsaWVudElkKTtcbiAgICAgICAgbGV0IGNsaVNlcSA9IHRoaXMuY2xpZW50U2VxTnVtYmVyc1tjbGllbnRJZF07XG4gICAgICAgIGlmIChzZXFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBwTGVuICs9IHRoaXMucGFydGlhbExlbmd0aHNbc2VxSW5kZXhdLmxlbjtcbiAgICAgICAgICAgIGlmIChjbGlMYXRlc3RpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsaUxhdGVzdCA9IGNsaVNlcVtjbGlMYXRlc3RpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNsaUxhdGVzdC5zZXEgPiByZWZTZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcExlbiArPSBjbGlMYXRlc3QubGVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlY2VkaW5nQ2xpSW5kZXggPSB0aGlzLmNsaUxhdGVzdExFUShjbGllbnRJZCwgcmVmU2VxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWNlZGluZ0NsaUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBMZW4gLT0gY2xpU2VxW3ByZWNlZGluZ0NsaUluZGV4XS5sZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpTGF0ZXN0aW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBjbGlMYXRlc3QgPSBjbGlTZXFbY2xpTGF0ZXN0aW5kZXhdO1xuICAgICAgICAgICAgICAgIHBMZW4gKz0gY2xpTGF0ZXN0LmxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcExlbjtcbiAgICB9XG4gICAgLy8gY2xlYXIgYXdheSBwYXJ0aWFsIHN1bXMgZm9yIHNlcXVlbmNlIG51bWJlcnMgZWFybGllciB0aGFuIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgIHphbWJvbmkoc2VnbWVudFdpbmRvdykge1xuICAgICAgICBmdW5jdGlvbiBjb3B5RG93bihwYXJ0aWFsTGVuZ3Rocykge1xuICAgICAgICAgICAgbGV0IG1pbmRleCA9IGxhdGVzdExFUShwYXJ0aWFsTGVuZ3Rocywgc2VnbWVudFdpbmRvdy5taW5TZXEpO1xuICAgICAgICAgICAgbGV0IG1pbkxlbmd0aCA9IDA7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBtaW5kZXggJHttaW5kZXh9YCk7XG4gICAgICAgICAgICBpZiAobWluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBtaW5MZW5ndGggPSBwYXJ0aWFsTGVuZ3Roc1ttaW5kZXhdLmxlbjtcbiAgICAgICAgICAgICAgICBsZXQgc2VxQ291bnQgPSBwYXJ0aWFsTGVuZ3Rocy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1pbmRleCA8PSAoc2VxQ291bnQgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCBzb21lIGVudHJpZXMgcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1haW5pbmdDb3VudCA9IChzZXFDb3VudCAtIG1pbmRleCkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvL2NvcHkgZG93blxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmluZ0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxMZW5ndGhzW2ldID0gcGFydGlhbExlbmd0aHNbaSArIG1pbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbExlbmd0aHNbaV0ubGVuIC09IG1pbkxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsTGVuZ3Rocy5sZW5ndGggPSByZW1haW5pbmdDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWluTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluTGVuZ3RoICs9IGNvcHlEb3duKHRoaXMucGFydGlhbExlbmd0aHMpO1xuICAgICAgICBmb3IgKGxldCBjbGllbnRJZCBpbiB0aGlzLmNsaWVudFNlcU51bWJlcnMpIHtcbiAgICAgICAgICAgIGxldCBjbGlQYXJ0aWFscyA9IHRoaXMuY2xpZW50U2VxTnVtYmVyc1tjbGllbnRJZF07XG4gICAgICAgICAgICBpZiAoY2xpUGFydGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb3B5RG93bihjbGlQYXJ0aWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2xpZW50U2VxTnVtYmVyKGNsaWVudElkLCBzZXEsIHNlZ2xlbikge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRTZXFOdW1iZXJzW2NsaWVudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFNlcU51bWJlcnNbY2xpZW50SWRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsaSA9IHRoaXMuY2xpZW50U2VxTnVtYmVyc1tjbGllbnRJZF07XG4gICAgICAgIGxldCBwTGVuID0gc2VnbGVuO1xuICAgICAgICBpZiAoY2xpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBMZW4gKz0gY2xpW2NsaS5sZW5ndGggLSAxXS5sZW47XG4gICAgICAgIH1cbiAgICAgICAgY2xpLnB1c2goeyBzZXE6IHNlcSwgbGVuOiBwTGVuLCBzZWdsZW46IHNlZ2xlbiB9KTtcbiAgICB9XG4gICAgLy8gYXNzdW1lcyBzZXF1ZW5jZSBudW1iZXIgYWxyZWFkeSBjb2FsZXNjZWRcbiAgICBhZGRDbGllbnRTZXFOdW1iZXJGcm9tUGFydGlhbChwYXJ0aWFsTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xpZW50U2VxTnVtYmVyKHBhcnRpYWxMZW5ndGguY2xpZW50SWQsIHBhcnRpYWxMZW5ndGguc2VxLCBwYXJ0aWFsTGVuZ3RoLnNlZ2xlbik7XG4gICAgICAgIGlmIChwYXJ0aWFsTGVuZ3RoLm92ZXJsYXBSZW1vdmVDbGllbnRzKSB7XG4gICAgICAgICAgICBwYXJ0aWFsTGVuZ3RoLm92ZXJsYXBSZW1vdmVDbGllbnRzLm1hcCgob2MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaWVudFNlcU51bWJlcihvYy5kYXRhLmNsaWVudElkLCBwYXJ0aWFsTGVuZ3RoLnNlcSwgb2MuZGF0YS5zZWdsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKG1lcmdlVHJlZSwgYmxvY2ssIHNlcSwgY2xpZW50SWQsIGNvbGxhYldpbmRvdykge1xuICAgICAgICBsZXQgc2VnQnJhbmNoSWQgPSBtZXJnZVRyZWUuZ2V0QnJhbmNoSWQoY2xpZW50SWQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgc2VnIGJyICR7c2VnQnJhbmNoSWR9IGNsaSAke2dsYyhtZXJnZVRyZWUsIHNlZ21lbnQuY2xpZW50SWQpfSBtZSAke2dsYyhtZXJnZVRyZWUsIG1lcmdlVHJlZS5jb2xsYWJXaW5kb3cuY2xpZW50SWQpfWApO1xuICAgICAgICBpZiAoc2VnQnJhbmNoSWQgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCcmFuY2gobWVyZ2VUcmVlLCAwLCBibG9jaywgc2VxLCBjbGllbnRJZCwgY29sbGFiV2luZG93KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VUcmVlLmxvY2FsQnJhbmNoSWQgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlVHJlZS5sb2NhbEJyYW5jaElkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYnJhbmNoSWQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnQnJhbmNoSWQgPD0gYnJhbmNoSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3duc3RyZWFtUGFydGlhbExlbmd0aHNbaV0udXBkYXRlQnJhbmNoKG1lcmdlVHJlZSwgYnJhbmNoSWQsIGJsb2NrLCBzZXEsIGNsaWVudElkLCBjb2xsYWJXaW5kb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhc3N1bWU6IHNlcSBpcyBsYXRlc3Qgc2VxdWVuY2UgbnVtYmVyOyBubyBzdHJ1Y3R1cmFsIGNoYW5nZSB0byBzdWItdHJlZSwgYnV0IGEgc2VnbWVudFxuICAgIC8vIHdpdGggc2VxdWVuY2UgbnVtYmVyIHNlcSBoYXMgYmVlbiBhZGRlZCB3aXRoaW4gdGhlIHN1Yi10cmVlXG4gICAgLy8gVE9ETzogYXNzZXJ0IGNsaWVudCBpZCBtYXRjaGVzXG4gICAgdXBkYXRlQnJhbmNoKG1lcmdlVHJlZSwgYnJhbmNoSWQsIG5vZGUsIHNlcSwgY2xpZW50SWQsIGNvbGxhYldpbmRvdykge1xuICAgICAgICBsZXQgc2VxU2VnbGVuID0gMDtcbiAgICAgICAgbGV0IHNlZ0NvdW50ID0gMDtcbiAgICAgICAgLy8gY29tcHV0ZSBsZW5ndGggZm9yIHNlcSBhY3Jvc3MgY2hpbGRyZW5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICghY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRCbG9jayA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGxldCBicmFuY2hQYXJ0aWFsTGVuZ3RocyA9IGNoaWxkQmxvY2sucGFydGlhbExlbmd0aHMucGFydGlhbExlbmd0aHNGb3JCcmFuY2goYnJhbmNoSWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0aWFsTGVuZ3RocyA9IGJyYW5jaFBhcnRpYWxMZW5ndGhzLnBhcnRpYWxMZW5ndGhzO1xuICAgICAgICAgICAgICAgIGxldCBzZXFJbmRleCA9IGxhdGVzdExFUShwYXJ0aWFsTGVuZ3Rocywgc2VxKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VxSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVxUGFydGlhbCA9IHBhcnRpYWxMZW5ndGhzW3NlcUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlcVBhcnRpYWwuc2VxID09IHNlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VxU2VnbGVuICs9IGxlcVBhcnRpYWwuc2VnbGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ0NvdW50ICs9IGJyYW5jaFBhcnRpYWxMZW5ndGhzLnNlZ21lbnRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgbGV0IHNlZ0JyYW5jaElkID0gbWVyZ2VUcmVlLmdldEJyYW5jaElkKHNlZ21lbnQuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIGxldCByZW1vdmFsSW5mbyA9IG1lcmdlVHJlZS5nZXRSZW1vdmFsSW5mbyhicmFuY2hJZCwgc2VnQnJhbmNoSWQsIHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnNlcSA9PSBzZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92YWxJbmZvLnJlbW92ZWRTZXEgIT09IHNlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VxU2VnbGVuICs9IHNlZ21lbnQuY2FjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSA9PT0gc2VxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFTZWdsZW4gLT0gc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VnQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZ21lbnRDb3VudCA9IHNlZ0NvdW50O1xuICAgICAgICBmdW5jdGlvbiBhZGRTZXEocGFydGlhbExlbmd0aHMsIHNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgICAgIGxldCBzZXFQYXJ0aWFsTGVuO1xuICAgICAgICAgICAgbGV0IHBlbnVsdFBhcnRpYWxMZW47XG4gICAgICAgICAgICBsZXQgbGVxSW5kZXggPSBsYXRlc3RMRVEocGFydGlhbExlbmd0aHMsIHNlcSk7XG4gICAgICAgICAgICBpZiAobGVxSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBwTGVuID0gcGFydGlhbExlbmd0aHNbbGVxSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChwTGVuLnNlcSA9PSBzZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxUGFydGlhbExlbiA9IHBMZW47XG4gICAgICAgICAgICAgICAgICAgIGxlcUluZGV4ID0gbGF0ZXN0TEVRKHBhcnRpYWxMZW5ndGhzLCBzZXEgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlcUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbnVsdFBhcnRpYWxMZW4gPSBwYXJ0aWFsTGVuZ3Roc1tsZXFJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbnVsdFBhcnRpYWxMZW4gPSBwTGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXFQYXJ0aWFsTGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXFQYXJ0aWFsTGVuID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXE6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbGVuOiBzZXFTZWdsZW4sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBjbGllbnRJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFydGlhbExlbmd0aHMucHVzaChzZXFQYXJ0aWFsTGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcVBhcnRpYWxMZW4uc2VnbGVuID0gc2VxU2VnbGVuO1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCBjbGllbnQgaWQgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBlbnVsdFBhcnRpYWxMZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlcVBhcnRpYWxMZW4ubGVuID0gc2VxUGFydGlhbExlbi5zZWdsZW4gKyBwZW51bHRQYXJ0aWFsTGVuLmxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcVBhcnRpYWxMZW4ubGVuID0gc2VxUGFydGlhbExlbi5zZWdsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkU2VxKHRoaXMucGFydGlhbExlbmd0aHMsIHNlcSwgY2xpZW50SWQpO1xuICAgICAgICBpZiAodGhpcy5jbGllbnRTZXFOdW1iZXJzW2NsaWVudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFNlcU51bWJlcnNbY2xpZW50SWRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYWRkU2VxKHRoaXMuY2xpZW50U2VxTnVtYmVyc1tjbGllbnRJZF0sIHNlcSk7XG4gICAgICAgIC8vICAgIGNvbnNvbGUubG9nKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChQYXJ0aWFsU2VxdWVuY2VMZW5ndGhzLm9wdGlvbnMuemFtYm9uaSkge1xuICAgICAgICAgICAgdGhpcy56YW1ib25pKGNvbGxhYldpbmRvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnWlpaJyk7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2codGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21MZWF2ZXMobWVyZ2VUcmVlLCBicmFuY2hJZCwgY29tYmluZWRQYXJ0aWFsTGVuZ3RocywgYmxvY2ssIGNvbGxhYldpbmRvdykge1xuICAgICAgICBjb21iaW5lZFBhcnRpYWxMZW5ndGhzLm1pbkxlbmd0aCA9IDA7XG4gICAgICAgIGNvbWJpbmVkUGFydGlhbExlbmd0aHMuc2VnbWVudENvdW50ID0gYmxvY2suY2hpbGRDb3VudDtcbiAgICAgICAgZnVuY3Rpb24gZ2V0T3ZlcmxhcENsaWVudHMob3ZlcmxhcENsaWVudGlkcywgc2VnbGVuKSB7XG4gICAgICAgICAgICBsZXQgYnN0ID0gbmV3IENvbGxlY3Rpb25zLlJlZEJsYWNrVHJlZShjb21wYXJlTnVtYmVycyk7XG4gICAgICAgICAgICBmb3IgKGxldCBjbGllbnRJZCBvZiBvdmVybGFwQ2xpZW50aWRzKSB7XG4gICAgICAgICAgICAgICAgYnN0LnB1dChjbGllbnRJZCwgeyBjbGllbnRJZDogY2xpZW50SWQsIHNlZ2xlbjogc2VnbGVuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJzdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhY2N1bXVsYXRlUmVtb3ZlQ2xpZW50T3ZlcmxhcChwYXJ0aWFsTGVuZ3RoLCBvdmVybGFwUmVtb3ZlQ2xpZW50SWRzLCBzZWdsZW4pIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsTGVuZ3RoLm92ZXJsYXBSZW1vdmVDbGllbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2xpZW50SWQgb2Ygb3ZlcmxhcFJlbW92ZUNsaWVudElkcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3ZsYXBDbGllbnROb2RlID0gcGFydGlhbExlbmd0aC5vdmVybGFwUmVtb3ZlQ2xpZW50cy5nZXQoY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW92bGFwQ2xpZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbExlbmd0aC5vdmVybGFwUmVtb3ZlQ2xpZW50cy5wdXQoY2xpZW50SWQsIHsgY2xpZW50SWQ6IGNsaWVudElkLCBzZWdsZW46IHNlZ2xlbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92bGFwQ2xpZW50Tm9kZS5kYXRhLnNlZ2xlbiArPSBzZWdsZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsTGVuZ3RoLm92ZXJsYXBSZW1vdmVDbGllbnRzID0gZ2V0T3ZlcmxhcENsaWVudHMob3ZlcmxhcFJlbW92ZUNsaWVudElkcywgc2VnbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRTZWdtZW50KHNlZ21lbnQsIHJlbW92ZWRTZXEgPSBmYWxzZSwgcmVtb3ZhbEluZm8gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBzZXEgPSBzZWdtZW50LnNlcTtcbiAgICAgICAgICAgIGxldCBzZWdtZW50TGVuID0gc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2xpZW50SWQgPSBzZWdtZW50LmNsaWVudElkO1xuICAgICAgICAgICAgbGV0IHJlbW92ZUNsaWVudE92ZXJsYXA7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZFNlcSkge1xuICAgICAgICAgICAgICAgIHNlcSA9IHJlbW92YWxJbmZvLnJlbW92ZWRTZXE7XG4gICAgICAgICAgICAgICAgc2VnbWVudExlbiA9IC1zZWdtZW50TGVuO1xuICAgICAgICAgICAgICAgIGNsaWVudElkID0gcmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudElkO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmFsSW5mby5yZW1vdmVkQ2xpZW50T3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGllbnRPdmVybGFwID0gcmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudE92ZXJsYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNlcVBhcnRpYWxzID0gY29tYmluZWRQYXJ0aWFsTGVuZ3Rocy5wYXJ0aWFsTGVuZ3RocztcbiAgICAgICAgICAgIGxldCBzZXFQYXJ0aWFsc0xlbiA9IHNlcVBhcnRpYWxzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGVudHJ5IHdpdGggc2VxdWVuY2UgbnVtYmVyIGdyZWF0ZXIgb3IgZXF1YWwgdG8gc2VxXG4gICAgICAgICAgICBsZXQgaW5kZXhGaXJzdEdURSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaW5kZXhGaXJzdEdURSA8IHNlcVBhcnRpYWxzTGVuOyBpbmRleEZpcnN0R1RFKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VxUGFydGlhbHNbaW5kZXhGaXJzdEdURV0uc2VxID49IHNlcSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGluZGV4Rmlyc3RHVEUgPCBzZXFQYXJ0aWFsc0xlbikgJiYgKHNlcVBhcnRpYWxzW2luZGV4Rmlyc3RHVEVdLnNlcSA9PSBzZXEpKSB7XG4gICAgICAgICAgICAgICAgc2VxUGFydGlhbHNbaW5kZXhGaXJzdEdURV0uc2VnbGVuICs9IHNlZ21lbnRMZW47XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUNsaWVudE92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZVJlbW92ZUNsaWVudE92ZXJsYXAoc2VxUGFydGlhbHNbaW5kZXhGaXJzdEdURV0sIHJlbW92ZUNsaWVudE92ZXJsYXAsIHNlZ21lbnRMZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwTGVuO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVDbGllbnRPdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdmVybGFwQ2xpZW50cyA9IGdldE92ZXJsYXBDbGllbnRzKHJlbW92ZUNsaWVudE92ZXJsYXAsIHNlZ21lbnRMZW4pO1xuICAgICAgICAgICAgICAgICAgICBwTGVuID0geyBzZXE6IHNlcSwgY2xpZW50SWQ6IGNsaWVudElkLCBsZW46IDAsIHNlZ2xlbjogc2VnbWVudExlbiwgb3ZlcmxhcFJlbW92ZUNsaWVudHM6IG92ZXJsYXBDbGllbnRzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwTGVuID0geyBzZXE6IHNlcSwgY2xpZW50SWQ6IGNsaWVudElkLCBsZW46IDAsIHNlZ2xlbjogc2VnbWVudExlbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhGaXJzdEdURSA8IHNlcVBhcnRpYWxzTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IGVudHJpZXMgd2l0aCBncmVhdGVyIHNlcXVlbmNlIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQgdXNpbmcgQlNUXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBzZXFQYXJ0aWFsc0xlbjsgayA+IGluZGV4Rmlyc3RHVEU7IGstLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VxUGFydGlhbHNba10gPSBzZXFQYXJ0aWFsc1trIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VxUGFydGlhbHNbaW5kZXhGaXJzdEdURV0gPSBwTGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxUGFydGlhbHMucHVzaChwTGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VxTFRFKHNlcSwgbWluU2VxKSB7XG4gICAgICAgICAgICByZXR1cm4gKHNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpICYmIChzZXEgPD0gbWluU2VxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBsZWFmIHNlZ21lbnRcbiAgICAgICAgICAgICAgICBsZXQgc2VnbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGxldCBzZWdCcmFuY2hJZCA9IG1lcmdlVHJlZS5nZXRCcmFuY2hJZChzZWdtZW50LmNsaWVudElkKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgc2VnIGJyICR7c2VnQnJhbmNoSWR9IGNsaSAke2dsYyhtZXJnZVRyZWUsIHNlZ21lbnQuY2xpZW50SWQpfSBtZSAke2dsYyhtZXJnZVRyZWUsIG1lcmdlVHJlZS5jb2xsYWJXaW5kb3cuY2xpZW50SWQpfWApO1xuICAgICAgICAgICAgICAgIGlmIChzZWdCcmFuY2hJZCA8PSBicmFuY2hJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VxTFRFKHNlZ21lbnQuc2VxLCBjb2xsYWJXaW5kb3cubWluU2VxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWRQYXJ0aWFsTGVuZ3Rocy5taW5MZW5ndGggKz0gc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5zZXEgIT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0U2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVtb3ZhbEluZm8gPSBtZXJnZVRyZWUuZ2V0UmVtb3ZhbEluZm8oYnJhbmNoSWQsIHNlZ0JyYW5jaElkLCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcUxURShyZW1vdmFsSW5mby5yZW1vdmVkU2VxLCBjb2xsYWJXaW5kb3cubWluU2VxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWRQYXJ0aWFsTGVuZ3Rocy5taW5MZW5ndGggLT0gc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlbW92YWxJbmZvLnJlbW92ZWRTZXEgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0U2VnbWVudChzZWdtZW50LCB0cnVlLCByZW1vdmFsSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcG9zdC1wcm9jZXNzIGNvcnJlY3RseS1vcmRlcmVkIHBhcnRpYWxzIGNvbXB1dGluZyBzdW1zIGFuZCBjcmVhdGluZ1xuICAgICAgICAvLyBsaXN0cyBmb3IgZWFjaCBwcmVzZW50IGNsaWVudCBpZFxuICAgICAgICBsZXQgc2VxUGFydGlhbHMgPSBjb21iaW5lZFBhcnRpYWxMZW5ndGhzLnBhcnRpYWxMZW5ndGhzO1xuICAgICAgICBsZXQgc2VxUGFydGlhbHNMZW4gPSBzZXFQYXJ0aWFscy5sZW5ndGg7XG4gICAgICAgIGxldCBwcmV2TGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXFQYXJ0aWFsc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICBzZXFQYXJ0aWFsc1tpXS5sZW4gPSBwcmV2TGVuICsgc2VxUGFydGlhbHNbaV0uc2VnbGVuO1xuICAgICAgICAgICAgcHJldkxlbiA9IHNlcVBhcnRpYWxzW2ldLmxlbjtcbiAgICAgICAgICAgIGNvbWJpbmVkUGFydGlhbExlbmd0aHMuYWRkQ2xpZW50U2VxTnVtYmVyRnJvbVBhcnRpYWwoc2VxUGFydGlhbHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjb21iaW5lKG1lcmdlVHJlZSwgYmxvY2ssIGNvbGxhYldpbmRvdywgcmVjdXIgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcGFydGlhbExlbmd0aHNUb3BCcmFuY2ggPSBQYXJ0aWFsU2VxdWVuY2VMZW5ndGhzLmNvbWJpbmVCcmFuY2gobWVyZ2VUcmVlLCBibG9jaywgY29sbGFiV2luZG93LCAwLCByZWN1cik7XG4gICAgICAgIGlmIChtZXJnZVRyZWUubG9jYWxCcmFuY2hJZCA+IDApIHtcbiAgICAgICAgICAgIHBhcnRpYWxMZW5ndGhzVG9wQnJhbmNoLmRvd25zdHJlYW1QYXJ0aWFsTGVuZ3RocyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXJnZVRyZWUubG9jYWxCcmFuY2hJZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbExlbmd0aHNUb3BCcmFuY2guZG93bnN0cmVhbVBhcnRpYWxMZW5ndGhzW2ldID1cbiAgICAgICAgICAgICAgICAgICAgUGFydGlhbFNlcXVlbmNlTGVuZ3Rocy5jb21iaW5lQnJhbmNoKG1lcmdlVHJlZSwgYmxvY2ssIGNvbGxhYldpbmRvdywgaSArIDEsIHJlY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGlhbExlbmd0aHNUb3BCcmFuY2g7XG4gICAgfVxuICAgIHBhcnRpYWxMZW5ndGhzRm9yQnJhbmNoKGJyYW5jaElkKSB7XG4gICAgICAgIGlmIChicmFuY2hJZCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvd25zdHJlYW1QYXJ0aWFsTGVuZ3Roc1ticmFuY2hJZCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZSB0aGUgcGFydGlhbCBsZW5ndGhzIG9mIGJsb2NrJ3MgY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0ge0lNZXJnZUJsb2NrfSBibG9jayBhbiBpbnRlcmlvciBub2RlOyBpdCBpcyBhc3N1bWVkIHRoYXQgZWFjaCBpbnRlcmlvciBub2RlIGNoaWxkIG9mIHRoaXMgYmxvY2tcbiAgICAgKiBoYXMgaXRzIHBhcnRpYWxzIHVwIHRvIGRhdGVcbiAgICAgKiBAcGFyYW0ge0NvbGxhYm9yYXRpb25XaW5kb3d9IGNvbGxhYldpbmRvdyBzZWdtZW50IHdpbmRvdyBmbyB0aGUgc2VnbWVudCB0cmVlIGNvbnRhaW5pbmcgdGV4dFNlZ21lbnRCbG9ja1xuICAgICAqL1xuICAgIHN0YXRpYyBjb21iaW5lQnJhbmNoKG1lcmdlVHJlZSwgYmxvY2ssIGNvbGxhYldpbmRvdywgYnJhbmNoSWQsIHJlY3VyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvbWJpbmVkUGFydGlhbExlbmd0aHMgPSBuZXcgUGFydGlhbFNlcXVlbmNlTGVuZ3Rocyhjb2xsYWJXaW5kb3cubWluU2VxKTtcbiAgICAgICAgUGFydGlhbFNlcXVlbmNlTGVuZ3Rocy5mcm9tTGVhdmVzKG1lcmdlVHJlZSwgYnJhbmNoSWQsIGNvbWJpbmVkUGFydGlhbExlbmd0aHMsIGJsb2NrLCBjb2xsYWJXaW5kb3cpO1xuICAgICAgICBsZXQgcHJldlBhcnRpYWw7XG4gICAgICAgIGZ1bmN0aW9uIGNvbWJpbmVPdmVybGFwQ2xpZW50cyhhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5vdmVybGFwUmVtb3ZlQ2xpZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChiLm92ZXJsYXBSZW1vdmVDbGllbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGIub3ZlcmxhcFJlbW92ZUNsaWVudHMubWFwKChiUHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFQcm9wID0gYS5vdmVybGFwUmVtb3ZlQ2xpZW50cy5nZXQoYlByb3Aua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFQcm9wLmRhdGEuc2VnbGVuICs9IGJQcm9wLmRhdGEuc2VnbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5vdmVybGFwUmVtb3ZlQ2xpZW50cy5wdXQoYlByb3AuZGF0YS5jbGllbnRJZCwgYlByb3AuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYS5vdmVybGFwUmVtb3ZlQ2xpZW50cyA9IGIub3ZlcmxhcFJlbW92ZUNsaWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkTmV4dChwYXJ0aWFsTGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgc2VxID0gcGFydGlhbExlbmd0aC5zZXE7XG4gICAgICAgICAgICBsZXQgcExlbiA9IDA7XG4gICAgICAgICAgICBpZiAocHJldlBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlBhcnRpYWwuc2VxID09IHBhcnRpYWxMZW5ndGguc2VxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJ0aWFsLnNlZ2xlbiArPSBwYXJ0aWFsTGVuZ3RoLnNlZ2xlbjtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcnRpYWwubGVuICs9IHBhcnRpYWxMZW5ndGguc2VnbGVuO1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lT3ZlcmxhcENsaWVudHMocHJldlBhcnRpYWwsIHBhcnRpYWxMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwTGVuID0gcHJldlBhcnRpYWwubGVuO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBzZXF1ZW5jZSBudW1iZXIgaXMgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWRQYXJ0aWFsTGVuZ3Rocy5hZGRDbGllbnRTZXFOdW1iZXJGcm9tUGFydGlhbChwcmV2UGFydGlhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBhcnRpYWwgPSB7XG4gICAgICAgICAgICAgICAgc2VxOiBzZXEsXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHBhcnRpYWxMZW5ndGguY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgbGVuOiBwTGVuICsgcGFydGlhbExlbmd0aC5zZWdsZW4sXG4gICAgICAgICAgICAgICAgc2VnbGVuOiBwYXJ0aWFsTGVuZ3RoLnNlZ2xlbixcbiAgICAgICAgICAgICAgICBvdmVybGFwUmVtb3ZlQ2xpZW50czogcGFydGlhbExlbmd0aC5vdmVybGFwUmVtb3ZlQ2xpZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbWJpbmVkUGFydGlhbExlbmd0aHMucGFydGlhbExlbmd0aHMucHVzaChwcmV2UGFydGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkUGFydGlhbHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEJsb2NrID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sucGFydGlhbExlbmd0aHMgPSBQYXJ0aWFsU2VxdWVuY2VMZW5ndGhzLmNvbWJpbmUobWVyZ2VUcmVlLCBjaGlsZEJsb2NrLCBjb2xsYWJXaW5kb3csIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZFBhcnRpYWxzLnB1c2goY2hpbGRCbG9jay5wYXJ0aWFsTGVuZ3Rocy5wYXJ0aWFsTGVuZ3Roc0ZvckJyYW5jaChicmFuY2hJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZFBhcnRpYWxzTGVuID0gY2hpbGRQYXJ0aWFscy5sZW5ndGg7XG4gICAgICAgIGlmIChjaGlsZFBhcnRpYWxzTGVuICE9IDApIHtcbiAgICAgICAgICAgIC8vIHNvbWUgY2hpbGRyZW4gYXJlIGludGVyaW9yIG5vZGVzXG4gICAgICAgICAgICBpZiAoY29tYmluZWRQYXJ0aWFsTGVuZ3Rocy5wYXJ0aWFsTGVuZ3Rocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZSBjaGlsZHJlbiB3ZXJlIGxlYXZlczsgYWRkIGNvbWJpbmVkIHBhcnRpYWxzIGZyb20gdGhlc2Ugc2VnbWVudHNcbiAgICAgICAgICAgICAgICBjaGlsZFBhcnRpYWxzLnB1c2goY29tYmluZWRQYXJ0aWFsTGVuZ3Rocyk7XG4gICAgICAgICAgICAgICAgY2hpbGRQYXJ0aWFsc0xlbisrO1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkUGFydGlhbExlbmd0aHMgPSBuZXcgUGFydGlhbFNlcXVlbmNlTGVuZ3Rocyhjb2xsYWJXaW5kb3cubWluU2VxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gbmV3IEFycmF5KGNoaWxkUGFydGlhbHNMZW4pO1xuICAgICAgICAgICAgbGV0IGNoaWxkUGFydGlhbHNDb3VudHMgPSBuZXcgQXJyYXkoY2hpbGRQYXJ0aWFsc0xlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkUGFydGlhbHNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGluZGljZXNbaV0gPSAwO1xuICAgICAgICAgICAgICAgIGNoaWxkUGFydGlhbHNDb3VudHNbaV0gPSBjaGlsZFBhcnRpYWxzW2ldLnBhcnRpYWxMZW5ndGhzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFBhcnRpYWxMZW5ndGhzLm1pbkxlbmd0aCArPSBjaGlsZFBhcnRpYWxzW2ldLm1pbkxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFBhcnRpYWxMZW5ndGhzLnNlZ21lbnRDb3VudCArPSBjaGlsZFBhcnRpYWxzW2ldLnNlZ21lbnRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvdXRlckluZGV4T2ZFYXJsaWVzdCA9IDA7XG4gICAgICAgICAgICBsZXQgZWFybGllc3RQYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKG91dGVySW5kZXhPZkVhcmxpZXN0ID49IDApIHtcbiAgICAgICAgICAgICAgICBvdXRlckluZGV4T2ZFYXJsaWVzdCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2hpbGRQYXJ0aWFsc0xlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgbmV4dCBlYXJsaWVzdCBzZXF1ZW5jZSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljZXNba10gPCBjaGlsZFBhcnRpYWxzQ291bnRzW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3BMZW4gPSBjaGlsZFBhcnRpYWxzW2tdLnBhcnRpYWxMZW5ndGhzW2luZGljZXNba11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvdXRlckluZGV4T2ZFYXJsaWVzdCA8IDApIHx8IChjcExlbi5zZXEgPCBlYXJsaWVzdFBhcnRpYWxMZW5ndGguc2VxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySW5kZXhPZkVhcmxpZXN0ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJsaWVzdFBhcnRpYWxMZW5ndGggPSBjcExlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3V0ZXJJbmRleE9mRWFybGllc3QgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGROZXh0KGVhcmxpZXN0UGFydGlhbExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNbb3V0ZXJJbmRleE9mRWFybGllc3RdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGNsaWVudCBlbnRyeSBmb3IgbGFzdCBwYXJ0aWFsLCBpZiBhbnlcbiAgICAgICAgICAgIGlmIChwcmV2UGFydGlhbCkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkUGFydGlhbExlbmd0aHMuYWRkQ2xpZW50U2VxTnVtYmVyRnJvbVBhcnRpYWwocHJldlBhcnRpYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGluY3JlbWVudGFsIHphbWJvbmkgZHVyaW5nIGJ1aWxkXG4gICAgICAgIC8vY29uc29sZS5sb2coY29tYmluZWRQYXJ0aWFsTGVuZ3Rocy50b1N0cmluZygpKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhgWlpaLi4uKG1pbiAke3NlZ21lbnRXaW5kb3cubWluU2VxfSlgKTtcbiAgICAgICAgaWYgKFBhcnRpYWxTZXF1ZW5jZUxlbmd0aHMub3B0aW9ucy56YW1ib25pKSB7XG4gICAgICAgICAgICBjb21iaW5lZFBhcnRpYWxMZW5ndGhzLnphbWJvbmkoY29sbGFiV2luZG93KTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGNvbWJpbmVkUGFydGlhbExlbmd0aHMudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZFBhcnRpYWxMZW5ndGhzO1xuICAgIH1cbn1cblBhcnRpYWxTZXF1ZW5jZUxlbmd0aHMub3B0aW9ucyA9IHtcbiAgICB6YW1ib25pOiB0cnVlXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNsb2NrKCkge1xuICAgIGlmIChwcm9jZXNzLmhydGltZSkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBlbGFwc2VkTWljcm9zZWNvbmRzKHN0YXJ0KSB7XG4gICAgaWYgKHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgICAgIGxldCBlbmQgPSBwcm9jZXNzLmhydGltZShzdGFydCk7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IE1hdGgucm91bmQoKGVuZFswXSAqIDEwMDAwMDApICsgKGVuZFsxXSAvIDEwMDApKTtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDEwMDAgKiAoRGF0ZS5ub3coKSAtIHN0YXJ0KTtcbiAgICB9XG59XG4vKipcbiAqIFVzZWQgZm9yIGluLW1lbW9yeSB0ZXN0aW5nLiAgVGhpcyB3aWxsIHF1ZXVlIGEgcmVmZXJlbmNlIHN0cmluZyBmb3IgZWFjaCBjbGllbnQgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUNoZWNrUSA9IGZhbHNlO1xubGV0IGluZGVudFN0cmluZ3MgPSBbXCJcIiwgXCIgXCIsIFwiICBcIl07XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuZWRTcGFjZXMobikge1xuICAgIGlmIChpbmRlbnRTdHJpbmdzW25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZW50U3RyaW5nc1tuXSA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpbmRlbnRTdHJpbmdzW25dICs9IFwiIFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRTdHJpbmdzW25dO1xufVxuZXhwb3J0IGNsYXNzIFJlZ2lzdGVyQ29sbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50Q29sbGVjdGlvbnMgPSBQcm9wZXJ0aWVzLmNyZWF0ZU1hcCgpO1xuICAgICAgICAvLyBUT0RPOiBzbmFwc2hvdFxuICAgIH1cbiAgICBzZXQoY2xpZW50SWQsIGlkLCBzZWdtZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50Q29sbGVjdGlvbnNbY2xpZW50SWRdKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudENvbGxlY3Rpb25zW2NsaWVudElkXSA9IFByb3BlcnRpZXMuY3JlYXRlTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRDb2xsZWN0aW9uc1tjbGllbnRJZF1baWRdID0gc2VnbWVudHM7XG4gICAgfVxuICAgIGdldChjbGllbnRJZCwgaWQpIHtcbiAgICAgICAgbGV0IGNsaWVudENvbGxlY3Rpb24gPSB0aGlzLmNsaWVudENvbGxlY3Rpb25zW2NsaWVudElkXTtcbiAgICAgICAgaWYgKGNsaWVudENvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRDb2xsZWN0aW9uW2lkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMZW5ndGgoY2xpZW50SWQsIGlkKSB7XG4gICAgICAgIGxldCBzZWdzID0gdGhpcy5nZXQoY2xpZW50SWQsIGlkKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGlmIChzZWdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIGxlbiArPSBzZWcuY2FjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIHJlbW92ZUNsaWVudChjbGllbnRJZCkge1xuICAgICAgICB0aGlzLmNsaWVudENvbGxlY3Rpb25zW2NsaWVudElkXSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgdmFyIGNsaWVudFNlcUNvbXBhcmVyID0ge1xuICAgIG1pbjogeyByZWZTZXE6IC0xLCBjbGllbnRJZDogXCJcIiB9LFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhLnJlZlNlcSAtIGIucmVmU2VxXG59O1xudmFyIExSVVNlZ21lbnRDb21wYXJlciA9IHtcbiAgICBtaW46IHsgbWF4U2VxOiAtMiB9LFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhLm1heFNlcSAtIGIubWF4U2VxXG59O1xuZnVuY3Rpb24gZ2xjKG1lcmdlVHJlZSwgaWQpIHtcbiAgICBpZiAobWVyZ2VUcmVlLmdldExvbmdDbGllbnRJZCkge1xuICAgICAgICByZXR1cm4gbWVyZ2VUcmVlLmdldExvbmdDbGllbnRJZChpZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaWQudG9TdHJpbmcoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUxlYWZSYW5nZU1hcmtlcihtYXJrZXIsIHNlYXJjaEluZm8pIHtcbiAgICBmb3IgKGxldCByYW5nZUxhYmVsIG9mIHNlYXJjaEluZm8ucmFuZ2VMYWJlbHMpIHtcbiAgICAgICAgaWYgKG1hcmtlci5oYXNSYW5nZUxhYmVsKHJhbmdlTGFiZWwpKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0YWNrID0gc2VhcmNoSW5mby5zdGFja3NbcmFuZ2VMYWJlbF07XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhY2sgPSBuZXcgQ29sbGVjdGlvbnMuU3RhY2soKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hJbmZvLnN0YWNrc1tyYW5nZUxhYmVsXSA9IGN1cnJlbnRTdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcGx5UmFuZ2VSZWZlcmVuY2UoY3VycmVudFN0YWNrLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUmFuZ2VMZWFmKHNlZ21lbnQsIHNlZ3BvcywgcmVmU2VxLCBjbGllbnRJZCwgc3RhcnQsIGVuZCwgc2VhcmNoSW5mbykge1xuICAgIGlmIChzZWdtZW50LmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuTWFya2VyKSB7XG4gICAgICAgIGxldCBtYXJrZXIgPSBzZWdtZW50O1xuICAgICAgICBpZiAobWFya2VyLnJlZlR5cGUgJlxuICAgICAgICAgICAgKG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RCZWdpbiB8IG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RFbmQpKSB7XG4gICAgICAgICAgICBhcHBseUxlYWZSYW5nZU1hcmtlcihtYXJrZXIsIHNlYXJjaEluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJhbmdlU2hpZnQobm9kZSwgc2VncG9zLCByZWZTZXEsIGNsaWVudElkLCBvZmZzZXQsIGVuZCwgc2VhcmNoSW5mbykge1xuICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgIGxldCBzZWcgPSBub2RlO1xuICAgICAgICBpZiAoKHNlYXJjaEluZm8ubWVyZ2VUcmVlLmxvY2FsTmV0TGVuZ3RoKHNlZykgPiAwKSAmJiAoc2VnLmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuTWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IG1hcmtlciA9IHNlZztcbiAgICAgICAgICAgIGlmIChtYXJrZXIucmVmVHlwZSAmXG4gICAgICAgICAgICAgICAgKG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RCZWdpbiB8IG9wcy5SZWZlcmVuY2VUeXBlLk5lc3RFbmQpKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlMZWFmUmFuZ2VNYXJrZXIobWFya2VyLCBzZWFyY2hJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGJsb2NrID0gbm9kZTtcbiAgICAgICAgYXBwbHlTdGFja0RlbHRhKHNlYXJjaEluZm8uc3RhY2tzLCBibG9jay5yYW5nZVN0YWNrcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVjb3JkVGlsZVN0YXJ0KHNlZ21lbnQsIHNlZ3BvcywgcmVmU2VxLCBjbGllbnRJZCwgc3RhcnQsIGVuZCwgc2VhcmNoSW5mbykge1xuICAgIGlmIChzZWdtZW50LmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuTWFya2VyKSB7XG4gICAgICAgIGxldCBtYXJrZXIgPSBzZWdtZW50O1xuICAgICAgICBpZiAobWFya2VyLmhhc1RpbGVMYWJlbChzZWFyY2hJbmZvLnRpbGVMYWJlbCkpIHtcbiAgICAgICAgICAgIHNlYXJjaEluZm8udGlsZSA9IG1hcmtlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0aWxlU2hpZnQobm9kZSwgc2VncG9zLCByZWZTZXEsIGNsaWVudElkLCBvZmZzZXQsIGVuZCwgc2VhcmNoSW5mbykge1xuICAgIGlmIChub2RlLmlzTGVhZigpKSB7XG4gICAgICAgIGxldCBzZWcgPSBub2RlO1xuICAgICAgICBpZiAoKHNlYXJjaEluZm8ubWVyZ2VUcmVlLmxvY2FsTmV0TGVuZ3RoKHNlZykgPiAwKSAmJiAoc2VnLmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuTWFya2VyKSkge1xuICAgICAgICAgICAgbGV0IG1hcmtlciA9IHNlZztcbiAgICAgICAgICAgIGlmIChtYXJrZXIuaGFzVGlsZUxhYmVsKHNlYXJjaEluZm8udGlsZUxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaEluZm8udGlsZSA9IG1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGJsb2NrID0gbm9kZTtcbiAgICAgICAgbGV0IG1hcmtlcjtcbiAgICAgICAgaWYgKHNlYXJjaEluZm8ucG9zUHJlY2VkZXNUaWxlKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBibG9jay5yaWdodG1vc3RUaWxlc1tzZWFyY2hJbmZvLnRpbGVMYWJlbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBibG9jay5sZWZ0bW9zdFRpbGVzW3NlYXJjaEluZm8udGlsZUxhYmVsXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlYXJjaEluZm8udGlsZSA9IG1hcmtlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmxldCBtaW5MaXN0ZW5lckNvbXBhcmVyID0ge1xuICAgIG1pbjogeyBtaW5SZXF1aXJlZDogTnVtYmVyLk1JTl9WQUxVRSB9LFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhLm1pblJlcXVpcmVkIC0gYi5taW5SZXF1aXJlZCxcbn07XG4vLyByZXByZXNlbnRzIGEgc2VxdWVuY2Ugb2YgdGV4dCBzZWdtZW50c1xuZXhwb3J0IGNsYXNzIE1lcmdlVHJlZSB7XG4gICAgLy8gVE9ETzogbWFrZSBhbmQgdXNlIGludGVyZmFjZSBkZXNjcmliaW5nIG9wdGlvbnNcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMud2luZG93VGltZSA9IDA7XG4gICAgICAgIHRoaXMucGFja1RpbWUgPSAwO1xuICAgICAgICB0aGlzLm9yZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLm1heE9yZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmJsb2NrVXBkYXRlTWFya2VycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbGxhYldpbmRvdyA9IG5ldyBDb2xsYWJvcmF0aW9uV2luZG93KCk7XG4gICAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGlzIHRvIEVTNiBtYXA7IGFkZCByZW1vdmUgb24gc2VnbWVudCByZW1vdmVcbiAgICAgICAgLy8gZm9yIG5vdyBhc3N1bWUgb25seSBtYXJrZXJzIGhhdmUgaWRzIGFuZCBzbyBwb2ludCBkaXJlY3RseSBhdCB0aGUgU2VnbWVudFxuICAgICAgICAvLyBpZiB3ZSBuZWVkIHRvIGhhdmUgcG9pbnRlcnMgdG8gbm9uLW1hcmtlcnMsIHdlIGNhbiBjaGFuZ2UgdG8gcG9pbnQgYXQgbG9jYWwgcmVmc1xuICAgICAgICB0aGlzLmlkVG9TZWdtZW50ID0gUHJvcGVydGllcy5jcmVhdGVNYXAoKTtcbiAgICAgICAgdGhpcy5jbGllbnRJZFRvQnJhbmNoSWQgPSBbXTtcbiAgICAgICAgdGhpcy5sb2NhbEJyYW5jaElkID0gMDtcbiAgICAgICAgdGhpcy5taW5TZXFQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2F0aGVyU2VnbWVudCA9IChzZWdtZW50LCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHN0YXJ0LCBlbmQsIGFjY3VtU2VnbWVudHMpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID4gc2VnbWVudC5jYWNoZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzZWdtZW50LmNhY2hlZExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50LmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgYWNjdW1TZWdtZW50cy5zZWdtZW50cy5wdXNoKHRleHRTZWdtZW50LmNsb25lKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZXIgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIGFjY3VtU2VnbWVudHMuc2VnbWVudHMucHVzaChtYXJrZXIuY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nYXRoZXJUZXh0ID0gKHNlZ21lbnQsIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc3RhcnQsIGVuZCwgYWNjdW1UZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5nZXRUeXBlKCkgPT0gU2VnbWVudFR5cGUuVGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZUdhdGhlclRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEBjbGkgJHt0aGlzLmdldExvbmdDbGllbnRJZCh0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9IGdhdGhlciBzZWcgc2VxICR7dGV4dFNlZ21lbnQuc2VxfSByc2VxICR7dGV4dFNlZ21lbnQucmVtb3ZlZFNlcX0gdGV4dCAke3RleHRTZWdtZW50LnRleHR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWdpblRhZ3MgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxldCBlbmRUYWdzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoYWNjdW1UZXh0LnBhcmFsbGVsQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGxldCBjbGllbnRzIHBhc3MgaW4gZnVuY3Rpb24gdG8gZ2V0IHRhZ1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5pdFRhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRTZWdtZW50LnByb3BlcnRpZXMgJiYgKHRleHRTZWdtZW50LnByb3BlcnRpZXNbXCJmb250LXdlaWdodFwiXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3MucHVzaChcImJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRTZWdtZW50LnByb3BlcnRpZXMgJiYgKHRleHRTZWdtZW50LnByb3BlcnRpZXNbXCJ0ZXh0LWRlY29yYXRpb25cIl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzLnB1c2goXCJ1XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1UYWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY3VtVGV4dC50YWdzSW5Qcm9ncmVzcy5pbmRleE9mKHRhZykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luVGFncyArPSBgPCR7dGFnfT5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0VGFncy5wdXNoKHRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYWNjdW1UYWcgb2YgYWNjdW1UZXh0LnRhZ3NJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ3MuaW5kZXhPZihhY2N1bVRhZykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRhZ3MgKz0gYDwvJHthY2N1bVRhZ30+YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtVGFncy5wdXNoKGFjY3VtVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbml0VGFnIG9mIGluaXRUYWdzLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtVGV4dC50YWdzSW5Qcm9ncmVzcy5wdXNoKGluaXRUYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYWNjdW1UYWcgb2YgYWNjdW1UZXh0LnRhZ3NJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGFncyArPSBgPC8ke2FjY3VtVGFnfT5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbVRhZ3MucHVzaChhY2N1bVRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmVtVGFnIG9mIHJlbVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW1kZXggPSBhY2N1bVRleHQudGFnc0luUHJvZ3Jlc3MuaW5kZXhPZihyZW1UYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1UZXh0LnRhZ3NJblByb2dyZXNzLnNwbGljZShyZW1kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtVGV4dC50ZXh0U2VnbWVudC50ZXh0ICs9IGVuZFRhZ3M7XG4gICAgICAgICAgICAgICAgYWNjdW1UZXh0LnRleHRTZWdtZW50LnRleHQgKz0gYmVnaW5UYWdzO1xuICAgICAgICAgICAgICAgIGlmICgoc3RhcnQgPD0gMCkgJiYgKGVuZCA+PSB0ZXh0U2VnbWVudC50ZXh0Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1UZXh0LnRleHRTZWdtZW50LnRleHQgKz0gdGV4dFNlZ21lbnQudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID49IHRleHRTZWdtZW50LnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVRleHQudGV4dFNlZ21lbnQudGV4dCArPSB0ZXh0U2VnbWVudC50ZXh0LnN1YnN0cmluZyhzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVRleHQudGV4dFNlZ21lbnQudGV4dCArPSB0ZXh0U2VnbWVudC50ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhY2N1bVRleHQucGxhY2Vob2xkZXIgJiYgKGFjY3VtVGV4dC5wbGFjZWhvbGRlci5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjdW1UZXh0LnBsYWNlaG9sZGVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtlciA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVRleHQudGV4dFNlZ21lbnQudGV4dCArPSBgXFxuJHttYXJrZXIudG9TdHJpbmcoKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50LmNhY2hlZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1UZXh0LnRleHRTZWdtZW50LnRleHQgKz0gYWNjdW1UZXh0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjY3VtVGV4dC5wYXJhbGxlbEFycmF5cykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya2VyID0gc2VnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlci5oYXNUaWxlTGFiZWwoYWNjdW1UZXh0LnBhcmFsbGVsTWFya2VyTGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVRleHQucGFyYWxsZWxNYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtVGV4dC5wYXJhbGxlbFRleHQucHVzaChhY2N1bVRleHQudGV4dFNlZ21lbnQudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVRleHQudGV4dFNlZ21lbnQudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGxpdExlYWZTZWdtZW50ID0gKHNlZ21lbnQsIHBvcykgPT4ge1xuICAgICAgICAgICAgbGV0IHNlZ21lbnRDaGFuZ2VzID0ge307XG4gICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRDaGFuZ2VzLm5leHQgPSBzZWdtZW50LnNwbGl0QXQocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50Q2hhbmdlcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibG9ja1VwZGF0ZUFjdGlvbnMgPSBNZXJnZVRyZWUuaW5pdEJsb2NrVXBkYXRlQWN0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJsb2NrVXBkYXRlTWFya2Vycykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tVcGRhdGVNYXJrZXJzID0gb3B0aW9ucy5ibG9ja1VwZGF0ZU1hcmtlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbE1pblNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYWJXaW5kb3cubG9jYWxNaW5TZXEgPSBvcHRpb25zLmxvY2FsTWluU2VxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuaW5pdGlhbFRleHROb2RlKHRoaXMudGV4dCk7XG4gICAgfVxuICAgIG1ha2VCbG9jayhjaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBibG9jaztcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tVcGRhdGVNYXJrZXJzKSB7XG4gICAgICAgICAgICBibG9jayA9IG5ldyBIaWVyTWVyZ2VCbG9jayhjaGlsZENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrID0gbmV3IE1lcmdlQmxvY2soY2hpbGRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2sub3JkaW5hbCA9IFwiXCI7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgaW5pdGlhbFRleHROb2RlKHRleHQpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gdGhpcy5tYWtlQmxvY2soMSk7XG4gICAgICAgIGJsb2NrLm9yZGluYWwgPSBcIlwiO1xuICAgICAgICBibG9jay5hc3NpZ25DaGlsZChuZXcgVGV4dFNlZ21lbnQodGV4dCwgVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIExvY2FsQ2xpZW50SWQpLCAwKTtcbiAgICAgICAgYmxvY2suY2FjaGVkTGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgYmxvY2tVcGRhdGVNYXJrZXJzOiB0aGlzLmJsb2NrVXBkYXRlTWFya2VycyxcbiAgICAgICAgICAgIGxvY2FsTWluU2VxOiB0aGlzLmNvbGxhYldpbmRvdy5sb2NhbE1pblNlcVxuICAgICAgICB9O1xuICAgICAgICBsZXQgYiA9IG5ldyBNZXJnZVRyZWUoXCJcIiwgb3B0aW9ucyk7XG4gICAgICAgIC8vIGZvciBub3cgYXNzdW1lIHRoYXQgYiB3aWxsIG5vdCBjb2xsYWJvcmF0ZVxuICAgICAgICBiLnJvb3QgPSBiLmJsb2NrQ2xvbmUodGhpcy5yb290KTtcbiAgICB9XG4gICAgYmxvY2tDbG9uZShibG9jaywgc2VnbWVudHMpIHtcbiAgICAgICAgbGV0IGJCbG9jayA9IHRoaXMubWFrZUJsb2NrKGJsb2NrLmNoaWxkQ291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuc2VnbWVudENsb25lKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBiQmxvY2suYXNzaWduQ2hpbGQoc2VnbWVudCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYkJsb2NrLmFzc2lnbkNoaWxkKHRoaXMuYmxvY2tDbG9uZShjaGlsZCwgc2VnbWVudHMpLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVVcGRhdGVMZW5ndGhOZXdTdHJ1Y3R1cmUoYkJsb2NrKTtcbiAgICAgICAgdGhpcy5ub2RlVXBkYXRlT3JkaW5hbHMoYkJsb2NrKTtcbiAgICAgICAgcmV0dXJuIGJCbG9jaztcbiAgICB9XG4gICAgc2VnbWVudENsb25lKHNlZ21lbnQpIHtcbiAgICAgICAgbGV0IGIgPSBzZWdtZW50LmNsb25lKCk7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBzdGFydEdyb3VwT3BlcmF0aW9uKGxpdmVTZWdtZW50R3JvdXApIHtcbiAgICAgICAgLy8gVE9ETzogYXNzZXJ0IHVuZGVmaW5lZFxuICAgICAgICBpZiAodGhpcy5jb2xsYWJXaW5kb3cuY29sbGFib3JhdGluZykge1xuICAgICAgICAgICAgaWYgKGxpdmVTZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uU2VnbWVudEdyb3VwID0gbGl2ZVNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25TZWdtZW50R3JvdXAgPSB7IHNlZ21lbnRzOiBbXSB9O1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1NlZ21lbnRzLmVucXVldWUodGhpcy50cmFuc2FjdGlvblNlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvblNlZ21lbnRHcm91cDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmRHcm91cE9wZXJhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGFiV2luZG93LmNvbGxhYm9yYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25TZWdtZW50R3JvdXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxOZXRMZW5ndGgoc2VnbWVudCkge1xuICAgICAgICBsZXQgc2VnQnJhbmNoSWQgPSB0aGlzLmdldEJyYW5jaElkKHNlZ21lbnQuY2xpZW50SWQpO1xuICAgICAgICBsZXQgcmVtb3ZhbEluZm8gPSBzZWdtZW50O1xuICAgICAgICBpZiAodGhpcy5sb2NhbEJyYW5jaElkID4gc2VnQnJhbmNoSWQpIHtcbiAgICAgICAgICAgIHJlbW92YWxJbmZvID0gdGhpcy5nZXRSZW1vdmFsSW5mbyh0aGlzLmxvY2FsQnJhbmNoSWQsIHNlZ0JyYW5jaElkLCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50LmNhY2hlZExlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCcmFuY2hJZChjbGllbnRJZCkge1xuICAgICAgICBpZiAoKHRoaXMuY2xpZW50SWRUb0JyYW5jaElkLmxlbmd0aCA+IGNsaWVudElkKSAmJiAoY2xpZW50SWQgPj0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudElkVG9CcmFuY2hJZFtjbGllbnRJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50SWQgPT09IExvY2FsQ2xpZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxCcmFuY2hJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiByZW1vdmUgaWQgd2hlbiBzZWdtZW50IHJlbW92ZWRcbiAgICBtYXBJZFRvU2VnbWVudChpZCwgc2VnbWVudCkge1xuICAgICAgICB0aGlzLmlkVG9TZWdtZW50W2lkXSA9IHNlZ21lbnQ7XG4gICAgfVxuICAgIGFkZE5vZGUoYmxvY2ssIG5vZGUpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYmxvY2suY2hpbGRDb3VudCsrO1xuICAgICAgICBibG9jay5hc3NpZ25DaGlsZChub2RlLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIHJlbG9hZEZyb21TZWdtZW50cyhzZWdtZW50cykge1xuICAgICAgICBsZXQgc2VnQ2FwID0gTWF4Tm9kZXNJbkJsb2NrIC0gMTtcbiAgICAgICAgY29uc3QgbWVhc3VyZVJlbG9hZFRpbWUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGJ1aWxkTWVyZ2VCbG9jayA9IChub2RlcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUNvdW50ID0gTWF0aC5jZWlsKG5vZGVzLmxlbmd0aCAvIHNlZ0NhcCk7XG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpXSA9IHRoaXMubWFrZUJsb2NrKDApO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VnQ2FwOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkSW5kZXggPSB0aGlzLmFkZE5vZGUoYmxvY2tzW2ldLCBub2Rlc1tub2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBub2Rlc1tub2RlSW5kZXhdLmNhY2hlZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrVXBkYXRlTWFya2Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoaWVyQmxvY2sgPSBibG9ja3NbaV0uaGllckJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGllckJsb2NrLmFkZE5vZGVSZWZlcmVuY2VzKHRoaXMsIG5vZGVzW25vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tVcGRhdGVBY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja1VwZGF0ZUFjdGlvbnMuY2hpbGQoYmxvY2tzW2ldLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9ja3NbaV0uY2FjaGVkTGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja3NbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRNZXJnZUJsb2NrKGJsb2Nrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjbG9ja1N0YXJ0O1xuICAgICAgICBpZiAobWVhc3VyZVJlbG9hZFRpbWUpIHtcbiAgICAgICAgICAgIGNsb2NrU3RhcnQgPSBjbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm1ha2VCbG9jaygxKTtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGJ1aWxkTWVyZ2VCbG9jayhzZWdtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJvb3QuYXNzaWduQ2hpbGQoYmxvY2ssIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrVXBkYXRlTWFya2Vycykge1xuICAgICAgICAgICAgICAgIGxldCBoaWVyUm9vdCA9IHRoaXMucm9vdC5oaWVyQmxvY2soKTtcbiAgICAgICAgICAgICAgICBoaWVyUm9vdC5hZGROb2RlUmVmZXJlbmNlcyh0aGlzLCBibG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja1VwZGF0ZUFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlQWN0aW9ucy5jaGlsZCh0aGlzLnJvb3QsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub2RlVXBkYXRlT3JkaW5hbHModGhpcy5yb290KTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5jYWNoZWRMZW5ndGggPSBibG9jay5jYWNoZWRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm1ha2VCbG9jaygwKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5jYWNoZWRMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5pbmRleCA9IDA7XG4gICAgICAgIGlmIChtZWFzdXJlUmVsb2FkVGltZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHJlbG9hZCB0aW1lICR7ZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igbm93IGFzc3VtZSBtaW4gc3RhcnRzIGF0IHplcm9cbiAgICBzdGFydENvbGxhYm9yYXRpb24obG9jYWxDbGllbnRJZCwgbWluU2VxLCBicmFuY2hJZCkge1xuICAgICAgICB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCA9IGxvY2FsQ2xpZW50SWQ7XG4gICAgICAgIHRoaXMuY29sbGFiV2luZG93Lm1pblNlcSA9IG1pblNlcTtcbiAgICAgICAgdGhpcy5jb2xsYWJXaW5kb3cuY29sbGFib3JhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29sbGFiV2luZG93LmN1cnJlbnRTZXEgPSBtaW5TZXE7XG4gICAgICAgIHRoaXMubG9jYWxCcmFuY2hJZCA9IGJyYW5jaElkO1xuICAgICAgICB0aGlzLnNlZ21lbnRzVG9TY291ciA9IG5ldyBDb2xsZWN0aW9ucy5IZWFwKFtdLCBMUlVTZWdtZW50Q29tcGFyZXIpO1xuICAgICAgICB0aGlzLnBlbmRpbmdTZWdtZW50cyA9IENvbGxlY3Rpb25zLkxpc3RNYWtlSGVhZCgpO1xuICAgICAgICBsZXQgbWVhc3VyZUZ1bGxDb2xsYWIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNsb2NrU3RhcnQ7XG4gICAgICAgIGlmIChtZWFzdXJlRnVsbENvbGxhYikge1xuICAgICAgICAgICAgY2xvY2tTdGFydCA9IGNsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlVXBkYXRlTGVuZ3RoTmV3U3RydWN0dXJlKHRoaXMucm9vdCwgdHJ1ZSk7XG4gICAgICAgIGlmIChtZWFzdXJlRnVsbENvbGxhYikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHVwZGF0ZSBwYXJ0aWFsIGxlbmd0aHMgYXQgc3RhcnQgJHtlbGFwc2VkTWljcm9zZWNvbmRzKGNsb2NrU3RhcnQpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRvTFJVU2V0KHNlZ21lbnQsIHNlcSkge1xuICAgICAgICB0aGlzLnNlZ21lbnRzVG9TY291ci5hZGQoeyBzZWdtZW50OiBzZWdtZW50LCBtYXhTZXE6IHNlcSB9KTtcbiAgICB9XG4gICAgdW5kZXJmbG93KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCA8IChNYXhOb2Rlc0luQmxvY2sgLyAyKTtcbiAgICB9XG4gICAgc2NvdXJOb2RlKG5vZGUsIGhvbGROb2Rlcykge1xuICAgICAgICBsZXQgcHJldlNlZ21lbnQ7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbm9kZS5jaGlsZENvdW50OyBrKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLmNoaWxkcmVuW2tdO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gY2hpbGROb2RlO1xuICAgICAgICAgICAgICAgIGlmICgoc2VnbWVudC5yZW1vdmVkU2VxICE9PSB1bmRlZmluZWQpICYmIChzZWdtZW50LnJlbW92ZWRTZXEgIT09IFVuYXNzaWduZWRTZXF1ZW5jZU51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNyZWF0ZUJyaWQgPSB0aGlzLmdldEJyYW5jaElkKHNlZ21lbnQuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVtb3ZlQnJpZCA9IHRoaXMuZ2V0QnJhbmNoSWQoc2VnbWVudC5yZW1vdmVkQ2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlbW92ZUJyaWQgIT0gY3JlYXRlQnJpZCkgfHwgKHNlZ21lbnQucmVtb3ZlZFNlcSA+IHRoaXMuY29sbGFiV2luZG93Lm1pblNlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGROb2Rlcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZVpSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHt0aGlzLmdldExvbmdDbGllbnRJZCh0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9OiBacmVtb3ZlICR7c2VnbWVudC50ZXh0fTsgY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQoc2VnbWVudC5jbGllbnRJZCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2U2VnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2VnbWVudC5zZXEgPD0gdGhpcy5jb2xsYWJXaW5kb3cubWluU2VxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5zZWdtZW50R3JvdXBzLmVtcHR5ICYmIChzZWdtZW50LnNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlNlZ21lbnQgJiYgcHJldlNlZ21lbnQuY2FuQXBwZW5kKHNlZ21lbnQsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZUFwcGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHt0aGlzLmdldExvbmdDbGllbnRJZCh0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9OiBhcHBlbmQgJHtwcmV2U2VnbWVudC50ZXh0fSArICR7c2VnbWVudC50ZXh0fTsgY2xpICR7dGhpcy5nZXRMb25nQ2xpZW50SWQocHJldlNlZ21lbnQuY2xpZW50SWQpfSArIGNsaSAke3RoaXMuZ2V0TG9uZ0NsaWVudElkKHNlZ21lbnQuY2xpZW50SWQpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2U2VnbWVudC5hcHBlbmQoc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkTm9kZXMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2NhbE5ldExlbmd0aChzZWdtZW50KSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNlZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZE5vZGVzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U2VnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvbGROb2Rlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgcHJldlNlZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaW50ZXJpb3Igbm9kZSB3aXRoIGFsbCBub2RlIGNoaWxkcmVuXG4gICAgcGFjayhibG9jaykge1xuICAgICAgICBsZXQgcGFyZW50ID0gYmxvY2sucGFyZW50O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGxldCBjaGlsZEluZGV4O1xuICAgICAgICBsZXQgY2hpbGRCbG9jaztcbiAgICAgICAgbGV0IGhvbGROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGNoaWxkSW5kZXggPSAwOyBjaGlsZEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQ7IGNoaWxkSW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZGVidWcgYXNzZXJ0IG5vdCBpc0xlYWYoKVxuICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zY291ck5vZGUoY2hpbGRCbG9jaywgaG9sZE5vZGVzKTtcbiAgICAgICAgICAgIC8vIHdpbGwgcmVwbGFjZSB0aGlzIGJsb2NrIHdpdGggYSBwYWNrZWQgYmxvY2tcbiAgICAgICAgICAgIGNoaWxkQmxvY2sucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbE5vZGVDb3VudCA9IGhvbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBoYWxmQ291bnQgPSBNYXhOb2Rlc0luQmxvY2sgLyAyO1xuICAgICAgICBsZXQgY2hpbGRDb3VudCA9IE1hdGgubWluKE1heE5vZGVzSW5CbG9jayAtIDEsIE1hdGguZmxvb3IodG90YWxOb2RlQ291bnQgLyBoYWxmQ291bnQpKTtcbiAgICAgICAgaWYgKGNoaWxkQ291bnQgPCAxKSB7XG4gICAgICAgICAgICBjaGlsZENvdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmFzZUNvdW50ID0gTWF0aC5mbG9vcih0b3RhbE5vZGVDb3VudCAvIGNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgZXh0cmFDb3VudCA9IHRvdGFsTm9kZUNvdW50ICUgY2hpbGRDb3VudDtcbiAgICAgICAgbGV0IHBhY2tlZEJsb2NrcyA9IG5ldyBBcnJheShNYXhOb2Rlc0luQmxvY2spO1xuICAgICAgICBsZXQgcmVhZENvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMDsgbm9kZUluZGV4IDwgY2hpbGRDb3VudDsgbm9kZUluZGV4KyspIHtcbiAgICAgICAgICAgIGxldCBub2RlQ291bnQgPSBiYXNlQ291bnQ7XG4gICAgICAgICAgICBpZiAoZXh0cmFDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlQ291bnQrKztcbiAgICAgICAgICAgICAgICBleHRyYUNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFja2VkQmxvY2sgPSB0aGlzLm1ha2VCbG9jayhub2RlQ291bnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgcGFja2VkTm9kZUluZGV4ID0gMDsgcGFja2VkTm9kZUluZGV4IDwgbm9kZUNvdW50OyBwYWNrZWROb2RlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlVG9QYWNrID0gaG9sZE5vZGVzW3JlYWRDb3VudCsrXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRCbG9jay5hc3NpZ25DaGlsZChub2RlVG9QYWNrLCBwYWNrZWROb2RlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhY2tlZEJsb2NrLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhY2tlZEJsb2Nrc1tub2RlSW5kZXhdID0gcGFja2VkQmxvY2s7XG4gICAgICAgICAgICB0aGlzLm5vZGVVcGRhdGVMZW5ndGhOZXdTdHJ1Y3R1cmUocGFja2VkQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkQ291bnQgIT0gdG90YWxOb2RlQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGB0b3RhbCBjb3VudCAke3RvdGFsTm9kZUNvdW50fSByZWFkQ291bnQgJHtyZWFkQ291bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuID0gcGFja2VkQmxvY2tzO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkQ291bnQ7IGorKykge1xuICAgICAgICAgICAgcGFyZW50LmFzc2lnbkNoaWxkKHBhY2tlZEJsb2Nrc1tqXSwgaiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5jaGlsZENvdW50ID0gY2hpbGRDb3VudDtcbiAgICAgICAgaWYgKHRoaXMudW5kZXJmbG93KHBhcmVudCkgJiYgKHBhcmVudC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnBhY2socGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZU9yZGluYWxzKHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlUGF0aExlbmd0aHMocGFyZW50LCBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIsIC0xLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB6YW1ib25pU2VnbWVudHMoKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coYHNjb3VyIGxpbmUgJHtzZWdtZW50c1RvU2NvdXIuY291bnQoKX1gKTtcbiAgICAgICAgbGV0IGNsb2NrU3RhcnQ7XG4gICAgICAgIGlmIChNZXJnZVRyZWUub3B0aW9ucy5tZWFzdXJlV2luZG93VGltZSkge1xuICAgICAgICAgICAgY2xvY2tTdGFydCA9IGNsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlZ21lbnRUb1Njb3VyID0gdGhpcy5zZWdtZW50c1RvU2NvdXIucGVlaygpO1xuICAgICAgICBpZiAoc2VnbWVudFRvU2NvdXIgJiYgKHNlZ21lbnRUb1Njb3VyLm1heFNlcSA8PSB0aGlzLmNvbGxhYldpbmRvdy5taW5TZXEpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1lcmdlVHJlZS56YW1ib25pU2VnbWVudHNNYXhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudFRvU2NvdXIgPSB0aGlzLnNlZ21lbnRzVG9TY291ci5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudFRvU2NvdXIgJiYgc2VnbWVudFRvU2NvdXIuc2VnbWVudC5wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlZ21lbnRUb1Njb3VyLm1heFNlcSA8PSB0aGlzLmNvbGxhYldpbmRvdy5taW5TZXEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBibG9jayA9IHNlZ21lbnRUb1Njb3VyLnNlZ21lbnQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW5Db3B5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBzY291cmluZyBmcm9tICR7c2VnbWVudFRvU2NvdXIuc2VnbWVudC5zZXF9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvdXJOb2RlKGJsb2NrLCBjaGlsZHJlbkNvcHkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Q2hpbGRDb3VudCA9IGNoaWxkcmVuQ29weS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZENvdW50IDwgYmxvY2suY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suY2hpbGRDb3VudCA9IG5ld0NoaWxkQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5jaGlsZHJlbiA9IGNoaWxkcmVuQ29weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3Q2hpbGRDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suYXNzaWduQ2hpbGQoY2hpbGRyZW5Db3B5W2pdLCBqLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51bmRlcmZsb3coYmxvY2spICYmIGJsb2NrLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9kZVVwZGF0ZVBhdGhMZW5ndGhzKG5vZGUsIFVuYXNzaWduZWRTZXF1ZW5jZU51bWJlciwgLTEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYWNrQ2xvY2tTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWVyZ2VUcmVlLm9wdGlvbnMubWVhc3VyZVdpbmRvd1RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja0Nsb2NrU3RhcnQgPSBjbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2soYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNZXJnZVRyZWUub3B0aW9ucy5tZWFzdXJlV2luZG93VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tUaW1lICs9IGVsYXBzZWRNaWNyb3NlY29uZHMocGFja0Nsb2NrU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZU9yZGluYWxzKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlUGF0aExlbmd0aHMoYmxvY2ssIFVuYXNzaWduZWRTZXF1ZW5jZU51bWJlciwgLTEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1lcmdlVHJlZS5vcHRpb25zLm1lYXN1cmVXaW5kb3dUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd1RpbWUgKz0gZWxhcHNlZE1pY3Jvc2Vjb25kcyhjbG9ja1N0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb2xsYWJXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxhYldpbmRvdztcbiAgICB9XG4gICAgZ2V0U3RhdHMoKSB7XG4gICAgICAgIGxldCBub2RlR2V0U3RhdHMgPSAoYmxvY2spID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0cyA9IHsgbWF4SGVpZ2h0OiAwLCBub2RlQ291bnQ6IDAsIGxlYWZDb3VudDogMCwgcmVtb3ZlZExlYWZDb3VudDogMCwgbGl2ZUNvdW50OiAwLCBoaXN0bzogW10gfTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTWF4Tm9kZXNJbkJsb2NrOyBrKyspIHtcbiAgICAgICAgICAgICAgICBzdGF0cy5oaXN0b1trXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSAxO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkU3RhdHMgPSBub2RlR2V0U3RhdHMoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAxICsgY2hpbGRTdGF0cy5tYXhIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLm5vZGVDb3VudCArPSBjaGlsZFN0YXRzLm5vZGVDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMubGVhZkNvdW50ICs9IGNoaWxkU3RhdHMubGVhZkNvdW50O1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5yZW1vdmVkTGVhZkNvdW50ICs9IGNoaWxkU3RhdHMucmVtb3ZlZExlYWZDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMubGl2ZUNvdW50ICs9IGNoaWxkU3RhdHMubGl2ZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1heE5vZGVzSW5CbG9jazsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5oaXN0b1tpXSArPSBjaGlsZFN0YXRzLmhpc3RvW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5sZWFmQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlZ21lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQucmVtb3ZlZFNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5yZW1vdmVkTGVhZkNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCA+IHN0YXRzLm1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5tYXhIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdHMuaGlzdG9bYmxvY2suY2hpbGRDb3VudF0rKztcbiAgICAgICAgICAgIHN0YXRzLm5vZGVDb3VudCsrO1xuICAgICAgICAgICAgc3RhdHMubGl2ZUNvdW50ICs9IGJsb2NrLmNoaWxkQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICAgIH07XG4gICAgICAgIGxldCByb290U3RhdHMgPSBub2RlR2V0U3RhdHModGhpcy5yb290KTtcbiAgICAgICAgaWYgKE1lcmdlVHJlZS5vcHRpb25zLm1lYXN1cmVXaW5kb3dUaW1lKSB7XG4gICAgICAgICAgICByb290U3RhdHMud2luZG93VGltZSA9IHRoaXMud2luZG93VGltZTtcbiAgICAgICAgICAgIHJvb3RTdGF0cy5wYWNrVGltZSA9IHRoaXMucGFja1RpbWU7XG4gICAgICAgICAgICByb290U3RhdHMub3JkVGltZSA9IHRoaXMub3JkVGltZTtcbiAgICAgICAgICAgIHJvb3RTdGF0cy5tYXhPcmRUaW1lID0gdGhpcy5tYXhPcmRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290U3RhdHM7XG4gICAgfVxuICAgIHRhcmRpc1Bvc2l0aW9uKHBvcywgZnJvbVNlcSwgdG9TZXEsIHRvQ2xpZW50SWQgPSBOb25Db2xsYWJDbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZGlzUG9zaXRpb25Gcm9tQ2xpZW50KHBvcywgZnJvbVNlcSwgdG9TZXEsIE5vbkNvbGxhYkNsaWVudCwgdG9DbGllbnRJZCk7XG4gICAgfVxuICAgIHRhcmRpc1Bvc2l0aW9uRnJvbUNsaWVudChwb3MsIGZyb21TZXEsIHRvU2VxLCBmcm9tQ2xpZW50SWQsIHRvQ2xpZW50SWQgPSBOb25Db2xsYWJDbGllbnQpIHtcbiAgICAgICAgaWYgKCgoZnJvbVNlcSA8IHRvU2VxKSB8fCAodG9DbGllbnRJZCA9PT0gdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpKSAmJiBwb3MgPCB0aGlzLmdldExlbmd0aChmcm9tU2VxLCBmcm9tQ2xpZW50SWQpKSB7XG4gICAgICAgICAgICBpZiAoKHRvU2VxIDw9IHRoaXMuY29sbGFiV2luZG93LmN1cnJlbnRTZXEpICYmIChmcm9tU2VxID49IHRoaXMuY29sbGFiV2luZG93Lm1pblNlcSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2Vnb2ZmID0gdGhpcy5nZXRDb250YWluaW5nU2VnbWVudChwb3MsIGZyb21TZXEsIGZyb21DbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgbGV0IHRvUG9zID0gdGhpcy5nZXRPZmZzZXQoc2Vnb2ZmLnNlZ21lbnQsIHRvU2VxLCB0b0NsaWVudElkKTtcbiAgICAgICAgICAgICAgICBsZXQgcmV0ID0gdG9Qb3MgKyBzZWdvZmYub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGFzc2VydChyZXQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhcmRpc1JhbmdlRnJvbUNsaWVudChyYW5nZVN0YXJ0LCByYW5nZUVuZCwgZnJvbVNlcSwgdG9TZXEsIGZyb21DbGllbnRJZCwgdG9DbGllbnRJZCA9IE5vbkNvbGxhYkNsaWVudCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGxldCByZWNvcmRSYW5nZSA9IChzZWdtZW50LCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlZ1N0YXJ0LCBzZWdFbmQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVMZW5ndGgoc2VnbWVudCwgdG9TZXEsIHRvQ2xpZW50SWQpID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmdldE9mZnNldChzZWdtZW50LCB0b1NlcSwgdG9DbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ1N0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWdFbmQgPiBzZWdtZW50LmNhY2hlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdFbmQgPSBzZWdtZW50LmNhY2hlZExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBzdGFydDogb2Zmc2V0ICsgc2VnU3RhcnQsIGVuZDogb2Zmc2V0ICsgc2VnRW5kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFwUmFuZ2UoeyBsZWFmOiByZWNvcmRSYW5nZSB9LCBmcm9tU2VxLCBmcm9tQ2xpZW50SWQsIHVuZGVmaW5lZCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICB0YXJkaXNSYW5nZShyYW5nZVN0YXJ0LCByYW5nZUVuZCwgZnJvbVNlcSwgdG9TZXEsIHRvQ2xpZW50SWQgPSBOb25Db2xsYWJDbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZGlzUmFuZ2VGcm9tQ2xpZW50KHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmcm9tU2VxLCB0b1NlcSwgTm9uQ29sbGFiQ2xpZW50LCB0b0NsaWVudElkKTtcbiAgICB9XG4gICAgZ2V0TGVuZ3RoKHJlZlNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tMZW5ndGgodGhpcy5yb290LCByZWZTZXEsIGNsaWVudElkKTtcbiAgICB9XG4gICAgZ2V0T2Zmc2V0KG5vZGUsIHJlZlNlcSwgY2xpZW50SWQpIHtcbiAgICAgICAgbGV0IHRvdGFsT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICBsZXQgcHJldlBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudDsgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKChwcmV2UGFyZW50ICYmIChjaGlsZCA9PSBwcmV2UGFyZW50KSkgfHwgKGNoaWxkID09IG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbE9mZnNldCArPSB0aGlzLm5vZGVMZW5ndGgoY2hpbGQsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsT2Zmc2V0O1xuICAgIH1cbiAgICBzZWFyY2hGcm9tUG9zKHBvcywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcztcbiAgICAgICAgbGV0IGVuZCA9IHBvcyArIE1lcmdlVHJlZS5zZWFyY2hDaHVua1NpemU7XG4gICAgICAgIGxldCBjaHVuayA9IFwiXCI7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gdGhpcy5yb290LmNhY2hlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucm9vdC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVuayArPSB0aGlzLmdldFRleHQoVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkLCBcIlwiLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjaHVuay5tYXRjaCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IHJlc3VsdFswXSwgcG9zOiByZXN1bHQuaW5kZXggfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ICs9IE1lcmdlVHJlZS5zZWFyY2hDaHVua1NpemU7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPj0gdGhpcy5yb290LmNhY2hlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kICs9IE1lcmdlVHJlZS5zZWFyY2hDaHVua1NpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jcmVtZW50YWxHZXRUZXh0KHJlZlNlcSwgY2xpZW50SWQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYmxvY2tMZW5ndGgodGhpcy5yb290LCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBUZXh0U2VnbWVudChcIlwiKTtcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IENvbGxlY3Rpb25zLlN0YWNrKCk7XG4gICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSBuZXcgSW5jcmVtZW50YWxNYXBTdGF0ZSh0aGlzLnJvb3QsIHsgbGVhZjogaW5jcmVtZW50YWxHYXRoZXJUZXh0IH0sIDAsIHJlZlNlcSwgY2xpZW50SWQsIGNvbnRleHQsIHN0YXJ0LCBlbmQsIDApO1xuICAgICAgICBzdGFjay5wdXNoKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIHdoaWxlICghc3RhY2suZW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRhbEJsb2NrTWFwKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dC50ZXh0O1xuICAgIH1cbiAgICBnZXRUZXh0QW5kTWFya2VycyhyZWZTZXEsIGNsaWVudElkLCBsYWJlbCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5ibG9ja0xlbmd0aCh0aGlzLnJvb3QsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2N1bSA9IHtcbiAgICAgICAgICAgIHRleHRTZWdtZW50OiBuZXcgVGV4dFNlZ21lbnQoXCJcIiksIHBhcmFsbGVsTWFya2VyTGFiZWw6IGxhYmVsLCBwYXJhbGxlbEFycmF5czogdHJ1ZSwgcGFyYWxsZWxNYXJrZXJzOiBbXSwgcGFyYWxsZWxUZXh0OiBbXSxcbiAgICAgICAgICAgIHRhZ3NJblByb2dyZXNzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlR2F0aGVyVGV4dCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGdldCB0ZXh0IG9uIGNsaSAke2dsYyh0aGlzLCB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9IHJlZiBjbGkgJHtnbGModGhpcywgY2xpZW50SWQpfSByZWZTZXEgJHtyZWZTZXF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXBSYW5nZSh7IGxlYWY6IHRoaXMuZ2F0aGVyVGV4dCB9LCByZWZTZXEsIGNsaWVudElkLCBhY2N1bSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB7IHBhcmFsbGVsVGV4dDogYWNjdW0ucGFyYWxsZWxUZXh0LCBwYXJhbGxlbE1hcmtlcnM6IGFjY3VtLnBhcmFsbGVsTWFya2VycyB9O1xuICAgIH1cbiAgICBjbG9uZVNlZ21lbnRzKHJlZlNlcSwgY2xpZW50SWQsIHN0YXJ0ID0gMCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5ibG9ja0xlbmd0aCh0aGlzLnJvb3QsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2N1bSA9IHtcbiAgICAgICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcFJhbmdlKHsgbGVhZjogdGhpcy5nYXRoZXJTZWdtZW50IH0sIHJlZlNlcSwgY2xpZW50SWQsIGFjY3VtLCBzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIGFjY3VtLnNlZ21lbnRzO1xuICAgIH1cbiAgICBnZXRJdGVtcyhyZWZTZXEsIGNsaWVudElkLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBhY2N1bSA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBnYXRoZXJJdGVtcyhzZWdtZW50LCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuUnVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuU2VnID0gc2VnbWVudDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcnVuU2VnLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwUmFuZ2UoeyBsZWFmOiBnYXRoZXJJdGVtcyB9LCByZWZTZXEsIGNsaWVudElkLCBhY2N1bSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9XG4gICAgZ2V0VGV4dChyZWZTZXEsIGNsaWVudElkLCBwbGFjZWhvbGRlciA9IFwiXCIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYmxvY2tMZW5ndGgodGhpcy5yb290LCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWNjdW0gPSB7IHRleHRTZWdtZW50OiBuZXcgVGV4dFNlZ21lbnQoXCJcIiksIHBsYWNlaG9sZGVyIH07XG4gICAgICAgIGlmIChNZXJnZVRyZWUudHJhY2VHYXRoZXJUZXh0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgZ2V0IHRleHQgb24gY2xpICR7Z2xjKHRoaXMsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkKX0gcmVmIGNsaSAke2dsYyh0aGlzLCBjbGllbnRJZCl9IHJlZlNlcSAke3JlZlNlcX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcFJhbmdlKHsgbGVhZjogdGhpcy5nYXRoZXJUZXh0IH0sIHJlZlNlcSwgY2xpZW50SWQsIGFjY3VtLCBzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIGFjY3VtLnRleHRTZWdtZW50LnRleHQ7XG4gICAgfVxuICAgIGdldENvbnRhaW5pbmdTZWdtZW50KHBvcywgcmVmU2VxLCBjbGllbnRJZCkge1xuICAgICAgICBsZXQgc2VnbWVudDtcbiAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgbGV0IGxlYWYgPSAobGVhZlNlZywgc2VncG9zLCByZWZTZXEsIGNsaWVudElkLCBzdGFydCkgPT4ge1xuICAgICAgICAgICAgc2VnbWVudCA9IGxlYWZTZWc7XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWFyY2hCbG9jayh0aGlzLnJvb3QsIHBvcywgMCwgcmVmU2VxLCBjbGllbnRJZCwgeyBsZWFmIH0pO1xuICAgICAgICByZXR1cm4geyBzZWdtZW50LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgYmxvY2tMZW5ndGgobm9kZSwgcmVmU2VxLCBjbGllbnRJZCkge1xuICAgICAgICBpZiAoKHRoaXMuY29sbGFiV2luZG93LmNvbGxhYm9yYXRpbmcpICYmIChjbGllbnRJZCAhPSB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcnRpYWxMZW5ndGhzLmdldFBhcnRpYWxMZW5ndGgodGhpcywgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jYWNoZWRMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVtb3ZhbEluZm8oYnJhbmNoSWQsIHNlZ0JyYW5jaElkLCBzZWdtZW50KSB7XG4gICAgICAgIGlmIChicmFuY2hJZCA+IHNlZ0JyYW5jaElkKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAoYnJhbmNoSWQgLSBzZWdCcmFuY2hJZCkgLSAxO1xuICAgICAgICAgICAgaWYgKCFzZWdtZW50LnJlbW92YWxzQnlCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50LnJlbW92YWxzQnlCcmFuY2ggPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VnbWVudC5yZW1vdmFsc0J5QnJhbmNoW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnQucmVtb3ZhbHNCeUJyYW5jaFtpbmRleF0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50LnJlbW92YWxzQnlCcmFuY2hbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZUxlbmd0aChub2RlLCByZWZTZXEsIGNsaWVudElkKSB7XG4gICAgICAgIGlmICgoIXRoaXMuY29sbGFiV2luZG93LmNvbGxhYm9yYXRpbmcpIHx8ICh0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCA9PSBjbGllbnRJZCkpIHtcbiAgICAgICAgICAgIC8vIGxvY2FsIGNsaWVudCBzZWVzIGFsbCBzZWdtZW50cywgZXZlbiB3aGVuIGNvbGxhYm9yYXRpbmdcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNhY2hlZExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsTmV0TGVuZ3RoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIHdpdGhpbiB3aW5kb3dcbiAgICAgICAgICAgIGxldCBicmFuY2hJZCA9IHRoaXMuZ2V0QnJhbmNoSWQoY2xpZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFydGlhbExlbmd0aHMuZ2V0UGFydGlhbExlbmd0aCh0aGlzLCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBsZXQgc2VnQnJhbmNoSWQgPSB0aGlzLmdldEJyYW5jaElkKHNlZ21lbnQuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmICgoc2VnQnJhbmNoSWQgPD0gYnJhbmNoSWQpICYmICgoc2VnbWVudC5jbGllbnRJZCA9PT0gY2xpZW50SWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICgoc2VnbWVudC5zZXEgIT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSAmJiAoc2VnbWVudC5zZXEgPD0gcmVmU2VxKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1vdmFsSW5mbyA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2hJZCA+IHNlZ0JyYW5jaElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmFsSW5mbyA9IHRoaXMuZ2V0UmVtb3ZhbEluZm8oYnJhbmNoSWQsIHNlZ0JyYW5jaElkLCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzZWdtZW50IGhhcHBlbmVkIGJ5IHJlZmVyZW5jZSBzZXF1ZW5jZSBudW1iZXIgb3Igc2VnbWVudCBmcm9tIHJlcXVlc3RpbmcgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmFsSW5mby5yZW1vdmVkU2VxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudElkID09PSBjbGllbnRJZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudE92ZXJsYXAgJiYgKHJlbW92YWxJbmZvLnJlbW92ZWRDbGllbnRPdmVybGFwLmluZGV4T2YoY2xpZW50SWQpID49IDApKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpICYmIChyZW1vdmFsSW5mby5yZW1vdmVkU2VxIDw9IHJlZlNlcSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgaW52aXNpYmxlIHRvIGNsaWVudCBhdCByZWZlcmVuY2Ugc2VxdWVuY2UgbnVtYmVyL2JyYW5jaCBpZC9jbGllbnQgaWQgb2Ygb3BcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxvY2FsTWluU2VxKGxvY2FsTWluU2VxKSB7XG4gICAgICAgIHRoaXMuY29sbGFiV2luZG93LmxvY2FsTWluU2VxID0gbG9jYWxNaW5TZXE7XG4gICAgICAgIHRoaXMuc2V0TWluU2VxKE1hdGgubWluKHRoaXMuY29sbGFiV2luZG93Lmdsb2JhbE1pblNlcSwgbG9jYWxNaW5TZXEpKTtcbiAgICB9XG4gICAgYWRkTWluU2VxTGlzdGVuZXIobWluUmVxdWlyZWQsIG9uTWluR0UpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pblNlcUxpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5taW5TZXFMaXN0ZW5lcnMgPSBuZXcgQ29sbGVjdGlvbnMuSGVhcChbXSwgbWluTGlzdGVuZXJDb21wYXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5TZXFMaXN0ZW5lcnMuYWRkKHsgbWluUmVxdWlyZWQsIG9uTWluR0UgfSk7XG4gICAgfVxuICAgIG5vdGlmeU1pblNlcUxpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5taW5TZXFQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgodGhpcy5taW5TZXFMaXN0ZW5lcnMuY291bnQoKSA+IDApICYmXG4gICAgICAgICAgICAodGhpcy5taW5TZXFMaXN0ZW5lcnMucGVlaygpLm1pblJlcXVpcmVkIDw9IHRoaXMuY29sbGFiV2luZG93Lm1pblNlcSkpIHtcbiAgICAgICAgICAgIGxldCBtaW5MaXN0ZW5lciA9IHRoaXMubWluU2VxTGlzdGVuZXJzLmdldCgpO1xuICAgICAgICAgICAgbWluTGlzdGVuZXIub25NaW5HRSh0aGlzLmNvbGxhYldpbmRvdy5taW5TZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE1pblNlcShtaW5TZXEpIHtcbiAgICAgICAgaWYgKG1pblNlcSA+IHRoaXMuY29sbGFiV2luZG93Lm1pblNlcSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYWJXaW5kb3cubWluU2VxID0gbWluU2VxO1xuICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS5vcHRpb25zLnphbWJvbmlTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuemFtYm9uaVNlZ21lbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taW5TZXFMaXN0ZW5lcnMgJiYgdGhpcy5taW5TZXFMaXN0ZW5lcnMuY291bnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluU2VxUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tbWl0R2xvYmFsTWluKCkge1xuICAgICAgICBpZiAodGhpcy5jb2xsYWJXaW5kb3cuZ2xvYmFsTWluU2VxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFiV2luZG93LmxvY2FsTWluU2VxID0gdGhpcy5jb2xsYWJXaW5kb3cuZ2xvYmFsTWluU2VxO1xuICAgICAgICAgICAgdGhpcy5zZXRNaW5TZXEodGhpcy5jb2xsYWJXaW5kb3cuZ2xvYmFsTWluU2VxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVHbG9iYWxNaW5TZXEoZ2xvYmFsTWluU2VxKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxhYldpbmRvdy5sb2NhbE1pblNlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1pblNlcShnbG9iYWxNaW5TZXEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xsYWJXaW5kb3cuZ2xvYmFsTWluU2VxID0gZ2xvYmFsTWluU2VxO1xuICAgICAgICAgICAgdGhpcy5zZXRNaW5TZXEoTWF0aC5taW4oZ2xvYmFsTWluU2VxLCB0aGlzLmNvbGxhYldpbmRvdy5sb2NhbE1pblNlcSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZmVyZW5jZVBvc2l0aW9uVG9Mb2NhbFBvc2l0aW9uKHJlZlBvcywgcmVmU2VxID0gVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIGNsaWVudElkID0gdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpIHtcbiAgICAgICAgbGV0IHNlZyA9IHJlZlBvcy5nZXRTZWdtZW50KCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSByZWZQb3MuZ2V0T2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLmdldE9mZnNldChzZWcsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgIH1cbiAgICBnZXRTdGFja0NvbnRleHQoc3RhcnRQb3MsIGNsaWVudElkLCByYW5nZUxhYmVscykge1xuICAgICAgICBsZXQgc2VhcmNoSW5mbyA9IHtcbiAgICAgICAgICAgIG1lcmdlVHJlZTogdGhpcyxcbiAgICAgICAgICAgIHN0YWNrczogUHJvcGVydGllcy5jcmVhdGVNYXAoKSxcbiAgICAgICAgICAgIHJhbmdlTGFiZWxzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VhcmNoKHN0YXJ0UG9zLCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgY2xpZW50SWQsIHsgbGVhZjogcmVjb3JkUmFuZ2VMZWFmLCBzaGlmdDogcmFuZ2VTaGlmdCB9LCBzZWFyY2hJbmZvKTtcbiAgICAgICAgcmV0dXJuIHNlYXJjaEluZm8uc3RhY2tzO1xuICAgIH1cbiAgICAvLyBUT0RPOiB3aXRoIGFubm90YXRpb24gb3AgY2hhbmdlIHZhbHVlXG4gICAgY2hlcnJ5UGlja2VkVW5kbyh1bmRvSW5mbykge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHVuZG9JbmZvLnNlZztcbiAgICAgICAgLy8gbm8gYnJhbmNoZXNcbiAgICAgICAgaWYgKHNlZ21lbnQucmVtb3ZlZFNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWdtZW50LnJlbW92ZWRTZXEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzZWdtZW50LnJlbW92ZWRDbGllbnRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1bmRvSW5mby5vcCA9PT0gMSAvKiBSRU1PVkUgKi8pIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50LnJlbW92ZWRTZXEgPSB1bmRvSW5mby5zZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50LnJlbW92ZWRTZXEgPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWdtZW50LnJlbW92ZWRDbGllbnRJZCA9IHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxvY2tVcGRhdGVQYXRoTGVuZ3RocyhzZWdtZW50LnBhcmVudCwgVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyLCAtMSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGZpbHRlciBmdW5jdGlvblxuICAgIGZpbmRUaWxlKHN0YXJ0UG9zLCBjbGllbnRJZCwgdGlsZUxhYmVsLCBwb3NQcmVjZWRlc1RpbGUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBzZWFyY2hJbmZvID0ge1xuICAgICAgICAgICAgbWVyZ2VUcmVlOiB0aGlzLFxuICAgICAgICAgICAgcG9zUHJlY2VkZXNUaWxlLFxuICAgICAgICAgICAgdGlsZUxhYmVsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocG9zUHJlY2VkZXNUaWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaChzdGFydFBvcywgVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIGNsaWVudElkLCB7IGxlYWY6IHJlY29yZFRpbGVTdGFydCwgc2hpZnQ6IHRpbGVTaGlmdCB9LCBzZWFyY2hJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRTZWFyY2goc3RhcnRQb3MsIFVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCBjbGllbnRJZCwgeyBsZWFmOiByZWNvcmRUaWxlU3RhcnQsIHNoaWZ0OiB0aWxlU2hpZnQgfSwgc2VhcmNoSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlYXJjaEluZm8udGlsZSkge1xuICAgICAgICAgICAgbGV0IHBvcztcbiAgICAgICAgICAgIGlmIChzZWFyY2hJbmZvLnRpbGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2VyID0gc2VhcmNoSW5mby50aWxlO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuZ2V0T2Zmc2V0KG1hcmtlciwgVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIGNsaWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsb2NhbFJlZiA9IHNlYXJjaEluZm8udGlsZTtcbiAgICAgICAgICAgICAgICBwb3MgPSBsb2NhbFJlZi50b1Bvc2l0aW9uKHRoaXMsIFVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCBjbGllbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0aWxlOiBzZWFyY2hJbmZvLnRpbGUsIHBvcyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlYXJjaChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIGFjdGlvbnMsIGNsaWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoQmxvY2sodGhpcy5yb290LCBwb3MsIDAsIHJlZlNlcSwgY2xpZW50SWQsIGFjdGlvbnMsIGNsaWVudERhdGEpO1xuICAgIH1cbiAgICBzZWFyY2hCbG9jayhibG9jaywgcG9zLCBzZWdwb3MsIHJlZlNlcSwgY2xpZW50SWQsIGFjdGlvbnMsIGNsaWVudERhdGEpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gYmxvY2suY2hpbGRyZW47XG4gICAgICAgIGlmIChhY3Rpb25zICYmIGFjdGlvbnMucHJlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnByZShibG9jaywgc2VncG9zLCByZWZTZXEsIGNsaWVudElkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2xpZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5zID0gYWN0aW9ucyAmJiBhY3Rpb25zLmNvbnRhaW5zO1xuICAgICAgICBmb3IgKGxldCBjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IGJsb2NrLmNoaWxkQ291bnQ7IGNoaWxkSW5kZXgrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5ub2RlTGVuZ3RoKGNoaWxkLCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgIGlmICgoKCFjb250YWlucykgJiYgKHBvcyA8IGxlbikpIHx8IChjb250YWlucyAmJiBjb250YWlucyhjaGlsZCwgcG9zLCByZWZTZXEsIGNsaWVudElkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2xpZW50RGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgZW50cnkgY29udGFpbmluZyBwb3NcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEJsb2NrKGNoaWxkLCBwb3MsIHNlZ3BvcywgcmVmU2VxLCBjbGllbnRJZCwgYWN0aW9ucywgY2xpZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9ucyAmJiBhY3Rpb25zLmxlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMubGVhZihjaGlsZCwgc2VncG9zLCByZWZTZXEsIGNsaWVudElkLCBwb3MsIC0xLCBjbGllbnREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMgJiYgYWN0aW9ucy5zaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNoaWZ0KGNoaWxkLCBzZWdwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHBvcywgdW5kZWZpbmVkLCBjbGllbnREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zIC09IGxlbjtcbiAgICAgICAgICAgICAgICBzZWdwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25zICYmIGFjdGlvbnMucG9zdCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wb3N0KGJsb2NrLCBzZWdwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjbGllbnREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiYWNrd2FyZFNlYXJjaChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIGFjdGlvbnMsIGNsaWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja3dhcmRTZWFyY2hCbG9jayh0aGlzLnJvb3QsIHBvcywgdGhpcy5nZXRMZW5ndGgocmVmU2VxLCBjbGllbnRJZCksIHJlZlNlcSwgY2xpZW50SWQsIGFjdGlvbnMsIGNsaWVudERhdGEpO1xuICAgIH1cbiAgICBiYWNrd2FyZFNlYXJjaEJsb2NrKGJsb2NrLCBwb3MsIHNlZ0VuZCwgcmVmU2VxLCBjbGllbnRJZCwgYWN0aW9ucywgY2xpZW50RGF0YSkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGFjdGlvbnMgJiYgYWN0aW9ucy5wcmUpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHJlKGJsb2NrLCBzZWdFbmQsIHJlZlNlcSwgY2xpZW50SWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjbGllbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbnMgPSBhY3Rpb25zICYmIGFjdGlvbnMuY29udGFpbnM7XG4gICAgICAgIGZvciAobGV0IGNoaWxkSW5kZXggPSBibG9jay5jaGlsZENvdW50IC0gMTsgY2hpbGRJbmRleCA+PSAwOyBjaGlsZEluZGV4LS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMubm9kZUxlbmd0aChjaGlsZCwgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgICAgICBsZXQgc2VncG9zID0gc2VnRW5kIC0gbGVuO1xuICAgICAgICAgICAgaWYgKCgoIWNvbnRhaW5zKSAmJiAocG9zID49IHNlZ3BvcykpIHx8XG4gICAgICAgICAgICAgICAgKGNvbnRhaW5zICYmIGNvbnRhaW5zKGNoaWxkLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjbGllbnREYXRhKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbnRyeSBjb250YWluaW5nIHBvc1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja3dhcmRTZWFyY2hCbG9jayhjaGlsZCwgcG9zLCBzZWdFbmQsIHJlZlNlcSwgY2xpZW50SWQsIGFjdGlvbnMsIGNsaWVudERhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMgJiYgYWN0aW9ucy5sZWFmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmxlYWYoY2hpbGQsIHNlZ3BvcywgcmVmU2VxLCBjbGllbnRJZCwgcG9zLCAtMSwgY2xpZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25zICYmIGFjdGlvbnMuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5zaGlmdChjaGlsZCwgc2VncG9zLCByZWZTZXEsIGNsaWVudElkLCBwb3MsIHVuZGVmaW5lZCwgY2xpZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZ0VuZCA9IHNlZ3BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9ucyAmJiBhY3Rpb25zLnBvc3QpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucG9zdChibG9jaywgc2VnRW5kLCByZWZTZXEsIGNsaWVudElkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2xpZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUm9vdChzcGxpdE5vZGUsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSkge1xuICAgICAgICBpZiAoc3BsaXROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBuZXdSb290ID0gdGhpcy5tYWtlQmxvY2soMik7XG4gICAgICAgICAgICBuZXdSb290LmluZGV4ID0gMDtcbiAgICAgICAgICAgIG5ld1Jvb3Qub3JkaW5hbCA9IFwiXCI7XG4gICAgICAgICAgICBuZXdSb290LmFzc2lnbkNoaWxkKHRoaXMucm9vdCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgbmV3Um9vdC5hc3NpZ25DaGlsZChzcGxpdE5vZGUsIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ld1Jvb3Q7XG4gICAgICAgICAgICB0aGlzLm5vZGVVcGRhdGVPcmRpbmFscyh0aGlzLnJvb3QpO1xuICAgICAgICAgICAgdGhpcy5ub2RlVXBkYXRlTGVuZ3RoTmV3U3RydWN0dXJlKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWduIHNlcXVlbmNlIG51bWJlciB0byBleGlzdGluZyBzZWdtZW50OyB1cGRhdGUgcGFydGlhbCBsZW5ndGhzIHRvIHJlZmxlY3QgdGhlIGNoYW5nZVxuICAgICAqIEBwYXJhbSBzZXEgc2VxdWVuY2UgbnVtYmVyIGdpdmVuIGJ5IHNlcnZlciB0byBwZW5kaW5nIHNlZ21lbnRcbiAgICAgKi9cbiAgICBhY2tQZW5kaW5nU2VnbWVudChzZXEsIHZlcmJvc2VPcHMgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcGVuZGluZ1NlZ21lbnRHcm91cCA9IHRoaXMucGVuZGluZ1NlZ21lbnRzLmRlcXVldWUoKTtcbiAgICAgICAgbGV0IG5vZGVzVG9VcGRhdGUgPSBbXTtcbiAgICAgICAgbGV0IGNsaWVudElkO1xuICAgICAgICBsZXQgb3ZlcndyaXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChwZW5kaW5nU2VnbWVudEdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlT3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHNlZ21lbnQgZ3JvdXAgaGFzICR7cGVuZGluZ1NlZ21lbnRHcm91cC5zZWdtZW50cy5sZW5ndGh9IHNlZ21lbnRzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nU2VnbWVudEdyb3VwLnNlZ21lbnRzLm1hcCgocGVuZGluZ1NlZ21lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1NlZ21lbnQuc2VxID09PSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1NlZ21lbnQuc2VxID0gc2VxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlZ0JyYW5jaElkID0gdGhpcy5nZXRCcmFuY2hJZChwZW5kaW5nU2VnbWVudC5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1vdmFsSW5mbyA9IHRoaXMuZ2V0UmVtb3ZhbEluZm8odGhpcy5sb2NhbEJyYW5jaElkLCBzZWdCcmFuY2hJZCwgcGVuZGluZ1NlZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyd3JpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNZXJnZVRyZWUuZGlhZ092ZXJsYXBwaW5nUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBncnVtcCBAc2VxICR7c2VxfSBjbGkgJHtnbGModGhpcywgdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpfSBmcm9tICR7cGVuZGluZ1NlZ21lbnQucmVtb3ZlZFNlcX0gdGV4dCAke3BlbmRpbmdTZWdtZW50LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSA9IHNlcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50R3JvdXAgPSBwZW5kaW5nU2VnbWVudC5zZWdtZW50R3JvdXBzLmRlcXVldWUoKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2VnbWVudEdyb3VwLCBwZW5kaW5nU2VnbWVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICBjbGllbnRJZCA9IHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlc1RvVXBkYXRlLmluZGV4T2YocGVuZGluZ1NlZ21lbnQucGFyZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1VwZGF0ZS5wdXNoKHBlbmRpbmdTZWdtZW50LnBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzVG9VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlUGF0aExlbmd0aHMobm9kZSwgc2VxLCBjbGllbnRJZCwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICAvL25vZGVVcGRhdGVQYXRoTGVuZ3Rocyhub2RlLCBzZXEsIGNsaWVudElkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUb1BlbmRpbmdMaXN0KHNlZ21lbnQsIHNlZ21lbnRHcm91cCkge1xuICAgICAgICBpZiAoc2VnbWVudEdyb3VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uU2VnbWVudEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudEdyb3VwID0gdGhpcy50cmFuc2FjdGlvblNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRHcm91cCA9IHsgc2VnbWVudHM6IFtdIH07XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudHMuZW5xdWV1ZShzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHNoYXJlIHRoaXMgZ3JvdXAgd2l0aCBVTkRPXG4gICAgICAgIHNlZ21lbnQuc2VnbWVudEdyb3Vwcy5lbnF1ZXVlKHNlZ21lbnRHcm91cCk7XG4gICAgICAgIHJldHVybiBzZWdtZW50R3JvdXA7XG4gICAgfVxuICAgIC8vIFRPRE86IGVycm9yIGNoZWNraW5nXG4gICAgZ2V0U2VnbWVudEZyb21JZChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZFRvU2VnbWVudFtpZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcG9zaXRpb24gc3BlY2lmaWVkIHJlbGF0aXZlIHRvIGEgbWFya2VyIGlkLCBsb29rdXAgdGhlIG1hcmtlclxuICAgICAqIGFuZCBjb252ZXJ0IHRoZSBwb3NpdGlvbiB0byBhIGNoYXJhY3RlciBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQb3MgSWQgb2YgbWFya2VyIChtYXkgYmUgaW5kaXJlY3QpIGFuZCB3aGV0aGVyIHBvc2l0aW9uIGlzIGJlZm9yZSBvciBhZnRlciBtYXJrZXIuXG4gICAgICogQHBhcmFtIHJlZnNlcSBUaGUgcmVmZXJlbmNlIHNlcXVlbmNlIG51bWJlciBhdCB3aGljaCB0byBjb21wdXRlIHRoZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgVGhlIGNsaWVudCBpZCB3aXRoIHdoaWNoIHRvIGNvbXB1dGUgdGhlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHBvc0Zyb21SZWxhdGl2ZVBvcyhyZWxhdGl2ZVBvcywgcmVmc2VxID0gVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIGNsaWVudElkID0gdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpIHtcbiAgICAgICAgbGV0IHBvcyA9IC0xO1xuICAgICAgICBsZXQgbWFya2VyO1xuICAgICAgICBpZiAocmVsYXRpdmVQb3MuaWQpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuZ2V0U2VnbWVudEZyb21JZChyZWxhdGl2ZVBvcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRPZmZzZXQobWFya2VyLCByZWZzZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmVQb3MuYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9IG1hcmtlci5jYWNoZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUG9zLm9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSByZWxhdGl2ZVBvcy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUG9zLm9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyAtPSByZWxhdGl2ZVBvcy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGluc2VydChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnRGF0YSwgdHJhdmVyc2UsIG9wQXJncykge1xuICAgICAgICB0aGlzLmVuc3VyZUludGVydmFsQm91bmRhcnkocG9zLCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZU9yZGluYWxzKSB7XG4gICAgICAgICAgICB0aGlzLm9yZGluYWxJbnRlZ3JpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvL3RyYWNlVHJhdmVyc2FsID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNwbGl0Tm9kZSA9IHRyYXZlcnNlKHRoaXMucm9vdCwgcG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIHNlZ0RhdGEpO1xuICAgICAgICAvL3RyYWNlVHJhdmVyc2FsID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlUm9vdChzcGxpdE5vZGUsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSk7XG4gICAgICAgIGlmICh0aGlzLm1lcmdlVHJlZURlbHRhQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubWVyZ2VUcmVlRGVsdGFDYWxsYmFjayhvcEFyZ3MsIHtcbiAgICAgICAgICAgICAgICBtZXJnZVRyZWVDbGllbnRJZDogY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgICAgICAgICBtZXJnZVRyZWU6IHRoaXMsXG4gICAgICAgICAgICAgICAgc2VnbWVudHM6IFtzZWdEYXRhXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0U2VnbWVudChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnbWVudCwgb3BBcmdzKSB7XG4gICAgICAgIC8vIGNvbnN0IHR0ID0gTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsO1xuICAgICAgICAvLyBNZXJnZVRyZWUudHJhY2VUcmF2ZXJzYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmluc2VydChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnbWVudCwgKGJsb2NrLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnKSA9PiB0aGlzLmJsb2NrSW5zZXJ0KGJsb2NrLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnKSwgb3BBcmdzKTtcbiAgICAgICAgLy8gTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsID0gdHQ7XG4gICAgfVxuICAgIGluc2VydE1hcmtlcihwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgYmVoYXZpb3JzLCBwcm9wcywgb3BBcmdzKSB7XG4gICAgICAgIGxldCBtYXJrZXIgPSBNYXJrZXIubWFrZShiZWhhdmlvcnMsIHByb3BzLCBzZXEsIGNsaWVudElkKTtcbiAgICAgICAgbGV0IG1hcmtlcklkID0gbWFya2VyLmdldElkKCk7XG4gICAgICAgIGlmIChtYXJrZXJJZCkge1xuICAgICAgICAgICAgdGhpcy5tYXBJZFRvU2VnbWVudChtYXJrZXJJZCwgbWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgbWFya2VyLCAoYmxvY2ssIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBtYXJrZXIpID0+IHRoaXMuYmxvY2tJbnNlcnQoYmxvY2ssIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBtYXJrZXIpLCBvcEFyZ3MpO1xuICAgICAgICAvLyByZXBvcnQgc2VnbWVudCBpZiBjbGllbnQgaW50ZXJlc3RlZFxuICAgICAgICBpZiAodGhpcy5tYXJrZXJNb2RpZmllZEhhbmRsZXIgJiYgKHNlcSAhPT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJNb2RpZmllZEhhbmRsZXIobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbiAgICBpbnNlcnRUZXh0TWFya2VyUmVsYXRpdmUobWFya2VyUG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIHRleHQsIHByb3BzLCBvcEFyZ3MpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zRnJvbVJlbGF0aXZlUG9zKG1hcmtlclBvcywgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgbGV0IG5ld1NlZ21lbnQgPSBUZXh0U2VnbWVudC5tYWtlKHRleHQsIHByb3BzLCBzZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgIC8vIE1lcmdlVHJlZS50cmFjZVRyYXZlcnNhbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmluc2VydChwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgbmV3U2VnbWVudCwgKGJsb2NrLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnbWVudCkgPT4gdGhpcy5ibG9ja0luc2VydCh0aGlzLnJvb3QsIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBzZWdtZW50KSwgb3BBcmdzKTtcbiAgICAgICAgICAgIE1lcmdlVHJlZS50cmFjZVRyYXZlcnNhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGFiV2luZG93LmNvbGxhYm9yYXRpbmcgJiYgTWVyZ2VUcmVlLm9wdGlvbnMuemFtYm9uaVNlZ21lbnRzICYmXG4gICAgICAgICAgICAgICAgKHNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56YW1ib25pU2VnbWVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRUZXh0KHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCB0ZXh0LCBwcm9wcywgb3BBcmdzKSB7XG4gICAgICAgIGxldCBuZXdTZWdtZW50ID0gVGV4dFNlZ21lbnQubWFrZSh0ZXh0LCBwcm9wcywgc2VxLCBjbGllbnRJZCk7XG4gICAgICAgIC8vIE1lcmdlVHJlZS50cmFjZVRyYXZlcnNhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBuZXdTZWdtZW50LCAoYmxvY2ssIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBzZWdtZW50KSA9PiB0aGlzLmJsb2NrSW5zZXJ0KHRoaXMucm9vdCwgcG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIHNlZ21lbnQpLCBvcEFyZ3MpO1xuICAgICAgICBNZXJnZVRyZWUudHJhY2VUcmF2ZXJzYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZU9yZGluYWxzKSB7XG4gICAgICAgICAgICB0aGlzLm9yZGluYWxJbnRlZ3JpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2xsYWJXaW5kb3cuY29sbGFib3JhdGluZyAmJiBNZXJnZVRyZWUub3B0aW9ucy56YW1ib25pU2VnbWVudHMgJiZcbiAgICAgICAgICAgIChzZXEgIT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgdGhpcy56YW1ib25pU2VnbWVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja0luc2VydChibG9jaywgcG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIG5ld1NlZ21lbnQpIHtcbiAgICAgICAgbGV0IHNlZ0lzTG9jYWwgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNoZWNrU2VnbWVudElzTG9jYWwgPSAoc2VnbWVudCwgcG9zLCByZWZTZXEsIGNsaWVudElkKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5zZXEgPT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS5kaWFnSW5zZXJ0VGllKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAY2xpICR7Z2xjKHRoaXMsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkKX06IHByb21vdGluZyBjb250aW51ZSBkdWUgdG8gc2VxICR7c2VnbWVudC5zZXF9IHRleHQgJHtzZWdtZW50LnRvU3RyaW5nKCl9IHJlZiAke3JlZlNlcX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VnSXNMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmx5IG5lZWQgdG8gbG9vayBhdCBmaXJzdCBzZWdtZW50IHRoYXQgZm9sbG93cyBmaW5pc2hlZCBub2RlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250aW51ZUZyb20gPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgc2VnSXNMb2NhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yaWdodEV4Y3Vyc2lvbihub2RlLCBjaGVja1NlZ21lbnRJc0xvY2FsKTtcbiAgICAgICAgICAgIGlmIChNZXJnZVRyZWUuZGlhZ0luc2VydFRpZSAmJiBzZWdJc0xvY2FsICYmIChuZXdTZWdtZW50LmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuVGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5ld1NlZ21lbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQGNsaSAke2dsYyh0aGlzLCB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9OiBhdHRlbXB0aW5nIGNvbnRpbnVlIHdpdGggc2VxICR7c2VxfSB0ZXh0ICR7dGV4dH0gcmVmICR7cmVmU2VxfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZ0lzTG9jYWw7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvbkxlYWYgPSAoc2VnbWVudCwgcG9zLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2F2ZUlmTG9jYWwgPSAobG9jU2VnbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNhdmUgc2VnbWVudCBzbyBjYW4gYXNzaWduIHNlcXVlbmNlIG51bWJlciB3aGVuIGFja2VkIGJ5IHNlcnZlclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxhYldpbmRvdy5jb2xsYWJvcmF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG9jU2VnbWVudC5zZXEgPT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWVudElkID09IHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb1BlbmRpbmdMaXN0KGxvY1NlZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChsb2NTZWdtZW50LnNlcSA+PSB0aGlzLmNvbGxhYldpbmRvdy5taW5TZXEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNZXJnZVRyZWUub3B0aW9ucy56YW1ib25pU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9MUlVTZXQobG9jU2VnbWVudCwgbG9jU2VnbWVudC5zZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBzZWdtZW50Q2hhbmdlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmVmb3JlIHNlZ21lbnRcbiAgICAgICAgICAgICAgICBzZWdtZW50Q2hhbmdlcy5yZXBsYWNlQ3VycmVudCA9IG5ld1NlZ21lbnQ7XG4gICAgICAgICAgICAgICAgc2VnbWVudENoYW5nZXMubmV4dCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50Q2hhbmdlcy5uZXh0ID0gbmV3U2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhdmVJZkxvY2FsKG5ld1NlZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRDaGFuZ2VzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRpbmdXYWxrKGJsb2NrLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgbmV3U2VnbWVudC5nZXRUeXBlKCksIHsgbGVhZjogb25MZWFmLCBjYW5kaWRhdGVTZWdtZW50OiBuZXdTZWdtZW50LCBjb250aW51ZVByZWRpY2F0ZTogY29udGludWVGcm9tIH0pO1xuICAgIH1cbiAgICBlbnN1cmVJbnRlcnZhbEJvdW5kYXJ5KHBvcywgcmVmU2VxLCBjbGllbnRJZCkge1xuICAgICAgICBsZXQgc3BsaXROb2RlID0gdGhpcy5pbnNlcnRpbmdXYWxrKHRoaXMucm9vdCwgcG9zLCByZWZTZXEsIGNsaWVudElkLCBUcmVlTWFpbnRlbmFuY2VTZXF1ZW5jZU51bWJlciwgU2VnbWVudFR5cGUuQmFzZSwgeyBsZWFmOiB0aGlzLnNwbGl0TGVhZlNlZ21lbnQgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlUm9vdChzcGxpdE5vZGUsIHJlZlNlcSwgY2xpZW50SWQsIFRyZWVNYWludGVuYW5jZVNlcXVlbmNlTnVtYmVyKTtcbiAgICB9XG4gICAgLy8gYXNzdW1lIGNhbGxlZCBvbmx5IHdoZW4gcG9zID09IGxlblxuICAgIGJyZWFrVGllKHBvcywgbGVuLCBzZXEsIG5vZGUsIHJlZlNlcSwgY2xpZW50SWQsIGNhbmRpZGF0ZVNlZ21lbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgIGxldCBzZWdtZW50ID0gbm9kZTtcbiAgICAgICAgICAgIC8vIFRPRE86IG1hcmtlci9tYXJrZXIgdGllIGJyZWFrICYgYWx0ZXJuYXRlIHRpZSBicmVhayBydWxlc1xuICAgICAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQuc2VxICE9PSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB2aXNpdCBzZWdtZW50cyBzdGFydGluZyBmcm9tIG5vZGUncyByaWdodCBzaWJsaW5ncywgdGhlbiB1cCB0byBub2RlJ3MgcGFyZW50XG4gICAgbGVmdEV4Y3Vyc2lvbihub2RlLCBsZWFmQWN0aW9uKSB7XG4gICAgICAgIGxldCBhY3Rpb25zID0geyBsZWFmOiBsZWFmQWN0aW9uIH07XG4gICAgICAgIGxldCBnbyA9IHRydWU7XG4gICAgICAgIGxldCBzdGFydE5vZGUgPSBub2RlO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnROb2RlLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgbGV0IGNoaWxkSW5kZXg7XG4gICAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVkU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY2hpbGRJbmRleCA9IHBhcmVudC5jaGlsZENvdW50IC0gMTsgY2hpbGRJbmRleCA+PSAwOyBjaGlsZEluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEJsb2NrID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gdGhpcy5ub2RlTWFwUmV2ZXJzZShjaGlsZEJsb2NrLCBhY3Rpb25zLCAwLCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbyA9IGxlYWZBY3Rpb24obm9kZSwgMCwgVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTdGFydCA9IChzdGFydE5vZGUgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdmlzaXQgc2VnbWVudHMgc3RhcnRpbmcgZnJvbSBub2RlJ3MgcmlnaHQgc2libGluZ3MsIHRoZW4gdXAgdG8gbm9kZSdzIHBhcmVudFxuICAgIHJpZ2h0RXhjdXJzaW9uKG5vZGUsIGxlYWZBY3Rpb24pIHtcbiAgICAgICAgbGV0IGFjdGlvbnMgPSB7IGxlYWY6IGxlYWZBY3Rpb24gfTtcbiAgICAgICAgbGV0IGdvID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0YXJ0Tm9kZSA9IG5vZGU7XG4gICAgICAgIGxldCBwYXJlbnQgPSBzdGFydE5vZGUucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBsZXQgY2hpbGRJbmRleDtcbiAgICAgICAgICAgIGxldCBub2RlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50OyBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEJsb2NrID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gdGhpcy5ub2RlTWFwKGNoaWxkQmxvY2ssIGFjdGlvbnMsIDAsIFVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gbGVhZkFjdGlvbihub2RlLCAwLCBVbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFN0YXJ0ID0gKHN0YXJ0Tm9kZSA9PT0gbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnROb2RlID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRpbmdXYWxrKGJsb2NrLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgc2VnVHlwZSwgY29udGV4dCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbjtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXg7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgbGV0IG5ld05vZGU7XG4gICAgICAgIGxldCBmcm9tU3BsaXQ7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNoaWxkSW5kZXggPSAwOyBjaGlsZEluZGV4IDwgYmxvY2suY2hpbGRDb3VudDsgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMubm9kZUxlbmd0aChjaGlsZCwgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlZ0luZm87XG4gICAgICAgICAgICAgICAgaWYgKCghY2hpbGQuaXNMZWFmKCkpICYmIHRoaXMuY29sbGFiV2luZG93LmNvbGxhYm9yYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnSW5mbyA9IGBtaW5MZW5ndGg6ICR7Y2hpbGQucGFydGlhbExlbmd0aHMubWluTGVuZ3RofWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBzZWdJbmZvID0gYGNsaTogJHtnbGModGhpcywgc2VnbWVudC5jbGllbnRJZCl9IHNlcTogJHtzZWdtZW50LnNlcX0gdGV4dDogJHtzZWdtZW50LnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQucmVtb3ZlZFNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdJbmZvICs9IGAgcmNsaTogJHtnbGModGhpcywgc2VnbWVudC5yZW1vdmVkQ2xpZW50SWQpfSByc2VxOiAke3NlZ21lbnQucmVtb3ZlZFNlcX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAdGNsaTogJHtnbGModGhpcywgdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpfSBsZW46ICR7bGVufSBwb3M6ICR7cG9zfSBgICsgc2VnSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHBvcyA8IGxlbikgfHwgKChwb3MgPT0gbGVuKSAmJiB0aGlzLmJyZWFrVGllKHBvcywgbGVuLCBzZXEsIGNoaWxkLCByZWZTZXEsIGNsaWVudElkLCBjb250ZXh0LmNhbmRpZGF0ZVNlZ21lbnQpKSkge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGVudHJ5IGNvbnRhaW5pbmcgcG9zXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkQmxvY2sgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgLy9pbnRlcm5hbCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdE5vZGUgPSB0aGlzLmluc2VydGluZ1dhbGsoY2hpbGRCbG9jaywgcG9zLCByZWZTZXEsIGNsaWVudElkLCBzZXEsIHNlZ1R5cGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN0cnVjdHVyZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZUxlbmd0aE5ld1N0cnVjdHVyZShibG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlTGVuZ3RoKGJsb2NrLCBzZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3BsaXROb2RlID09IE1lcmdlVHJlZS50aGVVbmZpbmlzaGVkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZVRyYXZlcnNhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAY2xpICR7Z2xjKHRoaXMsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkKX0gdW5maW5pc2hlZCBidXMgcG9zICR7cG9zfSBsZW4gJHtsZW59YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgLT0gbGVuOyAvLyBhY3QgYXMgaWYgc2hpZnRlZCBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSBzcGxpdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tU3BsaXQgPSBzcGxpdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEluZGV4Kys7IC8vIGluc2VydCBhZnRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQHRjbGk6ICR7Z2xjKHRoaXMsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkKX06IGxlYWYgYWN0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hJZCA9IHRoaXMuZ2V0QnJhbmNoSWQoY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50QnJhbmNoSWQgPSB0aGlzLmdldEJyYW5jaElkKHNlZ21lbnQuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmFsSW5mbyA9IHRoaXMuZ2V0UmVtb3ZhbEluZm8oYnJhbmNoSWQsIHNlZ21lbnRCcmFuY2hJZCwgc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmFsSW5mbyAmJiByZW1vdmFsSW5mby5yZW1vdmVkU2VxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudENoYW5nZXMgPSBjb250ZXh0LmxlYWYoc2VnbWVudCwgcG9zLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRDaGFuZ2VzLnJlcGxhY2VDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlT3JkaW5hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgYXNzaWduIGZyb20gbGVhZiB3aXRoIGJsb2NrIG9yZCAke29yZGluYWxUb0FycmF5KGJsb2NrLm9yZGluYWwpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suYXNzaWduQ2hpbGQoc2VnbWVudENoYW5nZXMucmVwbGFjZUN1cnJlbnQsIGNoaWxkSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRDaGFuZ2VzLnJlcGxhY2VDdXJyZW50Lm9yZGluYWwgPSBjaGlsZC5vcmRpbmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Q2hhbmdlcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gc2VnbWVudENoYW5nZXMubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgrKzsgLy8gaW5zZXJ0IGFmdGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN0cnVjdHVyZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZUxlbmd0aE5ld1N0cnVjdHVyZShibG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zIC09IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsKSB7XG4gICAgICAgICAgICBpZiAoKCFmb3VuZCkgJiYgKHBvcyA+IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGluc2VydGluZyB3YWxrIGZlbGwgdGhyb3VnaCBwb3MgJHtwb3N9IGxlbjogJHt0aGlzLmJsb2NrTGVuZ3RoKHRoaXMucm9vdCwgcmVmU2VxLCBjbGllbnRJZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXdOb2RlKSB7XG4gICAgICAgICAgICBpZiAocG9zID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNlcSAhPSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpICYmIGNvbnRleHQuY29udGludWVQcmVkaWNhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jb250aW51ZVByZWRpY2F0ZShibG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lcmdlVHJlZS50aGVVbmZpbmlzaGVkTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNZXJnZVRyZWUudHJhY2VUcmF2ZXJzYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBAdGNsaTogJHtnbGModGhpcywgdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpfTogbGVhZiBhY3Rpb24gcG9zIDBgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudENoYW5nZXMgPSBjb250ZXh0LmxlYWYodW5kZWZpbmVkLCBwb3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gc2VnbWVudENoYW5nZXMubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHNlZ21lbnRDaGFuZ2VzLnJlcGxhY2VDdXJyZW50ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBibG9jay5jaGlsZENvdW50OyBpID4gY2hpbGRJbmRleDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suY2hpbGRyZW5baV0gPSBibG9jay5jaGlsZHJlbltpIC0gMV07XG4gICAgICAgICAgICAgICAgYmxvY2suY2hpbGRyZW5baV0uaW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYXNzaWduQ2hpbGQobmV3Tm9kZSwgY2hpbGRJbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgYmxvY2suY2hpbGRDb3VudCsrO1xuICAgICAgICAgICAgYmxvY2suc2V0T3JkaW5hbChuZXdOb2RlLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgIGlmIChibG9jay5jaGlsZENvdW50IDwgTWF4Tm9kZXNJbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21TcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlT3JkaW5hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBzcGxpdCBvcmQgJHtvcmRpbmFsVG9BcnJheShmcm9tU3BsaXQub3JkaW5hbCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlVXBkYXRlT3JkaW5hbHMoZnJvbVNwbGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3RydWN0dXJlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZUxlbmd0aE5ld1N0cnVjdHVyZShibG9jayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlTGVuZ3RoKGJsb2NrLCBzZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHVwZGF0ZSBvcmRpbmFscyBiZWNhdXNlIGhpZ2hlciBibG9jayB3aWxsIGRvIGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGxpdChub2RlKSB7XG4gICAgICAgIGxldCBoYWxmQ291bnQgPSBNYXhOb2Rlc0luQmxvY2sgLyAyO1xuICAgICAgICBsZXQgbmV3Tm9kZSA9IHRoaXMubWFrZUJsb2NrKGhhbGZDb3VudCk7XG4gICAgICAgIG5vZGUuY2hpbGRDb3VudCA9IGhhbGZDb3VudDtcbiAgICAgICAgLy8gdXBkYXRlIG9yZGluYWxzIHRvIHJlZmxlY3QgbG93ZXJlZCBjaGlsZCBjb3VudFxuICAgICAgICB0aGlzLm5vZGVVcGRhdGVPcmRpbmFscyhub2RlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbmV3Tm9kZS5hc3NpZ25DaGlsZChub2RlLmNoaWxkcmVuW2hhbGZDb3VudCArIGldLCBpLCBmYWxzZSk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuW2hhbGZDb3VudCArIGldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVVwZGF0ZUxlbmd0aE5ld1N0cnVjdHVyZShub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlVXBkYXRlTGVuZ3RoTmV3U3RydWN0dXJlKG5ld05vZGUpO1xuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG4gICAgb3JkaW5hbEludGVncml0eSgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjaGsgb3JkbmxzXCIpO1xuICAgICAgICB0aGlzLm5vZGVPcmRpbmFsSW50ZWdyaXR5KHRoaXMucm9vdCk7XG4gICAgfVxuICAgIG5vZGVPcmRpbmFsSW50ZWdyaXR5KGJsb2NrKSB7XG4gICAgICAgIGxldCBvbGVuID0gYmxvY2sub3JkaW5hbC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2suY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2suY2hpbGRyZW5baV0ub3JkaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChvbGVuICE9PSAoYmxvY2suY2hpbGRyZW5baV0ub3JkaW5hbC5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vZGUgaW50ZWdyaXR5IGlzc3VlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrLmNoaWxkcmVuW2ldLm9yZGluYWwgPD0gYmxvY2suY2hpbGRyZW5baSAtIDFdLm9yZGluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm9kZSBzaWIgaW50ZWdyaXR5IGlzc3VlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYD8/OiBwcm50IGNobGQgcHJldiAke29yZGluYWxUb0FycmF5KGJsb2NrLm9yZGluYWwpfSAke29yZGluYWxUb0FycmF5KGJsb2NrLmNoaWxkcmVuW2ldLm9yZGluYWwpfSAkeyhpID4gMCkgPyBvcmRpbmFsVG9BcnJheShibG9jay5jaGlsZHJlbltpIC0gMV0ub3JkaW5hbCkgOiBcIk5BXCJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5jaGlsZHJlbltpXS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVPcmRpbmFsSW50ZWdyaXR5KGJsb2NrLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgbm9kZSBjaGlsZCBvcmRpbmFsIG5vdCBzZXQgJHtpfWApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGA/PzogcHJudCAke29yZGluYWxUb0FycmF5KGJsb2NrLm9yZGluYWwpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVVcGRhdGVPcmRpbmFscyhibG9jaykge1xuICAgICAgICBpZiAoTWVyZ2VUcmVlLnRyYWNlT3JkaW5hbHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGB1cGRhdGUgb3JkaW5hbHMgZm9yIGNoaWxkcmVuIG9mIG5vZGUgd2l0aCBvcmRpbmFsICR7b3JkaW5hbFRvQXJyYXkoYmxvY2sub3JkaW5hbCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsb2NrU3RhcnQ7XG4gICAgICAgIGlmIChNZXJnZVRyZWUub3B0aW9ucy5tZWFzdXJlT3JkaW5hbFRpbWUpIHtcbiAgICAgICAgICAgIGNsb2NrU3RhcnQgPSBjbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2suY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBibG9jay5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGJsb2NrLnNldE9yZGluYWwoY2hpbGQsIGkpO1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZU9yZGluYWxzKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTWVyZ2VUcmVlLm9wdGlvbnMubWVhc3VyZU9yZGluYWxUaW1lKSB7XG4gICAgICAgICAgICBsZXQgZWxhcHNlZCA9IGVsYXBzZWRNaWNyb3NlY29uZHMoY2xvY2tTdGFydCk7XG4gICAgICAgICAgICBpZiAoZWxhcHNlZCA+IHRoaXMubWF4T3JkVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4T3JkVGltZSA9IGVsYXBzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9yZFRpbWUgKz0gZWxhcHNlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRPdmVybGFwcGluZ0NsaWVudChyZW1vdmFsSW5mbywgY2xpZW50SWQpIHtcbiAgICAgICAgaWYgKCFyZW1vdmFsSW5mby5yZW1vdmVkQ2xpZW50T3ZlcmxhcCkge1xuICAgICAgICAgICAgcmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudE92ZXJsYXAgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWVyZ2VUcmVlLmRpYWdPdmVybGFwcGluZ1JlbW92ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGFkZGVkIGNsaSAke2dsYyh0aGlzLCBjbGllbnRJZCl9IHRvIHJzZXE6ICR7cmVtb3ZhbEluZm8ucmVtb3ZlZFNlcX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmFsSW5mby5yZW1vdmVkQ2xpZW50T3ZlcmxhcC5wdXNoKGNsaWVudElkKTtcbiAgICB9XG4gICAgYW5ub3RhdGVSYW5nZShwcm9wcywgc3RhcnQsIGVuZCwgcmVmU2VxLCBjbGllbnRJZCwgc2VxLCBjb21iaW5pbmdPcCwgb3BBcmdzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW50ZXJ2YWxCb3VuZGFyeShzdGFydCwgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgIHRoaXMuZW5zdXJlSW50ZXJ2YWxCb3VuZGFyeShlbmQsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICBjb25zdCBhbm5vdGF0ZWRTZWdtZW50cyA9IFtdO1xuICAgICAgICBsZXQgYW5ub3RhdGVTZWdtZW50ID0gKHNlZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBzZWdUeXBlID0gc2VnbWVudC5nZXRUeXBlKCk7XG4gICAgICAgICAgICBpZiAoKHNlZ1R5cGUgPT0gU2VnbWVudFR5cGUuTWFya2VyKSB8fCAoc2VnVHlwZSA9PSBTZWdtZW50VHlwZS5UZXh0KSkge1xuICAgICAgICAgICAgICAgIGFubm90YXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5hZGRQcm9wZXJ0aWVzKHByb3BzLCBjb21iaW5pbmdPcCwgc2VxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJNb2RpZmllZEhhbmRsZXIgJiYgKHNlZ1R5cGUgPT09IFNlZ21lbnRUeXBlLk1hcmtlcikgJiYgKHNlcSAhPT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtlck1vZGlmaWVkSGFuZGxlcihzZWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYXBSYW5nZSh7IGxlYWY6IGFubm90YXRlU2VnbWVudCB9LCByZWZTZXEsIGNsaWVudElkLCB1bmRlZmluZWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAodGhpcy5tZXJnZVRyZWVEZWx0YUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlVHJlZURlbHRhQ2FsbGJhY2sob3BBcmdzLCB7XG4gICAgICAgICAgICAgICAgbWVyZ2VUcmVlQ2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogMiAvKiBBTk5PVEFURSAqLyxcbiAgICAgICAgICAgICAgICBtZXJnZVRyZWU6IHRoaXMsXG4gICAgICAgICAgICAgICAgc2VnbWVudHM6IGFubm90YXRlZFNlZ21lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXJrUmFuZ2VSZW1vdmVkKHN0YXJ0LCBlbmQsIHJlZlNlcSwgY2xpZW50SWQsIHNlcSwgb3ZlcndyaXRlID0gZmFsc2UsIG9wQXJncykge1xuICAgICAgICB0aGlzLmVuc3VyZUludGVydmFsQm91bmRhcnkoc3RhcnQsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICB0aGlzLmVuc3VyZUludGVydmFsQm91bmRhcnkoZW5kLCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgbGV0IHNlZ21lbnRHcm91cDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFNlZ21lbnRzID0gW107XG4gICAgICAgIGxldCBzYXZlZExvY2FsUmVmcyA9IFtdO1xuICAgICAgICBsZXQgbWFya1JlbW92ZWQgPSAoc2VnbWVudCwgcG9zLCBzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgICAgICBsZXQgYnJhbmNoSWQgPSB0aGlzLmdldEJyYW5jaElkKGNsaWVudElkKTtcbiAgICAgICAgICAgIGxldCBzZWdCcmFuY2hJZCA9IHRoaXMuZ2V0QnJhbmNoSWQoc2VnbWVudC5jbGllbnRJZCk7XG4gICAgICAgICAgICBmb3IgKGxldCBicmlkID0gYnJhbmNoSWQ7IGJyaWQgPD0gdGhpcy5sb2NhbEJyYW5jaElkOyBicmlkKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVtb3ZhbEluZm8gPSB0aGlzLmdldFJlbW92YWxJbmZvKGJyaWQsIHNlZ0JyYW5jaElkLCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS5kaWFnT3ZlcmxhcHBpbmdSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB5dW1wIEBzZXEgJHtzZXF9IGNsaSAke2dsYyh0aGlzLCB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCl9OiBvdmVybGFwcyBkZWxldGVkIHNlZ21lbnQgJHtyZW1vdmFsSW5mby5yZW1vdmVkU2VxfSB0ZXh0ICcke3NlZ21lbnQudG9TdHJpbmcoKX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92YWxJbmZvLnJlbW92ZWRTZXEgPT09IFVuYXNzaWduZWRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBvbmx5IGhhcHBlbiBvbiBsb2NhbCBicmFuY2ggKGJyaWQgPT09IHRoaXMubG9jYWxCcmFuY2hJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYmVjYXVzZSBjb21lcyBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmFsSW5mby5yZW1vdmVkU2VxID0gc2VxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHJlcGxhY2UgZWFybGllciBzZXF1ZW5jZSBudW1iZXIgZm9yIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRPdmVybGFwcGluZ0NsaWVudChyZW1vdmFsSW5mbywgY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmFsSW5mby5yZW1vdmVkQ2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZhbEluZm8ucmVtb3ZlZFNlcSA9IHNlcTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LmxvY2FsUmVmcyAmJiAoYnJpZCA9PT0gdGhpcy5sb2NhbEJyYW5jaElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWRMb2NhbFJlZnMucHVzaChzZWdtZW50LmxvY2FsUmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LmxvY2FsUmVmcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNhdmUgc2VnbWVudCBzbyBjYW4gYXNzaWduIHJlbW92ZWQgc2VxdWVuY2UgbnVtYmVyIHdoZW4gYWNrZWQgYnkgc2VydmVyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xsYWJXaW5kb3cuY29sbGFib3JhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIHJlcG9ydCBzZWdtZW50IGlmIGNsaWVudCBpbnRlcmVzdGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyTW9kaWZpZWRIYW5kbGVyICYmIChzZWdtZW50LmdldFR5cGUoKSA9PT0gU2VnbWVudFR5cGUuTWFya2VyKSAmJiAoc2VxICE9PSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya2VyTW9kaWZpZWRIYW5kbGVyKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1c2UgcmVtb3ZhbCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIGxldCByZW1vdmFsSW5mbyA9IHRoaXMuZ2V0UmVtb3ZhbEluZm8odGhpcy5sb2NhbEJyYW5jaElkLCBzZWdCcmFuY2hJZCwgc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKChyZW1vdmFsSW5mby5yZW1vdmVkU2VxID09PSBVbmFzc2lnbmVkU2VxdWVuY2VOdW1iZXIpICYmIChjbGllbnRJZCA9PT0gdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRHcm91cCA9IHRoaXMuYWRkVG9QZW5kaW5nTGlzdChzZWdtZW50LCBzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS5vcHRpb25zLnphbWJvbmlTZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb0xSVVNldChzZWdtZW50LCBzZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coYHNhdmVkIGxvY2FsIHJlbW92ZWQgc2VnIHdpdGggdGV4dDogJHt0ZXh0U2VnbWVudC50ZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBhZnRlck1hcmtSZW1vdmVkID0gKG5vZGUsIHBvcywgc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZUxlbmd0aE5ld1N0cnVjdHVyZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tVcGRhdGVMZW5ndGgobm9kZSwgc2VxLCBjbGllbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXBSYW5nZSh7IGxlYWY6IG1hcmtSZW1vdmVkLCBwb3N0OiBhZnRlck1hcmtSZW1vdmVkIH0sIHJlZlNlcSwgY2xpZW50SWQsIHVuZGVmaW5lZCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChzYXZlZExvY2FsUmVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXJTZWc7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWdTYXZlZFJlZnMgb2Ygc2F2ZWRMb2NhbFJlZnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsb2NhbFJlZiBvZiBzZWdTYXZlZFJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsUmVmLnJlZlR5cGUgJiYgKGxvY2FsUmVmLnJlZlR5cGUgJiBvcHMuUmVmZXJlbmNlVHlwZS5TbGlkZU9uUmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZnRlclNlZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZnRlclNlZ09mZiA9IHRoaXMuZ2V0Q29udGFpbmluZ1NlZ21lbnQoc3RhcnQsIHJlZlNlcSwgY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyU2VnID0gYWZ0ZXJTZWdPZmYuc2VnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlclNlZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmLnNlZ21lbnQgPSBhZnRlclNlZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFJlZi5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyU2VnLmFkZExvY2FsUmVmKGxvY2FsUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZnRlclNlZykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tVcGRhdGVQYXRoTGVuZ3RocyhhZnRlclNlZy5wYXJlbnQsIFRyZWVNYWludGVuYW5jZVNlcXVlbmNlTnVtYmVyLCBMb2NhbENsaWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXJnZVRyZWVEZWx0YUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1lcmdlVHJlZURlbHRhQ2FsbGJhY2sob3BBcmdzLCB7XG4gICAgICAgICAgICAgICAgbWVyZ2VUcmVlQ2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogMSAvKiBSRU1PVkUgKi8sXG4gICAgICAgICAgICAgICAgbWVyZ2VUcmVlOiB0aGlzLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzOiByZW1vdmVkU2VnbWVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbGxhYldpbmRvdy5jb2xsYWJvcmF0aW5nICYmIChzZXEgIT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS5vcHRpb25zLnphbWJvbmlTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuemFtYm9uaVNlZ21lbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgc2hvdWxkIG5vdCBiZSB1c2VkLiBJdCBtb2RpZmllcyBleGlzdGluZyBzZWdtZW50cy5cbiAgICByZW1vdmVSYW5nZShzdGFydCwgZW5kLCByZWZTZXEsIGNsaWVudElkKSB7XG4gICAgICAgIGxldCByZW1vdmVJbmZvID0ge307XG4gICAgICAgIHRoaXMubm9kZVJlbW92ZVJhbmdlKHRoaXMucm9vdCwgc3RhcnQsIGVuZCwgcmVmU2VxLCBjbGllbnRJZCwgcmVtb3ZlSW5mbyk7XG4gICAgICAgIGlmIChyZW1vdmVJbmZvLmhpZ2hlc3RCbG9ja1JlbW92aW5nQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCByZW1CbG9jayA9IHJlbW92ZUluZm8uaGlnaGVzdEJsb2NrUmVtb3ZpbmdDaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMubm9kZVVwZGF0ZU9yZGluYWxzKHJlbUJsb2NrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlUmVtb3ZlUmFuZ2UoYmxvY2ssIHN0YXJ0LCBlbmQsIHJlZlNlcSwgY2xpZW50SWQsIHJlbW92ZUluZm8pIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gYmxvY2suY2hpbGRyZW47XG4gICAgICAgIGxldCBzdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZEluZGV4ID0gYmxvY2suY2hpbGRDb3VudDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCBibG9jay5jaGlsZENvdW50OyBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMubm9kZUxlbmd0aChjaGlsZCwgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgICAgICBpZiAoKHN0YXJ0ID49IDApICYmIChzdGFydCA8IGxlbikpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gY2hpbGRJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVJlbW92ZVJhbmdlKGNoaWxkLCBzdGFydCwgZW5kLCByZWZTZXEsIGNsaWVudElkLCByZW1vdmVJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnJlbW92ZVJhbmdlKHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSRVZJRVc6IHJ1biB0aGlzIGNsYXVzZSBldmVuIGlmIGFib3ZlIGNsYXVzZSBydW5zXG4gICAgICAgICAgICBpZiAoZW5kIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBjaGlsZEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVSZW1vdmVSYW5nZShjaGlsZCwgc3RhcnQsIGVuZCwgcmVmU2VxLCBjbGllbnRJZCwgcmVtb3ZlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnJlbW92ZVJhbmdlKDAsIGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCAtPSBsZW47XG4gICAgICAgICAgICBlbmQgLT0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWxldGVDb3VudCA9IChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC0gMTtcbiAgICAgICAgbGV0IGRlbGV0ZVN0YXJ0ID0gc3RhcnRJbmRleCArIDE7XG4gICAgICAgIGlmIChkZWxldGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBub2RlcyBpbiBtaWRkbGUgb2YgcmFuZ2VcbiAgICAgICAgICAgIGxldCBjb3B5U3RhcnQgPSBkZWxldGVTdGFydCArIGRlbGV0ZUNvdW50O1xuICAgICAgICAgICAgbGV0IGNvcHlDb3VudCA9IGJsb2NrLmNoaWxkQ291bnQgLSBjb3B5U3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvcHlDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suYXNzaWduQ2hpbGQoY2hpbGRyZW5bY29weVN0YXJ0ICsgal0sIGRlbGV0ZVN0YXJ0ICsgaiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suY2hpbGRDb3VudCAtPSBkZWxldGVDb3VudDtcbiAgICAgICAgICAgIGlmIChyZW1vdmVJbmZvLmhpZ2hlc3RCbG9ja1JlbW92aW5nQ2hpbGRyZW4gJiYgcmVtb3ZlSW5mby5oaWdoZXN0QmxvY2tSZW1vdmluZ0NoaWxkcmVuLnBhcmVudCAmJlxuICAgICAgICAgICAgICAgIChyZW1vdmVJbmZvLmhpZ2hlc3RCbG9ja1JlbW92aW5nQ2hpbGRyZW4ucGFyZW50ID09PSBibG9jay5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlSW5mby5oaWdoZXN0QmxvY2tSZW1vdmluZ0NoaWxkcmVuID0gYmxvY2sucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlSW5mby5oaWdoZXN0QmxvY2tSZW1vdmluZ0NoaWxkcmVuID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlVXBkYXRlTGVuZ3RoTmV3U3RydWN0dXJlKGJsb2NrKTtcbiAgICB9XG4gICAgbm9kZVVwZGF0ZUxlbmd0aE5ld1N0cnVjdHVyZShub2RlLCByZWN1ciA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYmxvY2tVcGRhdGUobm9kZSk7XG4gICAgICAgIGlmICh0aGlzLmNvbGxhYldpbmRvdy5jb2xsYWJvcmF0aW5nKSB7XG4gICAgICAgICAgICBub2RlLnBhcnRpYWxMZW5ndGhzID0gUGFydGlhbFNlcXVlbmNlTGVuZ3Rocy5jb21iaW5lKHRoaXMsIG5vZGUsIHRoaXMuY29sbGFiV2luZG93LCByZWN1cik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTG9jYWxSZWZlcmVuY2Uoc2VnbWVudCwgbHJlZikge1xuICAgICAgICBsZXQgcmVtb3ZlZFJlZiA9IHNlZ21lbnQucmVtb3ZlTG9jYWxSZWYobHJlZik7XG4gICAgICAgIGlmIChyZW1vdmVkUmVmKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrVXBkYXRlUGF0aExlbmd0aHMoc2VnbWVudC5wYXJlbnQsIFRyZWVNYWludGVuYW5jZVNlcXVlbmNlTnVtYmVyLCBMb2NhbENsaWVudElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRMb2NhbFJlZmVyZW5jZShscmVmKSB7XG4gICAgICAgIGxldCBzZWdtZW50ID0gbHJlZi5zZWdtZW50O1xuICAgICAgICBzZWdtZW50LmFkZExvY2FsUmVmKGxyZWYpO1xuICAgICAgICB0aGlzLmJsb2NrVXBkYXRlUGF0aExlbmd0aHMoc2VnbWVudC5wYXJlbnQsIFRyZWVNYWludGVuYW5jZVNlcXVlbmNlTnVtYmVyLCBMb2NhbENsaWVudElkKTtcbiAgICB9XG4gICAgYmxvY2tVcGRhdGUoYmxvY2spIHtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGxldCBoaWVyQmxvY2s7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrVXBkYXRlTWFya2Vycykge1xuICAgICAgICAgICAgaGllckJsb2NrID0gYmxvY2suaGllckJsb2NrKCk7XG4gICAgICAgICAgICBoaWVyQmxvY2sucmlnaHRtb3N0VGlsZXMgPSBQcm9wZXJ0aWVzLmNyZWF0ZU1hcCgpO1xuICAgICAgICAgICAgaGllckJsb2NrLmxlZnRtb3N0VGlsZXMgPSBQcm9wZXJ0aWVzLmNyZWF0ZU1hcCgpO1xuICAgICAgICAgICAgaGllckJsb2NrLnJhbmdlU3RhY2tzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgbGVuICs9IG5vZGVUb3RhbExlbmd0aCh0aGlzLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja1VwZGF0ZU1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgICBoaWVyQmxvY2suYWRkTm9kZVJlZmVyZW5jZXModGhpcywgY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tVcGRhdGVBY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1VwZGF0ZUFjdGlvbnMuY2hpbGQoYmxvY2ssIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmNhY2hlZExlbmd0aCA9IGxlbjtcbiAgICB9XG4gICAgYmxvY2tVcGRhdGVQYXRoTGVuZ3RocyhibG9jaywgc2VxLCBjbGllbnRJZCwgbmV3U3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgd2hpbGUgKGJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdHJ1Y3R1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVVcGRhdGVMZW5ndGhOZXdTdHJ1Y3R1cmUoYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1VwZGF0ZUxlbmd0aChibG9jaywgc2VxLCBjbGllbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayA9IGJsb2NrLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja1VwZGF0ZUxlbmd0aChub2RlLCBzZXEsIGNsaWVudElkKSB7XG4gICAgICAgIHRoaXMuYmxvY2tVcGRhdGUobm9kZSk7XG4gICAgICAgIGlmICh0aGlzLmNvbGxhYldpbmRvdy5jb2xsYWJvcmF0aW5nICYmIChzZXEgIT0gVW5hc3NpZ25lZFNlcXVlbmNlTnVtYmVyKSAmJiAoc2VxICE9IFRyZWVNYWludGVuYW5jZVNlcXVlbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFydGlhbExlbmd0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChNZXJnZVRyZWUub3B0aW9ucy5pbmNyZW1lbnRhbFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcnRpYWxMZW5ndGhzLnVwZGF0ZSh0aGlzLCBub2RlLCBzZXEsIGNsaWVudElkLCB0aGlzLmNvbGxhYldpbmRvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcnRpYWxMZW5ndGhzID0gUGFydGlhbFNlcXVlbmNlTGVuZ3Rocy5jb21iaW5lKHRoaXMsIG5vZGUsIHRoaXMuY29sbGFiV2luZG93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnBhcnRpYWxMZW5ndGhzID0gUGFydGlhbFNlcXVlbmNlTGVuZ3Rocy5jb21iaW5lKHRoaXMsIG5vZGUsIHRoaXMuY29sbGFiV2luZG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXAoYWN0aW9ucywgcmVmU2VxLCBjbGllbnRJZCwgYWNjdW0pIHtcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdG8gYXZvaWQgY29tcGFyaXNvbnNcbiAgICAgICAgdGhpcy5ub2RlTWFwKHRoaXMucm9vdCwgYWN0aW9ucywgMCwgcmVmU2VxLCBjbGllbnRJZCwgYWNjdW0pO1xuICAgIH1cbiAgICBtYXBSYW5nZShhY3Rpb25zLCByZWZTZXEsIGNsaWVudElkLCBhY2N1bSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLm5vZGVNYXAodGhpcy5yb290LCBhY3Rpb25zLCAwLCByZWZTZXEsIGNsaWVudElkLCBhY2N1bSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHJhbmdlVG9TdHJpbmcoc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgc3RyYnVmID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCB0aGlzLnJvb3QuY2hpbGRDb3VudDsgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnJvb3QuY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWNoaWxkLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuYmxvY2tMZW5ndGgoYmxvY2ssIFVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCB0aGlzLmNvbGxhYldpbmRvdy5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKChzdGFydCA8PSBsZW4pICYmIChlbmQgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJidWYgKz0gdGhpcy5ub2RlVG9TdHJpbmcoYmxvY2ssIHN0cmJ1ZiwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0IC09IGxlbjtcbiAgICAgICAgICAgICAgICBlbmQgLT0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJidWY7XG4gICAgfVxuICAgIG5vZGVUb1N0cmluZyhibG9jaywgc3RyYnVmLCBpbmRlbnRDb3VudCA9IDApIHtcbiAgICAgICAgc3RyYnVmICs9IGludGVybmVkU3BhY2VzKGluZGVudENvdW50KTtcbiAgICAgICAgc3RyYnVmICs9IGBOb2RlIChsZW4gJHtibG9jay5jYWNoZWRMZW5ndGh9KSBwIGxlbiAoJHtibG9jay5wYXJlbnQgPyBibG9jay5wYXJlbnQuY2FjaGVkTGVuZ3RoIDogMH0pIG9yZCAke29yZGluYWxUb0FycmF5KGJsb2NrLm9yZGluYWwpfSB3aXRoICR7YmxvY2suY2hpbGRDb3VudH0gc2VnczpcXG5gO1xuICAgICAgICBpZiAodGhpcy5ibG9ja1VwZGF0ZU1hcmtlcnMpIHtcbiAgICAgICAgICAgIHN0cmJ1ZiArPSBpbnRlcm5lZFNwYWNlcyhpbmRlbnRDb3VudCk7XG4gICAgICAgICAgICBzdHJidWYgKz0gYmxvY2suaGllclRvU3RyaW5nKGluZGVudENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2xsYWJXaW5kb3cuY29sbGFib3JhdGluZykge1xuICAgICAgICAgICAgc3RyYnVmICs9IGludGVybmVkU3BhY2VzKGluZGVudENvdW50KTtcbiAgICAgICAgICAgIHN0cmJ1ZiArPSBibG9jay5wYXJ0aWFsTGVuZ3Rocy50b1N0cmluZygoaWQpID0+IGdsYyh0aGlzLCBpZCksIGluZGVudENvdW50KSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBjaGlsZEluZGV4ID0gMDsgY2hpbGRJbmRleCA8IGJsb2NrLmNoaWxkQ291bnQ7IGNoaWxkSW5kZXgrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWNoaWxkLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgc3RyYnVmID0gdGhpcy5ub2RlVG9TdHJpbmcoY2hpbGQsIHN0cmJ1ZiwgaW5kZW50Q291bnQgKyA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgc3RyYnVmICs9IGludGVybmVkU3BhY2VzKGluZGVudENvdW50ICsgNCk7XG4gICAgICAgICAgICAgICAgc3RyYnVmICs9IGBjbGk6ICR7Z2xjKHRoaXMsIHNlZ21lbnQuY2xpZW50SWQpfSBzZXE6ICR7c2VnbWVudC5zZXF9IG9yZDogJHtvcmRpbmFsVG9BcnJheShzZWdtZW50Lm9yZGluYWwpfWA7XG4gICAgICAgICAgICAgICAgbGV0IHNlZ0JyYW5jaElkID0gdGhpcy5nZXRCcmFuY2hJZChzZWdtZW50LmNsaWVudElkKTtcbiAgICAgICAgICAgICAgICBsZXQgYnJhbmNoSWQgPSB0aGlzLmxvY2FsQnJhbmNoSWQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlbW92YWxJbmZvID0gdGhpcy5nZXRSZW1vdmFsSW5mbyhicmFuY2hJZCwgc2VnQnJhbmNoSWQsIHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmFsSW5mby5yZW1vdmVkU2VxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyYnVmICs9IGAgcmNsaTogJHtnbGModGhpcywgcmVtb3ZhbEluZm8ucmVtb3ZlZENsaWVudElkKX0gcnNlcTogJHtyZW1vdmFsSW5mby5yZW1vdmVkU2VxfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmJ1ZiArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgIHN0cmJ1ZiArPSBpbnRlcm5lZFNwYWNlcyhpbmRlbnRDb3VudCArIDQpO1xuICAgICAgICAgICAgICAgIHN0cmJ1ZiArPSBzZWdtZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgc3RyYnVmICs9IFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmJ1ZjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVUb1N0cmluZyh0aGlzLnJvb3QsIFwiXCIsIDApO1xuICAgIH1cbiAgICBpbmNyZW1lbnRhbEJsb2NrTWFwKHN0YXRlU3RhY2spIHtcbiAgICAgICAgd2hpbGUgKCFzdGF0ZVN0YWNrLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHN0YXRlU3RhY2sudG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhdGUub3AgIT0gSW5jcmVtZW50YWxFeGVjT3AuR28pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuY2hpbGRJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZW5kID0gdGhpcy5ibG9ja0xlbmd0aChzdGF0ZS5ibG9jaywgc3RhdGUucmVmU2VxLCBzdGF0ZS5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hY3Rpb25zLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hY3Rpb25zLnByZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChzdGF0ZS5vcCA9PSBJbmNyZW1lbnRhbEV4ZWNPcC5HbykgJiYgKHN0YXRlLmNoaWxkSW5kZXggPCBzdGF0ZS5ibG9jay5jaGlsZENvdW50KSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHN0YXRlLmJsb2NrLmNoaWxkcmVuW3N0YXRlLmNoaWxkSW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLm5vZGVMZW5ndGgoY2hpbGQsIHN0YXRlLnJlZlNlcSwgc3RhdGUuY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmIChNZXJnZVRyZWUudHJhY2VJbmNyVHJhdmVyc2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGNvbnNpZGVyaW5nIChyICR7c3RhdGUucmVmU2VxfSBjICR7Z2xjKHRoaXMsIHN0YXRlLmNsaWVudElkKX0pIHNlZyB3aXRoIHRleHQgJHtjaGlsZC50ZXh0fSBsZW4gJHtsZW59IHNlcSAke2NoaWxkLnNlcX0gcnNlcSAke2NoaWxkLnJlbW92ZWRTZXF9IGNsaSAke2dsYyh0aGlzLCBjaGlsZC5jbGllbnRJZCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChsZW4gPiAwKSAmJiAoc3RhdGUuc3RhcnQgPCBsZW4pICYmIChzdGF0ZS5lbmQgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRTdGF0ZSA9IG5ldyBJbmNyZW1lbnRhbE1hcFN0YXRlKGNoaWxkLCBzdGF0ZS5hY3Rpb25zLCBzdGF0ZS5wb3MsIHN0YXRlLnJlZlNlcSwgc3RhdGUuY2xpZW50SWQsIHN0YXRlLmNvbnRleHQsIHN0YXRlLnN0YXJ0LCBzdGF0ZS5lbmQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKGNoaWxkU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZUluY3JUcmF2ZXJzYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgYWN0aW9uIG9uIHNlZyB3aXRoIHRleHQgJHtjaGlsZC50ZXh0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aW9ucy5sZWFmKGNoaWxkLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUucG9zICs9IGxlbjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGFydCAtPSBsZW47XG4gICAgICAgICAgICAgICAgc3RhdGUuZW5kIC09IGxlbjtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jaGlsZEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY2hpbGRJbmRleCA9PSBzdGF0ZS5ibG9jay5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUub3AgPT0gSW5jcmVtZW50YWxFeGVjT3AuR28pICYmIHN0YXRlLmFjdGlvbnMucG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aW9ucy5wb3N0KHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlTWFwKG5vZGUsIGFjdGlvbnMsIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgYWNjdW0sIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYmxvY2tMZW5ndGgobm9kZSwgcmVmU2VxLCBjbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFjdGlvbnMucHJlKSB7XG4gICAgICAgICAgICBnbyA9IGFjdGlvbnMucHJlKG5vZGUsIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc3RhcnQsIGVuZCwgYWNjdW0pO1xuICAgICAgICAgICAgaWYgKCFnbykge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCB0aGlzIG5vZGUgYnV0IG5vdCBlbnRpcmUgdHJhdmVyc2FsXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChsZXQgY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCBub2RlLmNoaWxkQ291bnQ7IGNoaWxkSW5kZXgrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5ub2RlTGVuZ3RoKGNoaWxkLCByZWZTZXEsIGNsaWVudElkKTtcbiAgICAgICAgICAgIGlmIChNZXJnZVRyZWUudHJhY2VUcmF2ZXJzYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VnSW5mbztcbiAgICAgICAgICAgICAgICBpZiAoKCFjaGlsZC5pc0xlYWYoKSkgJiYgdGhpcy5jb2xsYWJXaW5kb3cuY29sbGFib3JhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBzZWdJbmZvID0gYG1pbkxlbmd0aDogJHtjaGlsZC5wYXJ0aWFsTGVuZ3Rocy5taW5MZW5ndGh9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWdtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHNlZ0luZm8gPSBgY2xpOiAke2dsYyh0aGlzLCBzZWdtZW50LmNsaWVudElkKX0gc2VxOiAke3NlZ21lbnQuc2VxfSB0ZXh0OiAnJHtzZWdtZW50LnRvU3RyaW5nKCl9J2A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnJlbW92ZWRTZXEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnSW5mbyArPSBgIHJjbGk6ICR7Z2xjKHRoaXMsIHNlZ21lbnQucmVtb3ZlZENsaWVudElkKX0gcnNlcTogJHtzZWdtZW50LnJlbW92ZWRTZXF9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQHRjbGkgJHtnbGModGhpcywgdGhpcy5jb2xsYWJXaW5kb3cuY2xpZW50SWQpfTogbWFwIGxlbjogJHtsZW59IHN0YXJ0OiAke3N0YXJ0fSBlbmQ6ICR7ZW5kfSBgICsgc2VnSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaXNMZWFmID0gY2hpbGQuaXNMZWFmKCk7XG4gICAgICAgICAgICBpZiAoZ28gJiYgKGVuZCA+IDApICYmIChsZW4gPiAwKSAmJiAoc3RhcnQgPCBsZW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgZW50cnkgY29udGFpbmluZyBwb3NcbiAgICAgICAgICAgICAgICBpZiAoIWlzTGVhZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gdGhpcy5ub2RlTWFwKGNoaWxkLCBhY3Rpb25zLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIGFjY3VtLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1lcmdlVHJlZS50cmFjZVRyYXZlcnNhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEB0Y2xpICR7Z2xjKHRoaXMsIHRoaXMuY29sbGFiV2luZG93LmNsaWVudElkKX06IG1hcCBsZWFmIGFjdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdvID0gYWN0aW9ucy5sZWFmKGNoaWxkLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHN0YXJ0LCBlbmQsIGFjY3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdvKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9ucy5zaGlmdCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMuc2hpZnQoY2hpbGQsIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgc3RhcnQsIGVuZCwgYWNjdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIHN0YXJ0IC09IGxlbjtcbiAgICAgICAgICAgIGVuZCAtPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvICYmIGFjdGlvbnMucG9zdCkge1xuICAgICAgICAgICAgZ28gPSBhY3Rpb25zLnBvc3Qobm9kZSwgcG9zLCByZWZTZXEsIGNsaWVudElkLCBzdGFydCwgZW5kLCBhY2N1bSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdvO1xuICAgIH1cbiAgICAvLyBzdHJhaWdodCBjYWxsIGV2ZXJ5IHNlZ21lbnQ7IGdvZXMgdW50aWwgbGVhZiBhY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgIG5vZGVNYXBSZXZlcnNlKGJsb2NrLCBhY3Rpb25zLCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIGFjY3VtKSB7XG4gICAgICAgIGxldCBnbyA9IHRydWU7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBjaGlsZEluZGV4ID0gYmxvY2suY2hpbGRDb3VudCAtIDE7IGNoaWxkSW5kZXggPj0gMDsgY2hpbGRJbmRleC0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltjaGlsZEluZGV4XTtcbiAgICAgICAgICAgIGxldCBpc0xlYWYgPSBjaGlsZC5pc0xlYWYoKTtcbiAgICAgICAgICAgIGlmIChnbykge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGVudHJ5IGNvbnRhaW5pbmcgcG9zXG4gICAgICAgICAgICAgICAgaWYgKCFpc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbyA9IHRoaXMubm9kZU1hcFJldmVyc2UoY2hpbGQsIGFjdGlvbnMsIHBvcywgcmVmU2VxLCBjbGllbnRJZCwgYWNjdW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbyA9IGFjdGlvbnMubGVhZihjaGlsZCwgcG9zLCByZWZTZXEsIGNsaWVudElkLCAwLCAwLCBhY2N1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnbykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbztcbiAgICB9XG59XG4vLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyXG5NZXJnZVRyZWUuVGV4dFNlZ21lbnRHcmFudWxhcml0eSA9IDEyODtcbk1lcmdlVHJlZS56YW1ib25pU2VnbWVudHNNYXhDb3VudCA9IDI7XG5NZXJnZVRyZWUub3B0aW9ucyA9IHtcbiAgICBpbmNyZW1lbnRhbFVwZGF0ZTogdHJ1ZSxcbiAgICB6YW1ib25pU2VnbWVudHM6IHRydWUsXG4gICAgbWVhc3VyZVdpbmRvd1RpbWU6IHRydWUsXG4gICAgbWVhc3VyZU9yZGluYWxUaW1lOiB0cnVlLFxufTtcbk1lcmdlVHJlZS5zZWFyY2hDaHVua1NpemUgPSAyNTY7XG5NZXJnZVRyZWUudHJhY2VBcHBlbmQgPSBmYWxzZTtcbk1lcmdlVHJlZS50cmFjZVpSZW1vdmUgPSBmYWxzZTtcbk1lcmdlVHJlZS50cmFjZU9yZGluYWxzID0gZmFsc2U7XG5NZXJnZVRyZWUudHJhY2VHYXRoZXJUZXh0ID0gZmFsc2U7XG5NZXJnZVRyZWUuZGlhZ0luc2VydFRpZSA9IGZhbHNlO1xuTWVyZ2VUcmVlLnNraXBMZWZ0U2hpZnQgPSB0cnVlO1xuTWVyZ2VUcmVlLmRpYWdPdmVybGFwcGluZ1JlbW92ZSA9IGZhbHNlO1xuTWVyZ2VUcmVlLnRyYWNlVHJhdmVyc2FsID0gZmFsc2U7XG5NZXJnZVRyZWUudHJhY2VJbmNyVHJhdmVyc2FsID0gZmFsc2U7XG5NZXJnZVRyZWUudGhlVW5maW5pc2hlZE5vZGUgPSB7IGNoaWxkQ291bnQ6IC0xIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVRyZWUuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxuLy8gdHNsaW50OmRpc2FibGU6YmFuLXR5cGVzXG5leHBvcnQgdmFyIFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFJlZmVyZW5jZVR5cGUpIHtcbiAgICBSZWZlcmVuY2VUeXBlW1JlZmVyZW5jZVR5cGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XG4gICAgUmVmZXJlbmNlVHlwZVtSZWZlcmVuY2VUeXBlW1wiVGlsZVwiXSA9IDFdID0gXCJUaWxlXCI7XG4gICAgUmVmZXJlbmNlVHlwZVtSZWZlcmVuY2VUeXBlW1wiTmVzdEJlZ2luXCJdID0gMl0gPSBcIk5lc3RCZWdpblwiO1xuICAgIFJlZmVyZW5jZVR5cGVbUmVmZXJlbmNlVHlwZVtcIk5lc3RFbmRcIl0gPSA0XSA9IFwiTmVzdEVuZFwiO1xuICAgIFJlZmVyZW5jZVR5cGVbUmVmZXJlbmNlVHlwZVtcIlJhbmdlQmVnaW5cIl0gPSAxNl0gPSBcIlJhbmdlQmVnaW5cIjtcbiAgICBSZWZlcmVuY2VUeXBlW1JlZmVyZW5jZVR5cGVbXCJSYW5nZUVuZFwiXSA9IDMyXSA9IFwiUmFuZ2VFbmRcIjtcbiAgICBSZWZlcmVuY2VUeXBlW1JlZmVyZW5jZVR5cGVbXCJTbGlkZU9uUmVtb3ZlXCJdID0gNjRdID0gXCJTbGlkZU9uUmVtb3ZlXCI7XG4gICAgUmVmZXJlbmNlVHlwZVtSZWZlcmVuY2VUeXBlW1wiVHJhbnNpZW50XCJdID0gMjU2XSA9IFwiVHJhbnNpZW50XCI7XG59KShSZWZlcmVuY2VUeXBlIHx8IChSZWZlcmVuY2VUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgSW50ZXJ2YWxUeXBlO1xuKGZ1bmN0aW9uIChJbnRlcnZhbFR5cGUpIHtcbiAgICBJbnRlcnZhbFR5cGVbSW50ZXJ2YWxUeXBlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIEludGVydmFsVHlwZVtJbnRlcnZhbFR5cGVbXCJOZXN0XCJdID0gMV0gPSBcIk5lc3RcIjtcbiAgICBJbnRlcnZhbFR5cGVbSW50ZXJ2YWxUeXBlW1wiU2xpZGVPblJlbW92ZVwiXSA9IDJdID0gXCJTbGlkZU9uUmVtb3ZlXCI7XG4gICAgSW50ZXJ2YWxUeXBlW0ludGVydmFsVHlwZVtcIlRyYW5zaWVudFwiXSA9IDRdID0gXCJUcmFuc2llbnRcIjtcbn0pKEludGVydmFsVHlwZSB8fCAoSW50ZXJ2YWxUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wcy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY29tYmluZShjb21iaW5pbmdJbmZvLCBjdXJyZW50VmFsdWUsIG5ld1ZhbHVlLCBzZXEpIHtcbiAgICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gY29tYmluaW5nSW5mby5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIC8vIGZpeGVkIHNldCBvZiBvcGVyYXRpb25zIGZvciBub3dcbiAgICBzd2l0Y2ggKGNvbWJpbmluZ0luZm8ubmFtZSkge1xuICAgICAgICBjYXNlIFwiaW5jclwiOlxuICAgICAgICAgICAgY3VycmVudFZhbHVlICs9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgaWYgKGNvbWJpbmluZ0luZm8ubWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgY29tYmluaW5nSW5mby5taW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBjb21iaW5pbmdJbmZvLm1pblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29uc2Vuc3VzXCI6XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjdiA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Yuc2VxID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjdi5zZXEgPSBzZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hQcm9wZXJ0aWVzKGEsIGIpIHtcbiAgICBpZiAoYSkge1xuICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZvciBub3csIHN0cmFpZ2h0Zm9yd2FyZDsgbGF0ZXIgdXNlIGhhc2hpbmdcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYltrZXldICE9PSBhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGJhc2UsIGV4dGVuc2lvbiwgY29tYmluaW5nT3AsIHNlcSkge1xuICAgIGlmIChleHRlbnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoKHR5cGVvZiBleHRlbnNpb24gIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgb2ggbXkgJHtleHRlbnNpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGV4dGVuc2lvbikge1xuICAgICAgICAgICAgbGV0IHYgPSBleHRlbnNpb25ba2V5XTtcbiAgICAgICAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb21iaW5pbmdPcCAmJiAoY29tYmluaW5nT3AubmFtZSAhPT0gXCJyZXdyaXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2Vba2V5XSA9IGNvbWJpbmUoY29tYmluaW5nT3AsIGJhc2Vba2V5XSwgdiwgc2VxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2Vba2V5XSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb3BlcnRpZXMob2xkUHJvcHMsIG5ld1Byb3BzLCBvcCwgc2VxKSB7XG4gICAgaWYgKCghb2xkUHJvcHMpIHx8IChvcCAmJiAob3AubmFtZSA9PT0gXCJyZXdyaXRlXCIpKSkge1xuICAgICAgICBvbGRQcm9wcyA9IGNyZWF0ZU1hcCgpO1xuICAgIH1cbiAgICBleHRlbmQob2xkUHJvcHMsIG5ld1Byb3BzLCBvcCwgc2VxKTtcbiAgICByZXR1cm4gb2xkUHJvcHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kSWZVbmRlZmluZWQoYmFzZSwgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKGV4dGVuc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGV4dGVuc2lvbiAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBvaCBteSAke2V4dGVuc2lvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpZiAoYmFzZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiYXNlW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cbi8qKiBDcmVhdGUgYSBNYXBMaWtlIHdpdGggZ29vZCBwZXJmb3JtYW5jZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1udWxsLWtleXdvcmRcbiAgICAvLyBVc2luZyAnZGVsZXRlJyBvbiBhbiBvYmplY3QgY2F1c2VzIFY4IHRvIHB1dCB0aGUgb2JqZWN0IGluIGRpY3Rpb25hcnkgbW9kZS5cbiAgICAvLyBUaGlzIGRpc2FibGVzIGNyZWF0aW9uIG9mIGhpZGRlbiBjbGFzc2VzLCB3aGljaCBhcmUgZXhwZW5zaXZlIHdoZW4gYW4gb2JqZWN0IGlzXG4gICAgLy8gY29uc3RhbnRseSBjaGFuZ2luZyBzaGFwZS5cbiAgICBtYXBbXCJfX1wiXSA9IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgbWFwW1wiX19cIl07XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIiwiaW1wb3J0IHsgTGlzdE1ha2VIZWFkIH0gZnJvbSBcIi4vY29sbGVjdGlvbnNcIjtcbmV4cG9ydCBjbGFzcyBTZWdtZW50R3JvdXBDb2xsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZWdtZW50KSB7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIHRoaXMuc2VnbWVudEdyb3VwcyA9IExpc3RNYWtlSGVhZCgpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudEdyb3Vwcy5jb3VudCgpO1xuICAgIH1cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRHcm91cHMuZW1wdHkoKTtcbiAgICB9XG4gICAgZW5xdWV1ZShzZWdtZW50R3JvdXApIHtcbiAgICAgICAgdGhpcy5zZWdtZW50R3JvdXBzLmVucXVldWUoc2VnbWVudEdyb3VwKTtcbiAgICAgICAgc2VnbWVudEdyb3VwLnNlZ21lbnRzLnB1c2godGhpcy5zZWdtZW50KTtcbiAgICB9XG4gICAgZGVxdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudEdyb3Vwcy5kZXF1ZXVlKCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRHcm91cHMuY2xlYXIoKTtcbiAgICB9XG4gICAgY29weVRvKHNlZ21lbnQpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50R3JvdXBzLndhbGsoKHNnKSA9PiBzZWdtZW50LnNlZ21lbnRHcm91cHMuZW5xdWV1ZShzZykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlZ21lbnRHcm91cENvbGxlY3Rpb24uanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGaWxlTW9kZSwgVHJlZUVudHJ5IH0gZnJvbSBcIkBwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zXCI7XG5pbXBvcnQgKiBhcyBNZXJnZVRyZWUgZnJvbSBcIi4vbWVyZ2VUcmVlXCI7XG5leHBvcnQgY2xhc3MgU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKG1lcmdlVHJlZSwgZmlsZW5hbWUsIG9uQ29tcGxldGlvbikge1xuICAgICAgICB0aGlzLm1lcmdlVHJlZSA9IG1lcmdlVHJlZTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLm9uQ29tcGxldGlvbiA9IG9uQ29tcGxldGlvbjtcbiAgICB9XG4gICAgZ2V0U2VxTGVuZ3RoU2VncyhhbGxTZWdtZW50cywgYWxsTGVuZ3RocywgYXBwcm94U2VxdWVuY2VMZW5ndGgsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGxldCBzZXF1ZW5jZUxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBzZWdDb3VudCA9IDA7XG4gICAgICAgIHdoaWxlICgoc2VxdWVuY2VMZW5ndGggPCBhcHByb3hTZXF1ZW5jZUxlbmd0aCkgJiYgKChzdGFydEluZGV4ICsgc2VnQ291bnQpIDwgYWxsU2VnbWVudHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgbGV0IHBzZWcgPSBhbGxTZWdtZW50c1tzdGFydEluZGV4ICsgc2VnQ291bnRdO1xuICAgICAgICAgICAgc2VnQ291bnQrKztcbiAgICAgICAgICAgIHNlZ3MucHVzaChwc2VnKTtcbiAgICAgICAgICAgIHNlcXVlbmNlTGVuZ3RoICs9IGFsbExlbmd0aHNbc3RhcnRJbmRleCArIHNlZ0NvdW50XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2h1bmtTdGFydFNlZ21lbnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgIGNodW5rU2VnbWVudENvdW50OiBzZWdDb3VudCxcbiAgICAgICAgICAgIGNodW5rTGVuZ3RoQ2hhcnM6IHNlcXVlbmNlTGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxMZW5ndGhDaGFyczogdGhpcy5oZWFkZXIuc2VnbWVudHNUb3RhbExlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsU2VnbWVudENvdW50OiBhbGxTZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjaHVua1NlcXVlbmNlTnVtYmVyOiB0aGlzLmhlYWRlci5zZXEsXG4gICAgICAgICAgICBzZWdtZW50VGV4dHM6IHNlZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZW1pdCgpIHtcbiAgICAgICAgbGV0IGNodW5rMSA9IHRoaXMuZ2V0U2VxTGVuZ3RoU2Vncyh0aGlzLnNlZ21lbnRzLCB0aGlzLnNlZ21lbnRMZW5ndGhzLCAxMDAwMCk7XG4gICAgICAgIGxldCBjaHVuazIgPSB0aGlzLmdldFNlcUxlbmd0aFNlZ3ModGhpcy5zZWdtZW50cywgdGhpcy5zZWdtZW50TGVuZ3RocywgY2h1bmsxLnRvdGFsTGVuZ3RoQ2hhcnMsIGNodW5rMS5jaHVua1NlZ21lbnRDb3VudCk7XG4gICAgICAgIGNvbnN0IHRyZWUgPSB7XG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiBGaWxlTW9kZS5GaWxlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUcmVlRW50cnlbVHJlZUVudHJ5LkJsb2JdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IEpTT04uc3RyaW5naWZ5KGNodW5rMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiBGaWxlTW9kZS5GaWxlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBcImJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVHJlZUVudHJ5W1RyZWVFbnRyeS5CbG9iXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBKU09OLnN0cmluZ2lmeShjaHVuazIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwidXRmLThcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNoYTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIGV4dHJhY3RTeW5jKCkge1xuICAgICAgICBsZXQgY29sbGFiV2luZG93ID0gdGhpcy5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCk7XG4gICAgICAgIHRoaXMuc2VxID0gY29sbGFiV2luZG93Lm1pblNlcTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB7XG4gICAgICAgICAgICBzZWdtZW50c1RvdGFsTGVuZ3RoOiB0aGlzLm1lcmdlVHJlZS5nZXRMZW5ndGgodGhpcy5tZXJnZVRyZWUuY29sbGFiV2luZG93Lm1pblNlcSwgTWVyZ2VUcmVlLk5vbkNvbGxhYkNsaWVudCksXG4gICAgICAgICAgICBzZXE6IHRoaXMubWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5taW5TZXEsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGxldCBzZWdMZW5ndGhzID0gW107XG4gICAgICAgIGxldCBleHRyYWN0U2VnbWVudCA9IChzZWdtZW50LCBwb3MsIHJlZlNlcSwgY2xpZW50SWQsIHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgICAgIGlmICgoc2VnbWVudC5zZXEgIT0gTWVyZ2VUcmVlLlVuYXNzaWduZWRTZXF1ZW5jZU51bWJlcikgJiYgKHNlZ21lbnQuc2VxIDw9IHRoaXMuc2VxKSAmJlxuICAgICAgICAgICAgICAgICgoc2VnbWVudC5yZW1vdmVkU2VxID09PSB1bmRlZmluZWQpIHx8IChzZWdtZW50LnJlbW92ZWRTZXEgPT0gTWVyZ2VUcmVlLlVuYXNzaWduZWRTZXF1ZW5jZU51bWJlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlZ21lbnQucmVtb3ZlZFNlcSA+IHRoaXMuc2VxKSkpIHtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goc2VnbWVudC50b0pTT05PYmplY3QoKSk7XG4gICAgICAgICAgICAgICAgc2VnTGVuZ3Rocy5wdXNoKHNlZ21lbnQuY2FjaGVkTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1lcmdlVHJlZS5tYXAoeyBsZWFmOiBleHRyYWN0U2VnbWVudCB9LCB0aGlzLnNlcSwgTWVyZ2VUcmVlLk5vbkNvbGxhYkNsaWVudCk7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBzZWdzO1xuICAgICAgICB0aGlzLnNlZ21lbnRMZW5ndGhzID0gc2VnTGVuZ3RocztcbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkQ2h1bmsoc3RvcmFnZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGNodW5rQXNTdHJpbmcgPSB5aWVsZCBzdG9yYWdlLnJlYWQocGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gU25hcHNob3QucHJvY2Vzc0NodW5rKGNodW5rQXNTdHJpbmcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHByb2Nlc3NDaHVuayhjaHVuaykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShjaHVuaywgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGYtOFwiKSk7XG4gICAgfVxufVxuU25hcHNob3QuU25hcENodW5rTWF4U2l6ZSA9IDB4MjAwMDA7XG5TbmFwc2hvdC5TZWdtZW50TGVuZ3RoU2l6ZSA9IDB4NDtcblNuYXBzaG90LlNuYXBzaG90SGVhZGVyU2l6ZSA9IDB4MTQ7XG5TbmFwc2hvdC5FbXB0eUNodW5rID0ge1xuICAgIGNodW5rU3RhcnRTZWdtZW50SW5kZXg6IC0xLFxuICAgIGNodW5rU2VnbWVudENvdW50OiAtMSxcbiAgICBjaHVua0xlbmd0aENoYXJzOiAtMSxcbiAgICB0b3RhbExlbmd0aENoYXJzOiAtMSxcbiAgICB0b3RhbFNlZ21lbnRDb3VudDogLTEsXG4gICAgY2h1bmtTZXF1ZW5jZU51bWJlcjogMCxcbiAgICBzZWdtZW50VGV4dHM6IFtdLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNuYXBzaG90LmpzLm1hcCIsImltcG9ydCAqIGFzIE1lcmdlVHJlZSBmcm9tIFwiLi9tZXJnZVRyZWVcIjtcbmltcG9ydCAqIGFzIG9wcyBmcm9tIFwiLi9vcHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBsb2FkU2VnbWVudHMoY29udGVudCwgc2VnTGltaXQsIG1hcmtlcnMgPSBmYWxzZSwgd2l0aFByb3BzID0gdHJ1ZSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1wYXJhbWV0ZXItcmVhc3NpZ25tZW50XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXlxcdUZFRkYvLCBcIlwiKTtcbiAgICBjb25zdCBzZXEgPSBNZXJnZVRyZWUuVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXI7XG4gICAgY29uc3QgY2xpID0gTWVyZ2VUcmVlLkxvY2FsQ2xpZW50SWQ7XG4gICAgY29uc3QgcGFyYWdyYXBocyA9IGNvbnRlbnQuc3BsaXQoXCJcXHJcXG5cIik7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWluY3JlbWVudC1kZWNyZW1lbnRcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyYWdyYXBocy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwYXJhZ3JhcGhzW2ldID0gcGFyYWdyYXBoc1tpXVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbi9nLCBcIiBcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDFjfFxcdTIwMWQvZywgJ1wiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDE5L2csIFwiJ1wiKTtcbiAgICAgICAgaWYgKCFtYXJrZXJzICYmIGkgIT09IHBhcmFncmFwaHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcGFyYWdyYXBoc1tpXSArPSBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXJhZ3JhcGggb2YgcGFyYWdyYXBocykge1xuICAgICAgICBsZXQgcGdNYXJrZXI7XG4gICAgICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICAgICAgICBwZ01hcmtlciA9IE1lcmdlVHJlZS5NYXJrZXIubWFrZShvcHMuUmVmZXJlbmNlVHlwZS5UaWxlLCB7IFtNZXJnZVRyZWUucmVzZXJ2ZWRUaWxlTGFiZWxzS2V5XTogW1wicGdcIl0gfSwgc2VxLCBjbGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aXRoUHJvcHMpIHtcbiAgICAgICAgICAgIGlmICgocGFyYWdyYXBoLmluZGV4T2YoXCJDaGFwdGVyXCIpID49IDApIHx8IChwYXJhZ3JhcGguaW5kZXhPZihcIlBSSURFIEFORCBQUkVKXCIpID49IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGdNYXJrZXIuYWRkUHJvcGVydGllcyh7IGhlYWRlcjogMiB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgTWVyZ2VUcmVlLlRleHRTZWdtZW50KHBhcmFncmFwaCwgc2VxLCBjbGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goTWVyZ2VUcmVlLlRleHRTZWdtZW50Lm1ha2UocGFyYWdyYXBoLCB7IGZvbnRTaXplOiBcIjE0MCVcIiwgbGluZUhlaWdodDogXCIxNTAlXCIgfSwgc2VxLCBjbGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXBoU3RyaW5ncyA9IHBhcmFncmFwaC5zcGxpdChcIl9cIik7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWluY3JlbWVudC1kZWNyZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZW1waFN0cmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1waFN0cmluZ3NbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goTWVyZ2VUcmVlLlRleHRTZWdtZW50Lm1ha2UoZW1waFN0cmluZ3NbaV0sIHsgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sIHNlcSwgY2xpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1waFN0cmluZ3NbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IE1lcmdlVHJlZS5UZXh0U2VnbWVudChlbXBoU3RyaW5nc1tpXSwgc2VxLCBjbGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IE1lcmdlVHJlZS5UZXh0U2VnbWVudChwYXJhZ3JhcGgsIHNlcSwgY2xpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gocGdNYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWdMaW1pdCA+IDApIHtcbiAgICAgICAgc2VnbWVudHMubGVuZ3RoID0gc2VnTGltaXQ7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2FkVGV4dChjb250ZW50LCBtZXJnZVRyZWUsIHNlZ0xpbWl0LCBtYXJrZXJzID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IGxvYWRTZWdtZW50cyhjb250ZW50LCBzZWdMaW1pdCwgbWFya2Vycyk7XG4gICAgbWVyZ2VUcmVlLnJlbG9hZEZyb21TZWdtZW50cyhzZWdtZW50cyk7XG4gICAgLy8gY29uc29sZS5sb2coYE51bWJlciBvZiBTZWdtZW50czogJHtzZWdtZW50cy5sZW5ndGh9YCk7XG4gICAgLy8gY29uc29sZS5sb2coYEhlaWdodDogJHttZXJnZVRyZWUuZ2V0U3RhdHMoKS5tYXhIZWlnaHR9YCk7XG4gICAgLy8gY29uc29sZS5sb2coc2VnVHJlZS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gbWVyZ2VUcmVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udGFpbmVyX2RlZmluaXRpb25zXzEgPSByZXF1aXJlKFwiQHByYWd1ZS9jb250YWluZXItZGVmaW5pdGlvbnNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby11bnNhZmUtYW55XG5jbGFzcyBDb21wb25lbnRSdW50aW1lIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UnVudGltZSwgcGtnLCBpZCwgZXhpc3RpbmcsIGNoYWluY29kZSwgc3RvcmFnZSwgYmFzZVNuYXBzaG90KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaG9zdFJ1bnRpbWUgPSBob3N0UnVudGltZTtcbiAgICAgICAgdGhpcy5wa2cgPSBwa2c7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5leGlzdGluZyA9IGV4aXN0aW5nO1xuICAgICAgICB0aGlzLmNoYWluY29kZSA9IGNoYWluY29kZTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5iYXNlU25hcHNob3QgPSBiYXNlU25hcHNob3Q7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYWNrcyB0aGUgYmFzZSBzbmFwc2hvdCBoYXNoLiBJZiBubyBvcHMgZWZmZWN0IHRoaXMgY29tcG9uZW50IHRoZW4gdGhlIHNoYSB2YWx1ZSBjYW4gYmUgcmV0dXJuZWQgb24gYVxuICAgICAgICAvLyBzbmFwc2hvdCBjYWxsXG4gICAgICAgIHRoaXMuYmFzZVNoYSA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVNoYSA9IGJhc2VTbmFwc2hvdCA/IGJhc2VTbmFwc2hvdC5zaGEgOiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGhvc3RSdW50aW1lLCBpZCwgcGtnLCBzdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0geWllbGQgaG9zdFJ1bnRpbWUuZ2V0UGFja2FnZShwa2cpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0geWllbGQgZmFjdG9yeS5pbnN0YW50aWF0ZUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudFJ1bnRpbWUoaG9zdFJ1bnRpbWUsIHBrZywgaWQsIGZhbHNlLCBleHRlbnNpb24sIHN0b3JhZ2UsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBMb2FkRnJvbVNuYXBzaG90KGhvc3RSdW50aW1lLCBpZCwgcGtnLCBzdG9yYWdlLCBjaGFubmVscykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHlpZWxkIGhvc3RSdW50aW1lLmdldFBhY2thZ2UocGtnKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHlpZWxkIGZhY3RvcnkuaW5zdGFudGlhdGVDb21wb25lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRSdW50aW1lKGhvc3RSdW50aW1lLCBwa2csIGlkLCB0cnVlLCBleHRlbnNpb24sIHN0b3JhZ2UsIGNoYW5uZWxzKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgdGVuYW50SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RSdW50aW1lLnRlbmFudElkO1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuaWQ7XG4gICAgfVxuICAgIGdldCBwYXJlbnRCcmFuY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RSdW50aW1lLnBhcmVudEJyYW5jaDtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RSdW50aW1lLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBjbGllbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuY2xpZW50SWQ7XG4gICAgfVxuICAgIGdldCBibG9iTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuYmxvYk1hbmFnZXI7XG4gICAgfVxuICAgIGdldCBkZWx0YU1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RSdW50aW1lLmRlbHRhTWFuYWdlcjtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuY29ubmVjdGVkO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGlvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0UnVudGltZS5jb25uZWN0aW9uU3RhdGU7XG4gICAgfVxuICAgIGdldCBzdWJtaXRGbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuc3VibWl0Rm47XG4gICAgfVxuICAgIGdldCBzbmFwc2hvdEZuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0UnVudGltZS5zbmFwc2hvdEZuO1xuICAgIH1cbiAgICBnZXQgY2xvc2VGbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuY2xvc2VGbjtcbiAgICB9XG4gICAgZ2V0IGJyYW5jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuYnJhbmNoO1xuICAgIH1cbiAgICBjcmVhdGVBbmRBdHRhY2hDb21wb25lbnQoaWQsIHBrZykge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0UnVudGltZS5jcmVhdGVBbmRBdHRhY2hDb21wb25lbnQoaWQsIHBrZyk7XG4gICAgfVxuICAgIGdldENvbXBvbmVudChpZCwgd2FpdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0UnVudGltZS5nZXRDb21wb25lbnQoaWQsIHdhaXQpO1xuICAgIH1cbiAgICBjaGFuZ2VDb25uZWN0aW9uU3RhdGUodmFsdWUsIGNsaWVudElkKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlci5jaGFuZ2VDb25uZWN0aW9uU3RhdGUodmFsdWUsIGNsaWVudElkKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGFmdGVyIGEgc25hcHNob3QgdG8gdXBkYXRlIHRoZSBiYXNlIHNoYVxuICAgIHVwZGF0ZUJhc2VTaGEoc2hhKSB7XG4gICAgICAgIHRoaXMuYmFzZVNoYSA9IHNoYTtcbiAgICB9XG4gICAgcHJlcGFyZShtZXNzYWdlLCBsb2NhbCkge1xuICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnByZXBhcmUobWVzc2FnZSwgbG9jYWwpO1xuICAgIH1cbiAgICBwcm9jZXNzKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIC8vIGNvbXBvbmVudCBoYXMgYmVlbiBtb2RpZmllZCBhbmQgd2lsbCBuZWVkIHRvIHJlZ2VuZXJhdGUgaXRzIHNuYXBzaG90XG4gICAgICAgIHRoaXMuYmFzZVNoYSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIucHJvY2VzcyhtZXNzYWdlLCBsb2NhbCwgY29udGV4dCk7XG4gICAgfVxuICAgIGdldFF1b3J1bSgpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuZ2V0UXVvcnVtKCk7XG4gICAgfVxuICAgIGdldEJsb2JNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2JNYW5hZ2VyLmdldEJsb2JNZXRhZGF0YSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zbmFwc2hvdCgpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5ob3N0UnVudGltZS5jbG9zZUZuKCk7XG4gICAgfVxuICAgIHVwZGF0ZU1pblNlcXVlbmNlTnVtYmVyKG1zbikge1xuICAgICAgICB0aGlzLmhhbmRsZXIudXBkYXRlTWluU2VxdWVuY2VOdW1iZXIobXNuKTtcbiAgICB9XG4gICAgc25hcHNob3QoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEF0dHJpYnV0ZXMgPSB7IHBrZzogdGhpcy5wa2cgfTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLmNoYWluY29kZS5zbmFwc2hvdCgpO1xuICAgICAgICBzbmFwc2hvdC5lbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgbW9kZTogY29udGFpbmVyX2RlZmluaXRpb25zXzEuRmlsZU1vZGUuRmlsZSxcbiAgICAgICAgICAgIHBhdGg6IFwiLmNvbXBvbmVudFwiLFxuICAgICAgICAgICAgdHlwZTogY29udGFpbmVyX2RlZmluaXRpb25zXzEuVHJlZUVudHJ5W2NvbnRhaW5lcl9kZWZpbml0aW9uc18xLlRyZWVFbnRyeS5CbG9iXSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29udGVudHM6IEpTT04uc3RyaW5naWZ5KGNvbXBvbmVudEF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYmFzZSBzaGEgc3RpbGwgYmVpbmcgc2V0IG1lYW5zIHByZXZpb3VzIHNuYXBzaG90IGlzIHN0aWxsIHZhbGlkXG4gICAgICAgIGlmICh0aGlzLmJhc2VTaGEpIHtcbiAgICAgICAgICAgIHNuYXBzaG90LnNoYSA9IHRoaXMuYmFzZVNoYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgfVxuICAgIHJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5yZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VibWl0TWVzc2FnZSh0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Ym1pdCh0eXBlLCBjb250ZW50KTtcbiAgICB9XG4gICAgZXJyb3IoZXJyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0geWllbGQgdGhpcy5jaGFpbmNvZGUucnVuKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXR0YWNoKHBsYXRmb3JtKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmNvZGUuYXR0YWNoKHBsYXRmb3JtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1Ym1pdCh0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0ge1xuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5pZCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJ1bnRpbWUuc3VibWl0Rm4oY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuT3BlcmF0aW9uLCBlbnZlbG9wZSk7XG4gICAgfVxuICAgIHZlcmlmeU5vdENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9uZW50UnVudGltZSA9IENvbXBvbmVudFJ1bnRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnRSdW50aW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDb21wb25lbnRTdG9yYWdlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcmFnZVNlcnZpY2UsIGJsb2JzKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZVNlcnZpY2UgPSBzdG9yYWdlU2VydmljZTtcbiAgICAgICAgdGhpcy5ibG9icyA9IGJsb2JzO1xuICAgIH1cbiAgICBnZXQgcmVwb3NpdG9yeVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVNlcnZpY2UucmVwb3NpdG9yeVVybDtcbiAgICB9XG4gICAgLy8gVE9ETyBXaWxsIGEgc3ViY29tcG9uZW50IGV2ZXIgbmVlZCB0aGlzPyBPciB3ZSBjYW4gcHJvYmFibHkgcmVzdHJpY3QgdGhlIHJlZiB0byBpdHNlbGZcbiAgICBnZXRTbmFwc2hvdFRyZWUodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRTbmFwc2hvdFRyZWUodmVyc2lvbik7XG4gICAgfVxuICAgIGdldFZlcnNpb25zKHNoYSwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0VmVyc2lvbnMoc2hhLCBjb3VudCk7XG4gICAgfVxuICAgIGdldENvbnRlbnQodmVyc2lvbiwgcGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRDb250ZW50KHZlcnNpb24sIHBhdGgpO1xuICAgIH1cbiAgICByZWFkKHNoYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvYnMuaGFzKHNoYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9icy5nZXQoc2hhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VTZXJ2aWNlLnJlYWQoc2hhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE8gdGhlIHdyaXRlIGFzIHdlbGwgcG90ZW50aWFsbHkgZG9lc24ndCBzZWVtIG5lY2Vzc2FyeVxuICAgIHdyaXRlKHJvb3QsIHBhcmVudHMsIG1lc3NhZ2UsIHJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS53cml0ZShyb290LCBwYXJlbnRzLCBtZXNzYWdlLCByZWYpO1xuICAgIH1cbiAgICBjcmVhdGVCbG9iKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVNlcnZpY2UuY3JlYXRlQmxvYihmaWxlKTtcbiAgICB9XG4gICAgZ2V0UmF3VXJsKHNoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5nZXRSYXdVcmwoc2hhKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvbmVudFN0b3JhZ2VTZXJ2aWNlID0gQ29tcG9uZW50U3RvcmFnZVNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnRTdG9yYWdlU2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZ2lzdGVyRGVidWcgPSByZXF1aXJlKFwiZGVidWdcIik7XG5leHBvcnRzLmRlYnVnID0gcmVnaXN0ZXJEZWJ1ZyhcInByYWd1ZTpwcm9jZXNzLWxvYWRlclwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3J1bnRpbWVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vd2ViUGxhdGZvcm1cIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiLi9kZWJ1Z1wiKTtcbmV4cG9ydHMuUXVvcnVtS2V5ID0gXCJsZWFkZXJcIjtcbmNsYXNzIExlYWRlckVsZWN0b3IgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHF1b3J1bSwgY2xpZW50SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5xdW9ydW0gPSBxdW9ydW07XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5hdHRhY2hRdW9ydW1MaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcHJvcG9zZUxlYWRlcnNoaXAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdW9ydW0ucHJvcG9zZShleHBvcnRzLlF1b3J1bUtleSwgdGhpcy5jbGllbnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYWRlcjtcbiAgICB9XG4gICAgYXR0YWNoUXVvcnVtTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnF1b3J1bS5vbihcImFwcHJvdmVQcm9wb3NhbFwiLCAoc2VxdWVuY2VOdW1iZXIsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGV4cG9ydHMuUXVvcnVtS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXdMZWFkZXJcIiwgdGhpcy5sZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdW9ydW0ub24oXCJhZGRQcm9wb3NhbFwiLCAocHJvcG9zYWwpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wb3NhbC5rZXkgPT09IGV4cG9ydHMuUXVvcnVtS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdW9ydW0ub24oXCJyZW1vdmVNZW1iZXJcIiwgKHJlbW92ZWRDbGllbnRJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVhZGVyID09PSB1bmRlZmluZWQgfHwgcmVtb3ZlZENsaWVudElkID09PSB0aGlzLmxlYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxlYWRlckxlZnRcIiwgcmVtb3ZlZENsaWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1lbWJlckxlZnRcIiwgcmVtb3ZlZENsaWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVvcnVtLm9uKFwicmVqZWN0UHJvcG9zYWxcIiwgKHNlcXVlbmNlTnVtYmVyLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBVc2Ugb2YgJ2FueScgaW4gdGVtcGxhdGUgbGl0ZXJhbCBzaG91bGQgYmUgYXMgc2FmZSBhcyAoXCJcIiArIHZhbHVlKSBjb2VyY2lvbi5cbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnNhZmUtYW55XG4gICAgICAgICAgICBkZWJ1Z18xLmRlYnVnKGBQcm9wb3NhbCByZWplY3RlZCBAJHtzZXF1ZW5jZU51bWJlcn0uICR7a2V5fToke3ZhbHVlfWApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxlYWRlckVsZWN0b3IgPSBMZWFkZXJFbGVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZGVyRWxlY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xID0gcmVxdWlyZShcIkBwcmFndWUvY29udGFpbmVyLWRlZmluaXRpb25zXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAcHJhZ3VlL3V0aWxzXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGNvbXBvbmVudFJ1bnRpbWVfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudFJ1bnRpbWVcIik7XG5jb25zdCBjb21wb25lbnRTdG9yYWdlU2VydmljZV8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50U3RvcmFnZVNlcnZpY2VcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5jb25zdCBsZWFkZXJFbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vbGVhZGVyRWxlY3Rpb25cIik7XG5jb25zdCB0YXNrQW5hbHl6ZXJfMSA9IHJlcXVpcmUoXCIuL3Rhc2tBbmFseXplclwiKTtcbi8vIENvbnRleHQgd2lsbCBkZWZpbmUgdGhlIGNvbXBvbmVudCBsZXZlbCBtYXBwaW5nc1xuY2xhc3MgUnVudGltZSBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IocmVnaXN0cnksIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRhc2tzID0gW107XG4gICAgICAgIC8vIENvbXBvbmVudHMgdHJhY2tlZCBieSB0aGUgRG9tYWluXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzRGVmZXJyZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0F0dGFjaCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sYXN0TWluU2VxdWVuY2VOdW1iZXIgPSBjb250ZXh0Lm1pbmltdW1TZXF1ZW5jZU51bWJlcjtcbiAgICB9XG4gICAgc3RhdGljIExvYWQocmVnaXN0cnksIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWUgPSBuZXcgUnVudGltZShyZWdpc3RyeSwgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RUcmVlc1AgPSBPYmplY3Qua2V5cyhjb250ZXh0LmJhc2VTbmFwc2hvdC5jb21taXRzKS5tYXAoKGtleSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNoYSA9IGNvbnRleHQuYmFzZVNuYXBzaG90LmNvbW1pdHNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21taXQgPSAoeWllbGQgY29udGV4dC5zdG9yYWdlLmdldFZlcnNpb25zKG1vZHVsZVNoYSwgMSkpWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVRyZWUgPSB5aWVsZCBjb250ZXh0LnN0b3JhZ2UuZ2V0U25hcHNob3RUcmVlKGNvbW1pdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGtleSwgdHJlZTogbW9kdWxlVHJlZSB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RUcmVlID0geWllbGQgUHJvbWlzZS5hbGwoc25hcHNob3RUcmVlc1ApO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBzbmFwc2hvdFRyZWUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnNldCh2YWx1ZS5pZCwgdmFsdWUudHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzUCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY29tcG9uZW50SWQsIHNuYXBzaG90XSBvZiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UCA9IHJ1bnRpbWUubG9hZENvbXBvbmVudChjb21wb25lbnRJZCwgc25hcHNob3QsIGNvbnRleHQuYmxvYnMpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNQLnB1c2goY29tcG9uZW50UCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChjb21wb25lbnRzUCk7XG4gICAgICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29ubmVjdGlvblN0YXRlO1xuICAgIH1cbiAgICBnZXQgdGVuYW50SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudGVuYW50SWQ7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pZDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudEJyYW5jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5wYXJlbnRCcmFuY2g7XG4gICAgfVxuICAgIGdldCBleGlzdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5leGlzdGluZztcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVuc2FmZS1hbnlcbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgY2xpZW50SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY2xpZW50SWQ7XG4gICAgfVxuICAgIGdldCBibG9iTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5ibG9iTWFuYWdlcjtcbiAgICB9XG4gICAgZ2V0IGRlbHRhTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5kZWx0YU1hbmFnZXI7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnN0b3JhZ2U7XG4gICAgfVxuICAgIGdldCBicmFuY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYnJhbmNoO1xuICAgIH1cbiAgICBnZXQgbWluaW11bVNlcXVlbmNlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm1pbmltdW1TZXF1ZW5jZU51bWJlcjtcbiAgICB9XG4gICAgZ2V0IHN1Ym1pdEZuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnN1Ym1pdEZuO1xuICAgIH1cbiAgICBnZXQgc25hcHNob3RGbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zbmFwc2hvdEZuO1xuICAgIH1cbiAgICBnZXQgY2xvc2VGbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jbG9zZUZuO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUgPT09IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLkNvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQ7XG4gICAgfVxuICAgIGxvYWRDb21wb25lbnQoaWQsIHNuYXBzaG90VHJlZSwgZXh0cmFCbG9icykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byByaXAgdGhyb3VnaCBzbmFwc2hvdCBhbmQgdXNlIHRoYXQgdG8gcG9wdWxhdGUgZXh0cmFCbG9ic1xuICAgICAgICAgICAgY29uc3QgcnVudGltZVN0b3JhZ2UgPSBuZXcgY29tcG9uZW50U3RvcmFnZVNlcnZpY2VfMS5Db21wb25lbnRTdG9yYWdlU2VydmljZSh0aGlzLnN0b3JhZ2UsIGV4dHJhQmxvYnMpO1xuICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IHlpZWxkIHV0aWxzXzEucmVhZEFuZFBhcnNlKHRoaXMuc3RvcmFnZSwgc25hcHNob3RUcmVlLmJsb2JzW1wiLmNvbXBvbmVudFwiXSk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRQID0gY29tcG9uZW50UnVudGltZV8xLkNvbXBvbmVudFJ1bnRpbWUuTG9hZEZyb21TbmFwc2hvdCh0aGlzLCBpZCwgZGV0YWlscy5wa2csIHJ1bnRpbWVTdG9yYWdlLCBzbmFwc2hvdFRyZWUpO1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgdXRpbHNfMS5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjb21wb25lbnRQKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c0RlZmVycmVkLnNldChpZCwgZGVmZXJyZWQpO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0geWllbGQgY29tcG9uZW50UDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXQoaWQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICB5aWVsZCBjb21wb25lbnQuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVxdWVzdEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgZ2V0UGFja2FnZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmdldChuYW1lKTtcbiAgICB9XG4gICAgcmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IDQwNCwgbWltZVR5cGU6IFwidGV4dC9wbGFpblwiLCB2YWx1ZTogYCR7cmVxdWVzdC51cmx9IG5vdCBmb3VuZGAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc25hcHNob3QodGFnTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUHVsbCBpbiB0aGUgcHJpb3IgdmVyc2lvbiBhbmQgc25hcHNob3QgdHJlZSB0byBzdG9yZSBhZ2FpbnN0XG4gICAgICAgICAgICBjb25zdCBsYXN0VmVyc2lvbiA9IHlpZWxkIHRoaXMuc3RvcmFnZS5nZXRWZXJzaW9ucyh0aGlzLmlkLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHRyZWUgPSBsYXN0VmVyc2lvbi5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyB5aWVsZCB0aGlzLnN0b3JhZ2UuZ2V0U25hcHNob3RUcmVlKGxhc3RWZXJzaW9uWzBdKVxuICAgICAgICAgICAgICAgIDogeyBibG9iczoge30sIGNvbW1pdHM6IHt9LCB0cmVlczoge30gfTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGNvbXBvbmVudCBhbmQgYXNrIGl0IHRvIHNuYXBzaG90XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRW50cmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKChjb21wb25lbnQsIGtleSkgPT4gY2hhbm5lbEVudHJpZXMuc2V0KGtleSwgY29tcG9uZW50LnNuYXBzaG90KCkpKTtcbiAgICAgICAgICAgIC8vIFVzZSBiYXNlIHRyZWUgdG8ga25vdyBwcmV2aW91cyBjb21wb25lbnQgc25hcHNob3QgYW5kIHRoZW4gc25hcHNob3QgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxDb21taXRzUCA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hhbm5lbElkLCBjaGFubmVsU25hcHNob3RdIG9mIGNoYW5uZWxFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2hhIGV4aXN0cyB0aGVuIHByZXZpb3VzIGNvbW1pdCBpcyBzdGlsbCB2YWxpZFxuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsU25hcHNob3Quc2hhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb21taXRzUC5wdXNoKFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXQ6IHRyZWUuY29tbWl0c1tjaGFubmVsSWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoYW5uZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gY2hhbm5lbElkIGluIHRyZWUuY29tbWl0cyA/IFt0cmVlLmNvbW1pdHNbY2hhbm5lbElkXV0gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbENvbW1pdFAgPSB0aGlzLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC53cml0ZShjaGFubmVsU25hcHNob3QsIHBhcmVudCwgYCR7Y2hhbm5lbElkfSBjb21taXQgJHt0YWdNZXNzYWdlfWAsIGNoYW5uZWxJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjb21taXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5nZXQoY2hhbm5lbElkKS51cGRhdGVCYXNlU2hhKGNvbW1pdC50cmVlLnNoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZDogY2hhbm5lbElkLCBjb21taXQ6IGNvbW1pdC5zaGEgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb21taXRzUC5wdXNoKGNoYW5uZWxDb21taXRQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb290ID0geyBlbnRyaWVzOiBbXSwgc2hhOiBudWxsIH07XG4gICAgICAgICAgICAvLyBBZGQgaW4gbW9kdWxlIHJlZmVyZW5jZXMgdG8gdGhlIGNvbXBvbmVudCBzbmFwc2hvdHNcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxDb21taXRzID0geWllbGQgUHJvbWlzZS5hbGwoY2hhbm5lbENvbW1pdHNQKTtcbiAgICAgICAgICAgIGxldCBnaXRNb2R1bGVzID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbm5lbENvbW1pdCBvZiBjaGFubmVsQ29tbWl0cykge1xuICAgICAgICAgICAgICAgIHJvb3QuZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogY29udGFpbmVyX2RlZmluaXRpb25zXzEuRmlsZU1vZGUuQ29tbWl0LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjaGFubmVsQ29tbWl0LmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5UcmVlRW50cnlbY29udGFpbmVyX2RlZmluaXRpb25zXzEuVHJlZUVudHJ5LkNvbW1pdF0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFubmVsQ29tbWl0LmNvbW1pdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBvVXJsID0gXCJodHRwczovL2dpdGh1Yi5jb20va3VydGIvcHJhZ3VlZG9jcy5naXRcIjsgLy8gdGhpcy5zdG9yYWdlU2VydmljZS5yZXBvc2l0b3J5VXJsXG4gICAgICAgICAgICAgICAgZ2l0TW9kdWxlcyArPSBgW3N1Ym1vZHVsZSBcIiR7Y2hhbm5lbENvbW1pdC5pZH1cIl1cXG5cXHRwYXRoID0gJHtjaGFubmVsQ29tbWl0LmlkfVxcblxcdHVybCA9ICR7cmVwb1VybH1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIG1vZHVsZSBsb29rdXAgZGV0YWlsc1xuICAgICAgICAgICAgcm9vdC5lbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1vZGU6IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLkZpbGVNb2RlLkZpbGUsXG4gICAgICAgICAgICAgICAgcGF0aDogXCIuZ2l0bW9kdWxlc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLlRyZWVFbnRyeVtjb250YWluZXJfZGVmaW5pdGlvbnNfMS5UcmVlRW50cnkuQmxvYl0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IGdpdE1vZHVsZXMsXG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0U25hcHNob3QodGFnTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZXF1ZXN0U25hcHNob3QodGFnTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoYW5nZUNvbm5lY3Rpb25TdGF0ZSh2YWx1ZSwgY2xpZW50SWQpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgLy8gUmVzZW5kIGFsbCBwZW5kaW5nIGF0dGFjaCBtZXNzYWdlcyBwcmlvciB0byBub3RpZnlpbmcgY2xpZW50c1xuICAgICAgICBpZiAodmFsdWUgPT09IGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLkNvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgbWVzc2FnZV0gb2YgdGhpcy5wZW5kaW5nQXR0YWNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXQoY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuQXR0YWNoLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFssIGNvbXBvbmVudF0gb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuY2hhbmdlQ29ubmVjdGlvblN0YXRlKHZhbHVlLCBjbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5Db25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIiwgdGhpcy5jbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZShtZXNzYWdlLCBsb2NhbCkge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5PcGVyYXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZU9wZXJhdGlvbihtZXNzYWdlLCBsb2NhbCk7XG4gICAgICAgICAgICBjYXNlIGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLk1lc3NhZ2VUeXBlLkF0dGFjaDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlQXR0YWNoKG1lc3NhZ2UsIGxvY2FsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3MobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuT3BlcmF0aW9uOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc09wZXJhdGlvbihtZXNzYWdlLCBsb2NhbCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnRhaW5lcl9kZWZpbml0aW9uc18xLk1lc3NhZ2VUeXBlLkF0dGFjaDpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NBdHRhY2gobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJvcFwiLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMubGFzdE1pblNlcXVlbmNlTnVtYmVyICE9PSBtZXNzYWdlLm1pbmltdW1TZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5sYXN0TWluU2VxdWVuY2VOdW1iZXIgPSBtZXNzYWdlLm1pbmltdW1TZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWluU2VxdWVuY2VOdW1iZXIobWVzc2FnZS5taW5pbXVtU2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc3RQcm9jZXNzKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuQXR0YWNoOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0UHJvY2Vzc0F0dGFjaChtZXNzYWdlLCBsb2NhbCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZU1pblNlcXVlbmNlTnVtYmVyKG1pbmltdW1TZXF1ZW5jZU51bWJlcikge1xuICAgICAgICBmb3IgKGNvbnN0IFssIGNvbXBvbmVudF0gb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnQudXBkYXRlTWluU2VxdWVuY2VOdW1iZXIobWluaW11bVNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb21wb25lbnQoaWQsIHdhaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnRzRGVmZXJyZWQuaGFzKGlkKSkge1xuICAgICAgICAgICAgaWYgKCF3YWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBQcm9jZXNzICR7aWR9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgaW4gYSBkZWZlcnJlZCB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBwcm9jZXNzIElEIGFycml2ZXNcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c0RlZmVycmVkLnNldChpZCwgbmV3IHV0aWxzXzEuRGVmZXJyZWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50c0RlZmVycmVkLmdldChpZCkucHJvbWlzZTtcbiAgICB9XG4gICAgY3JlYXRlQW5kQXR0YWNoQ29tcG9uZW50KGlkLCBwa2cpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgICAgICBjb25zdCBydW50aW1lU3RvcmFnZSA9IG5ldyBjb21wb25lbnRTdG9yYWdlU2VydmljZV8xLkNvbXBvbmVudFN0b3JhZ2VTZXJ2aWNlKHRoaXMuc3RvcmFnZSwgbmV3IE1hcCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHlpZWxkIGNvbXBvbmVudFJ1bnRpbWVfMS5Db21wb25lbnRSdW50aW1lLmNyZWF0ZSh0aGlzLCBpZCwgcGtnLCBydW50aW1lU3RvcmFnZSk7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgYXR0YWNoIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZTogcGtnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0F0dGFjaC5zZXQoaWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5zdWJtaXQoY29udGFpbmVyX2RlZmluaXRpb25zXzEuTWVzc2FnZVR5cGUuQXR0YWNoLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIHlpZWxkIGNvbXBvbmVudC5zdGFydCgpO1xuICAgICAgICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXQoaWQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIGFueSBwZW5kaW5nIHJlcXVlc3RzIGZvciB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzRGVmZXJyZWQuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c0RlZmVycmVkLmdldChpZCkucmVzb2x2ZShjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgdXRpbHNfMS5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNEZWZlcnJlZC5zZXQoaWQsIGRlZmVycmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRRdW9ydW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucXVvcnVtO1xuICAgIH1cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmNvbnRleHQuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICByZWdpc3RlclRhc2tzKHRhc2tzLCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMudGFza3MgPSB0YXNrcztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5zdGFydExlYWRlckVsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN1Ym1pdCh0eXBlLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90Q2xvc2VkKCk7XG4gICAgICAgIHRoaXMuc3VibWl0Rm4odHlwZSwgY29udGVudCk7XG4gICAgfVxuICAgIHZlcmlmeU5vdENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlT3BlcmF0aW9uKG1lc3NhZ2UsIGxvY2FsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IG1lc3NhZ2UuY29udGVudHM7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGVudmVsb3BlLmFkZHJlc3MpO1xuICAgICAgICAgICAgYXNzZXJ0KGNvbXBvbmVudCk7XG4gICAgICAgICAgICBjb25zdCBpbm5lckNvbnRlbnRzID0gZW52ZWxvcGUuY29udGVudHM7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogbWVzc2FnZS5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBjbGllbnRTZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5jbGllbnRTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb250ZW50czogaW5uZXJDb250ZW50cy5jb250ZW50LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXNzYWdlLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIG1pbmltdW1TZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5taW5pbXVtU2VxdWVuY2VOdW1iZXIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBtZXNzYWdlLm9yaWdpbixcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VTZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5yZWZlcmVuY2VTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5zZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG1lc3NhZ2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIHRyYWNlczogbWVzc2FnZS50cmFjZXMsXG4gICAgICAgICAgICAgICAgdHlwZTogaW5uZXJDb250ZW50cy50eXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQucHJlcGFyZSh0cmFuc2Zvcm1lZCwgbG9jYWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc09wZXJhdGlvbihtZXNzYWdlLCBsb2NhbCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBlbnZlbG9wZSA9IG1lc3NhZ2UuY29udGVudHM7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50cy5nZXQoZW52ZWxvcGUuYWRkcmVzcyk7XG4gICAgICAgIGFzc2VydChjb21wb25lbnQpO1xuICAgICAgICBjb25zdCBpbm5lckNvbnRlbnRzID0gZW52ZWxvcGUuY29udGVudHM7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0ge1xuICAgICAgICAgICAgY2xpZW50SWQ6IG1lc3NhZ2UuY2xpZW50SWQsXG4gICAgICAgICAgICBjbGllbnRTZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5jbGllbnRTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIGNvbnRlbnRzOiBpbm5lckNvbnRlbnRzLmNvbnRlbnQsXG4gICAgICAgICAgICBtZXRhZGF0YTogbWVzc2FnZS5tZXRhZGF0YSxcbiAgICAgICAgICAgIG1pbmltdW1TZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5taW5pbXVtU2VxdWVuY2VOdW1iZXIsXG4gICAgICAgICAgICBvcmlnaW46IG1lc3NhZ2Uub3JpZ2luLFxuICAgICAgICAgICAgcmVmZXJlbmNlU2VxdWVuY2VOdW1iZXI6IG1lc3NhZ2UucmVmZXJlbmNlU2VxdWVuY2VOdW1iZXIsXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWVzc2FnZS5zZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbWVzc2FnZS50aW1lc3RhbXAsXG4gICAgICAgICAgICB0cmFjZXM6IG1lc3NhZ2UudHJhY2VzLFxuICAgICAgICAgICAgdHlwZTogaW5uZXJDb250ZW50cy50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBjb21wb25lbnQucHJvY2Vzcyh0cmFuc2Zvcm1lZCwgbG9jYWwsIGNvbnRleHQpO1xuICAgIH1cbiAgICBwcmVwYXJlQXR0YWNoKG1lc3NhZ2UsIGxvY2FsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeU5vdENsb3NlZCgpO1xuICAgICAgICAgICAgLy8gdGhlIGxvY2FsIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGF0dGFjaGVkXG4gICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRhY2hNZXNzYWdlID0gbWVzc2FnZS5jb250ZW50cztcbiAgICAgICAgICAgIGxldCBzbmFwc2hvdFRyZWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGF0dGFjaE1lc3NhZ2Uuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmbGF0dGVuZWQgPSB1dGlsc18xLmZsYXR0ZW4oYXR0YWNoTWVzc2FnZS5zbmFwc2hvdC5lbnRyaWVzLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICAgIHNuYXBzaG90VHJlZSA9IHV0aWxzXzEuYnVpbGRIaWVyYXJjaHkoZmxhdHRlbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzdG9yYWdlIHNlcnZpY2UgdGhhdCB3cmFwcyB0aGUgYXR0YWNoIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVTdG9yYWdlID0gbmV3IGNvbXBvbmVudFN0b3JhZ2VTZXJ2aWNlXzEuQ29tcG9uZW50U3RvcmFnZVNlcnZpY2UodGhpcy5zdG9yYWdlLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0geWllbGQgY29tcG9uZW50UnVudGltZV8xLkNvbXBvbmVudFJ1bnRpbWUuTG9hZEZyb21TbmFwc2hvdCh0aGlzLCBhdHRhY2hNZXNzYWdlLmlkLCBhdHRhY2hNZXNzYWdlLnR5cGUsIHJ1bnRpbWVTdG9yYWdlLCBzbmFwc2hvdFRyZWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRhY2gobWVzc2FnZSwgbG9jYWwsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RDbG9zZWQoKTtcbiAgICAgICAgZGVidWdfMS5kZWJ1ZyhcInByb2Nlc3NBdHRhY2hcIik7XG4gICAgfVxuICAgIHBvc3RQcm9jZXNzQXR0YWNoKG1lc3NhZ2UsIGxvY2FsLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRhY2hNZXNzYWdlID0gbWVzc2FnZS5jb250ZW50cztcbiAgICAgICAgICAgIC8vIElmIGEgbm9uLWxvY2FsIG9wZXJhdGlvbiB0aGVuIGdvIGFuZCBjcmVhdGUgdGhlIG9iamVjdCAtIG90aGVyd2lzZSBtYXJrIGl0IGFzIG9mZmljaWFsbHkgYXR0YWNoZWQuXG4gICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQodGhpcy5wZW5kaW5nQXR0YWNoLmhhcyhhdHRhY2hNZXNzYWdlLmlkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQXR0YWNoLmRlbGV0ZShhdHRhY2hNZXNzYWdlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbnRleHQuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGF0dGFjaE1lc3NhZ2UuaWQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgcGVuZGluZyBnZXRzIGFuZCBzdG9yZSBvZmYgYW55IG5ldyBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c0RlZmVycmVkLmhhcyhhdHRhY2hNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNEZWZlcnJlZC5nZXQoYXR0YWNoTWVzc2FnZS5pZCkucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IHV0aWxzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzRGVmZXJyZWQuc2V0KGF0dGFjaE1lc3NhZ2UuaWQsIGRlZmVycmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydExlYWRlckVsZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWx0YU1hbmFnZXIgJiYgdGhpcy5kZWx0YU1hbmFnZXIuY2xpZW50VHlwZSA9PT0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuQnJvd3Nlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0TGVhZGVyRWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImNvbm5lY3RlZFwiLCAoKSA9PiB0aGlzLmluaXRMZWFkZXJFbGVjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0TGVhZGVyRWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVhZGVyRWxlY3RvciA9IG5ldyBsZWFkZXJFbGVjdGlvbl8xLkxlYWRlckVsZWN0b3IodGhpcy5nZXRRdW9ydW0oKSwgdGhpcy5jbGllbnRJZCk7XG4gICAgICAgIHRoaXMubGVhZGVyRWxlY3Rvci5vbihcIm5ld0xlYWRlclwiLCAoY2xpZW50SWQpID0+IHtcbiAgICAgICAgICAgIGRlYnVnXzEuZGVidWcoYE5ldyBsZWFkZXIgZWxlY3RlZDogJHtjbGllbnRJZH1gKTtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza0FuYWx5emVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlYWRlckVsZWN0b3Iub24oXCJsZWFkZXJMZWZ0XCIsIChjbGllbnRJZCkgPT4ge1xuICAgICAgICAgICAgZGVidWdfMS5kZWJ1ZyhgTGVhZGVyICR7Y2xpZW50SWR9IGxlZnRgKTtcbiAgICAgICAgICAgIHRoaXMucHJvcG9zZUxlYWRlcnNoaXAoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVhZGVyRWxlY3Rvci5vbihcIm1lbWJlckxlZnRcIiwgKGNsaWVudElkKSA9PiB7XG4gICAgICAgICAgICBkZWJ1Z18xLmRlYnVnKGBNZW1iZXIgJHtjbGllbnRJZH0gbGVmdGApO1xuICAgICAgICAgICAgdGhpcy5ydW5UYXNrQW5hbHl6ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcG9zZUxlYWRlcnNoaXAoKTtcbiAgICB9XG4gICAgcHJvcG9zZUxlYWRlcnNoaXAoKSB7XG4gICAgICAgIGlmICh0YXNrQW5hbHl6ZXJfMS5nZXRMZWFkZXJDYW5kaWRhdGUodGhpcy5nZXRRdW9ydW0oKS5nZXRNZW1iZXJzKCkpID09PSB0aGlzLmNsaWVudElkKSB7XG4gICAgICAgICAgICB0aGlzLmxlYWRlckVsZWN0b3IucHJvcG9zZUxlYWRlcnNoaXAoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1Z18xLmRlYnVnKGBQcm9wb3NhbCBhY2NlcHRlZGApO1xuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVidWcoYFByb3Bvc2FsIHJlamVjdGVkOiAke2Vycn1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIGEgY2xpZW50IGpvaW5pbmcvZGVwYXJ0dXJlLCBkZWNpZGUgd2hldGhlciB0aGlzIGNsaWVudCBpcyB0aGUgbmV3IGxlYWRlci5cbiAgICAgKiBJZiBzbywgY2FsY3VsYXRlIGlmIHRoZXJlIGFyZSBhbnkgdW5oYW5kbGVkIHRhc2tzIGZvciBicm93c2VycyBhbmQgcmVtb3RlIGFnZW50cy5cbiAgICAgKiBFbWl0IGxvY2FsIGhlbHAgbWVzc2FnZSBmb3IgdGhpcyBicm93c2VyIGFuZCBzdWJtaXRzIGEgcmVtb3RlIGhlbHAgbWVzc2FnZSBmb3IgYWdlbnRzLlxuICAgICAqL1xuICAgIHJ1blRhc2tBbmFseXplcigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVhZGVyRWxlY3Rvci5nZXRMZWFkZXIoKSA9PT0gdGhpcy5jbGllbnRJZCkge1xuICAgICAgICAgICAgLy8gQW5hbHl6ZSB0aGUgY3VycmVudCBzdGF0ZSBhbmQgYXNrIGZvciBsb2NhbCBhbmQgcmVtb3RlIGhlbHAgc2VwZXJhdGVseS5cbiAgICAgICAgICAgIGNvbnN0IGhlbHBUYXNrcyA9IHRhc2tBbmFseXplcl8xLmFuYWx5emVUYXNrcyh0aGlzLmNsaWVudElkLCB0aGlzLmdldFF1b3J1bSgpLmdldE1lbWJlcnMoKSwgdGhpcy50YXNrcyk7XG4gICAgICAgICAgICBpZiAoaGVscFRhc2tzICYmIChoZWxwVGFza3MuYnJvd3Nlci5sZW5ndGggPiAwIHx8IGhlbHBUYXNrcy5yb2JvdC5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChoZWxwVGFza3MuYnJvd3Nlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSGVscE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrczogaGVscFRhc2tzLmJyb3dzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXF1ZXN0aW5nIGxvY2FsIGhlbHAgZm9yICR7aGVscFRhc2tzLmJyb3dzZXJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxvY2FsSGVscFwiLCBsb2NhbEhlbHBNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlbHBUYXNrcy5yb2JvdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUhlbHBNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3M6IGhlbHBUYXNrcy5yb2JvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlcXVlc3RpbmcgcmVtb3RlIGhlbHAgZm9yICR7aGVscFRhc2tzLnJvYm90fWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdChjb250YWluZXJfZGVmaW5pdGlvbnNfMS5NZXNzYWdlVHlwZS5SZW1vdGVIZWxwLCByZW1vdGVIZWxwTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SdW50aW1lID0gUnVudGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb250YWluZXJfZGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiKTtcbi8vIEZvciBhIGdpdmVuIGxpc3Qgb2YgY29ubmVjdGVkIGNsaWVudHMgYW5kIHRhc2tzIHRvIHJ1biwgdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIG5lZWQgZm9yIGxvY2FsICYgcmVtb3RlIGhlbHAuXG4vLyBSaWdodCBub3cgb25seSBvbmUgY2xpZW50IChha2EgbGVhZGVyKSBpcyBhbGxvd2VkIHRvIHJ1biB0YXNrcyBhbmQgYXNrIGZvciBsb2NhbCBhbmQgcmVtb3RlLlxuLy8gVG8gYmVjb21lIGNvbXBsZXRlbHkgZGlzdHJpYnV0ZWQsIGVhY2ggY2xpZW50IHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBvdGhlciBjbGllbnQgcGVybWlzc2lvbnNcbi8vIGFuZCBjYWxjdWxhdGUgaGVscCBsaXN0LiBUaGVuIGVhY2ggY2xpZW50IHdpbGwgcGljayB1cCB3b3JrIGluZGVwZW5kZW50bHkgYW5kIG9ubHkgbGVhZGVyIHdpbGxcbi8vIGFzayBmb3IgaGVscC5cbi8vIFRPRE86IE1ha2UgdGhpcyBydW4gb24gYWxsIGNsaWVudHMgb25jZSBzZXJ2aWNlcyBhcmUgaGFyZGVuZWQgYmV0dGVyLlxuZnVuY3Rpb24gYW5hbHl6ZVRhc2tzKHJ1bm5lckNsaWVudElkLCBjbGllbnRzLCB0YXNrcykge1xuICAgIGNvbnN0IHJvYm90Q2xpZW50cyA9IFsuLi5jbGllbnRzXS5maWx0ZXIoKGNsaWVudCkgPT4gaXNSb2JvdChjbGllbnRbMV0pKTtcbiAgICBjb25zdCBoYW5kbGVkVGFza3MgPSByb2JvdENsaWVudHMubWFwKChyb2JvdCkgPT4gcm9ib3RbMV0uY2xpZW50LnR5cGUpO1xuICAgIGNvbnN0IHVuaGFuZGxlZFRhc2tzID0gdGFza3MuZmlsdGVyKCh0YXNrKSA9PiBoYW5kbGVkVGFza3MuaW5kZXhPZih0YXNrKSA9PT0gLTEpO1xuICAgIGlmICh1bmhhbmRsZWRUYXNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lckNsaWVudCA9IGNsaWVudHMuZ2V0KHJ1bm5lckNsaWVudElkKTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6c3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IHJ1bm5lckNsaWVudC5jbGllbnQgJiYgcnVubmVyQ2xpZW50LmNsaWVudC5wZXJtaXNzaW9uID8gcnVubmVyQ2xpZW50LmNsaWVudC5wZXJtaXNzaW9uIDogW107XG4gICAgICAgIGNvbnN0IGFsbG93ZWRUYXNrcyA9IHVuaGFuZGxlZFRhc2tzLmZpbHRlcigodGFzaykgPT4gcGVybWlzc2lvbiAmJiBwZXJtaXNzaW9uLmluZGV4T2YodGFzaykgIT09IC0xKTtcbiAgICAgICAgY29uc3Qgcm9ib3ROZWVkZWQgPSB1bmhhbmRsZWRUYXNrcy5maWx0ZXIoKHRhc2spID0+IHBlcm1pc3Npb24gJiYgcGVybWlzc2lvbi5pbmRleE9mKHRhc2spID09PSAtMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBicm93c2VyOiBhbGxvd2VkVGFza3MsXG4gICAgICAgICAgICByb2JvdDogcm9ib3ROZWVkZWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5hbmFseXplVGFza3MgPSBhbmFseXplVGFza3M7XG5mdW5jdGlvbiBnZXRMZWFkZXJDYW5kaWRhdGUoY2xpZW50cykge1xuICAgIGNvbnN0IGJyb3dzZXJDbGllbnRzID0gWy4uLmNsaWVudHNdLmZpbHRlcigoY2xpZW50KSA9PiAhaXNSb2JvdChjbGllbnRbMV0pKTtcbiAgICBpZiAoYnJvd3NlckNsaWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBicm93c2VyQ2xpZW50cy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2WzFdLnNlcXVlbmNlTnVtYmVyIDwgY3VyclsxXS5zZXF1ZW5jZU51bWJlciA/IHByZXYgOiBjdXJyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVswXTtcbiAgICB9XG59XG5leHBvcnRzLmdldExlYWRlckNhbmRpZGF0ZSA9IGdldExlYWRlckNhbmRpZGF0ZTtcbmZ1bmN0aW9uIGlzUm9ib3QoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5jbGllbnQgJiYgY2xpZW50LmNsaWVudC50eXBlICYmIGNsaWVudC5jbGllbnQudHlwZSAhPT0gY29udGFpbmVyX2RlZmluaXRpb25zXzEuQnJvd3Nlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhc2tBbmFseXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY2xhc3MgRGVmaW5pdGlvbkd1aWRlIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5kdHMgPSBcIlwiO1xuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZHRzID0gXCJkZWNsYXJlIGNsYXNzIEZhY3RzIHtcXG5cIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkdHMgKz0gYCAgICBzdGF0aWMgbmV4dCR7aX0oKTogc3RyaW5nO1xcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdHMgKz0gXCJ9XCI7XG4gICAgICAgICAgICB0aGlzLmR0cyA9IGR0cztcbiAgICAgICAgICAgIHRoaXMuY291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVmaW5pdGlvbnNDaGFuZ2VkXCIpO1xuICAgICAgICB9LCA1MDAwKTtcbiAgICB9XG4gICAgZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHRzO1xuICAgIH1cbn1cbmNsYXNzIFdlYlBsYXRmb3JtIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkaXYpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBuZXcgRGVmaW5pdGlvbkd1aWRlKCk7XG4gICAgfVxuICAgIHF1ZXJ5SW50ZXJmYWNlKGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRvbVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpdlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgICAgICAgICAgICAgY2FzZSBcImR0c1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9ucztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRlbXBvcmFyeSBtZWFzdXJlIHRvIGluZGljYXRlIHRoZSBVSSBjaGFuZ2VkXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIik7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViUGxhdGZvcm0gPSBXZWJQbGF0Zm9ybTtcbmNsYXNzIFdlYlBsYXRmb3JtRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoZGl2KSB7XG4gICAgICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIH1cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYlBsYXRmb3JtKHRoaXMuZGl2KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJQbGF0Zm9ybUZhY3RvcnkgPSBXZWJQbGF0Zm9ybUZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJQbGF0Zm9ybS5qcy5tYXAiLCJjb25zdCBNYXhCYXRjaFNpemUgPSAxMDA7XG5leHBvcnQgY2xhc3MgQmF0Y2hNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgICAgIHRoaXMucGVuZGluZ1dvcmsgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFkZChpZCwgd29yaykge1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1dvcmsuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nV29yay5zZXQoaWQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdXb3JrLmdldChpZClcbiAgICAgICAgICAgIC5wdXNoKHdvcmspO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nV29yay5nZXQoaWQpLmxlbmd0aCA+PSBNYXhCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0V29yaygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgb25jZSBhbGwgcGVuZGluZyB3b3JrIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgZHJhaW4oKSB7XG4gICAgICAgIHRoaXMuc3RhcnRXb3JrKCk7XG4gICAgfVxuICAgIHN0YXJ0V29yaygpIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGludGVybmFsIGZsYWdzIGZpcnN0IHRvIGF2b2lkIGlzc3VlcyBpbiBjYXNlIGFueSBvZiB0aGUgcGVuZGluZyB3b3JrIGNhbGxzIGJhY2sgaW50b1xuICAgICAgICAvLyB0aGUgYmF0Y2ggbWFuYWdlci4gV2UgY291bGQgYWxzbyBkbyB0aGlzIHdpdGggYSBzZWNvbmQgc2V0SW1tZWRpYXRlIGNhbGwgYnV0IGF2b2RpaW5nIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIHdvcmsgcXVpY2tlci5cbiAgICAgICAgY29uc3QgcGVuZGluZ1dvcmsgPSB0aGlzLnBlbmRpbmdXb3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmdXb3JrID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUT0RPIGxvZyB0byBpbmZsdXggaG93IG11Y2ggcGVuZGluZyB3b3JrIHRoZXJlIGlzLiBXZSB3YW50IHRvIGxpbWl0IHRoZSBzaXplIG9mIGEgYmF0Y2hcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGJhdGNoXSBvZiBwZW5kaW5nV29yaykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGlkLCBiYXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaE1hbmFnZXIuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGaWxlTW9kZSwgVHJlZUVudHJ5LCB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN1Ym1vZHVsZS1pbXBvcnRzXG5pbXBvcnQgKiBhcyBzaGExIGZyb20gXCJzaGEuanMvc2hhMVwiO1xuLyoqXG4gKiBDcmVhdGUgSGFzaCAoR2l0aHViIGhhc2hlcyB0aGUgc3RyaW5nIHdpdGggYmxvYiBhbmQgc2l6ZSlcbiAqIEBwYXJhbSBmaWxlIFRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBpbiBhIGJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2l0SGFzaEZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHNpemUgPSBmaWxlLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZmlsZVByZWZpeCA9IFwiYmxvYiBcIiArIHNpemUudG9TdHJpbmcoKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBzaGExKCk7XG4gICAgcmV0dXJuIGVuZ2luZS51cGRhdGUoZmlsZVByZWZpeClcbiAgICAgICAgLnVwZGF0ZShmaWxlKVxuICAgICAgICAuZGlnZXN0KFwiaGV4XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4odHJlZSwgYmxvYk1hcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmbGF0dGVuQ29yZShcIlwiLCB0cmVlLCBibG9iTWFwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaGE6IG51bGwsXG4gICAgICAgIHRyZWU6IGVudHJpZXMsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRBbmRQYXJzZShzdG9yYWdlLCBzaGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0geWllbGQgc3RvcmFnZS5yZWFkKHNoYSk7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBCdWZmZXJcbiAgICAgICAgICAgIC5mcm9tKGVuY29kZWQsIFwiYmFzZTY0XCIpXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuQ29yZShwYXRoLCB0cmVlRW50cmllcywgYmxvYk1hcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IHRyZWVFbnRyeSBvZiB0cmVlRW50cmllcykge1xuICAgICAgICBjb25zdCBzdWJQYXRoID0gYCR7cGF0aH0ke3RyZWVFbnRyeS5wYXRofWA7XG4gICAgICAgIGlmICh0cmVlRW50cnkudHlwZSA9PT0gVHJlZUVudHJ5W1RyZWVFbnRyeS5CbG9iXSkge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IHRyZWVFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJsb2IuY29udGVudHMsIGJsb2IuZW5jb2RpbmcpO1xuICAgICAgICAgICAgY29uc3Qgc2hhID0gZ2l0SGFzaEZpbGUoYnVmZmVyKTtcbiAgICAgICAgICAgIGJsb2JNYXAuc2V0KHNoYSwgYnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlW3RyZWVFbnRyeS5tb2RlXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIHNoYSxcbiAgICAgICAgICAgICAgICBzaXplOiBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgICAgICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRyZWVFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlW3RyZWVFbnRyeS5tb2RlXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIHNoYTogbnVsbCxcbiAgICAgICAgICAgICAgICBzaXplOiAtMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRyZWVcIixcbiAgICAgICAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlRyZWVFbnRyaWVzID0gZmxhdHRlbkNvcmUoc3ViUGF0aCArIFwiL1wiLCB0LmVudHJpZXMsIGJsb2JNYXApO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKC4uLnN1YlRyZWVFbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEhpZXJhcmNoeShmbGF0VHJlZSkge1xuICAgIGlmICghZmxhdFRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cCA9IHt9O1xuICAgIGNvbnN0IHJvb3QgPSB7IHNoYTogZmxhdFRyZWUuc2hhLCBibG9iczoge30sIGNvbW1pdHM6IHt9LCB0cmVlczoge30gfTtcbiAgICBsb29rdXBbXCJcIl0gPSByb290O1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZmxhdFRyZWUudHJlZSkge1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBlbnRyeS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZW50cnlQYXRoRGlyID0gZW50cnkucGF0aC5zbGljZSgwLCBNYXRoLm1heCgwLCBsYXN0SW5kZXgpKTtcbiAgICAgICAgY29uc3QgZW50cnlQYXRoQmFzZSA9IGVudHJ5LnBhdGguc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICAgIC8vIFRoZSBmbGF0IG91dHB1dCBpcyBicmVhZHRoLWZpcnN0IHNvIHdlIGNhbiBhc3N1bWUgd2Ugc2VlIHRyZWUgbm9kZXMgcHJpb3IgdG8gdGhlaXIgY29udGVudHNcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxvb2t1cFtlbnRyeVBhdGhEaXJdO1xuICAgICAgICAvLyBBZGQgaW4gZWl0aGVyIHRoZSBibG9iIG9yIHRyZWVcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09IFwidHJlZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0geyBzaGE6IGVudHJ5LnNoYSwgYmxvYnM6IHt9LCBjb21taXRzOiB7fSwgdHJlZXM6IHt9IH07XG4gICAgICAgICAgICBub2RlLnRyZWVzW2VudHJ5UGF0aEJhc2VdID0gbmV3VHJlZTtcbiAgICAgICAgICAgIGxvb2t1cFtlbnRyeS5wYXRoXSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gXCJibG9iXCIpIHtcbiAgICAgICAgICAgIG5vZGUuYmxvYnNbZW50cnlQYXRoQmFzZV0gPSBlbnRyeS5zaGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gXCJjb21taXRcIikge1xuICAgICAgICAgICAgbm9kZS5jb21taXRzW2VudHJ5UGF0aEJhc2VdID0gZW50cnkuc2hhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYnMuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxuLy8gdHNsaW50OmRpc2FibGU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuLy8gdHNsaW50OmRpc2FibGU6bm8tcGFyYW1ldGVyLXJlYXNzaWdubWVudFxuZXhwb3J0IGNvbnN0IE51bWJlckNvbXBhcmVyID0ge1xuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBtaW46IE51bWJlci5NSU5fVkFMVUUsXG59O1xuZXhwb3J0IGNsYXNzIEhlYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXApIHtcbiAgICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgICAgdGhpcy5MID0gW3sgdmFsdWU6IGNvbXAubWluLCBwb3NpdGlvbjogMCB9XTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTFsxXTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICB0aGlzLnN3YXAoMSwgdGhpcy5jb3VudCgpKTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuTC5wb3AoKTtcbiAgICAgICAgdGhpcy5maXhkb3duKDEpO1xuICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICB9XG4gICAgYWRkKHgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IHgsIHBvc2l0aW9uOiB0aGlzLkwubGVuZ3RoIH07XG4gICAgICAgIHRoaXMuTC5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmZpeHVwKHRoaXMuY291bnQoKSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIGhlYXAgdG8gYmUgdXBkYXRlZCBhZnRlciBhIG5vZGUncyB2YWx1ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgdXBkYXRlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgayA9IG5vZGUucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmlzR3JlYXRlclRoYW5QYXJlbnQoaykpIHtcbiAgICAgICAgICAgIHRoaXMuZml4dXAoayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpeGRvd24oayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBoZWFwXG4gICAgICovXG4gICAgcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgbm9kZSB3ZSB3YW50IHRvIHJlbW92ZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XG4gICAgICAgIHRoaXMuc3dhcChub2RlLnBvc2l0aW9uLCB0aGlzLkwubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuTC5zcGxpY2UodGhpcy5MLmxlbmd0aCAtIDEpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN3YXBwZWQgbm9kZSBhc3N1bWluZyB3ZSBkaWRuJ3QgcmVtb3ZlIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSB0aGlzLkwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLkxbcG9zaXRpb25dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTC5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBmaXh1cChrKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzR3JlYXRlclRoYW5QYXJlbnQoaykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGsgPj4gMTtcbiAgICAgICAgICAgIHRoaXMuc3dhcChrLCBwYXJlbnQpO1xuICAgICAgICAgICAgayA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0dyZWF0ZXJUaGFuUGFyZW50KGspIHtcbiAgICAgICAgcmV0dXJuIGsgPiAxICYmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxbayA+PiAxXS52YWx1ZSwgdGhpcy5MW2tdLnZhbHVlKSA+IDApO1xuICAgIH1cbiAgICBmaXhkb3duKGspIHtcbiAgICAgICAgd2hpbGUgKChrIDw8IDEpIDw9IHRoaXMuY291bnQoKSkge1xuICAgICAgICAgICAgbGV0IGogPSBrIDw8IDE7XG4gICAgICAgICAgICBpZiAoKGogPCB0aGlzLmNvdW50KCkpICYmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxbal0udmFsdWUsIHRoaXMuTFtqICsgMV0udmFsdWUpID4gMCkpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wLmNvbXBhcmUodGhpcy5MW2tdLnZhbHVlLCB0aGlzLkxbal0udmFsdWUpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3dhcChrLCBqKTtcbiAgICAgICAgICAgIGsgPSBqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3YXAoaywgaikge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLkxba107XG4gICAgICAgIHRoaXMuTFtrXSA9IHRoaXMuTFtqXTtcbiAgICAgICAgdGhpcy5MW2tdLnBvc2l0aW9uID0gaztcbiAgICAgICAgdGhpcy5MW2pdID0gdG1wO1xuICAgICAgICB0aGlzLkxbal0ucG9zaXRpb24gPSBqO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYXAuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vYmF0Y2hNYW5hZ2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ibG9ic1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVhcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvbWlzZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JhbmdlVHJhY2tlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmF0ZUxpbWl0dGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zYWZlUGFyc2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91dGlsc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbi8qKlxuICogQSBkZWZlcnJlZCBjcmVhdGVzIGEgcHJvbWlzZSBhbmQgdGhlIGFiaWxpdHkgdG8gcmVzb2x2ZSBvciByZWplY3QgaXRcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6cHJvbWlzZS1tdXN0LWNvbXBsZXRlICovXG4gICAgICAgIHRoaXMucCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1bmRlcmx5aW5nIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZFxuICAgICAqL1xuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgcHJvbWlzZVxuICAgICAqL1xuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXModmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlXG4gICAgICovXG4gICAgcmVqZWN0KGVycm9yKSB7XG4gICAgICAgIHRoaXMucmVqKGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gcHJvbWlzZSBvbmx5IHJlc29sdmVzXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOnByb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RSZWplY3RlZChwcm9taXNlKSB7XG4gICAgLy8gQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHByb21pc2Ugb25seSByZXNvbHZlc1xuICAgIHByb21pc2UuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFzc2VydC5vayhmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlcy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuLy8gdHNsaW50OmRpc2FibGU6bm8tdmFyLXJlcXVpcmVzXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3VibW9kdWxlLWltcG9ydHNcbmNvbnN0IGNsb25lRGVlcCA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiB0aGUgcmVsYXRpb24gYmV0d2VlbiB0d28gcmFuZ2VzIGluIGEgMTpOIGZhc2hpb24uIFByaW1hcnlcbiAqIGlzIGNvbnRpbnVvdXMgYW5kIGFsd2F5cyBtYXBzIHRvIGEgc2luZ2xlIHZhbHVlIGluIHNlY29uZGFyeSBhYm92ZSB0aGUgYmFzZSB2YWx1ZS4gVGhlIHJhbmdlXG4gKiBkZWZpbmVzIGFuIGluY3JlYXNpbmcgc3RlcCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlVHJhY2tlciB7XG4gICAgZ2V0IGJhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS5wcmltYXJ5O1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeUhlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RQcmltYXJ5O1xuICAgIH1cbiAgICBnZXQgc2Vjb25kYXJ5SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlY29uZGFyeTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbWFyeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBbeyBsZW5ndGg6IDAsIHByaW1hcnksIHNlY29uZGFyeSB9XTtcbiAgICAgICAgICAgIHRoaXMubGFzdFByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICAgICAgdGhpcy5sYXN0U2Vjb25kYXJ5ID0gc2Vjb25kYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBjbG9uZURlZXAocHJpbWFyeS5yYW5nZXMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0UHJpbWFyeSA9IHByaW1hcnkubGFzdFByaW1hcnk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWNvbmRhcnkgPSBwcmltYXJ5Lmxhc3RTZWNvbmRhcnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgUmFuZ2VUcmFja2VyXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFzdFByaW1hcnk6IHRoaXMubGFzdFByaW1hcnksXG4gICAgICAgICAgICBsYXN0U2Vjb25kYXJ5OiB0aGlzLmxhc3RTZWNvbmRhcnksXG4gICAgICAgICAgICByYW5nZXM6IGNsb25lRGVlcCh0aGlzLnJhbmdlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHByaW1hcnkgaXMgdGltZSAtIHNlY29uZGFyeSBpcyB0aGUgTVNOXG4gICAgYWRkKHByaW1hcnksIHNlY29uZGFyeSkge1xuICAgICAgICAvLyBCb3RoIHZhbHVlcyBtdXN0IGNvbnRpbnVvdXNseSBiZSBpbmNyZWFzaW5nIC0gd2Ugd29uJ3QgYWx3YXlzIHRyYWNrIHRoZSBsYXN0IHZhbHVlIHdlIHNhdyBzbyB3ZSBkbyBzb1xuICAgICAgICAvLyBiZWxvdyB0byBjaGVjayBpbnZhcmlhbnRzXG4gICAgICAgIGFzc2VydChwcmltYXJ5ID49IHRoaXMubGFzdFByaW1hcnkpO1xuICAgICAgICBhc3NlcnQoc2Vjb25kYXJ5ID49IHRoaXMubGFzdFNlY29uZGFyeSk7XG4gICAgICAgIHRoaXMubGFzdFByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICB0aGlzLmxhc3RTZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gICAgICAgIC8vIEdldCBxdWlja2VyIHJlZmVyZW5jZXMgdG8gdGhlIGhlYWQgb2YgdGhlIHJhbmdlXG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcHJpbWFyeUhlYWQgPSBoZWFkLnByaW1hcnkgKyBoZWFkLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2Vjb25kYXJ5SGVhZCA9IGhlYWQuc2Vjb25kYXJ5ICsgaGVhZC5sZW5ndGg7XG4gICAgICAgIC8vIFNhbWUgc2Vjb25kYXJ5IGluZGljYXRlcyB0aGlzIGlzIG5vdCBhIHRydWUgaW5mbGVjdGlvbiBwb2ludCAtIHdlIGNhbiBpZ25vcmUgaXRcbiAgICAgICAgaWYgKHNlY29uZGFyeSA9PT0gc2Vjb25kYXJ5SGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBzZWNvbmRhcnkgLSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2VzXG4gICAgICAgIGlmIChwcmltYXJ5ID09PSBwcmltYXJ5SGVhZCkge1xuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBjb2RlIHBhdGggaGFzIHVzIHN1cHBvcnRpbmcgTjpOIHJhbmdlcy4gQnV0IHdlIHNpbXBseSBvdmVyd3JpdGUgZHVwbGljYXRlIHZhbHVlcyB0b1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgMTpOIHNpbmNlIHlvdSBjYW4gb25seSBsb29rdXAgZnJvbSB0aGUgcHJpbWFyeSB0byBhIHNlY29uZGFyeVxuICAgICAgICAgICAgaWYgKGhlYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcmFuZ2UgcmVwcmVzZW50ZWQgLSB3ZSBjYW4gc2ltcGx5IHVwZGF0ZSBzZWNvbmRhcnkgd2l0aCB0aGUgb3ZlcndyaXR0ZW4gdmFsdWVcbiAgICAgICAgICAgICAgICBoZWFkLnNlY29uZGFyeSA9IHNlY29uZGFyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZXMgaW4gdGhlIHJhbmdlIGJlZm9yZSB0aGlzIG9uZSBhcmUgdmFsaWQgLSBidXQgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lIGZvciB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmNyZW1lbnQtZGVjcmVtZW50XG4gICAgICAgICAgICAgICAgaGVhZC5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlcy5wdXNoKHsgbGVuZ3RoOiAwLCBwcmltYXJ5LCBzZWNvbmRhcnkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJpbWFyeUhlYWQgKyAxID09PSBwcmltYXJ5ICYmIHNlY29uZGFyeUhlYWQgKyAxID09PSBzZWNvbmRhcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgdGhlIGxlbmd0aCBpZiBib3RoIGluY3JlYXNlIGJ5IHRoZSBzYW1lIGFtb3VudFxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmNyZW1lbnQtZGVjcmVtZW50XG4gICAgICAgICAgICAgICAgaGVhZC5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZXMucHVzaCh7IGxlbmd0aDogMCwgcHJpbWFyeSwgc2Vjb25kYXJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldChwcmltYXJ5KSB7XG4gICAgICAgIGFzc2VydChwcmltYXJ5ID49IHRoaXMucmFuZ2VzWzBdLnByaW1hcnkpO1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByYW5nZSB3aGVyZSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBwcmltYXJ5LiBPdXIgdGFyZ2V0IHJhbmdlIGlzXG4gICAgICAgIC8vIHRoZSBvbmUgYmVmb3JlIGl0LlxuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuICAgICAgICBmb3IgKDsgaW5kZXggPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5IDwgdGhpcy5yYW5nZXNbaW5kZXhdLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdLnByaW1hcnkpO1xuICAgICAgICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBpcyB3aXRoaW4gdGhlIHN0b3JlZCByYW5nZSB1c2UgaXQgLSBvdGhlcndpc2UgYWRkIGluIHRoZSBsZW5ndGggLSAxIGFzIHRoZSBoaWdoZXN0XG4gICAgICAgIC8vIHN0b3JlZCBzZWNvbmRhcnkgdmFsdWUgdG8gdXNlLlxuICAgICAgICBjb25zdCBjbG9zZXN0UmFuZ2UgPSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJpbWFyeSAtIGNsb3Nlc3RSYW5nZS5wcmltYXJ5LCBjbG9zZXN0UmFuZ2UubGVuZ3RoKSArIGNsb3Nlc3RSYW5nZS5zZWNvbmRhcnk7XG4gICAgfVxuICAgIHVwZGF0ZUJhc2UocHJpbWFyeSkge1xuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1swXS5wcmltYXJ5KTtcbiAgICAgICAgLy8gV2FsayB0aGUgcmFuZ2VzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhlIHByaW1hcnkuIFByaW1hcnkgaXMgdGhlbiB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHByZXZpb3VzIGluZGV4IGJ5IGRlZmluaXRpb24gKHNpbmNlIGl0J3MgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4J3MgcHJpbWFyeSBidXQgZ3JlYXRoZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgaW5kZXgncyBwcmltYXJ5KSBhbmQgd2Uga25vdyBwcmltYXJ5IG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBiYXNlLlxuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuICAgICAgICBmb3IgKDsgaW5kZXggPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5IDwgdGhpcy5yYW5nZXNbaW5kZXhdLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdLnByaW1hcnkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgcmFuZ2UgdmFsdWVzXG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZXNbaW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwcmltYXJ5IC0gcmFuZ2UucHJpbWFyeTtcbiAgICAgICAgcmFuZ2Uuc2Vjb25kYXJ5ID0gcmFuZ2Uuc2Vjb25kYXJ5ICsgTWF0aC5taW4oZGVsdGEsIHJhbmdlLmxlbmd0aCk7XG4gICAgICAgIHJhbmdlLmxlbmd0aCA9IE1hdGgubWF4KHJhbmdlLmxlbmd0aCAtIGRlbHRhLCAwKTtcbiAgICAgICAgcmFuZ2UucHJpbWFyeSA9IHByaW1hcnk7XG4gICAgICAgIC8vIEFuZCByZW1vdmUgdW5uZWNlc3NhcnkgcmFuZ2VzXG4gICAgICAgIHRoaXMucmFuZ2VzID0gaW5kZXggLSAxID4gMCA/IHRoaXMucmFuZ2VzLnNsaWNlKGluZGV4IC0gMSkgOiB0aGlzLnJhbmdlcztcbiAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIGxvd2VzdCB2YWx1ZSBpcyBub3cgdGhlIGlucHV0IHRvIHRoaXMgbWV0aG9kXG4gICAgICAgIGFzc2VydC5lcXVhbChwcmltYXJ5LCB0aGlzLnJhbmdlc1swXS5wcmltYXJ5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZVRyYWNrZXIuanMubWFwIiwiLy8gQSByYXRlIGxpbWl0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgYSBjbGllbnQgY2FuIG9ubHkgcmVxdWVzdCBoZWxwIGZvciBvbmUgdGFzayB3aXRoaW4gYSB0aW1lIHdpbmRvdy5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdpbmRvd01TZWMpIHtcbiAgICAgICAgdGhpcy53aW5kb3dNU2VjID0gd2luZG93TVNlYztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmaWx0ZXIoY2xpZW50SWQsIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7Y2xpZW50SWR9LyR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RNYXAuc2V0KGtleSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGFwcHJvdmVkTGlzdC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXF1ZXN0TWFwLmdldChrZXkpICsgdGhpcy53aW5kb3dNU2VjID4gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdE1hcC5zZXQoa2V5LCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgYXBwcm92ZWRMaXN0LnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcHJvdmVkTGlzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRlTGltaXR0ZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHNhZmVseVBhcnNlSlNPTihqc29uKSB7XG4gICAgbGV0IHBhcnNlZDtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvL1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZVBhcnNlci5qcy5tYXAiLCJpbXBvcnQgeyBNZXNzYWdlVHlwZSB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3lzdGVtVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBNZXNzYWdlVHlwZS5SZW1vdGVIZWxwIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkludGVncmF0ZSB8fFxuICAgICAgICB0eXBlID09PSBNZXNzYWdlVHlwZS5DbGllbnRKb2luIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkNsaWVudExlYXZlIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkZvcmspO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTaGFyZWROdW1iZXJTZXF1ZW5jZSwgU2hhcmVkT2JqZWN0U2VxdWVuY2UgfSBmcm9tIFwiLi9zZXF1ZW5jZVwiO1xuaW1wb3J0IHsgU2hhcmVkU3RyaW5nIH0gZnJvbSBcIi4vc2hhcmVkU3RyaW5nXCI7XG5leHBvcnQgY2xhc3MgU2hhcmVkU3RyaW5nRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcmVkU3RyaW5nRXh0ZW5zaW9uLlR5cGU7XG4gICAgfVxuICAgIGxvYWQoZG9jdW1lbnQsIGlkLCBtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIHNlcnZpY2VzLCBoZWFkZXJPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFN0cmluZyA9IG5ldyBTaGFyZWRTdHJpbmcoZG9jdW1lbnQsIGlkLCBzZXJ2aWNlcyk7XG4gICAgICAgICAgICB5aWVsZCBzaGFyZWRTdHJpbmcubG9hZChtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIGhlYWRlck9yaWdpbiwgc2VydmljZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZFN0cmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZShkb2N1bWVudCwgaWQpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkU3RyaW5nID0gbmV3IFNoYXJlZFN0cmluZyhkb2N1bWVudCwgaWQpO1xuICAgICAgICBzaGFyZWRTdHJpbmcuaW5pdGlhbGl6ZUxvY2FsKCk7XG4gICAgICAgIHJldHVybiBzaGFyZWRTdHJpbmc7XG4gICAgfVxufVxuLy8gVE9ETyByZW5hbWUgYmFjayB0byBodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdHlwZXMvbWVyZ2VUcmVlL3N0cmluZyBvbmNlIHBhcGFyYXp6aSBpcyBhYmxlIHRvIGR5bmFtaWNhbGx5XG4vLyBsb2FkIGNvZGVcblNoYXJlZFN0cmluZ0V4dGVuc2lvbi5UeXBlID0gXCJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdHlwZXMvbWVyZ2VUcmVlXCI7XG5leHBvcnQgY2xhc3MgU2hhcmVkT2JqZWN0U2VxdWVuY2VFeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFyZWRPYmplY3RTZXF1ZW5jZUV4dGVuc2lvbi5UeXBlO1xuICAgIH1cbiAgICBsb2FkKGRvY3VtZW50LCBpZCwgbWluaW11bVNlcXVlbmNlTnVtYmVyLCBzZXJ2aWNlcywgaGVhZGVyT3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRTZXEgPSBuZXcgU2hhcmVkT2JqZWN0U2VxdWVuY2UoZG9jdW1lbnQsIGlkLCBzZXJ2aWNlcyk7XG4gICAgICAgICAgICB5aWVsZCBzaGFyZWRTZXEubG9hZChtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIGhlYWRlck9yaWdpbiwgc2VydmljZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZFNlcTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZShkb2N1bWVudCwgaWQpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkU3RyaW5nID0gbmV3IFNoYXJlZE9iamVjdFNlcXVlbmNlKGRvY3VtZW50LCBpZCk7XG4gICAgICAgIHNoYXJlZFN0cmluZy5pbml0aWFsaXplTG9jYWwoKTtcbiAgICAgICAgcmV0dXJuIHNoYXJlZFN0cmluZztcbiAgICB9XG59XG5TaGFyZWRPYmplY3RTZXF1ZW5jZUV4dGVuc2lvbi5UeXBlID0gXCJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdHlwZXMvbWVyZ2VUcmVlL29iamVjdC1zZXF1ZW5jZVwiO1xuZXhwb3J0IGNsYXNzIFNoYXJlZE51bWJlclNlcXVlbmNlRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcmVkTnVtYmVyU2VxdWVuY2VFeHRlbnNpb24uVHlwZTtcbiAgICB9XG4gICAgbG9hZChkb2N1bWVudCwgaWQsIG1pbmltdW1TZXF1ZW5jZU51bWJlciwgc2VydmljZXMsIGhlYWRlck9yaWdpbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VxID0gbmV3IFNoYXJlZE51bWJlclNlcXVlbmNlKGRvY3VtZW50LCBpZCwgc2VydmljZXMpO1xuICAgICAgICAgICAgeWllbGQgc2hhcmVkU2VxLmxvYWQobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXJPcmlnaW4sIHNlcnZpY2VzKTtcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWRTZXE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGUoZG9jdW1lbnQsIGlkKSB7XG4gICAgICAgIGNvbnN0IHNoYXJlZFN0cmluZyA9IG5ldyBTaGFyZWROdW1iZXJTZXF1ZW5jZShkb2N1bWVudCwgaWQpO1xuICAgICAgICBzaGFyZWRTdHJpbmcuaW5pdGlhbGl6ZUxvY2FsKCk7XG4gICAgICAgIHJldHVybiBzaGFyZWRTdHJpbmc7XG4gICAgfVxufVxuU2hhcmVkTnVtYmVyU2VxdWVuY2VFeHRlbnNpb24uVHlwZSA9IFwiaHR0cHM6Ly9ncmFwaC5taWNyb3NvZnQuY29tL3R5cGVzL21lcmdlVHJlZS9udW1iZXItc2VxdWVuY2VcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5qcy5tYXAiLCJleHBvcnQgeyBTaGFyZWRTdHJpbmdJbnRlcnZhbCwgSW50ZXJ2YWwsIFNoYXJlZEludGVydmFsQ29sbGVjdGlvbiwgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uVmlldywgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uVmFsdWVUeXBlLCBTaGFyZWRTdHJpbmdJbnRlcnZhbENvbGxlY3Rpb25WYWx1ZVR5cGUsIH0gZnJvbSBcIi4vaW50ZXJ2YWxDb2xsZWN0aW9uXCI7XG5leHBvcnQgeyBTaGFyZWRTdHJpbmcsIH0gZnJvbSBcIi4vc2hhcmVkU3RyaW5nXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXF1ZW5jZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vZXh0ZW5zaW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXF1ZW5jZURlbHRhRXZlbnRcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0ICogYXMgTWVyZ2VUcmVlIGZyb20gXCJAcHJhZ3VlL21lcmdlLXRyZWVcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcbmV4cG9ydCBjbGFzcyBJbnRlcnZhbCB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgcHJvcHMpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFkZGl0aW9uYWxQcm9wZXJ0eVNldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1eFByb3BzO1xuICAgIH1cbiAgICBhZGRQcm9wZXJ0eVNldChwcm9wcykge1xuICAgICAgICBpZiAodGhpcy5hdXhQcm9wcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmF1eFByb3BzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXhQcm9wcy5wdXNoKHByb3BzKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGNsaWVudCkge1xuICAgICAgICBsZXQgc2VxID0gMDtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgc2VxID0gY2xpZW50LmdldEN1cnJlbnRTZXEoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1vYmplY3QtbGl0ZXJhbC10eXBlLWFzc2VydGlvbiAqL1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkSW50ZXJ2YWwgPSB7XG4gICAgICAgICAgICBlbmQ6IHRoaXMuZW5kLFxuICAgICAgICAgICAgaW50ZXJ2YWxUeXBlOiAwLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IHNlcSxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkSW50ZXJ2YWwucHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZEludGVydmFsO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29tcGFyZShiKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gdGhpcy5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgIGlmIChzdGFydFJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVuZCAtIGIuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvdmVybGFwcyhiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICh0aGlzLnN0YXJ0IDwgYi5lbmQpICYmXG4gICAgICAgICAgICAodGhpcy5lbmQgPj0gYi5zdGFydCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHVuaW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbChNYXRoLm1pbih0aGlzLnN0YXJ0LCBiLnN0YXJ0KSwgTWF0aC5tYXgodGhpcy5lbmQsIGIuZW5kKSwgdGhpcy5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgZ2V0UHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcztcbiAgICB9XG4gICAgYWRkUHJvcGVydGllcyhuZXdQcm9wcywgb3ApIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gTWVyZ2VUcmVlLmFkZFByb3BlcnRpZXModGhpcy5wcm9wZXJ0aWVzLCBuZXdQcm9wcywgb3ApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaGFyZWRTdHJpbmdJbnRlcnZhbCB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgaW50ZXJ2YWxUeXBlLCBwcm9wcykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmludGVydmFsVHlwZSA9IGludGVydmFsVHlwZTtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlcmlhbGl6ZShjbGllbnQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnQudG9Qb3NpdGlvbihjbGllbnQubWVyZ2VUcmVlLCBjbGllbnQuZ2V0Q3VycmVudFNlcSgpLCBjbGllbnQuZ2V0Q2xpZW50SWQoKSk7XG4gICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gdGhpcy5lbmQudG9Qb3NpdGlvbihjbGllbnQubWVyZ2VUcmVlLCBjbGllbnQuZ2V0Q3VycmVudFNlcSgpLCBjbGllbnQuZ2V0Q2xpZW50SWQoKSk7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnRlcnZhbCA9IHtcbiAgICAgICAgICAgIGVuZDogZW5kUG9zaXRpb24sXG4gICAgICAgICAgICBpbnRlcnZhbFR5cGU6IHRoaXMuaW50ZXJ2YWxUeXBlLFxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXI6IGNsaWVudC5nZXRDdXJyZW50U2VxKCksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRQb3NpdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgc2VyaWFsaXplZEludGVydmFsLnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRJbnRlcnZhbDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkU3RyaW5nSW50ZXJ2YWwodGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMuaW50ZXJ2YWxUeXBlKTtcbiAgICB9XG4gICAgY29tcGFyZShiKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gdGhpcy5zdGFydC5jb21wYXJlKGIuc3RhcnQpO1xuICAgICAgICBpZiAoc3RhcnRSZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5lbmQuY29tcGFyZShiLmVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0UmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIG92ZXJsYXBzKGIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKHRoaXMuc3RhcnQuY29tcGFyZShiLmVuZCkgPCAwKSAmJlxuICAgICAgICAgICAgKHRoaXMuZW5kLmNvbXBhcmUoYi5zdGFydCkgPj0gMCk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrTWVyZ2VUcmVlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrT3ZlcmxhcHMoYiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB1bmlvbihiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkU3RyaW5nSW50ZXJ2YWwodGhpcy5zdGFydC5taW4oYi5zdGFydCksIHRoaXMuZW5kLm1heChiLmVuZCksIHRoaXMuaW50ZXJ2YWxUeXBlKTtcbiAgICB9XG4gICAgYWRkUHJvcGVydGllcyhuZXdQcm9wcywgb3ApIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gTWVyZ2VUcmVlLmFkZFByb3BlcnRpZXModGhpcy5wcm9wZXJ0aWVzLCBuZXdQcm9wcywgb3ApO1xuICAgIH1cbiAgICBvdmVybGFwc1BvcyhtZXJnZVRyZWUsIGJzdGFydCwgYmVuZCkge1xuICAgICAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhcnQudG9Qb3NpdGlvbihtZXJnZVRyZWUsIE1lcmdlVHJlZS5Vbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgbWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCk7XG4gICAgICAgIGNvbnN0IGVuZFBvcyA9IHRoaXMuc3RhcnQudG9Qb3NpdGlvbihtZXJnZVRyZWUsIE1lcmdlVHJlZS5Vbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgbWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCk7XG4gICAgICAgIHJldHVybiAoZW5kUG9zID4gYnN0YXJ0KSAmJiAoc3RhcnRQb3MgPCBiZW5kKTtcbiAgICB9XG4gICAgY2hlY2tPdmVybGFwcyhiLCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgYXN0YXJ0ID0gdGhpcy5zdGFydC50b1Bvc2l0aW9uKHRoaXMuY2hlY2tNZXJnZVRyZWUsIHRoaXMuY2hlY2tNZXJnZVRyZWUuY29sbGFiV2luZG93LmN1cnJlbnRTZXEsIHRoaXMuY2hlY2tNZXJnZVRyZWUuY29sbGFiV2luZG93LmNsaWVudElkKTtcbiAgICAgICAgY29uc3QgYnN0YXJ0ID0gYi5zdGFydC50b1Bvc2l0aW9uKHRoaXMuY2hlY2tNZXJnZVRyZWUsIHRoaXMuY2hlY2tNZXJnZVRyZWUuY29sbGFiV2luZG93LmN1cnJlbnRTZXEsIHRoaXMuY2hlY2tNZXJnZVRyZWUuY29sbGFiV2luZG93LmNsaWVudElkKTtcbiAgICAgICAgY29uc3QgYWVuZCA9IHRoaXMuZW5kLnRvUG9zaXRpb24odGhpcy5jaGVja01lcmdlVHJlZSwgdGhpcy5jaGVja01lcmdlVHJlZS5jb2xsYWJXaW5kb3cuY3VycmVudFNlcSwgdGhpcy5jaGVja01lcmdlVHJlZS5jb2xsYWJXaW5kb3cuY2xpZW50SWQpO1xuICAgICAgICBjb25zdCBiZW5kID0gYi5lbmQudG9Qb3NpdGlvbih0aGlzLmNoZWNrTWVyZ2VUcmVlLCB0aGlzLmNoZWNrTWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jdXJyZW50U2VxLCB0aGlzLmNoZWNrTWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCk7XG4gICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gKChhc3RhcnQgPCBiZW5kKSAmJiAoYnN0YXJ0IDwgYWVuZCkpO1xuICAgICAgICBpZiAoY2hlY2tSZXN1bHQgIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgICAgICAgY29uc29sZS5sb2coYGNoZWNrIG1pc21hdGNoOiByZXMgJHtyZXN1bHR9ICR7dGhpcy5zdGFydC5zZWdtZW50ID09PSBiLmVuZC5zZWdtZW50fSAke2Iuc3RhcnQuc2VnbWVudCA9PT0gdGhpcy5lbmQuc2VnbWVudH1gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBhcyAke2FzdGFydH0gYWUgJHthZW5kfSBicyAke2JzdGFydH0gYmUgJHtiZW5kfWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYGFzICR7TWVyZ2VUcmVlLm9yZGluYWxUb0FycmF5KHRoaXMuc3RhcnQuc2VnbWVudC5vcmRpbmFsKX1AJHt0aGlzLnN0YXJ0Lm9mZnNldH1gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBhZSAke01lcmdlVHJlZS5vcmRpbmFsVG9BcnJheSh0aGlzLmVuZC5zZWdtZW50Lm9yZGluYWwpfUAke3RoaXMuZW5kLm9mZnNldH1gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBicyAke01lcmdlVHJlZS5vcmRpbmFsVG9BcnJheShiLnN0YXJ0LnNlZ21lbnQub3JkaW5hbCl9QCR7Yi5zdGFydC5vZmZzZXR9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgYmUgJHtNZXJnZVRyZWUub3JkaW5hbFRvQXJyYXkoYi5lbmQuc2VnbWVudC5vcmRpbmFsKX1AJHtiLmVuZC5vZmZzZXR9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmNoZWNrTWVyZ2VUcmVlLm5vZGVUb1N0cmluZyhiLnN0YXJ0LnNlZ21lbnQucGFyZW50LCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvblJlZmVyZW5jZShjbGllbnQsIHBvcywgcmVmVHlwZSwgcmVmU2VxID0gY2xpZW50LmdldEN1cnJlbnRTZXEoKSwgY2xpZW50SWQgPSBjbGllbnQuZ2V0Q2xpZW50SWQoKSkge1xuICAgIGNvbnN0IHNlZ29mZiA9IGNsaWVudC5tZXJnZVRyZWUuZ2V0Q29udGFpbmluZ1NlZ21lbnQocG9zLCByZWZTZXEsIGNsaWVudC5nZXRDbGllbnRJZCgpKTtcbiAgICBpZiAoc2Vnb2ZmICYmIHNlZ29mZi5zZWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGJhc2VTZWdtZW50ID0gc2Vnb2ZmLnNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IGxyZWYgPSBuZXcgTWVyZ2VUcmVlLkxvY2FsUmVmZXJlbmNlKGJhc2VTZWdtZW50LCBzZWdvZmYub2Zmc2V0LCByZWZUeXBlKTtcbiAgICAgICAgaWYgKHJlZlR5cGUgIT09IE1lcmdlVHJlZS5SZWZlcmVuY2VUeXBlLlRyYW5zaWVudCkge1xuICAgICAgICAgICAgY2xpZW50Lm1lcmdlVHJlZS5hZGRMb2NhbFJlZmVyZW5jZShscmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbHJlZjtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFyZWRTdHJpbmdJbnRlcnZhbChsYWJlbCwgc3RhcnQsIGVuZCwgY2xpZW50LCBpbnRlcnZhbFR5cGUpIHtcbiAgICBsZXQgYmVnaW5SZWZUeXBlID0gTWVyZ2VUcmVlLlJlZmVyZW5jZVR5cGUuUmFuZ2VCZWdpbjtcbiAgICBsZXQgZW5kUmVmVHlwZSA9IE1lcmdlVHJlZS5SZWZlcmVuY2VUeXBlLlJhbmdlRW5kO1xuICAgIGlmIChpbnRlcnZhbFR5cGUgPT09IE1lcmdlVHJlZS5JbnRlcnZhbFR5cGUuTmVzdCkge1xuICAgICAgICBiZWdpblJlZlR5cGUgPSBNZXJnZVRyZWUuUmVmZXJlbmNlVHlwZS5OZXN0QmVnaW47XG4gICAgICAgIGVuZFJlZlR5cGUgPSBNZXJnZVRyZWUuUmVmZXJlbmNlVHlwZS5OZXN0RW5kO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnRlcnZhbFR5cGUgPT09IE1lcmdlVHJlZS5JbnRlcnZhbFR5cGUuVHJhbnNpZW50KSB7XG4gICAgICAgIGJlZ2luUmVmVHlwZSA9IE1lcmdlVHJlZS5SZWZlcmVuY2VUeXBlLlRyYW5zaWVudDtcbiAgICAgICAgZW5kUmVmVHlwZSA9IE1lcmdlVHJlZS5SZWZlcmVuY2VUeXBlLlRyYW5zaWVudDtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMcmVmID0gY3JlYXRlUG9zaXRpb25SZWZlcmVuY2UoY2xpZW50LCBzdGFydCwgYmVnaW5SZWZUeXBlKTtcbiAgICBjb25zdCBlbmRMcmVmID0gY3JlYXRlUG9zaXRpb25SZWZlcmVuY2UoY2xpZW50LCBlbmQsIGVuZFJlZlR5cGUpO1xuICAgIGlmIChzdGFydExyZWYgJiYgZW5kTHJlZikge1xuICAgICAgICBzdGFydExyZWYucGFpcmVkUmVmID0gZW5kTHJlZjtcbiAgICAgICAgZW5kTHJlZi5wYWlyZWRSZWYgPSBzdGFydExyZWY7XG4gICAgICAgIGNvbnN0IHJhbmdlUHJvcCA9IHtcbiAgICAgICAgICAgIFtNZXJnZVRyZWUucmVzZXJ2ZWRSYW5nZUxhYmVsc0tleV06IFtsYWJlbF0sXG4gICAgICAgIH07XG4gICAgICAgIHN0YXJ0THJlZi5hZGRQcm9wZXJ0aWVzKHJhbmdlUHJvcCk7XG4gICAgICAgIGVuZExyZWYuYWRkUHJvcGVydGllcyhyYW5nZVByb3ApO1xuICAgICAgICBjb25zdCBpdmFsID0gbmV3IFNoYXJlZFN0cmluZ0ludGVydmFsKHN0YXJ0THJlZiwgZW5kTHJlZiwgaW50ZXJ2YWxUeXBlLCByYW5nZVByb3ApO1xuICAgICAgICAvLyBpdmFsLmNoZWNrTWVyZ2VUcmVlID0gc2hhcmVkU3RyaW5nLmNsaWVudC5tZXJnZVRyZWU7XG4gICAgICAgIHJldHVybiBpdmFsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRJbnRlcnZhbENvbmZsaWN0UmVzb2x2ZXIoYSwgYikge1xuICAgIGEuYWRkUHJvcGVydHlTZXQoYi5wcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnRlcnZhbEluZGV4KGNvbmZsaWN0KSB7XG4gICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgY29tcGFyZUVuZHM6IGNvbXBhcmVJbnRlcnZhbEVuZHMsXG4gICAgICAgIGNyZWF0ZTogY3JlYXRlSW50ZXJ2YWwsXG4gICAgfTtcbiAgICBjb25zdCBsYyA9IG5ldyBMb2NhbEludGVydmFsQ29sbGVjdGlvbih1bmRlZmluZWQsIFwiXCIsIGhlbHBlcnMpO1xuICAgIGlmIChjb25mbGljdCkge1xuICAgICAgICBsYy5hZGRDb25mbGljdFJlc29sdmVyKGNvbmZsaWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxjLmFkZENvbmZsaWN0UmVzb2x2ZXIoZGVmYXVsdEludGVydmFsQ29uZmxpY3RSZXNvbHZlcik7XG4gICAgfVxuICAgIHJldHVybiBsYztcbn1cbmV4cG9ydCBjbGFzcyBMb2NhbEludGVydmFsQ29sbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBsYWJlbCwgaGVscGVycykge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzO1xuICAgICAgICB0aGlzLmludGVydmFsVHJlZSA9IG5ldyBNZXJnZVRyZWUuSW50ZXJ2YWxUcmVlKCk7XG4gICAgICAgIHRoaXMuZW5kSW50ZXJ2YWxUcmVlID1cbiAgICAgICAgICAgIG5ldyBNZXJnZVRyZWUuUmVkQmxhY2tUcmVlKGhlbHBlcnMuY29tcGFyZUVuZHMpO1xuICAgIH1cbiAgICBhZGRDb25mbGljdFJlc29sdmVyKGNvbmZsaWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5jb25mbGljdFJlc29sdmVyID0gY29uZmxpY3RSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lbmRDb25mbGljdFJlc29sdmVyID1cbiAgICAgICAgICAgIChrZXksIGN1cnJlbnRLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdmFsID0gdGhpcy5jb25mbGljdFJlc29sdmVyKGtleSwgY3VycmVudEtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaXZhbCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpdmFsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBtYXAoZm4pIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUubWFwKGZuKTtcbiAgICB9XG4gICAgZmluZE92ZXJsYXBwaW5nSW50ZXJ2YWxzKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcnZhbFRyZWUuaW50ZXJ2YWxzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpZW50SW50ZXJ2YWwgPSB0aGlzLmhlbHBlcnMuY3JlYXRlKFwidHJhbnNpZW50XCIsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCB0aGlzLmNsaWVudCwgTWVyZ2VUcmVlLkludGVydmFsVHlwZS5UcmFuc2llbnQpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdJbnRlcnZhbE5vZGVzID0gdGhpcy5pbnRlcnZhbFRyZWUubWF0Y2godHJhbnNpZW50SW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nSW50ZXJ2YWxOb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2aW91c0ludGVydmFsKHBvcykge1xuICAgICAgICBjb25zdCB0cmFuc2llbnRJbnRlcnZhbCA9IHRoaXMuaGVscGVycy5jcmVhdGUoXCJ0cmFuc2llbnRcIiwgcG9zLCBwb3MsIHRoaXMuY2xpZW50LCBNZXJnZVRyZWUuSW50ZXJ2YWxUeXBlLlRyYW5zaWVudCk7XG4gICAgICAgIGNvbnN0IHJiTm9kZSA9IHRoaXMuZW5kSW50ZXJ2YWxUcmVlLmZsb29yKHRyYW5zaWVudEludGVydmFsKTtcbiAgICAgICAgaWYgKHJiTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJiTm9kZS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRJbnRlcnZhbChwb3MpIHtcbiAgICAgICAgY29uc3QgdHJhbnNpZW50SW50ZXJ2YWwgPSB0aGlzLmhlbHBlcnMuY3JlYXRlKFwidHJhbnNpZW50XCIsIHBvcywgcG9zLCB0aGlzLmNsaWVudCwgTWVyZ2VUcmVlLkludGVydmFsVHlwZS5UcmFuc2llbnQpO1xuICAgICAgICBjb25zdCByYk5vZGUgPSB0aGlzLmVuZEludGVydmFsVHJlZS5jZWlsKHRyYW5zaWVudEludGVydmFsKTtcbiAgICAgICAgaWYgKHJiTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJiTm9kZS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUludGVydmFsKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaWVudEludGVydmFsID0gdGhpcy5oZWxwZXJzLmNyZWF0ZShcInRyYW5zaWVudFwiLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgdGhpcy5jbGllbnQsIE1lcmdlVHJlZS5JbnRlcnZhbFR5cGUuVHJhbnNpZW50KTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucmVtb3ZlKHRyYW5zaWVudEludGVydmFsKTtcbiAgICAgICAgdGhpcy5lbmRJbnRlcnZhbFRyZWUucmVtb3ZlKHRyYW5zaWVudEludGVydmFsKTtcbiAgICB9XG4gICAgY3JlYXRlSW50ZXJ2YWwoc3RhcnQsIGVuZCwgaW50ZXJ2YWxUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlbHBlcnMuY3JlYXRlKHRoaXMubGFiZWwsIHN0YXJ0LCBlbmQsIHRoaXMuY2xpZW50LCBpbnRlcnZhbFR5cGUpO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZW1vdmUgaW50ZXJ2YWwsIGhhbmRsZSBkdXBsaWNhdGUgaW50ZXJ2YWxzXG4gICAgYWRkSW50ZXJ2YWwoc3RhcnQsIGVuZCwgaW50ZXJ2YWxUeXBlLCBwcm9wcykge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuY3JlYXRlSW50ZXJ2YWwoc3RhcnQsIGVuZCwgaW50ZXJ2YWxUeXBlKTtcbiAgICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgICAgICBpbnRlcnZhbC5hZGRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsICYmICh0aGlzLmxhYmVsLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwucHJvcGVydGllc1tNZXJnZVRyZWUucmVzZXJ2ZWRSYW5nZUxhYmVsc0tleV0gPSBbdGhpcy5sYWJlbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5wdXQoaW50ZXJ2YWwsIHRoaXMuY29uZmxpY3RSZXNvbHZlcik7XG4gICAgICAgICAgICB0aGlzLmVuZEludGVydmFsVHJlZS5wdXQoaW50ZXJ2YWwsIGludGVydmFsLCB0aGlzLmVuZENvbmZsaWN0UmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudDtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxzID0gdGhpcy5pbnRlcnZhbFRyZWUuaW50ZXJ2YWxzLmtleXMoKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHJldHVybiBpbnRlcnZhbHMubWFwKChpbnRlcnZhbCkgPT4gaW50ZXJ2YWwuc2VyaWFsaXplKGNsaWVudCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaGFyZWRTdHJpbmdJbnRlcnZhbEVuZHMoYSwgYikge1xuICAgIHJldHVybiBhLmVuZC5jb21wYXJlKGIuZW5kKTtcbn1cbmNsYXNzIFNoYXJlZFN0cmluZ0ludGVydmFsQ29sbGVjdGlvbkZhY3Rvcnkge1xuICAgIGxvYWQoZW1pdHRlciwgcmF3KSB7XG4gICAgICAgIGNvbnN0IGhlbHBlcnMgPSB7XG4gICAgICAgICAgICBjb21wYXJlRW5kczogY29tcGFyZVNoYXJlZFN0cmluZ0ludGVydmFsRW5kcyxcbiAgICAgICAgICAgIGNyZWF0ZTogY3JlYXRlU2hhcmVkU3RyaW5nSW50ZXJ2YWwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uKGhlbHBlcnMsIHRydWUsIGVtaXR0ZXIsIHJhdyB8fCBbXSk7XG4gICAgfVxuICAgIHN0b3JlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zZXJpYWxpemVJbnRlcm5hbCgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaGFyZWRTdHJpbmdJbnRlcnZhbENvbGxlY3Rpb25WYWx1ZVR5cGUge1xuICAgIC8vIHRzbGludDplbmFibGU6dmFyaWFibGUtbmFtZVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9mYWN0b3J5ID0gbmV3IFNoYXJlZFN0cmluZ0ludGVydmFsQ29sbGVjdGlvbkZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fb3BzID0gbmV3IE1hcChbW1xuICAgICAgICAgICAgICAgIFwiYWRkXCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpwcm9taXNlLWZ1bmN0aW9uLWFzeW5jICovXG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmU6ICh2YWx1ZSwgcGFyYW1zLCBsb2NhbCwgb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIG9wcyB3ZXJlIGFwcGxpZWQgd2hlbiB0aGUgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByZXBhcmVBZGRJbnRlcm5hbChwYXJhbXMsIGxvY2FsLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6ICh2YWx1ZSwgcGFyYW1zLCBjb250ZXh0LCBsb2NhbCwgb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIG9wcyB3ZXJlIGFwcGxpZWQgd2hlbiB0aGUgbWVzc2FnZSB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkSW50ZXJuYWwocGFyYW1zLCBjb250ZXh0LCBsb2NhbCwgb3ApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gU2hhcmVkU3RyaW5nSW50ZXJ2YWxDb2xsZWN0aW9uVmFsdWVUeXBlLk5hbWU7XG4gICAgfVxuICAgIGdldCBmYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFjdG9yeTtcbiAgICB9XG4gICAgZ2V0IG9wcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wcztcbiAgICB9XG59XG5TaGFyZWRTdHJpbmdJbnRlcnZhbENvbGxlY3Rpb25WYWx1ZVR5cGUuTmFtZSA9IFwic2hhcmVkU3RyaW5nSW50ZXJ2YWxDb2xsZWN0aW9uXCI7XG5mdW5jdGlvbiBjb21wYXJlSW50ZXJ2YWxFbmRzKGEsIGIpIHtcbiAgICByZXR1cm4gYS5lbmQgLSBiLmVuZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVydmFsKGxhYmVsLCBzdGFydCwgZW5kLCBjbGllbnQpIHtcbiAgICBsZXQgcmFuZ2VQcm9wO1xuICAgIGlmIChsYWJlbCAmJiAobGFiZWwubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgcmFuZ2VQcm9wID0ge1xuICAgICAgICAgICAgW01lcmdlVHJlZS5yZXNlcnZlZFJhbmdlTGFiZWxzS2V5XTogW2xhYmVsXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbChzdGFydCwgZW5kLCByYW5nZVByb3ApO1xufVxuY2xhc3MgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uRmFjdG9yeSB7XG4gICAgbG9hZChlbWl0dGVyLCByYXcpIHtcbiAgICAgICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgICAgIGNvbXBhcmVFbmRzOiBjb21wYXJlSW50ZXJ2YWxFbmRzLFxuICAgICAgICAgICAgY3JlYXRlOiBjcmVhdGVJbnRlcnZhbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IG5ldyBTaGFyZWRJbnRlcnZhbENvbGxlY3Rpb24oaGVscGVycywgZmFsc2UsIGVtaXR0ZXIsIHJhdyB8fCBbXSk7XG4gICAgICAgIGNvbGxlY3Rpb24uYXR0YWNoKHVuZGVmaW5lZCwgXCJcIik7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzdG9yZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2VyaWFsaXplSW50ZXJuYWwoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uVmFsdWVUeXBlIHtcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlOnZhcmlhYmxlLW5hbWVcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IG5ldyBTaGFyZWRJbnRlcnZhbENvbGxlY3Rpb25GYWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX29wcyA9IG5ldyBNYXAoW1tcbiAgICAgICAgICAgICAgICBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZTogKHZhbHVlLCBwYXJhbXMsIGxvY2FsLCBvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgb3BzIHdlcmUgYXBwbGllZCB3aGVuIHRoZSBtZXNzYWdlIHdhcyBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUucHJlcGFyZUFkZEludGVybmFsKHBhcmFtcywgbG9jYWwsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzczogKHZhbHVlLCBwYXJhbXMsIGNvbnRleHQsIGxvY2FsLCBvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgb3BzIHdlcmUgYXBwbGllZCB3aGVuIHRoZSBtZXNzYWdlIHdhcyBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGRJbnRlcm5hbChwYXJhbXMsIGNvbnRleHQsIGxvY2FsLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF1dKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBTaGFyZWRJbnRlcnZhbENvbGxlY3Rpb25WYWx1ZVR5cGUuTmFtZTtcbiAgICB9XG4gICAgZ2V0IGZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3J5O1xuICAgIH1cbiAgICBnZXQgb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3BzO1xuICAgIH1cbn1cblNoYXJlZEludGVydmFsQ29sbGVjdGlvblZhbHVlVHlwZS5OYW1lID0gXCJzaGFyZWRJbnRlcnZhbENvbGxlY3Rpb25cIjtcbmV4cG9ydCBjbGFzcyBTaGFyZWRJbnRlcnZhbENvbGxlY3Rpb25WaWV3IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHNhdmVkU2VyaWFsaXplZEludGVydmFscywgbGFiZWwsIGhlbHBlcnMsIGVtaXR0ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuYXR0YWNoaW5nUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAvLyBJbnN0YW50aWF0ZSB0aGUgbG9jYWwgaW50ZXJ2YWwgY29sbGVjdGlvbiBiYXNlZCBvbiB0aGUgc2F2ZWQgaW50ZXJ2YWxzXG4gICAgICAgIHRoaXMubG9jYWxDb2xsZWN0aW9uID0gbmV3IExvY2FsSW50ZXJ2YWxDb2xsZWN0aW9uKGNsaWVudCwgbGFiZWwsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoc2F2ZWRTZXJpYWxpemVkSW50ZXJ2YWxzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlcmlhbGl6ZWRJbnRlcnZhbCBvZiBzYXZlZFNlcmlhbGl6ZWRJbnRlcnZhbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsQ29sbGVjdGlvbi5hZGRJbnRlcnZhbChzZXJpYWxpemVkSW50ZXJ2YWwuc3RhcnQsIHNlcmlhbGl6ZWRJbnRlcnZhbC5lbmQsIHNlcmlhbGl6ZWRJbnRlcnZhbC5pbnRlcnZhbFR5cGUsIHNlcmlhbGl6ZWRJbnRlcnZhbC5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hEZXNlcmlhbGl6ZXIob25EZXNlcmlhbGl6ZSwgb25QcmVwYXJlRGVzZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoaW5nUCA9IHRoaXMuYXR0YWNoRGVzZXJpYWxpemVyQ29yZShvbkRlc2VyaWFsaXplLCBvblByZXBhcmVEZXNlcmlhbGl6ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hpbmdQO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluZE92ZXJsYXBwaW5nSW50ZXJ2YWxzKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsQ29sbGVjdGlvbi5maW5kT3ZlcmxhcHBpbmdJbnRlcnZhbHMoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgIH1cbiAgICBtYXAoZm4pIHtcbiAgICAgICAgdGhpcy5sb2NhbENvbGxlY3Rpb24ubWFwKGZuKTtcbiAgICB9XG4gICAgcHJldmlvdXNJbnRlcnZhbChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxDb2xsZWN0aW9uLnByZXZpb3VzSW50ZXJ2YWwocG9zKTtcbiAgICB9XG4gICAgbmV4dEludGVydmFsKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbENvbGxlY3Rpb24ubmV4dEludGVydmFsKHBvcyk7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVubmVjZXNzYXJ5LW92ZXJyaWRlICovXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBhZGQoc3RhcnQsIGVuZCwgaW50ZXJ2YWxUeXBlLCBwcm9wcykge1xuICAgICAgICBsZXQgc2VxID0gMDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50KSB7XG4gICAgICAgICAgICBzZXEgPSB0aGlzLmNsaWVudC5nZXRDdXJyZW50U2VxKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEludGVydmFsID0ge1xuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgaW50ZXJ2YWxUeXBlLFxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcHMsXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogc2VxLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSW50ZXJuYWwoc2VyaWFsaXplZEludGVydmFsLCBudWxsLCB0cnVlLCBudWxsKTtcbiAgICB9XG4gICAgLy8gVE9ETzogZXJyb3IgY2FzZXNcbiAgICBhZGRJbnRlcm5hbChzZXJpYWxpemVkSW50ZXJ2YWwsIGNvbnRleHQsIGxvY2FsLCBvcCkge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMubG9jYWxDb2xsZWN0aW9uLmFkZEludGVydmFsKHNlcmlhbGl6ZWRJbnRlcnZhbC5zdGFydCwgc2VyaWFsaXplZEludGVydmFsLmVuZCwgc2VyaWFsaXplZEludGVydmFsLmludGVydmFsVHlwZSwgc2VyaWFsaXplZEludGVydmFsLnByb3BlcnRpZXMpO1xuICAgICAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIC8vIExvY2FsIG9wcyBnZXQgc3VibWl0dGVkIHRvIHRoZSBzZXJ2ZXIuIFJlbW90ZSBvcHMgaGF2ZSB0aGUgZGVzZXJpYWxpemVyIHJ1bi5cbiAgICAgICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwiYWRkXCIsIHNlcmlhbGl6ZWRJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkRlc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EZXNlcmlhbGl6ZShpbnRlcnZhbCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImFkZEludGVydmFsXCIsIGludGVydmFsLCBsb2NhbCwgb3ApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJlcGFyZUFkZChpbnRlcnZhbCwgbG9jYWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYXR0YWNoaW5nUDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUHJlcGFyZURlc2VyaWFsaXplID8gdGhpcy5vblByZXBhcmVEZXNlcmlhbGl6ZShpbnRlcnZhbC5wcm9wZXJ0aWVzKSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXJpYWxpemVJbnRlcm5hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxDb2xsZWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICBhdHRhY2hEZXNlcmlhbGl6ZXJDb3JlKG9uRGVzZXJpYWxpemUsIG9uUHJlcGFyZURlc2VyaWFsaXplKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBkZXNlcmlhbGl6ZXIgaXMgc3BlY2lmaWVkIGNhbiBza2lwIGFsbCBwcm9jZXNzaW5nIHdvcmtcbiAgICAgICAgICAgIGlmICghb25EZXNlcmlhbGl6ZSAmJiAhb25QcmVwYXJlRGVzZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBieSBzdG9yaW5nIHRoZSBjYWxsYmFja3Mgc28gdGhhdCBhbnkgc3Vic2VxdWVudCBtb2RpZmljYXRpb25zIG1ha2UgdXNlIG9mIHRoZW1cbiAgICAgICAgICAgIHRoaXMub25EZXNlcmlhbGl6ZSA9IG9uRGVzZXJpYWxpemU7XG4gICAgICAgICAgICB0aGlzLm9uUHJlcGFyZURlc2VyaWFsaXplID0gb25QcmVwYXJlRGVzZXJpYWxpemU7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBhc3luYyBwcmVwYXJlIHdvcmsgYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkSW50ZXJ2YWxzUCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5sb2NhbENvbGxlY3Rpb24ubWFwKChpbnRlcnZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkSW50ZXJ2YWxQID0gb25QcmVwYXJlRGVzZXJpYWxpemUoaW50ZXJ2YWwucHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNvbnRleHQpID0+ICh7IGNvbnRleHQsIGludGVydmFsIH0pKTtcbiAgICAgICAgICAgICAgICBwcmVwYXJlZEludGVydmFsc1AucHVzaChwcmVwYXJlZEludGVydmFsUCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkSW50ZXJ2YWxzID0geWllbGQgUHJvbWlzZS5hbGwocHJlcGFyZWRJbnRlcnZhbHNQKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlcGFyZWRJbnRlcnZhbCBvZiBwcmVwYXJlZEludGVydmFscykge1xuICAgICAgICAgICAgICAgIHRoaXMub25EZXNlcmlhbGl6ZShwcmVwYXJlZEludGVydmFsLmludGVydmFsLCBwcmVwYXJlZEludGVydmFsLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoZWxwZXJzLCByZXF1aXJlc0NsaWVudCwgZW1pdHRlciwgc2VyaWFsaXplZEludGVydmFscykge1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzO1xuICAgICAgICB0aGlzLnJlcXVpcmVzQ2xpZW50ID0gcmVxdWlyZXNDbGllbnQ7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuc2F2ZWRTZXJpYWxpemVkSW50ZXJ2YWxzID0gc2VyaWFsaXplZEludGVydmFscztcbiAgICB9XG4gICAgZ2V0IGF0dGFjaGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZpZXc7XG4gICAgfVxuICAgIGF0dGFjaChjbGllbnQsIGxhYmVsKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgc3VwcG9ydHMgb25lIFNoYXJlZFN0cmluZyBhdHRhY2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjbGllbnQgPT09IHVuZGVmaW5lZCkgJiYgKHRoaXMucmVxdWlyZXNDbGllbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgcmVxdWlyZWQgZm9yIHRoaXMgY29sbGVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uVmlldyhjbGllbnQsIHRoaXMuc2F2ZWRTZXJpYWxpemVkSW50ZXJ2YWxzLCBsYWJlbCwgdGhpcy5oZWxwZXJzLCB0aGlzLmVtaXR0ZXIpO1xuICAgICAgICB0aGlzLnNhdmVkU2VyaWFsaXplZEludGVydmFscyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYWRkKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBpbnRlcnZhbFR5cGUsIHByb3BzKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJhdHRhY2ggbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gYWRkaW5nIGludGVydmFsc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcuYWRkKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBpbnRlcnZhbFR5cGUsIHByb3BzKTtcbiAgICB9XG4gICAgZ2V0VmlldyhvbkRlc2VyaWFsaXplLCBvblByZXBhcmVEZXNlcmlhbGl6ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJhdHRhY2hTaGFyZWRTdHJpbmcgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gcmV0cmlldmluZyB0aGUgdmlld1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0dGFjaCBjdXN0b20gZGVzZXJpYWxpemVycyBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChvbkRlc2VyaWFsaXplIHx8IG9uUHJlcGFyZURlc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy52aWV3LmF0dGFjaERlc2VyaWFsaXplcihvbkRlc2VyaWFsaXplLCBvblByZXBhcmVEZXNlcmlhbGl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlcGFyZUFkZEludGVybmFsKGludGVydmFsLCBsb2NhbCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiYXR0YWNoU2hhcmVkU3RyaW5nIG11c3QgYmUgY2FsbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcucHJlcGFyZUFkZChpbnRlcnZhbCwgbG9jYWwsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBhZGRJbnRlcm5hbChzZXJpYWxpemVkSW50ZXJ2YWwsIGNvbnRleHQsIGxvY2FsLCBvcCkge1xuICAgICAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0YWNoU2hhcmVkU3RyaW5nIG11c3QgYmUgY2FsbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuYWRkSW50ZXJuYWwoc2VyaWFsaXplZEludGVydmFsLCBjb250ZXh0LCBsb2NhbCwgb3ApO1xuICAgIH1cbiAgICBzZXJpYWxpemVJbnRlcm5hbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGFjaFNoYXJlZFN0cmluZyBtdXN0IGJlIGNhbGxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnNlcmlhbGl6ZUludGVybmFsKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJ2YWxDb2xsZWN0aW9uLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLy8gdHNsaW50OmRpc2FibGU6d2hpdGVzcGFjZSBhbGlnbiBuby1iaXR3aXNlXG5pbXBvcnQgeyBGaWxlTW9kZSwgVHJlZUVudHJ5LCB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuaW1wb3J0IHsgTWFwRXh0ZW5zaW9uLCBTaGFyZWRNYXAsIH0gZnJvbSBcIkBwcmFndWUvbWFwXCI7XG5pbXBvcnQgKiBhcyBNZXJnZVRyZWUgZnJvbSBcIkBwcmFndWUvbWVyZ2UtdHJlZVwiO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tIFwiQHByYWd1ZS91dGlsc1wiO1xuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdWJtb2R1bGUtaW1wb3J0cyBuby12YXItcmVxdWlyZXMgbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCBjbG9uZURlZXAgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdWJtb2R1bGUtaW1wb3J0c1xuaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZC92NFwiO1xuaW1wb3J0IHsgU2hhcmVkTnVtYmVyU2VxdWVuY2VFeHRlbnNpb24sIFNoYXJlZE9iamVjdFNlcXVlbmNlRXh0ZW5zaW9uLCB9IGZyb20gXCIuL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgU2hhcmVkU3RyaW5nSW50ZXJ2YWxDb2xsZWN0aW9uVmFsdWVUeXBlLCB9IGZyb20gXCIuL2ludGVydmFsQ29sbGVjdGlvblwiO1xuaW1wb3J0IHsgU2VxdWVuY2VEZWx0YUV2ZW50IH0gZnJvbSBcIi4vc2VxdWVuY2VEZWx0YUV2ZW50XCI7XG5leHBvcnQgY2xhc3MgU2VnbWVudFNlcXVlbmNlIGV4dGVuZHMgU2hhcmVkTWFwIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgaWQsIGV4dGVuc2lvblR5cGUsIHNlcnZpY2VzKSB7XG4gICAgICAgIHN1cGVyKGlkLCBkb2N1bWVudCwgZXh0ZW5zaW9uVHlwZSk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbGxhYlN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWluU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgICAvLyBEZWZlcnJlZCB0aGF0IHRyaWdnZXJzIG9uY2UgdGhlIG9iamVjdCBpcyBsb2FkZWRcbiAgICAgICAgdGhpcy5sb2FkZWREZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2luY2VNU05DaGFuZ2UgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyBNZXJnZVRyZWUuQ2xpZW50KFwiXCIsIGRvY3VtZW50Lm9wdGlvbnMpO1xuICAgICAgICBzdXBlci5vbihcIm5ld0xpc3RlbmVyXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZXF1ZW5jZURlbHRhXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnQubWVyZ2VUcmVlLm1lcmdlVHJlZURlbHRhQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5tZXJnZVRyZWVEZWx0YUNhbGxiYWNrID0gKG9wQXJncywgZGVsdGFBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwic2VxdWVuY2VEZWx0YVwiLCB0aGlzLCBuZXcgU2VxdWVuY2VEZWx0YUV2ZW50KG9wQXJncywgdGhpcy5jbGllbnQsIGRlbHRhQXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3VwZXIub24oXCJyZW1vdmVMaXN0ZW5lclwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2VxdWVuY2VEZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwZXIubGlzdGVuZXJDb3VudChldmVudCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5tZXJnZVRyZWVEZWx0YUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZWREZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW5uZWNlc3Nhcnktb3ZlcnJpZGVcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZVJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHBvczE6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zMjogZW5kLFxuICAgICAgICAgICAgdHlwZTogMSAvKiBSRU1PVkUgKi8sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50LnJlbW92ZVNlZ21lbnRMb2NhbChzdGFydCwgZW5kLCB7IG9wOiByZW1vdmVNZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQocmVtb3ZlTWVzc2FnZSk7XG4gICAgfVxuICAgIGN1dChyZWdpc3Rlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCByZW1vdmVNZXNzYWdlID0ge1xuICAgICAgICAgICAgcG9zMTogc3RhcnQsXG4gICAgICAgICAgICBwb3MyOiBlbmQsXG4gICAgICAgICAgICByZWdpc3RlcixcbiAgICAgICAgICAgIHR5cGU6IDEgLyogUkVNT1ZFICovLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsaWVudC5jb3B5KHN0YXJ0LCBlbmQsIHJlZ2lzdGVyLCB0aGlzLmNsaWVudC5nZXRDdXJyZW50U2VxKCksIHRoaXMuY2xpZW50LmdldENsaWVudElkKCksIHRoaXMuY2xpZW50LmxvbmdDbGllbnRJZCk7XG4gICAgICAgIHRoaXMuY2xpZW50LnJlbW92ZVNlZ21lbnRMb2NhbChzdGFydCwgZW5kLCB7IG9wOiByZW1vdmVNZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQocmVtb3ZlTWVzc2FnZSk7XG4gICAgfVxuICAgIHBhc3RlKHJlZ2lzdGVyLCBwb3MpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHBvczE6IHBvcyxcbiAgICAgICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICAgICAgdHlwZTogMCAvKiBJTlNFUlQgKi8sXG4gICAgICAgIH07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1wYXJhbWV0ZXItcmVhc3NpZ25tZW50XG4gICAgICAgIHBvcyA9IHRoaXMuY2xpZW50LnBhc3RlTG9jYWwocmVnaXN0ZXIsIHBvcywgeyBvcDogaW5zZXJ0TWVzc2FnZSB9KTtcbiAgICAgICAgdGhpcy5zdWJtaXRJZkF0dGFjaGVkKGluc2VydE1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBjb3B5KHJlZ2lzdGVyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGluc2VydE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBwb3MxOiBzdGFydCxcbiAgICAgICAgICAgIHBvczI6IGVuZCxcbiAgICAgICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICAgICAgdHlwZTogMCAvKiBJTlNFUlQgKi8sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50LmNvcHkoc3RhcnQsIGVuZCwgcmVnaXN0ZXIsIHRoaXMuY2xpZW50LmdldEN1cnJlbnRTZXEoKSwgdGhpcy5jbGllbnQuZ2V0Q2xpZW50SWQoKSwgdGhpcy5jbGllbnQubG9uZ0NsaWVudElkKTtcbiAgICAgICAgdGhpcy5zdWJtaXRJZkF0dGFjaGVkKGluc2VydE1lc3NhZ2UpO1xuICAgIH1cbiAgICBncm91cE9wZXJhdGlvbihncm91cE9wKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRHcm91cCA9IHRoaXMuY2xpZW50LmxvY2FsVHJhbnNhY3Rpb24oZ3JvdXBPcCk7XG4gICAgICAgIHRoaXMuc3VibWl0SWZBdHRhY2hlZChncm91cE9wKTtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRHcm91cDtcbiAgICB9XG4gICAgYW5ub3RhdGVSYW5nZShwcm9wcywgc3RhcnQsIGVuZCwgb3ApIHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGVNZXNzYWdlID0ge1xuICAgICAgICAgICAgcG9zMTogc3RhcnQsXG4gICAgICAgICAgICBwb3MyOiBlbmQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQU5OT1RBVEUgKi8sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgYW5ub3RhdGVNZXNzYWdlLmNvbWJpbmluZ09wID0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQuYW5ub3RhdGVTZWdtZW50TG9jYWwocHJvcHMsIHN0YXJ0LCBlbmQsIG9wLCB7IG9wOiBhbm5vdGF0ZU1lc3NhZ2UgfSk7XG4gICAgICAgIHRoaXMuc3VibWl0SWZBdHRhY2hlZChhbm5vdGF0ZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZXRQcm9wZXJ0aWVzQXRQb3NpdGlvbihwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldFByb3BlcnRpZXNBdFBvc2l0aW9uKHBvcyk7XG4gICAgfVxuICAgIGdldFJhbmdlRXh0ZW50c09mUG9zaXRpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5nZXRSYW5nZUV4dGVudHNPZlBvc2l0aW9uKHBvcyk7XG4gICAgfVxuICAgIHNldExvY2FsTWluU2VxKGxtc2VxKSB7XG4gICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS51cGRhdGVMb2NhbE1pblNlcShsbXNlcSk7XG4gICAgfVxuICAgIGNyZWF0ZVBvc2l0aW9uUmVmZXJlbmNlKHBvcywgcmVmVHlwZSwgcmVmU2VxID0gdGhpcy5jbGllbnQuZ2V0Q3VycmVudFNlcSgpLCBjbGllbnRJZCA9IHRoaXMuY2xpZW50LmdldENsaWVudElkKCkpIHtcbiAgICAgICAgY29uc3Qgc2Vnb2ZmID0gdGhpcy5jbGllbnQubWVyZ2VUcmVlLmdldENvbnRhaW5pbmdTZWdtZW50KHBvcywgcmVmU2VxLCB0aGlzLmNsaWVudC5nZXRDbGllbnRJZCgpKTtcbiAgICAgICAgaWYgKHNlZ29mZiAmJiBzZWdvZmYuc2VnbWVudCkge1xuICAgICAgICAgICAgY29uc3QgbHJlZiA9IG5ldyBNZXJnZVRyZWUuTG9jYWxSZWZlcmVuY2Uoc2Vnb2ZmLnNlZ21lbnQsIHNlZ29mZi5vZmZzZXQsIHJlZlR5cGUpO1xuICAgICAgICAgICAgaWYgKHJlZlR5cGUgIT09IE1lcmdlVHJlZS5SZWZlcmVuY2VUeXBlLlRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5hZGRMb2NhbFJlZmVyZW5jZShscmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBscmVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsUmVmVG9Qb3MobG9jYWxSZWYpIHtcbiAgICAgICAgaWYgKGxvY2FsUmVmLnNlZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFJlZi5vZmZzZXQgKyB0aGlzLmNsaWVudC5tZXJnZVRyZWUuZ2V0T2Zmc2V0KGxvY2FsUmVmLnNlZ21lbnQsIHRoaXMuY2xpZW50LmdldEN1cnJlbnRTZXEoKSwgdGhpcy5jbGllbnQuZ2V0Q2xpZW50SWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW50ZXJ2YWxDb2xsZWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWxDb2xsZWN0aW9ucztcbiAgICB9XG4gICAgLy8gVE9ETzogZml4IHJhY2UgY29uZGl0aW9uIG9uIGNyZWF0aW9uIGJ5IHB1dHRpbmcgdHlwZSBvbiBldmVyeSBvcGVyYXRpb25cbiAgICBnZXRTaGFyZWRJbnRlcnZhbENvbGxlY3Rpb24obGFiZWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVydmFsQ29sbGVjdGlvbnMuaGFzKGxhYmVsKSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbENvbGxlY3Rpb25zLnNldChsYWJlbCwgdW5kZWZpbmVkLCBTaGFyZWRTdHJpbmdJbnRlcnZhbENvbGxlY3Rpb25WYWx1ZVR5cGUuTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcmVkQ29sbGVjdGlvbiA9IHRoaXMuaW50ZXJ2YWxDb2xsZWN0aW9ucy5nZXQobGFiZWwpO1xuICAgICAgICByZXR1cm4gc2hhcmVkQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgc2VuZE5BQ0tlZCgpIHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZFNlZ21lbnRzID0gW107XG4gICAgICAgIHdoaWxlICghdGhpcy5jbGllbnQubWVyZ2VUcmVlLnBlbmRpbmdTZWdtZW50cy5lbXB0eSgpKSB7XG4gICAgICAgICAgICBjb25zdCBOQUNLZWRTZWdtZW50R3JvdXAgPSB0aGlzLmNsaWVudC5tZXJnZVRyZWUucGVuZGluZ1NlZ21lbnRzLmRlcXVldWUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBOQUNLZWRTZWdtZW50R3JvdXAuc2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkU2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcmRlcmVkU2VnbWVudHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEub3JkaW5hbCA8IGIub3JkaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tb2JqZWN0LWxpdGVyYWwtdHlwZS1hc3NlcnRpb24gKi9cbiAgICAgICAgY29uc3Qgc2VnbWVudEdyb3VwID0ge1xuICAgICAgICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcExpc3QgPSBbXTtcbiAgICAgICAgbGV0IHByZXZTZWc7XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBvcmRlcmVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChwcmV2U2VnICE9PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5zZWdtZW50R3JvdXBzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5zZWdtZW50R3JvdXBzLmVucXVldWUoc2VnbWVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5zZWdtZW50VG9PcHMoc2VnbWVudCwgb3BMaXN0KTtcbiAgICAgICAgICAgICAgICBwcmV2U2VnID0gc2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cE9wID0ge1xuICAgICAgICAgICAgb3BzOiBvcExpc3QsXG4gICAgICAgICAgICB0eXBlOiAzIC8qIEdST1VQICovLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZ3JvdXBPcC5vcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQubWVyZ2VUcmVlLnBlbmRpbmdTZWdtZW50cy5lbnF1ZXVlKHNlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQoZ3JvdXBPcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZENvbnRlbnQobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXJPcmlnaW4sIHN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHlpZWxkIHN0b3JhZ2UucmVhZChcImhlYWRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemUobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXIsIHRydWUsIGhlYWRlck9yaWdpbiwgc3RvcmFnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplQ29udGVudCgpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxDb2xsZWN0aW9ucyA9IHRoaXMucnVudGltZS5jcmVhdGVDaGFubmVsKHV1aWQoKSwgTWFwRXh0ZW5zaW9uLlR5cGUpO1xuICAgICAgICB0aGlzLnNldChcImludGVydmFsQ29sbGVjdGlvbnNcIiwgaW50ZXJ2YWxDb2xsZWN0aW9ucyk7XG4gICAgICAgIC8vIFRPRE8gd2lsbCB3YW50IHRvIHVwZGF0ZSBpbml0aWFsaXplIHRvIG9wZXJhdGUgc3luY2hyb25vdXNseVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoMCwgbnVsbCwgZmFsc2UsIHRoaXMuaWQsIG51bGwpXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiaW5pdGlhbGl6ZUNvbnRlbnRcIiwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc25hcHNob3RDb250ZW50KCkge1xuICAgICAgICAvLyBkZWJ1ZyhgVHJhbnNmb3JtaW5nIHVwIHRvICR7dGhpcy5kZWx0YU1hbmFnZXIubWluaW11bVNlcXVlbmNlTnVtYmVyfWApO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZE1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB0aGlzLm1lc3NhZ2VzU2luY2VNU05DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZXMucHVzaCh0aGlzLnRyYW5zZm9ybShtZXNzYWdlLCB0aGlzLnJ1bnRpbWUuZGVsdGFNYW5hZ2VyLm1pbmltdW1TZXF1ZW5jZU51bWJlcikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5jb21taXRHbG9iYWxNaW4oKTtcbiAgICAgICAgY29uc3Qgc25hcCA9IG5ldyBNZXJnZVRyZWUuU25hcHNob3QodGhpcy5jbGllbnQubWVyZ2VUcmVlKTtcbiAgICAgICAgc25hcC5leHRyYWN0U3luYygpO1xuICAgICAgICBjb25zdCBtdFNuYXAgPSBzbmFwLmVtaXQoKTtcbiAgICAgICAgbXRTbmFwLmVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICBtb2RlOiBGaWxlTW9kZS5GaWxlLFxuICAgICAgICAgICAgcGF0aDogXCJ0YXJkaXNcIixcbiAgICAgICAgICAgIHR5cGU6IFRyZWVFbnRyeVtUcmVlRW50cnkuQmxvYl0sXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZE1lc3NhZ2VzKSxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtdFNuYXA7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlOnByb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbiAgICBwcmVwYXJlQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkRGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgcHJvY2Vzc0NvbnRlbnQobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzU2luY2VNU05DaGFuZ2UucHVzaChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgcHJvY2Vzc01pblNlcXVlbmNlTnVtYmVyQ2hhbmdlZENvbnRlbnQodmFsdWUpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yICg7IGluZGV4IDwgdGhpcy5tZXNzYWdlc1NpbmNlTVNOQ2hhbmdlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVzc2FnZXNTaW5jZU1TTkNoYW5nZVtpbmRleF0uc2VxdWVuY2VOdW1iZXIgPiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1NpbmNlTVNOQ2hhbmdlID0gdGhpcy5tZXNzYWdlc1NpbmNlTVNOQ2hhbmdlLnNsaWNlKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBkaXJlY3RseSBvbmNlIGxvYWRlZCAtIG90aGVyd2lzZSB0cmFjayBzbyB3ZSBjYW4gdXBkYXRlIGxhdGVyXG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC51cGRhdGVNaW5TZXEodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWluU2VxdWVuY2VOdW1iZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hDb250ZW50KCkge1xuICAgICAgICB0aGlzLmNsaWVudC5zdGFydENvbGxhYm9yYXRpb24odGhpcy5ydW50aW1lLmNsaWVudElkLCAwKTtcbiAgICAgICAgdGhpcy5jb2xsYWJTdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgb25Db25uZWN0Q29udGVudChwZW5kaW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBtZXJnZSB0cmVlIGNvbGxhYm9yYXRpb24gaW5mb3JtYXRpb24gd2l0aCBuZXcgY2xpZW50IElEIGFuZCB0aGVuIHJlc2VuZCBwZW5kaW5nIG9wc1xuICAgICAgICBpZiAodGhpcy5jb2xsYWJTdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC51cGRhdGVDb2xsYWJvcmF0aW9uKHRoaXMucnVudGltZS5jbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kTkFDS2VkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVhZHlDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZWQ7XG4gICAgfVxuICAgIHN1Ym1pdElmQXR0YWNoZWQobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1Ym1pdExvY2FsTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgcHJvY2Vzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmNsaWVudC5hcHBseU1zZyhtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5taW5TZXFQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5tZXJnZVRyZWUubm90aWZ5TWluU2VxTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKG9yaWdpbmFsTWVzc2FnZSwgc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgICAgIC8vIEFsbG93IHRoZSBkaXN0cmlidXRlZCBkYXRhIHR5cGVzIHRvIHBlcmZvcm0gY3VzdG9tIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBpZiAobWVzc2FnZS5yZWZlcmVuY2VTZXF1ZW5jZU51bWJlciA8IHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgY29weSBvZiBvcmlnaW5hbCBtZXNzYWdlIHNpbmNlIHdlIHdpbGwgYmUgbW9kaWZ5aW5nIGluIHBsYWNlXG4gICAgICAgICAgICBtZXNzYWdlID0gY2xvbmVEZWVwKG1lc3NhZ2UpO1xuICAgICAgICAgICAgbWVzc2FnZS5jb250ZW50cyA9IHRoaXMuY2xpZW50LnRyYW5zZm9ybShtZXNzYWdlLmNvbnRlbnRzLCBtZXNzYWdlLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyLCBzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICBtZXNzYWdlLnJlZmVyZW5jZVNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGxvYWRIZWFkZXIobWluaW11bVNlcXVlbmNlTnVtYmVyLCBoZWFkZXIsIHNoYXJlZCwgb3JpZ2luQnJhbmNoKSB7XG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSBNZXJnZVRyZWUuU25hcHNob3QucHJvY2Vzc0NodW5rKGhlYWRlcik7XG4gICAgICAgIGNvbnN0IHNlZ3MgPSB0aGlzLnNlZ21lbnRzRnJvbVNwZWNzKGNodW5rLnNlZ21lbnRUZXh0cyk7XG4gICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5yZWxvYWRGcm9tU2VnbWVudHMoc2Vncyk7XG4gICAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gY3VycmVudGx5IG9ubHkgYXNzdW1lcyB0d28gbGV2ZWxzIG9mIGJyYW5jaGluZ1xuICAgICAgICAgICAgY29uc3QgYnJhbmNoSWQgPSBvcmlnaW5CcmFuY2ggPT09IHRoaXMucnVudGltZS5kb2N1bWVudElkID8gMCA6IDE7XG4gICAgICAgICAgICB0aGlzLmNvbGxhYlN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuc3RhcnRDb2xsYWJvcmF0aW9uKHRoaXMucnVudGltZS5jbGllbnRJZCwgbWluaW11bVNlcXVlbmNlTnVtYmVyLCBicmFuY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZEJvZHkoaGVhZGVyLCBvcmlnaW5CcmFuY2gsIHNlcnZpY2VzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBJZiBsb2FkaW5nIGZyb20gYSBzbmFwc2hvdCBsb2FkIGluIHRoZSBib2R5IGFuZCB0YXJkaXMgbWVzc2FnZXNcbiAgICAgICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2h1bmssIHJhd01lc3NhZ2VzXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgTWVyZ2VUcmVlLlNuYXBzaG90LmxvYWRDaHVuayhzZXJ2aWNlcywgXCJib2R5XCIpLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlcy5yZWFkKFwidGFyZGlzXCIpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnU3BlYyBvZiBjaHVuay5zZWdtZW50VGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KHNlZ1NwZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IEpTT04ucGFyc2UoQnVmZmVyLmZyb20ocmF3TWVzc2FnZXMsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5CcmFuY2ggIT09IHRoaXMucnVudGltZS5kb2N1bWVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGJyYW5jaCBpbmZvcm1hdGlvbiB3aGVuIHRyYW5zZm9ybWluZyBmb3IgdGhlIGNhc2Ugb2YgbWVzc2FnZXMgc3Rhc2hlZCB3aXRoIHRoZSBzbmFwc2hvdFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG9yaWdpbkJyYW5jaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtU2VxdWVuY2VOdW1iZXI6IG1lc3NhZ2UubWluaW11bVNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiBtZXNzYWdlLnNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBhbGwgcGVuZGluZyBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuZCBpbml0aWFsaXplIHRoZSBpbnRlcnZhbCBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplSW50ZXJ2YWxDb2xsZWN0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIGhlYWRlciwgc2hhcmVkLCBvcmlnaW5CcmFuY2gsIHNlcnZpY2VzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChtaW5pbXVtU2VxdWVuY2VOdW1iZXIsIE1lcmdlVHJlZS5TbmFwc2hvdC5FbXB0eUNodW5rLmNodW5rU2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2FkSGVhZGVyKG1pbmltdW1TZXF1ZW5jZU51bWJlciwgaGVhZGVyLCBzaGFyZWQsIG9yaWdpbkJyYW5jaCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRCb2R5KGhlYWRlciwgb3JpZ2luQnJhbmNoLCBzZXJ2aWNlcylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkRmluaXNoZWQoKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEZpbmlzaGVkKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUludGVydmFsQ29sbGVjdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxDb2xsZWN0aW9ucyA9IHRoaXMuZ2V0KFwiaW50ZXJ2YWxDb2xsZWN0aW9uc1wiKTtcbiAgICAgICAgLy8gTGlzdGVuIGFuZCBpbml0aWFsaXplIG5ldyBTaGFyZWRJbnRlcnZhbENvbGxlY3Rpb25zXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxDb2xsZWN0aW9ucy5vbihcInZhbHVlQ2hhbmdlZFwiLCAoZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsQ29sbGVjdGlvbiA9IHRoaXMuaW50ZXJ2YWxDb2xsZWN0aW9ucy5nZXQoZXYua2V5KTtcbiAgICAgICAgICAgIGlmICghaW50ZXJ2YWxDb2xsZWN0aW9uLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxDb2xsZWN0aW9uLmF0dGFjaCh0aGlzLmNsaWVudCwgZXYua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZXhpc3RpbmcgU2hhcmVkSW50ZXJ2YWxDb2xsZWN0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmludGVydmFsQ29sbGVjdGlvbnMua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbENvbGxlY3Rpb24gPSB0aGlzLmludGVydmFsQ29sbGVjdGlvbnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpbnRlcnZhbENvbGxlY3Rpb24uYXR0YWNoKHRoaXMuY2xpZW50LCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWRGaW5pc2hlZChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkRGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWREZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIE1TTiBpZiBsYXJnZXIgdGhhbiB0aGUgc2V0IHZhbHVlXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWluU2VxdWVuY2VOdW1iZXIgPiB0aGlzLmNsaWVudC5tZXJnZVRyZWUuZ2V0Q29sbGFiV2luZG93KCkubWluU2VxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQudXBkYXRlTWluU2VxKHRoaXMucGVuZGluZ01pblNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaGFyZWRTZXF1ZW5jZSBleHRlbmRzIFNlZ21lbnRTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIGlkLCBleHRlbnNpb25UeXBlLCBzZXJ2aWNlcykge1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgaWQsIGV4dGVuc2lvblR5cGUsIHNlcnZpY2VzKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uVHlwZSA9PT0gU2hhcmVkTnVtYmVyU2VxdWVuY2VFeHRlbnNpb24uVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5pc051bWVyaWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZFNlZ21lbnQoc2VnU3BlYykge1xuICAgICAgICBjb25zdCBtZXJnZVRyZWUgPSB0aGlzLmNsaWVudC5tZXJnZVRyZWU7XG4gICAgICAgIGNvbnN0IHBvcyA9IG1lcmdlVHJlZS5yb290LmNhY2hlZExlbmd0aDtcbiAgICAgICAgbWVyZ2VUcmVlLmluc2VydFNlZ21lbnQocG9zLCBNZXJnZVRyZWUuVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIG1lcmdlVHJlZS5jb2xsYWJXaW5kb3cuY2xpZW50SWQsIE1lcmdlVHJlZS5Vbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgTWVyZ2VUcmVlLnJ1blRvU2VnKHNlZ1NwZWMpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpbnNlcnQocG9zLCBpdGVtcywgcHJvcHMpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgcG9zMTogcG9zLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNOdW1lcmljKSB7XG4gICAgICAgICAgICBpbnNlcnRNZXNzYWdlLmlzTnVtYmVyU2VxdWVuY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgTWVyZ2VUcmVlLlN1YlNlcXVlbmNlKGl0ZW1zKTtcbiAgICAgICAgdGhpcy5jbGllbnQuaW5zZXJ0U2VnbWVudExvY2FsKHBvcywgc2VnbWVudCwgcHJvcHMsIHsgb3A6IGluc2VydE1lc3NhZ2UgfSk7XG4gICAgICAgIHRoaXMuc3VibWl0SWZBdHRhY2hlZChpbnNlcnRNZXNzYWdlKTtcbiAgICB9XG4gICAgcmVtb3ZlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZ2V0SXRlbUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubWVyZ2VUcmVlLmdldExlbmd0aCh0aGlzLmNsaWVudC5nZXRDdXJyZW50U2VxKCksIHRoaXMuY2xpZW50LmdldENsaWVudElkKCkpO1xuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTogbm8tcGFyYW1ldGVyLXJlYXNzaWdubWVudFxuICAgIGdldEl0ZW1zKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmdldEl0ZW1Db3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5tZXJnZVRyZWUuZ2V0SXRlbXModGhpcy5jbGllbnQuZ2V0Q3VycmVudFNlcSgpLCB0aGlzLmNsaWVudC5nZXRDbGllbnRJZCgpLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgc2VnbWVudHNGcm9tU3BlY3Moc2VnU3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHNlZ1NwZWNzLm1hcChNZXJnZVRyZWUucnVuVG9TZWcpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaGFyZWRPYmplY3RTZXF1ZW5jZSBleHRlbmRzIFNoYXJlZFNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgaWQsIHNlcnZpY2VzKSB7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBpZCwgU2hhcmVkT2JqZWN0U2VxdWVuY2VFeHRlbnNpb24uVHlwZSwgc2VydmljZXMpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIGdldFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbXMoc3RhcnQsIGVuZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNoYXJlZE51bWJlclNlcXVlbmNlIGV4dGVuZHMgU2hhcmVkU2VxdWVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBpZCwgc2VydmljZXMpIHtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIGlkLCBTaGFyZWROdW1iZXJTZXF1ZW5jZUV4dGVuc2lvbi5UeXBlLCBzZXJ2aWNlcyk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgZ2V0UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtcyhzdGFydCwgZW5kKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZW5jZS5qcy5tYXAiLCIvKipcbiAqIFRoZSBldmVudCBvYmplY3QgcmV0dXJuZWQgb24gc2VxdWVuY2VEZWx0YSBldmVudHMuXG4gKlxuICogVGhlIHByb3BlcnRpZXMgb2YgdGhpcyBvYmplY3QgYW5kIGl0J3Mgc3ViLW9iamVjdHMgcmVwcmVzZW50IGEgcG9pbnQgaW4gdGltZSBzdGF0ZVxuICogYXQgdGhlIHRpbWUgdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC4gVGhleSB3aWxsIG5vdCB0YWtlIGludG8gYW55IGZ1dHVyZSBtb2RpZmljYXRpb25zXG4gKiAgcGVyZm9ybWVkIHRvIHRoZSB1bmRseWluZyBzZXF1ZW5jZSBhbmQgbWVyZ2UgdHJlZS5cbiAqXG4gKiBGb3IgZ3JvdXAgb3BzLCBlYWNoIG9wIHdpbGwgZ2V0IGl0J3Mgb3duIGV2ZW50LCBhbmQgdGhlIGdyb3VwIG9wIHByb3BlcnR5IHdpbGwgYmUgc2V0IG9uIHRoZSBvcCBhcmdzLlxuICpcbiAqIE9wcyBtYXkgZ2V0IG11bHRpcGxlIGV2ZW50cy4gRm9yIGluc3RhbmNlLCBhcyBpbnNlcnQtcmVwbGFjZSB3aWxsIGdldCBhIHJlbW92ZSB0aGVuIGFuIGluc2VydCBldmVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlcXVlbmNlRGVsdGFFdmVudCB7XG4gICAgY29uc3RydWN0b3Iob3BBcmdzLCBtZXJnZVRyZWVDbGllbnQsIGRlbHRhQXJncykge1xuICAgICAgICB0aGlzLm9wQXJncyA9IG9wQXJncztcbiAgICAgICAgdGhpcy5tZXJnZVRyZWVDbGllbnQgPSBtZXJnZVRyZWVDbGllbnQ7XG4gICAgICAgIHRoaXMuZGVsdGFBcmdzID0gZGVsdGFBcmdzO1xuICAgICAgICB0aGlzLmlzTG9jYWwgPVxuICAgICAgICAgICAgdGhpcy5kZWx0YUFyZ3MubWVyZ2VUcmVlQ2xpZW50SWQgPT09XG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YUFyZ3MubWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZDtcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gZGVsdGFBcmdzLnNlZ21lbnRzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgdGhpcy5kZWx0YU9wZXJhdGlvbiA9IGRlbHRhQXJncy5vcGVyYXRpb247XG4gICAgICAgIHRoaXMuc29ydGVkUmFuZ2VzID0gbmV3IExhenkoKCkgPT4gdGhpcy5kZWx0YUFyZ3Muc2VnbWVudHMuc29ydCgoYSwgYikgPT4gYS5vcmRpbmFsIDwgYi5vcmRpbmFsID8gLTEgOiAoYS5vcmRpbmFsID4gYi5vcmRpbmFsID8gMSA6IDApKVxuICAgICAgICAgICAgLm1hcCgoc2VnbWVudCkgPT4gbmV3IExhenkoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmRlbHRhQXJncy5tZXJnZVRyZWUuZ2V0T2Zmc2V0KHNlZ21lbnQsIHRoaXMuZGVsdGFBcmdzLm1lcmdlVHJlZS5jb2xsYWJXaW5kb3cuY3VycmVudFNlcSwgdGhpcy5kZWx0YUFyZ3MubWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSkpO1xuICAgICAgICB0aGlzLnBTdGFydCA9IG5ldyBMYXp5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkUmFuZ2VzLnZhbHVlWzBdLnZhbHVlLnN0YXJ0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wRW5kID0gbmV3IExhenkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXN0UmFuZ2UgPSB0aGlzLnNvcnRlZFJhbmdlcy52YWx1ZVt0aGlzLnNvcnRlZFJhbmdlcy52YWx1ZS5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0UmFuZ2Uuc3RhcnQgKyBsYXN0UmFuZ2Uuc2VnbWVudC5jYWNoZWRMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBDbGllbnRJZCA9IG5ldyBMYXp5KCgpID0+IHRoaXMubWVyZ2VUcmVlQ2xpZW50LmdldExvbmdDbGllbnRJZCh0aGlzLmRlbHRhQXJncy5tZXJnZVRyZWVDbGllbnRJZCkpO1xuICAgICAgICB0aGlzLnBSYW5nZXMgPSBuZXcgTGF6eSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNlZ21lbnRzO1xuICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgbGV0IGxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0eXBlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHRoaXMuc29ydGVkUmFuZ2VzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0YXJ0ID0gc2VnbWVudC52YWx1ZS5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGVuZ3RoID0gc2VnbWVudC52YWx1ZS5zZWdtZW50LmNhY2hlZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHlwZSA9IHNlZ21lbnQudmFsdWUuc2VnbWVudC5nZXRUeXBlKCk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIC8vIGZvciByZW1vdmUgZG9uJ3QgYWRkIHRoZSBsZW5ndGgsIHNpbmNlIGdldE9mZnNldCB3b24ndCBpbmNsdWRlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsdGFBcmdzLm9wZXJhdGlvbiAhPT0gMSAvKiBSRU1PVkUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uICs9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IG5leHRUeXBlIHx8IGN1cnJlbnRQb3NpdGlvbiAhPT0gbmV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHB1c2ggaWYgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IFtzZWdtZW50LnZhbHVlLnNlZ21lbnRdO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbmV4dExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG5leHRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50LnZhbHVlLnNlZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gbmV4dExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBTdGFydC52YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucEVuZC52YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGNsaWVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wQ2xpZW50SWQudmFsdWU7XG4gICAgfVxuICAgIGdldCByYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBSYW5nZXMudmFsdWU7XG4gICAgfVxufVxuY2xhc3MgTGF6eSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVHZW5lcmF0b3IpIHtcbiAgICAgICAgdGhpcy52YWx1ZUdlbmVyYXRvciA9IHZhbHVlR2VuZXJhdG9yO1xuICAgICAgICB0aGlzLnBFdmFsdWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGV2YWx1YXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucEV2YWx1YXRlZDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICBpZiAoIXRoaXMucEV2YWx1YXRlZCkge1xuICAgICAgICAgICAgdGhpcy5wRXZhbHVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucFZhbHVlID0gdGhpcy52YWx1ZUdlbmVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBWYWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZW5jZURlbHRhRXZlbnQuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGU6d2hpdGVzcGFjZSBhbGlnbiBuby1iaXR3aXNlXG5pbXBvcnQgKiBhcyBNZXJnZVRyZWUgZnJvbSBcIkBwcmFndWUvbWVyZ2UtdHJlZVwiO1xuaW1wb3J0IHsgU2hhcmVkU3RyaW5nRXh0ZW5zaW9uLCB9IGZyb20gXCIuL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgU2VnbWVudFNlcXVlbmNlLCB9IGZyb20gXCIuL3NlcXVlbmNlXCI7XG5mdW5jdGlvbiB0ZXh0c1RvU2VnbWVudHModGV4dHMpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHRleHQgb2YgdGV4dHMpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQ7XG4gICAgICAgIGlmIChwdGV4dC50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBNZXJnZVRyZWUuVGV4dFNlZ21lbnQubWFrZShwdGV4dC50ZXh0LCBwdGV4dC5wcm9wcywgTWVyZ2VUcmVlLlVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCBNZXJnZVRyZWUuTG9jYWxDbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3Igbm93IGFzc3VtZSBtYXJrZXJcbiAgICAgICAgICAgIHNlZ21lbnQgPSBNZXJnZVRyZWUuTWFya2VyLm1ha2UocHRleHQubWFya2VyLnJlZlR5cGUsIHB0ZXh0LnByb3BzLCBNZXJnZVRyZWUuVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIE1lcmdlVHJlZS5Mb2NhbENsaWVudElkKTtcbiAgICAgICAgfVxuICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudHM7XG59XG5leHBvcnQgY2xhc3MgU2hhcmVkU3RyaW5nIGV4dGVuZHMgU2VnbWVudFNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgaWQsIHNlcnZpY2VzKSB7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBpZCwgU2hhcmVkU3RyaW5nRXh0ZW5zaW9uLlR5cGUsIHNlcnZpY2VzKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICBhcHBlbmRTZWdtZW50KHNlZ1NwZWMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VUcmVlID0gdGhpcy5jbGllbnQubWVyZ2VUcmVlO1xuICAgICAgICBjb25zdCBwb3MgPSBtZXJnZVRyZWUucm9vdC5jYWNoZWRMZW5ndGg7XG4gICAgICAgIGlmIChzZWdTcGVjLnRleHQpIHtcbiAgICAgICAgICAgIG1lcmdlVHJlZS5pbnNlcnRUZXh0KHBvcywgTWVyZ2VUcmVlLlVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCBtZXJnZVRyZWUuY29sbGFiV2luZG93LmNsaWVudElkLCBNZXJnZVRyZWUuVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIHNlZ1NwZWMudGV4dCwgc2VnU3BlYy5wcm9wcywgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFzc3VtZSBtYXJrZXIgZm9yIG5vd1xuICAgICAgICAgICAgbWVyZ2VUcmVlLmluc2VydE1hcmtlcihwb3MsIE1lcmdlVHJlZS5Vbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgbWVyZ2VUcmVlLmNvbGxhYldpbmRvdy5jbGllbnRJZCwgTWVyZ2VUcmVlLlVuaXZlcnNhbFNlcXVlbmNlTnVtYmVyLCBzZWdTcGVjLm1hcmtlci5yZWZUeXBlLCBzZWdTcGVjLnByb3BzLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlZ21lbnRzRnJvbVNwZWNzKHNlZ1NwZWNzKSB7XG4gICAgICAgIHJldHVybiB0ZXh0c1RvU2VnbWVudHMoc2VnU3BlY3MpO1xuICAgIH1cbiAgICBpbnNlcnRNYXJrZXJSZWxhdGl2ZShyZWxhdGl2ZVBvczEsIHJlZlR5cGUsIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IGluc2VydE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBtYXJrZXI6IHsgcmVmVHlwZSB9LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICByZWxhdGl2ZVBvczEsXG4gICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5jbGllbnQubWVyZ2VUcmVlLnBvc0Zyb21SZWxhdGl2ZVBvcyhyZWxhdGl2ZVBvczEpO1xuICAgICAgICB0aGlzLmNsaWVudC5pbnNlcnRNYXJrZXJMb2NhbChwb3MsIHJlZlR5cGUsIHByb3BzLCB7IG9wOiBpbnNlcnRNZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQoaW5zZXJ0TWVzc2FnZSk7XG4gICAgfVxuICAgIGluc2VydE1hcmtlcihwb3MsIHJlZlR5cGUsIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IGluc2VydE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBtYXJrZXI6IHsgcmVmVHlwZSB9LFxuICAgICAgICAgICAgcG9zMTogcG9zLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQuaW5zZXJ0TWFya2VyTG9jYWwocG9zLCByZWZUeXBlLCBwcm9wcywgeyBvcDogaW5zZXJ0TWVzc2FnZSB9KTtcbiAgICAgICAgdGhpcy5zdWJtaXRJZkF0dGFjaGVkKGluc2VydE1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZXRUZXh0KHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldFRleHQoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGluc2VydFRleHRSZWxhdGl2ZShyZWxhdGl2ZVBvczEsIHRleHQsIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IGluc2VydE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHJlbGF0aXZlUG9zMSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5jbGllbnQubWVyZ2VUcmVlLnBvc0Zyb21SZWxhdGl2ZVBvcyhyZWxhdGl2ZVBvczEpO1xuICAgICAgICB0aGlzLmNsaWVudC5pbnNlcnRUZXh0TG9jYWwodGV4dCwgcG9zLCBwcm9wcywgeyBvcDogaW5zZXJ0TWVzc2FnZSB9KTtcbiAgICAgICAgdGhpcy5zdWJtaXRJZkF0dGFjaGVkKGluc2VydE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpbnNlcnRUZXh0KHRleHQsIHBvcywgcHJvcHMpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIHBvczE6IHBvcyxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHR5cGU6IDAgLyogSU5TRVJUICovLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsaWVudC5pbnNlcnRUZXh0TG9jYWwodGV4dCwgcG9zLCBwcm9wcywgeyBvcDogaW5zZXJ0TWVzc2FnZSB9KTtcbiAgICAgICAgdGhpcy5zdWJtaXRJZkF0dGFjaGVkKGluc2VydE1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXBsYWNlVGV4dCh0ZXh0LCBzdGFydCwgZW5kLCBwcm9wcykge1xuICAgICAgICBjb25zdCBpbnNlcnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgcG9zMTogc3RhcnQsXG4gICAgICAgICAgICBwb3MyOiBlbmQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB0eXBlOiAwIC8qIElOU0VSVCAqLyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQubWVyZ2VUcmVlLnN0YXJ0R3JvdXBPcGVyYXRpb24oKTtcbiAgICAgICAgdGhpcy5jbGllbnQucmVtb3ZlU2VnbWVudExvY2FsKHN0YXJ0LCBlbmQsIHsgb3A6IGluc2VydE1lc3NhZ2UgfSk7XG4gICAgICAgIHRoaXMuY2xpZW50Lmluc2VydFRleHRMb2NhbCh0ZXh0LCBzdGFydCwgcHJvcHMsIHsgb3A6IGluc2VydE1lc3NhZ2UgfSk7XG4gICAgICAgIHRoaXMuY2xpZW50Lm1lcmdlVHJlZS5lbmRHcm91cE9wZXJhdGlvbigpO1xuICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQoaW5zZXJ0TWVzc2FnZSk7XG4gICAgfVxuICAgIHJlbW92ZU5lc3QobmVzdFN0YXJ0LCBuZXN0RW5kKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jbGllbnQubWVyZ2VUcmVlLmdldE9mZnNldChuZXN0U3RhcnQsIE1lcmdlVHJlZS5Vbml2ZXJzYWxTZXF1ZW5jZU51bWJlciwgdGhpcy5jbGllbnQuZ2V0Q2xpZW50SWQoKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5lc3RFbmQuY2FjaGVkTGVuZ3RoICsgdGhpcy5jbGllbnQubWVyZ2VUcmVlLmdldE9mZnNldChuZXN0RW5kLCBNZXJnZVRyZWUuVW5pdmVyc2FsU2VxdWVuY2VOdW1iZXIsIHRoaXMuY2xpZW50LmdldENsaWVudElkKCkpO1xuICAgICAgICBjb25zb2xlLmxvZyhgcmVtb3ZpbmcgbmVzdCAke25lc3RTdGFydC5nZXRJZCgpfSBmcm9tIFske3N0YXJ0fSwke2VuZH0pYCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBjaGVja05lc3Q6IHsgaWQxOiBuZXN0U3RhcnQuZ2V0SWQoKSwgaWQyOiBuZXN0RW5kLmdldElkKCkgfSxcbiAgICAgICAgICAgIHBvczE6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zMjogZW5kLFxuICAgICAgICAgICAgdHlwZTogMSAvKiBSRU1PVkUgKi8sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50LnJlbW92ZVNlZ21lbnRMb2NhbChzdGFydCwgZW5kLCB7IG9wOiByZW1vdmVNZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQocmVtb3ZlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJlbW92ZVRleHQoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBhbm5vdGF0ZVJhbmdlRnJvbVBhc3QocHJvcHMsIHN0YXJ0LCBlbmQsIGZyb21TZXEpIHtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gdGhpcy5jbGllbnQubWVyZ2VUcmVlLnRhcmRpc1JhbmdlKHN0YXJ0LCBlbmQsIGZyb21TZXEsIHRoaXMuY2xpZW50LmdldEN1cnJlbnRTZXEoKSwgdGhpcy5jbGllbnQuZ2V0Q2xpZW50SWQoKSk7XG4gICAgICAgIHJhbmdlcy5tYXAoKHJhbmdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRlUmFuZ2UocHJvcHMsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYW5ub3RhdGVNYXJrZXJOb3RpZnlDb25zZW5zdXMobWFya2VyLCBwcm9wcywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSBtYXJrZXIuZ2V0SWQoKTtcbiAgICAgICAgY29uc3QgYW5ub3RhdGVNZXNzYWdlID0ge1xuICAgICAgICAgICAgY29tYmluaW5nT3A6IHsgbmFtZTogXCJjb25zZW5zdXNcIiB9LFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICByZWxhdGl2ZVBvczE6IHsgaWQsIGJlZm9yZTogdHJ1ZSB9LFxuICAgICAgICAgICAgcmVsYXRpdmVQb3MyOiB7IGlkIH0sXG4gICAgICAgICAgICB0eXBlOiAyIC8qIEFOTk9UQVRFICovLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsaWVudC5hbm5vdGF0ZU1hcmtlck5vdGlmeUNvbnNlbnN1cyhtYXJrZXIsIHByb3BzLCBjYWxsYmFjaywgeyBvcDogYW5ub3RhdGVNZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLnN1Ym1pdElmQXR0YWNoZWQoYW5ub3RhdGVNZXNzYWdlKTtcbiAgICB9XG4gICAgYW5ub3RhdGVNYXJrZXIocHJvcHMsIG1hcmtlciwgb3ApIHtcbiAgICAgICAgY29uc3QgaWQgPSBtYXJrZXIuZ2V0SWQoKTtcbiAgICAgICAgY29uc3QgYW5ub3RhdGVNZXNzYWdlID0ge1xuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICByZWxhdGl2ZVBvczE6IHsgaWQsIGJlZm9yZTogdHJ1ZSB9LFxuICAgICAgICAgICAgcmVsYXRpdmVQb3MyOiB7IGlkIH0sXG4gICAgICAgICAgICB0eXBlOiAyIC8qIEFOTk9UQVRFICovLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICAgIGFubm90YXRlTWVzc2FnZS5jb21iaW5pbmdPcCA9IG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50LmFubm90YXRlTWFya2VyKHByb3BzLCBtYXJrZXIsIG9wLCB7IG9wOiBhbm5vdGF0ZU1lc3NhZ2UgfSk7XG4gICAgICAgIHRoaXMuc3VibWl0SWZBdHRhY2hlZChhbm5vdGF0ZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBmaW5kVGlsZShzdGFydFBvcywgdGlsZUxhYmVsLCBwcmVjZWRpbmcgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5maW5kVGlsZShzdGFydFBvcywgdGlsZUxhYmVsLCBwcmVjZWRpbmcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlZFN0cmluZy5qcy5tYXAiLCJjb25zdCBNYXhCYXRjaFNpemUgPSAxMDA7XG5leHBvcnQgY2xhc3MgQmF0Y2hNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgICAgIHRoaXMucGVuZGluZ1dvcmsgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFkZChpZCwgd29yaykge1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1dvcmsuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nV29yay5zZXQoaWQsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdXb3JrLmdldChpZClcbiAgICAgICAgICAgIC5wdXNoKHdvcmspO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nV29yay5nZXQoaWQpLmxlbmd0aCA+PSBNYXhCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0V29yaygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgb25jZSBhbGwgcGVuZGluZyB3b3JrIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgZHJhaW4oKSB7XG4gICAgICAgIHRoaXMuc3RhcnRXb3JrKCk7XG4gICAgfVxuICAgIHN0YXJ0V29yaygpIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGludGVybmFsIGZsYWdzIGZpcnN0IHRvIGF2b2lkIGlzc3VlcyBpbiBjYXNlIGFueSBvZiB0aGUgcGVuZGluZyB3b3JrIGNhbGxzIGJhY2sgaW50b1xuICAgICAgICAvLyB0aGUgYmF0Y2ggbWFuYWdlci4gV2UgY291bGQgYWxzbyBkbyB0aGlzIHdpdGggYSBzZWNvbmQgc2V0SW1tZWRpYXRlIGNhbGwgYnV0IGF2b2RpaW5nIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIHdvcmsgcXVpY2tlci5cbiAgICAgICAgY29uc3QgcGVuZGluZ1dvcmsgPSB0aGlzLnBlbmRpbmdXb3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmdXb3JrID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBUT0RPIGxvZyB0byBpbmZsdXggaG93IG11Y2ggcGVuZGluZyB3b3JrIHRoZXJlIGlzLiBXZSB3YW50IHRvIGxpbWl0IHRoZSBzaXplIG9mIGEgYmF0Y2hcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGJhdGNoXSBvZiBwZW5kaW5nV29yaykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGlkLCBiYXRjaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaE1hbmFnZXIuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGaWxlTW9kZSwgVHJlZUVudHJ5LCB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXN1Ym1vZHVsZS1pbXBvcnRzXG5pbXBvcnQgKiBhcyBzaGExIGZyb20gXCJzaGEuanMvc2hhMVwiO1xuLyoqXG4gKiBDcmVhdGUgSGFzaCAoR2l0aHViIGhhc2hlcyB0aGUgc3RyaW5nIHdpdGggYmxvYiBhbmQgc2l6ZSlcbiAqIEBwYXJhbSBmaWxlIFRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBpbiBhIGJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2l0SGFzaEZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHNpemUgPSBmaWxlLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZmlsZVByZWZpeCA9IFwiYmxvYiBcIiArIHNpemUudG9TdHJpbmcoKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBzaGExKCk7XG4gICAgcmV0dXJuIGVuZ2luZS51cGRhdGUoZmlsZVByZWZpeClcbiAgICAgICAgLnVwZGF0ZShmaWxlKVxuICAgICAgICAuZGlnZXN0KFwiaGV4XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4odHJlZSwgYmxvYk1hcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmbGF0dGVuQ29yZShcIlwiLCB0cmVlLCBibG9iTWFwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaGE6IG51bGwsXG4gICAgICAgIHRyZWU6IGVudHJpZXMsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRBbmRQYXJzZShzdG9yYWdlLCBzaGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0geWllbGQgc3RvcmFnZS5yZWFkKHNoYSk7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBCdWZmZXJcbiAgICAgICAgICAgIC5mcm9tKGVuY29kZWQsIFwiYmFzZTY0XCIpXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuQ29yZShwYXRoLCB0cmVlRW50cmllcywgYmxvYk1hcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IHRyZWVFbnRyeSBvZiB0cmVlRW50cmllcykge1xuICAgICAgICBjb25zdCBzdWJQYXRoID0gYCR7cGF0aH0ke3RyZWVFbnRyeS5wYXRofWA7XG4gICAgICAgIGlmICh0cmVlRW50cnkudHlwZSA9PT0gVHJlZUVudHJ5W1RyZWVFbnRyeS5CbG9iXSkge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IHRyZWVFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJsb2IuY29udGVudHMsIGJsb2IuZW5jb2RpbmcpO1xuICAgICAgICAgICAgY29uc3Qgc2hhID0gZ2l0SGFzaEZpbGUoYnVmZmVyKTtcbiAgICAgICAgICAgIGJsb2JNYXAuc2V0KHNoYSwgYnVmZmVyLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlW3RyZWVFbnRyeS5tb2RlXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIHNoYSxcbiAgICAgICAgICAgICAgICBzaXplOiBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgICAgICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdCA9IHRyZWVFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIG1vZGU6IEZpbGVNb2RlW3RyZWVFbnRyeS5tb2RlXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIHNoYTogbnVsbCxcbiAgICAgICAgICAgICAgICBzaXplOiAtMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRyZWVcIixcbiAgICAgICAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlRyZWVFbnRyaWVzID0gZmxhdHRlbkNvcmUoc3ViUGF0aCArIFwiL1wiLCB0LmVudHJpZXMsIGJsb2JNYXApO1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKC4uLnN1YlRyZWVFbnRyaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEhpZXJhcmNoeShmbGF0VHJlZSkge1xuICAgIGlmICghZmxhdFRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxvb2t1cCA9IHt9O1xuICAgIGNvbnN0IHJvb3QgPSB7IHNoYTogZmxhdFRyZWUuc2hhLCBibG9iczoge30sIGNvbW1pdHM6IHt9LCB0cmVlczoge30gfTtcbiAgICBsb29rdXBbXCJcIl0gPSByb290O1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZmxhdFRyZWUudHJlZSkge1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBlbnRyeS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZW50cnlQYXRoRGlyID0gZW50cnkucGF0aC5zbGljZSgwLCBNYXRoLm1heCgwLCBsYXN0SW5kZXgpKTtcbiAgICAgICAgY29uc3QgZW50cnlQYXRoQmFzZSA9IGVudHJ5LnBhdGguc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICAgIC8vIFRoZSBmbGF0IG91dHB1dCBpcyBicmVhZHRoLWZpcnN0IHNvIHdlIGNhbiBhc3N1bWUgd2Ugc2VlIHRyZWUgbm9kZXMgcHJpb3IgdG8gdGhlaXIgY29udGVudHNcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxvb2t1cFtlbnRyeVBhdGhEaXJdO1xuICAgICAgICAvLyBBZGQgaW4gZWl0aGVyIHRoZSBibG9iIG9yIHRyZWVcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09IFwidHJlZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUcmVlID0geyBzaGE6IGVudHJ5LnNoYSwgYmxvYnM6IHt9LCBjb21taXRzOiB7fSwgdHJlZXM6IHt9IH07XG4gICAgICAgICAgICBub2RlLnRyZWVzW2VudHJ5UGF0aEJhc2VdID0gbmV3VHJlZTtcbiAgICAgICAgICAgIGxvb2t1cFtlbnRyeS5wYXRoXSA9IG5ld1RyZWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gXCJibG9iXCIpIHtcbiAgICAgICAgICAgIG5vZGUuYmxvYnNbZW50cnlQYXRoQmFzZV0gPSBlbnRyeS5zaGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gXCJjb21taXRcIikge1xuICAgICAgICAgICAgbm9kZS5jb21taXRzW2VudHJ5UGF0aEJhc2VdID0gZW50cnkuc2hhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYnMuanMubWFwIiwiLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxuLy8gdHNsaW50OmRpc2FibGU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuLy8gdHNsaW50OmRpc2FibGU6bm8tcGFyYW1ldGVyLXJlYXNzaWdubWVudFxuZXhwb3J0IGNvbnN0IE51bWJlckNvbXBhcmVyID0ge1xuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBtaW46IE51bWJlci5NSU5fVkFMVUUsXG59O1xuZXhwb3J0IGNsYXNzIEhlYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXApIHtcbiAgICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgICAgdGhpcy5MID0gW3sgdmFsdWU6IGNvbXAubWluLCBwb3NpdGlvbjogMCB9XTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTFsxXTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICB0aGlzLnN3YXAoMSwgdGhpcy5jb3VudCgpKTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuTC5wb3AoKTtcbiAgICAgICAgdGhpcy5maXhkb3duKDEpO1xuICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICB9XG4gICAgYWRkKHgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IHgsIHBvc2l0aW9uOiB0aGlzLkwubGVuZ3RoIH07XG4gICAgICAgIHRoaXMuTC5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLmZpeHVwKHRoaXMuY291bnQoKSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIGhlYXAgdG8gYmUgdXBkYXRlZCBhZnRlciBhIG5vZGUncyB2YWx1ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgdXBkYXRlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgayA9IG5vZGUucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmlzR3JlYXRlclRoYW5QYXJlbnQoaykpIHtcbiAgICAgICAgICAgIHRoaXMuZml4dXAoayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpeGRvd24oayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBoZWFwXG4gICAgICovXG4gICAgcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgbm9kZSB3ZSB3YW50IHRvIHJlbW92ZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XG4gICAgICAgIHRoaXMuc3dhcChub2RlLnBvc2l0aW9uLCB0aGlzLkwubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuTC5zcGxpY2UodGhpcy5MLmxlbmd0aCAtIDEpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN3YXBwZWQgbm9kZSBhc3N1bWluZyB3ZSBkaWRuJ3QgcmVtb3ZlIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSB0aGlzLkwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLkxbcG9zaXRpb25dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuTC5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBmaXh1cChrKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzR3JlYXRlclRoYW5QYXJlbnQoaykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGsgPj4gMTtcbiAgICAgICAgICAgIHRoaXMuc3dhcChrLCBwYXJlbnQpO1xuICAgICAgICAgICAgayA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0dyZWF0ZXJUaGFuUGFyZW50KGspIHtcbiAgICAgICAgcmV0dXJuIGsgPiAxICYmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxbayA+PiAxXS52YWx1ZSwgdGhpcy5MW2tdLnZhbHVlKSA+IDApO1xuICAgIH1cbiAgICBmaXhkb3duKGspIHtcbiAgICAgICAgd2hpbGUgKChrIDw8IDEpIDw9IHRoaXMuY291bnQoKSkge1xuICAgICAgICAgICAgbGV0IGogPSBrIDw8IDE7XG4gICAgICAgICAgICBpZiAoKGogPCB0aGlzLmNvdW50KCkpICYmICh0aGlzLmNvbXAuY29tcGFyZSh0aGlzLkxbal0udmFsdWUsIHRoaXMuTFtqICsgMV0udmFsdWUpID4gMCkpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wLmNvbXBhcmUodGhpcy5MW2tdLnZhbHVlLCB0aGlzLkxbal0udmFsdWUpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3dhcChrLCBqKTtcbiAgICAgICAgICAgIGsgPSBqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3YXAoaywgaikge1xuICAgICAgICBjb25zdCB0bXAgPSB0aGlzLkxba107XG4gICAgICAgIHRoaXMuTFtrXSA9IHRoaXMuTFtqXTtcbiAgICAgICAgdGhpcy5MW2tdLnBvc2l0aW9uID0gaztcbiAgICAgICAgdGhpcy5MW2pdID0gdG1wO1xuICAgICAgICB0aGlzLkxbal0ucG9zaXRpb24gPSBqO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYXAuanMubWFwIiwiZXhwb3J0ICogZnJvbSBcIi4vYmF0Y2hNYW5hZ2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ibG9ic1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVhcFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcHJvbWlzZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3JhbmdlVHJhY2tlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmF0ZUxpbWl0dGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zYWZlUGFyc2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi91dGlsc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbi8qKlxuICogQSBkZWZlcnJlZCBjcmVhdGVzIGEgcHJvbWlzZSBhbmQgdGhlIGFiaWxpdHkgdG8gcmVzb2x2ZSBvciByZWplY3QgaXRcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6cHJvbWlzZS1tdXN0LWNvbXBsZXRlICovXG4gICAgICAgIHRoaXMucCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB1bmRlcmx5aW5nIHByb21pc2UgZm9yIHRoZSBkZWZlcnJlZFxuICAgICAqL1xuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgcHJvbWlzZVxuICAgICAqL1xuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXModmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlXG4gICAgICovXG4gICAgcmVqZWN0KGVycm9yKSB7XG4gICAgICAgIHRoaXMucmVqKGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gcHJvbWlzZSBvbmx5IHJlc29sdmVzXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOnByb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RSZWplY3RlZChwcm9taXNlKSB7XG4gICAgLy8gQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHByb21pc2Ugb25seSByZXNvbHZlc1xuICAgIHByb21pc2UuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFzc2VydC5vayhmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlcy5qcy5tYXAiLCJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuLy8gdHNsaW50OmRpc2FibGU6bm8tdmFyLXJlcXVpcmVzXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3VibW9kdWxlLWltcG9ydHNcbmNvbnN0IGNsb25lRGVlcCA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdGhhdCBrZWVwcyB0cmFjayBvZiB0aGUgcmVsYXRpb24gYmV0d2VlbiB0d28gcmFuZ2VzIGluIGEgMTpOIGZhc2hpb24uIFByaW1hcnlcbiAqIGlzIGNvbnRpbnVvdXMgYW5kIGFsd2F5cyBtYXBzIHRvIGEgc2luZ2xlIHZhbHVlIGluIHNlY29uZGFyeSBhYm92ZSB0aGUgYmFzZSB2YWx1ZS4gVGhlIHJhbmdlXG4gKiBkZWZpbmVzIGFuIGluY3JlYXNpbmcgc3RlcCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlVHJhY2tlciB7XG4gICAgZ2V0IGJhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS5wcmltYXJ5O1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeUhlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RQcmltYXJ5O1xuICAgIH1cbiAgICBnZXQgc2Vjb25kYXJ5SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlY29uZGFyeTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbWFyeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBbeyBsZW5ndGg6IDAsIHByaW1hcnksIHNlY29uZGFyeSB9XTtcbiAgICAgICAgICAgIHRoaXMubGFzdFByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICAgICAgdGhpcy5sYXN0U2Vjb25kYXJ5ID0gc2Vjb25kYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW5zYWZlLWFueSAqL1xuICAgICAgICAgICAgdGhpcy5yYW5nZXMgPSBjbG9uZURlZXAocHJpbWFyeS5yYW5nZXMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0UHJpbWFyeSA9IHByaW1hcnkubGFzdFByaW1hcnk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWNvbmRhcnkgPSBwcmltYXJ5Lmxhc3RTZWNvbmRhcnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgUmFuZ2VUcmFja2VyXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFzdFByaW1hcnk6IHRoaXMubGFzdFByaW1hcnksXG4gICAgICAgICAgICBsYXN0U2Vjb25kYXJ5OiB0aGlzLmxhc3RTZWNvbmRhcnksXG4gICAgICAgICAgICByYW5nZXM6IGNsb25lRGVlcCh0aGlzLnJhbmdlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHByaW1hcnkgaXMgdGltZSAtIHNlY29uZGFyeSBpcyB0aGUgTVNOXG4gICAgYWRkKHByaW1hcnksIHNlY29uZGFyeSkge1xuICAgICAgICAvLyBCb3RoIHZhbHVlcyBtdXN0IGNvbnRpbnVvdXNseSBiZSBpbmNyZWFzaW5nIC0gd2Ugd29uJ3QgYWx3YXlzIHRyYWNrIHRoZSBsYXN0IHZhbHVlIHdlIHNhdyBzbyB3ZSBkbyBzb1xuICAgICAgICAvLyBiZWxvdyB0byBjaGVjayBpbnZhcmlhbnRzXG4gICAgICAgIGFzc2VydChwcmltYXJ5ID49IHRoaXMubGFzdFByaW1hcnkpO1xuICAgICAgICBhc3NlcnQoc2Vjb25kYXJ5ID49IHRoaXMubGFzdFNlY29uZGFyeSk7XG4gICAgICAgIHRoaXMubGFzdFByaW1hcnkgPSBwcmltYXJ5O1xuICAgICAgICB0aGlzLmxhc3RTZWNvbmRhcnkgPSBzZWNvbmRhcnk7XG4gICAgICAgIC8vIEdldCBxdWlja2VyIHJlZmVyZW5jZXMgdG8gdGhlIGhlYWQgb2YgdGhlIHJhbmdlXG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcHJpbWFyeUhlYWQgPSBoZWFkLnByaW1hcnkgKyBoZWFkLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2Vjb25kYXJ5SGVhZCA9IGhlYWQuc2Vjb25kYXJ5ICsgaGVhZC5sZW5ndGg7XG4gICAgICAgIC8vIFNhbWUgc2Vjb25kYXJ5IGluZGljYXRlcyB0aGlzIGlzIG5vdCBhIHRydWUgaW5mbGVjdGlvbiBwb2ludCAtIHdlIGNhbiBpZ25vcmUgaXRcbiAgICAgICAgaWYgKHNlY29uZGFyeSA9PT0gc2Vjb25kYXJ5SGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBzZWNvbmRhcnkgLSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2VzXG4gICAgICAgIGlmIChwcmltYXJ5ID09PSBwcmltYXJ5SGVhZCkge1xuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBjb2RlIHBhdGggaGFzIHVzIHN1cHBvcnRpbmcgTjpOIHJhbmdlcy4gQnV0IHdlIHNpbXBseSBvdmVyd3JpdGUgZHVwbGljYXRlIHZhbHVlcyB0b1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgMTpOIHNpbmNlIHlvdSBjYW4gb25seSBsb29rdXAgZnJvbSB0aGUgcHJpbWFyeSB0byBhIHNlY29uZGFyeVxuICAgICAgICAgICAgaWYgKGhlYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcmFuZ2UgcmVwcmVzZW50ZWQgLSB3ZSBjYW4gc2ltcGx5IHVwZGF0ZSBzZWNvbmRhcnkgd2l0aCB0aGUgb3ZlcndyaXR0ZW4gdmFsdWVcbiAgICAgICAgICAgICAgICBoZWFkLnNlY29uZGFyeSA9IHNlY29uZGFyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZXMgaW4gdGhlIHJhbmdlIGJlZm9yZSB0aGlzIG9uZSBhcmUgdmFsaWQgLSBidXQgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lIGZvciB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmNyZW1lbnQtZGVjcmVtZW50XG4gICAgICAgICAgICAgICAgaGVhZC5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlcy5wdXNoKHsgbGVuZ3RoOiAwLCBwcmltYXJ5LCBzZWNvbmRhcnkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJpbWFyeUhlYWQgKyAxID09PSBwcmltYXJ5ICYmIHNlY29uZGFyeUhlYWQgKyAxID09PSBzZWNvbmRhcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgdGhlIGxlbmd0aCBpZiBib3RoIGluY3JlYXNlIGJ5IHRoZSBzYW1lIGFtb3VudFxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmNyZW1lbnQtZGVjcmVtZW50XG4gICAgICAgICAgICAgICAgaGVhZC5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZXMucHVzaCh7IGxlbmd0aDogMCwgcHJpbWFyeSwgc2Vjb25kYXJ5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldChwcmltYXJ5KSB7XG4gICAgICAgIGFzc2VydChwcmltYXJ5ID49IHRoaXMucmFuZ2VzWzBdLnByaW1hcnkpO1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByYW5nZSB3aGVyZSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBwcmltYXJ5LiBPdXIgdGFyZ2V0IHJhbmdlIGlzXG4gICAgICAgIC8vIHRoZSBvbmUgYmVmb3JlIGl0LlxuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuICAgICAgICBmb3IgKDsgaW5kZXggPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5IDwgdGhpcy5yYW5nZXNbaW5kZXhdLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdLnByaW1hcnkpO1xuICAgICAgICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBpcyB3aXRoaW4gdGhlIHN0b3JlZCByYW5nZSB1c2UgaXQgLSBvdGhlcndpc2UgYWRkIGluIHRoZSBsZW5ndGggLSAxIGFzIHRoZSBoaWdoZXN0XG4gICAgICAgIC8vIHN0b3JlZCBzZWNvbmRhcnkgdmFsdWUgdG8gdXNlLlxuICAgICAgICBjb25zdCBjbG9zZXN0UmFuZ2UgPSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJpbWFyeSAtIGNsb3Nlc3RSYW5nZS5wcmltYXJ5LCBjbG9zZXN0UmFuZ2UubGVuZ3RoKSArIGNsb3Nlc3RSYW5nZS5zZWNvbmRhcnk7XG4gICAgfVxuICAgIHVwZGF0ZUJhc2UocHJpbWFyeSkge1xuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1swXS5wcmltYXJ5KTtcbiAgICAgICAgLy8gV2FsayB0aGUgcmFuZ2VzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhlIHByaW1hcnkuIFByaW1hcnkgaXMgdGhlbiB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHByZXZpb3VzIGluZGV4IGJ5IGRlZmluaXRpb24gKHNpbmNlIGl0J3MgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4J3MgcHJpbWFyeSBidXQgZ3JlYXRoZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgaW5kZXgncyBwcmltYXJ5KSBhbmQgd2Uga25vdyBwcmltYXJ5IG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBiYXNlLlxuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5jcmVtZW50LWRlY3JlbWVudFxuICAgICAgICBmb3IgKDsgaW5kZXggPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChwcmltYXJ5IDwgdGhpcy5yYW5nZXNbaW5kZXhdLnByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocHJpbWFyeSA+PSB0aGlzLnJhbmdlc1tpbmRleCAtIDFdLnByaW1hcnkpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgcmFuZ2UgdmFsdWVzXG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZXNbaW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwcmltYXJ5IC0gcmFuZ2UucHJpbWFyeTtcbiAgICAgICAgcmFuZ2Uuc2Vjb25kYXJ5ID0gcmFuZ2Uuc2Vjb25kYXJ5ICsgTWF0aC5taW4oZGVsdGEsIHJhbmdlLmxlbmd0aCk7XG4gICAgICAgIHJhbmdlLmxlbmd0aCA9IE1hdGgubWF4KHJhbmdlLmxlbmd0aCAtIGRlbHRhLCAwKTtcbiAgICAgICAgcmFuZ2UucHJpbWFyeSA9IHByaW1hcnk7XG4gICAgICAgIC8vIEFuZCByZW1vdmUgdW5uZWNlc3NhcnkgcmFuZ2VzXG4gICAgICAgIHRoaXMucmFuZ2VzID0gaW5kZXggLSAxID4gMCA/IHRoaXMucmFuZ2VzLnNsaWNlKGluZGV4IC0gMSkgOiB0aGlzLnJhbmdlcztcbiAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIGxvd2VzdCB2YWx1ZSBpcyBub3cgdGhlIGlucHV0IHRvIHRoaXMgbWV0aG9kXG4gICAgICAgIGFzc2VydC5lcXVhbChwcmltYXJ5LCB0aGlzLnJhbmdlc1swXS5wcmltYXJ5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZVRyYWNrZXIuanMubWFwIiwiLy8gQSByYXRlIGxpbWl0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgYSBjbGllbnQgY2FuIG9ubHkgcmVxdWVzdCBoZWxwIGZvciBvbmUgdGFzayB3aXRoaW4gYSB0aW1lIHdpbmRvdy5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdpbmRvd01TZWMpIHtcbiAgICAgICAgdGhpcy53aW5kb3dNU2VjID0gd2luZG93TVNlYztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmaWx0ZXIoY2xpZW50SWQsIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7Y2xpZW50SWR9LyR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RNYXAuc2V0KGtleSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGFwcHJvdmVkTGlzdC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZXF1ZXN0TWFwLmdldChrZXkpICsgdGhpcy53aW5kb3dNU2VjID4gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdE1hcC5zZXQoa2V5LCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgYXBwcm92ZWRMaXN0LnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcHJvdmVkTGlzdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRlTGltaXR0ZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHNhZmVseVBhcnNlSlNPTihqc29uKSB7XG4gICAgbGV0IHBhcnNlZDtcbiAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvL1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZVBhcnNlci5qcy5tYXAiLCJpbXBvcnQgeyBNZXNzYWdlVHlwZSB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3lzdGVtVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBNZXNzYWdlVHlwZS5SZW1vdGVIZWxwIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkludGVncmF0ZSB8fFxuICAgICAgICB0eXBlID09PSBNZXNzYWdlVHlwZS5DbGllbnRKb2luIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkNsaWVudExlYXZlIHx8XG4gICAgICAgIHR5cGUgPT09IE1lc3NhZ2VUeXBlLkZvcmspO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi9zdHJlYW1cIjtcbmV4cG9ydCBjbGFzcyBTdHJlYW1FeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSBTdHJlYW1FeHRlbnNpb24uVHlwZTtcbiAgICB9XG4gICAgbG9hZChydW50aW1lLCBpZCwgbWluaW11bVNlcXVlbmNlTnVtYmVyLCBzZXJ2aWNlcywgaGVhZGVyT3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKHJ1bnRpbWUsIGlkKTtcbiAgICAgICAgICAgIHlpZWxkIHN0cmVhbS5sb2FkKG1pbmltdW1TZXF1ZW5jZU51bWJlciwgaGVhZGVyT3JpZ2luLCBzZXJ2aWNlcyk7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlKHJ1bnRpbWUsIGlkKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0ocnVudGltZSwgaWQpO1xuICAgICAgICBzdHJlYW0uaW5pdGlhbGl6ZUxvY2FsKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxufVxuU3RyZWFtRXh0ZW5zaW9uLlR5cGUgPSBcImh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS90eXBlcy9zdHJlYW1cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5qcy5tYXAiLCJleHBvcnQgKiBmcm9tIFwiLi9leHRlbnNpb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludGVyZmFjZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NuYXBzaG90XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3VibW9kdWxlLWltcG9ydHNcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWQvdjRcIjtcbi8qKlxuICogRmx1ZW50IGltcGxlbWVudGF0aW9uIG9mIHRoZSBJRGVsdGEgaW50ZXJmYWNlIHRvIG1ha2UgY3JlYXRpb24gdGhlIHVuZGVybHlpbmcgb3BlcmF0aW9uIGVhc2llci5cbiAqIE9ubHkgb25lIG9wZXJhdGlvbiBwZXIgZGVsdGEgaXMgY3VycmVudGx5IHN1cHBvcnRlZCBidXQgaXQncyBleHBlY3RlZCB0aGlzIHdpbGwgZXhwYW5kIHRvIG11bHRpcGxlIGluXG4gKiB0aGUgZnV0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWx0YSB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0aW9ucyA9IFtdKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHR3byBpbmsgZGVsdGEgc3RyZWFtcyB0b2dldGhlciAtIHdoaWNoIGlzIGFzIHNpbXBsZSBhcyBhcHBlbmRpbmcgdGhlaXIgb3BlcmF0aW9uXG4gICAgICogbG9nc1xuICAgICAqL1xuICAgIGNvbXBvc2UoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gdGhpcy5vcGVyYXRpb25zLmNvbmNhdChkZWx0YS5vcGVyYXRpb25zKTtcbiAgICB9XG4gICAgcHVzaChvcGVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICB9XG4gICAgY2xlYXIodGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSB7XG4gICAgICAgIGNvbnN0IGNsZWFyID0ge307XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKHsgY2xlYXIsIHRpbWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdHlsdXNVcChwb2ludCwgcHJlc3N1cmUsIGlkID0gdXVpZCgpLCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bHVzVXAgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgcHJlc3N1cmUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKHsgc3R5bHVzVXAsIHRpbWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdHlsdXNEb3duKHBvaW50LCBwcmVzc3VyZSwgcGVuLCBsYXllciA9IDAsIGlkID0gdXVpZCgpLCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bHVzRG93biA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgICBwZW4sXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIHByZXNzdXJlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaCh7IHN0eWx1c0Rvd24sIHRpbWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdHlsdXNNb3ZlKHBvaW50LCBwcmVzc3VyZSwgaWQgPSB1dWlkKCksIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSkge1xuICAgICAgICBjb25zdCBzdHlsdXNNb3ZlID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIHByZXNzdXJlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaCh7IHN0eWx1c01vdmUsIHRpbWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0eXBlIG9mIGFjdGlvbiBjb250YWluZWQgd2l0aGluIHRoZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvblR5cGUob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5jbGVhcikge1xuICAgICAgICByZXR1cm4gQWN0aW9uVHlwZS5DbGVhcjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnN0eWx1c0Rvd24pIHtcbiAgICAgICAgcmV0dXJuIEFjdGlvblR5cGUuU3R5bHVzRG93bjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnN0eWx1c1VwKSB7XG4gICAgICAgIHJldHVybiBBY3Rpb25UeXBlLlN0eWx1c1VwO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24uc3R5bHVzTW92ZSkge1xuICAgICAgICByZXR1cm4gQWN0aW9uVHlwZS5TdHlsdXNNb3ZlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhY3Rpb25cIik7XG4gICAgfVxufVxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgSVN0eWx1c0FjdGlvbiBjb250YWluZWQgaW4gdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bHVzQWN0aW9uKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24uc3R5bHVzRG93bikge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLnN0eWx1c0Rvd247XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5zdHlsdXNVcCkge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLnN0eWx1c1VwO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24uc3R5bHVzTW92ZSkge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLnN0eWx1c01vdmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjdGlvblwiKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgSUQgb2YgdGhlIHN0eWx1cyBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWx1c0lkKG9wZXJhdGlvbikge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlKG9wZXJhdGlvbik7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQWN0aW9uVHlwZS5TdHlsdXNEb3duOlxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5zdHlsdXNEb3duLmlkO1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuU3R5bHVzVXA6XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLnN0eWx1c1VwLmlkO1xuICAgICAgICBjYXNlIEFjdGlvblR5cGUuU3R5bHVzTW92ZTpcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uc3R5bHVzTW92ZS5pZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1zdHlsdXMgZXZlbnRcIik7XG4gICAgfVxufVxuZXhwb3J0IHZhciBBY3Rpb25UeXBlO1xuKGZ1bmN0aW9uIChBY3Rpb25UeXBlKSB7XG4gICAgLy8gQWN0aW9uIG9mIHBsYWNpbmcgdGhlIHN0eWx1cyBvbiB0aGUgY2FudmFzXG4gICAgQWN0aW9uVHlwZVtBY3Rpb25UeXBlW1wiU3R5bHVzRG93blwiXSA9IDBdID0gXCJTdHlsdXNEb3duXCI7XG4gICAgLy8gQWN0aW9uIG9mIHBpY2tpbmcgdGhlIHN0eWx1cyB1cCBmcm9tIHRoZSBjYW52YXNcbiAgICBBY3Rpb25UeXBlW0FjdGlvblR5cGVbXCJTdHlsdXNVcFwiXSA9IDFdID0gXCJTdHlsdXNVcFwiO1xuICAgIC8vIFN0eWx1cyBoYXMgbW92ZWQgb24gdGhlIGNhbnZhc1xuICAgIEFjdGlvblR5cGVbQWN0aW9uVHlwZVtcIlN0eWx1c01vdmVcIl0gPSAyXSA9IFwiU3R5bHVzTW92ZVwiO1xuICAgIC8vIENhbnZhcyBoYXMgYmVlbiBjbGVhcmVkXG4gICAgQWN0aW9uVHlwZVtBY3Rpb25UeXBlW1wiQ2xlYXJcIl0gPSAzXSA9IFwiQ2xlYXJcIjtcbn0pKEFjdGlvblR5cGUgfHwgKEFjdGlvblR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiLCJpbXBvcnQgeyBBY3Rpb25UeXBlLCBnZXRBY3Rpb25UeXBlIH0gZnJvbSBcIi4vaW50ZXJmYWNlc1wiO1xuZXhwb3J0IGNsYXNzIFNuYXBzaG90IHtcbiAgICBjb25zdHJ1Y3RvcihsYXllcnMgPSBbXSwgbGF5ZXJJbmRleCA9IHt9KSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICB0aGlzLmxheWVySW5kZXggPSBsYXllckluZGV4O1xuICAgIH1cbiAgICBzdGF0aWMgQ2xvbmUoc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdChzbmFwc2hvdC5sYXllcnMsIHNuYXBzaG90LmxheWVySW5kZXgpO1xuICAgIH1cbiAgICBhcHBseShkZWx0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBkZWx0YS5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBnZXRBY3Rpb25UeXBlKG9wZXJhdGlvbik7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBBY3Rpb25UeXBlLkNsZWFyOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NsZWFyQWN0aW9uKG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFjdGlvblR5cGUuU3R5bHVzVXA6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzU3R5bHVzVXBBY3Rpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZS5TdHlsdXNEb3duOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1N0eWx1c0Rvd25BY3Rpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZS5TdHlsdXNNb3ZlOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1N0eWx1c01vdmVBY3Rpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhY3Rpb24gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzQ2xlYXJBY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMubGF5ZXJJbmRleCA9IHt9O1xuICAgIH1cbiAgICBwcm9jZXNzU3R5bHVzVXBBY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgIC8vIFRPRE8gLSBsb25nZXIgdGVybSBvbiBpbmsgdXAgLSBvciBwb3NzaWJseSBlYXJsaWVyIC0gd2UgY2FuIGF0dGVtcHQgdG8gc21vb3RoIHRoZSBwcm92aWRlZCBpbmtcbiAgICAgICAgdGhpcy5hZGRPcGVyYXRpb25Ub0xheWVyKG9wZXJhdGlvbi5zdHlsdXNVcC5pZCwgb3BlcmF0aW9uKTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0eWx1c0Rvd25BY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0ge1xuICAgICAgICAgICAgaWQ6IG9wZXJhdGlvbi5zdHlsdXNEb3duLmlkLFxuICAgICAgICAgICAgb3BlcmF0aW9uczogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFB1c2ggaWYgd2UgYXJlIGlzbmVydGluZyBhdCB0aGUgZW5kIC0gb3RoZXJ3aXNlIHNwbGljZSB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICAgICAgICBpZiAob3BlcmF0aW9uLnN0eWx1c0Rvd24ubGF5ZXIgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXllcnMuc3BsaWNlKHRoaXMubGF5ZXJzLmxlbmd0aCAtIG9wZXJhdGlvbi5zdHlsdXNEb3duLmxheWVyLCAwLCBsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSBzcGVjaWZpZWQgbGF5ZXJcbiAgICAgICAgbGV0IGxheWVySW5kZXggPSB0aGlzLmxheWVycy5sZW5ndGggLSAxIC0gb3BlcmF0aW9uLnN0eWx1c0Rvd24ubGF5ZXI7XG4gICAgICAgIHRoaXMubGF5ZXJJbmRleFtsYXllci5pZF0gPSBsYXllckluZGV4O1xuICAgICAgICAvLyBBbmQgbW92ZSBhbnkgYWZ0ZXIgaXQgZG93biBieSBvbmVcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWluY3JlbWVudC1kZWNyZW1lbnRcbiAgICAgICAgZm9yIChsYXllckluZGV4ID0gbGF5ZXJJbmRleCArIDE7IGxheWVySW5kZXggPCB0aGlzLmxheWVycy5sZW5ndGg7IGxheWVySW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJJZCA9IHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLmlkO1xuICAgICAgICAgICAgdGhpcy5sYXllckluZGV4W2xheWVySWRdID0gdGhpcy5sYXllckluZGV4W2xheWVySWRdICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbmQgc2F2ZSB0aGUgc3R5bHVzIGRvd25cbiAgICAgICAgdGhpcy5hZGRPcGVyYXRpb25Ub0xheWVyKG9wZXJhdGlvbi5zdHlsdXNEb3duLmlkLCBvcGVyYXRpb24pO1xuICAgIH1cbiAgICBwcm9jZXNzU3R5bHVzTW92ZUFjdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5hZGRPcGVyYXRpb25Ub0xheWVyKG9wZXJhdGlvbi5zdHlsdXNNb3ZlLmlkLCBvcGVyYXRpb24pO1xuICAgIH1cbiAgICBhZGRPcGVyYXRpb25Ub0xheWVyKGlkLCBvcGVyYXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogV2h5IGlzIHRoaXMgb3BlcmF0aW9uIHNvbWV0aW1lcyB1bmRlZmluZWQ/XG4gICAgICAgIGlmICh0aGlzLmxheWVySW5kZXhbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVySW5kZXggPSB0aGlzLmxheWVySW5kZXhbaWRdO1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLm9wZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdLm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c25hcHNob3QuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGaWxlTW9kZSwgTWVzc2FnZVR5cGUsIFRyZWVFbnRyeSwgfSBmcm9tIFwiQHByYWd1ZS9jb250YWluZXItZGVmaW5pdGlvbnNcIjtcbmltcG9ydCB7IFNoYXJlZE1hcCB9IGZyb20gXCJAcHJhZ3VlL21hcFwiO1xuaW1wb3J0IHsgU3RyZWFtRXh0ZW5zaW9uIH0gZnJvbSBcIi4vZXh0ZW5zaW9uXCI7XG5pbXBvcnQgeyBTbmFwc2hvdCB9IGZyb20gXCIuL3NuYXBzaG90XCI7XG5jb25zdCBzbmFwc2hvdEZpbGVOYW1lID0gXCJoZWFkZXJcIjtcbmNvbnN0IGVtcHR5U25hcHNob3QgPSB7IGxheWVyczogW10sIGxheWVySW5kZXg6IHt9IH07XG5leHBvcnQgY2xhc3MgU3RyZWFtIGV4dGVuZHMgU2hhcmVkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihydW50aW1lLCBpZCkge1xuICAgICAgICBzdXBlcihpZCwgcnVudGltZSwgU3RyZWFtRXh0ZW5zaW9uLlR5cGUpO1xuICAgIH1cbiAgICBnZXRMYXllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlua1NuYXBzaG90LmxheWVycztcbiAgICB9XG4gICAgZ2V0TGF5ZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlua1NuYXBzaG90LmxheWVyc1t0aGlzLmlua1NuYXBzaG90LmxheWVySW5kZXhba2V5XV07XG4gICAgfVxuICAgIHN1Ym1pdE9wKG9wKSB7XG4gICAgICAgIHRoaXMuc3VibWl0TG9jYWxNZXNzYWdlKG9wKTtcbiAgICAgICAgdGhpcy5pbmtTbmFwc2hvdC5hcHBseShvcCk7XG4gICAgfVxuICAgIGxvYWRDb250ZW50KG1pbmltdW1TZXF1ZW5jZU51bWJlciwgaGVhZGVyT3JpZ2luLCBzdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB5aWVsZCBzdG9yYWdlLnJlYWQoc25hcHNob3RGaWxlTmFtZSk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnNhZmUtYW55ICovXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gaGVhZGVyXG4gICAgICAgICAgICAgICAgPyBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGhlYWRlciwgXCJiYXNlNjRcIilcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKFwidXRmLThcIikpXG4gICAgICAgICAgICAgICAgOiBlbXB0eVNuYXBzaG90O1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUNvbnRlbnQoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShlbXB0eVNuYXBzaG90KTtcbiAgICB9XG4gICAgc25hcHNob3RDb250ZW50KCkge1xuICAgICAgICBjb25zdCB0cmVlID0ge1xuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogRmlsZU1vZGUuRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogc25hcHNob3RGaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVHJlZUVudHJ5W1RyZWVFbnRyeS5CbG9iXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBKU09OLnN0cmluZ2lmeSh0aGlzLmlua1NuYXBzaG90KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzaGE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICBwcm9jZXNzQ29udGVudChtZXNzYWdlLCBsb2NhbCkge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBNZXNzYWdlVHlwZS5PcGVyYXRpb24gJiYgIWxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmlua1NuYXBzaG90LmFwcGx5KG1lc3NhZ2UuY29udGVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ29ubmVjdENvbnRlbnQocGVuZGluZykge1xuICAgICAgICAvLyBTdHJlYW0gY2FuIHJlc2VuZCBtZXNzYWdlcyB1bmRlciBuZXcgY2xpZW50IGlkXG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdExvY2FsTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGluaXRpYWxpemUoZGF0YSkge1xuICAgICAgICB0aGlzLmlua1NuYXBzaG90ID0gU25hcHNob3QuQ2xvbmUoZGF0YSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMyBQZXRrYSBBbnRvbm92XG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczo8L3A+XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIERlcXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBnZXRDYXBhY2l0eShjYXBhY2l0eSk7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcm9udCA9IDA7XG4gICAgaWYgKGlzQXJyYXkoY2FwYWNpdHkpKSB7XG4gICAgICAgIHZhciBsZW4gPSBjYXBhY2l0eS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBjYXBhY2l0eVtpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgfVxufVxuXG5EZXF1ZS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIERlcXVlJHRvQXJyYXkoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgdmFyIGNhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICByZXRbal0gPSB0aGlzWyhmcm9udCArIGopICYgKGNhcGFjaXR5IC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuRGVxdWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBEZXF1ZSRwdXNoKGl0ZW0pIHtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAoYXJnc0xlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHk7XG4gICAgICAgIGlmIChsZW5ndGggKyBhcmdzTGVuZ3RoID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0xlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzW2pdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzWyhqICsgbGVuZ3RoKSAmIChjYXBhY2l0eSAtIDEpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGggKyBhcmdzTGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGFyZ3NMZW5ndGg7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChhcmdzTGVuZ3RoID09PSAwKSByZXR1cm4gbGVuZ3RoO1xuXG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gaXRlbTtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGggKyAxO1xufTtcblxuRGVxdWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIERlcXVlJHBvcCgpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIGkgPSAodGhpcy5fZnJvbnQgKyBsZW5ndGggLSAxKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHZhciByZXQgPSB0aGlzW2ldO1xuICAgIHRoaXNbaV0gPSB2b2lkIDA7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuRGVxdWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gRGVxdWUkc2hpZnQoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciByZXQgPSB0aGlzW2Zyb250XTtcbiAgICB0aGlzW2Zyb250XSA9IHZvaWQgMDtcbiAgICB0aGlzLl9mcm9udCA9IChmcm9udCArIDEpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuRGVxdWUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiBEZXF1ZSR1bnNoaWZ0KGl0ZW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuXG4gICAgaWYgKGFyZ3NMZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgICAgICBpZiAobGVuZ3RoICsgYXJnc0xlbmd0aCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gYXJnc0xlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9ICgoKCggdGhpcy5fZnJvbnQgLSAxICkgJlxuICAgICAgICAgICAgICAgICAgICAoIGNhcGFjaXR5IC0gMSkgKSBeIGNhcGFjaXR5ICkgLSBjYXBhY2l0eSApO1xuICAgICAgICAgICAgICAgIHRoaXNbal0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcmdzTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9ICgoKCggZnJvbnQgLSAxICkgJlxuICAgICAgICAgICAgICAgICAgICAoIGNhcGFjaXR5IC0gMSkgKSBeIGNhcGFjaXR5ICkgLSBjYXBhY2l0eSApO1xuICAgICAgICAgICAgICAgIHRoaXNbal0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgZnJvbnQgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZnJvbnQgPSBmcm9udDtcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIGFyZ3NMZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgYXJnc0xlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmdzTGVuZ3RoID09PSAwKSByZXR1cm4gbGVuZ3RoO1xuXG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgY2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB2YXIgaSA9ICgoKCggdGhpcy5fZnJvbnQgLSAxICkgJlxuICAgICAgICAoIGNhcGFjaXR5IC0gMSkgKSBeIGNhcGFjaXR5ICkgLSBjYXBhY2l0eSApO1xuICAgIHRoaXNbaV0gPSBpdGVtO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG4gICAgdGhpcy5fZnJvbnQgPSBpO1xuICAgIHJldHVybiBsZW5ndGggKyAxO1xufTtcblxuRGVxdWUucHJvdG90eXBlLnBlZWtCYWNrID0gZnVuY3Rpb24gRGVxdWUkcGVla0JhY2soKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCAtIDEpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgcmV0dXJuIHRoaXNbaW5kZXhdO1xufTtcblxuRGVxdWUucHJvdG90eXBlLnBlZWtGcm9udCA9IGZ1bmN0aW9uIERlcXVlJHBlZWtGcm9udCgpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW3RoaXMuX2Zyb250XTtcbn07XG5cbkRlcXVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBEZXF1ZSRnZXQoaW5kZXgpIHtcbiAgICB2YXIgaSA9IGluZGV4O1xuICAgIGlmICgoaSAhPT0gKGkgfCAwKSkpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgaSA9IGkgKyBsZW47XG4gICAgfVxuICAgIGlmIChpIDwgMCB8fCBpID49IGxlbikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1sodGhpcy5fZnJvbnQgKyBpKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpXTtcbn07XG5cbkRlcXVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gRGVxdWUkaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID09PSAwO1xufTtcblxuRGVxdWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gRGVxdWUkY2xlYXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aDtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICB2YXIgY2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgIHRoaXNbKGZyb250ICsgaikgJiAoY2FwYWNpdHkgLSAxKV0gPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJvbnQgPSAwO1xufTtcblxuRGVxdWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gRGVxdWUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLnRvU3RyaW5nKCk7XG59O1xuXG5EZXF1ZS5wcm90b3R5cGUudmFsdWVPZiA9IERlcXVlLnByb3RvdHlwZS50b1N0cmluZztcbkRlcXVlLnByb3RvdHlwZS5yZW1vdmVGcm9udCA9IERlcXVlLnByb3RvdHlwZS5zaGlmdDtcbkRlcXVlLnByb3RvdHlwZS5yZW1vdmVCYWNrID0gRGVxdWUucHJvdG90eXBlLnBvcDtcbkRlcXVlLnByb3RvdHlwZS5pbnNlcnRGcm9udCA9IERlcXVlLnByb3RvdHlwZS51bnNoaWZ0O1xuRGVxdWUucHJvdG90eXBlLmluc2VydEJhY2sgPSBEZXF1ZS5wcm90b3R5cGUucHVzaDtcbkRlcXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gRGVxdWUucHJvdG90eXBlLnB1c2g7XG5EZXF1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IERlcXVlLnByb3RvdHlwZS5zaGlmdDtcbkRlcXVlLnByb3RvdHlwZS50b0pTT04gPSBEZXF1ZS5wcm90b3R5cGUudG9BcnJheTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERlcXVlLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlwiKTtcbiAgICB9XG59KTtcblxuRGVxdWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gRGVxdWUkX2NoZWNrQ2FwYWNpdHkoc2l6ZSkge1xuICAgIGlmICh0aGlzLl9jYXBhY2l0eSA8IHNpemUpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplVG8oZ2V0Q2FwYWNpdHkodGhpcy5fY2FwYWNpdHkgKiAxLjUgKyAxNikpO1xuICAgIH1cbn07XG5cbkRlcXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiBEZXF1ZSRfcmVzaXplVG8oY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGZyb250ICsgbGVuZ3RoID4gb2xkQ2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgICAgICBhcnJheU1vdmUodGhpcywgMCwgdGhpcywgb2xkQ2FwYWNpdHksIG1vdmVJdGVtc0NvdW50KTtcbiAgICB9XG59O1xuXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gYXJyYXlNb3ZlKHNyYywgc3JjSW5kZXgsIGRzdCwgZHN0SW5kZXgsIGxlbikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZHN0W2ogKyBkc3RJbmRleF0gPSBzcmNbaiArIHNyY0luZGV4XTtcbiAgICAgICAgc3JjW2ogKyBzcmNJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwb3cyQXRMZWFzdChuKSB7XG4gICAgbiA9IG4gPj4+IDA7XG4gICAgbiA9IG4gLSAxO1xuICAgIG4gPSBuIHwgKG4gPj4gMSk7XG4gICAgbiA9IG4gfCAobiA+PiAyKTtcbiAgICBuID0gbiB8IChuID4+IDQpO1xuICAgIG4gPSBuIHwgKG4gPj4gOCk7XG4gICAgbiA9IG4gfCAobiA+PiAxNik7XG4gICAgcmV0dXJuIG4gKyAxO1xufVxuXG5mdW5jdGlvbiBnZXRDYXBhY2l0eShjYXBhY2l0eSkge1xuICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoY2FwYWNpdHkpKSB7XG4gICAgICAgICAgICBjYXBhY2l0eSA9IGNhcGFjaXR5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG93MkF0TGVhc3QoXG4gICAgICAgIE1hdGgubWluKFxuICAgICAgICAgICAgTWF0aC5tYXgoMTYsIGNhcGFjaXR5KSwgMTA3Mzc0MTgyNClcbiAgICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlcXVlO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwtP1xcZD9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgdmFyIGFjY3VtID0gdGhpcy5fbGVuXG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOykge1xuICAgIHZhciBhc3NpZ25lZCA9IGFjY3VtICUgYmxvY2tTaXplXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmRlcjsgaSsrKSB7XG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxuICAgIH1cblxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxuICAgIG9mZnNldCArPSByZW1haW5kZXJcblxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYmxvY2spXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fbGVuICs9IGxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciByZW0gPSB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVcblxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxuXG4gIC8vIHplcm8gKHJlbSArIDEpIHRyYWlsaW5nIGJpdHMsIHdoZXJlIChyZW0gKyAxKSBpcyB0aGUgc21hbGxlc3RcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgcmVtICsgMSlcblxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICB2YXIgYml0cyA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyB1aW50MzJcbiAgaWYgKGJpdHMgPD0gMHhmZmZmZmZmZikge1xuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAvLyB1aW50NjRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93Qml0cyA9IChiaXRzICYgMHhmZmZmZmZmZikgPj4+IDBcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXV0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiIsImltcG9ydCB7IENvbXBvbmVudCwgRG9jdW1lbnQgfSBmcm9tIFwiQHByYWd1ZS9hcHAtY29tcG9uZW50XCI7XHJcbmltcG9ydCB7IElDb250YWluZXJDb250ZXh0LCBJUnVudGltZSB9IGZyb20gXCJAcHJhZ3VlL2NvbnRhaW5lci1kZWZpbml0aW9uc1wiO1xyXG5pbXBvcnQgeyBDb3VudGVyLCBDb3VudGVyVmFsdWVUeXBlIH0gZnJvbSBcIkBwcmFndWUvbWFwXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ2xpY2tlciBleHRlbmRzIERvY3VtZW50IHtcclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSBjb21wb25lbnQncyBzY2hlbWEgYW5kIHBlcmZvcm0gb3RoZXIgaW5pdGlhbGl6YXRpb24gdGFza3NcclxuICAvLyAob25seSBjYWxsZWQgd2hlbiBkb2N1bWVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCkuXHJcbiAgcHJvdGVjdGVkIGFzeW5jIGNyZWF0ZSgpIHtcclxuICAgIHRoaXMucm9vdC5zZXQoXCJjbGlja3NcIiwgMCwgQ291bnRlclZhbHVlVHlwZS5OYW1lKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBhc3luYyByZW5kZXIoaG9zdDogSFRNTERpdkVsZW1lbnQpIHtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGRpc3RyaWJ1dGVkIENvdW50ZXJcclxuICAgIGNvbnN0IGNvdW50ZXIgPSBhd2FpdCB0aGlzLnJvb3Qud2FpdDxDb3VudGVyPihcImNsaWNrc1wiKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSA8c3Bhbj4gdGhhdCBkaXNwbGF5cyB0aGUgY3VycmVudCB2YWx1ZSBvZiAnY2xpY2tzJy5cclxuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGNvdW50ZXIudmFsdWUudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnJvb3Qub24oXCJ2YWx1ZUNoYW5nZWRcIiwgdXBkYXRlKTtcclxuICAgIHVwZGF0ZSgpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGJ1dHRvbiB0aGF0IGluY3JlbWVudHMgdGhlIHZhbHVlIG9mICdjbGlja3MnIHdoZW4gcHJlc3NlZC5cclxuICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgICBidG4udGV4dENvbnRlbnQgPSBcIitcIjtcclxuICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICBjb3VudGVyLmluY3JlbWVudCgxKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBib3RoIHRvIHRoZSA8ZGl2PiBwcm92aWRlZCBieSB0aGUgaG9zdDpcclxuICAgIGhvc3QuYXBwZW5kQ2hpbGQoc3Bhbik7XHJcbiAgICBob3N0LmFwcGVuZENoaWxkKGJ0bik7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgY29tcG9uZW50IGhhcyBiZWVuIGxvYWRlZC4gQXR0ZW1wdCB0byBnZXQgYSBkaXYgZnJvbSB0aGUgaG9zdC4gVE9ETyBleHBsYWluIHRoaXMgYmV0dGVyLlxyXG4gIHB1YmxpYyBhc3luYyBvcGVuZWQoKSB7XHJcbiAgICAvLyBJZiB0aGUgaG9zdCBwcm92aWRlZCBhIDxkaXY+LCByZW5kZXIgdGhlIGNvbXBvbmVudCBpbnRvIHRoYXQgRGl2XHJcbiAgICBjb25zdCBtYXliZURpdiA9IGF3YWl0IHRoaXMucGxhdGZvcm0ucXVlcnlJbnRlcmZhY2U8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpO1xyXG4gICAgaWYgKG1heWJlRGl2KSB7XHJcbiAgICAgIHRoaXMucmVuZGVyKG1heWJlRGl2KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZVJ1bnRpbWUoIGNvbnRleHQ6IElDb250YWluZXJDb250ZXh0ICk6IFByb21pc2U8SVJ1bnRpbWU+IHtcclxuICByZXR1cm4gQ29tcG9uZW50Lmluc3RhbnRpYXRlUnVudGltZShjb250ZXh0LCBcIkBjaGFpbmNvZGUvY291bnRlclwiLCBbXHJcbiAgICBbXCJAY2hhaW5jb2RlL2NvdW50ZXJcIiwgQ2xpY2tlcl1cclxuICBdKTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9