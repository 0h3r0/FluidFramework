// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../assert
//   ../debug
//   ../socket.io-client
//   ../gitresources
//   ../events

declare module 'prague' {
    export * from "prague/client-api/index";
}

declare module 'prague/client-api/index' {
    import * as api from "prague/api";
    export { api };
    import * as core from "prague/api-core";
    export { core };
    import * as cell from "prague/cell";
    export { cell };
    import * as utils from "prague/core-utils";
    export { utils };
    import * as types from "prague/data-types";
    export { types };
    import * as ink from "prague/ink";
    export { ink };
    import * as map from "prague/map";
    export { map };
    import * as mergeTree from "prague/merge-tree";
    export { mergeTree };
    import * as socketStorage from "prague/socket-storage";
    export { socketStorage };
    import * as assert from "assert";
    export { assert };
    import * as debug from "debug";
    export { debug };
    import * as socketIoClient from "socket.io-client";
    export { socketIoClient };
}

declare module 'prague/api' {
    export * from "prague/api/document";
}

declare module 'prague/api-core' {
    export * from "prague/api-core/collaborativeObject";
    export * from "prague/api-core/deltaConnection";
    export * from "prague/api-core/deltaManager";
    export * from "prague/api-core/document";
    export * from "prague/api-core/extension";
    export * from "prague/api-core/protocol";
    export * from "prague/api-core/storage";
    export * from "prague/api-core/types";
    export * from "prague/api-core/deltaManager";
    export * from "prague/api-core/localObjectStorageService";
    export * from "prague/api-core/objectStorageService";
}

declare module 'prague/cell' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { ICell } from "prague/data-types";
    /**
        * Cell snapshot definition
        */
    export interface ICellSnapshot {
            minimumSequenceNumber: number;
            offset: number;
            sequenceNumber: number;
            snapshot: any;
    }
    export enum CellValueType {
            Collaborative = 0,
            Plain = 1,
    }
    export interface ICollaborativeCellValue {
            type: string;
            id: string;
    }
    export interface ICellValue {
            type: string;
            value: any;
    }
    /**
        * The extension that defines the map
        */
    export class CellExtension implements api.IExtension {
            static Type: string;
            type: string;
            load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, header: string): ICell;
            create(document: api.IDocument, id: string): ICell;
    }
}

declare module 'prague/core-utils' {
    export * from "prague/core-utils/counters";
    export * from "prague/core-utils/promises";
    export * from "prague/core-utils/rangeTracker";
    export * from "prague/core-utils/utils";
}

declare module 'prague/data-types' {
    export * from "prague/data-types/cell";
    export * from "prague/data-types/map";
    export * from "prague/data-types/stream";
}

declare module 'prague/ink' {
    export * from "prague/ink/extension";
    export * from "prague/ink/snapshot";
}

declare module 'prague/map' {
    export * from "prague/map/map";
}

declare module 'prague/merge-tree' {
    import * as Collections from "prague/merge-tree/collections";
    export { Collections };
    export * from "prague/merge-tree/mergeTree";
    export * from "prague/merge-tree/ops";
    export * from "prague/merge-tree/sharedString";
    export * from "prague/merge-tree/properties";
    export { loadSegments } from "prague/merge-tree/text";
}

declare module 'prague/socket-storage' {
    export * from "prague/socket-storage/messages";
    export * from "prague/socket-storage/deltaStorageService";
    export * from "prague/socket-storage/documentService";
    export * from "prague/socket-storage/blobStorageService";
    export * from "prague/socket-storage/registration";
}

declare module 'prague/api/document' {
    import * as resources from "gitresources";
    import { ICollaborativeObject, IDistributedObjectServices, IDocumentService, IEnvelope, IExtension, ILatencyMessage, Registry } from "prague/api-core";
    import { ICell, IInk, IMap } from "prague/data-types";
    import * as mergeTree from "prague/merge-tree";
    export const defaultRegistry: Registry;
    export const defaultDocumentOptions: any;
    export function registerExtension(extension: IExtension): void;
    /**
        * Registers the default services to use for interacting with collaborative documents. To simplify the API it is
        * expected that the implementation provider of these will register themselves during startup prior to the user
        * requesting to load a collaborative object.
        */
    export function registerDocumentService(service: IDocumentService): void;
    export function getDefaultDocumentService(): IDocumentService;
    /**
        * A document is a collection of collaborative types.
        */
    export class Document {
            static Create(id: string, registry: Registry, service: IDocumentService, options: Object, version: resources.ICommit, connect: boolean): Promise<Document>;
            readonly clientId: string;
            readonly id: string;
            readonly options: Object;
            /**
                * Constructs a new collaborative object that can be attached to the document
                * @param type the identifier for the collaborative object type
                */
            create(type: string, id?: string): ICollaborativeObject;
            /**
                * Loads the specified distributed object. Returns null if it does not exist
                *
                * This method should not be called directly. Instead access should be obtained through the root map
                * or another distributed object.
                *
                * @param id Identifier of the object to load
                */
            get(id: string): ICollaborativeObject;
            /**
                * Attaches the given object to the document which also makes it available to collaborators. The object is
                * expected to immediately submit delta messages for itself once being attached.
                *
                * @param object
                */
            attach(object: ICollaborativeObject): IDistributedObjectServices;
            /**
                * Creates a new collaborative map
                */
            createMap(): IMap;
            /**
                * Creates a new collaborative cell.
                * TODO (tanvir): replace this with type class.
                */
            createCell(): ICell;
            /**
                * Creates a new collaborative string
                */
            createString(): mergeTree.SharedString;
            /**
                * Creates a new ink collaborative object
                */
            createInk(): IInk;
            /**
                * Retrieves the root collaborative object that the document is based on
                */
            getRoot(): IMap;
            /**
                * Closes the document and detaches all listeners
                */
            close(): void;
            submitObjectMessage(envelope: IEnvelope): Promise<void>;
            submitLatencyMessage(message: ILatencyMessage): void;
            on(event: string, listener: (...args: any[]) => void): this;
            removeListener(event: string, listener: (...args: any[]) => void): this;
            /**
                * Called to snapshot the given document
                */
            snapshot(): Promise<void>;
    }
    /**
        * Loads a collaborative object from the server
        */
    export function load(id: string, options?: Object, version?: resources.ICommit, registry?: Registry, service?: IDocumentService, connect?: boolean): Promise<Document>;
}

declare module 'prague/api-core/collaborativeObject' {
    import { EventEmitter } from "events";
    import { IDistributedObjectServices, IDocument } from "prague/api-core/document";
    import { IObjectMessage, ISequencedObjectMessage } from "prague/api-core/protocol";
    import { ITree } from "prague/api-core/storage";
    import { ICollaborativeObject } from "prague/api-core/types";
    export abstract class CollaborativeObject implements ICollaborativeObject {
            protected document: IDocument;
            id: string;
            type: string;
            protected services: IDistributedObjectServices;
            __collaborativeObject__: boolean;
            protected events: EventEmitter;
            readonly sequenceNumber: number;
            readonly minimumSequenceNumber: number;
            readonly referenceSequenceNumber: number;
            constructor(document: IDocument, id: string, type: string, sequenceNum: number, services?: IDistributedObjectServices);
            on(event: string, listener: (...args: any[]) => void): this;
            removeListener(event: string, listener: (...args: any[]) => void): this;
            removeAllListeners(event?: string): this;
            /**
                * Attaches the given collaborative object to its containing document
                */
            attach(): this;
            /**
                * Returns whether the given collaborative object is local
                */
            isLocal(): boolean;
            /**
                * Gets a form of the object that can be serialized.
                */
            abstract snapshot(): ITree;
            /**
                * Creates a new message from the provided message that is relative to the given sequenceNumber. It is valid
                * to modify the passed in object in place.
                */
            transform(message: IObjectMessage, sequenceNumber: number): IObjectMessage;
            /**
                * Allows the distributive data type the ability to perform custom processing prior to a delta
                * being submitted to the server
                */
            protected submitCore(message: IObjectMessage): void;
            /**
                * Allows the distributive data type the ability to perform custom processing once an attach has happened
                */
            protected attachCore(): void;
            protected abstract processCore(message: ISequencedObjectMessage): any;
            protected abstract processMinSequenceNumberChanged(value: number): any;
            /**
                * Processes a message by the local client
                */
            protected submitLocalOperation(contents: any): void;
    }
}

declare module 'prague/api-core/deltaConnection' {
    import { EventEmitter } from "events";
    import { IDeltaConnection, IDocument } from "prague/api-core/document";
    import { IObjectMessage, ITrace } from "prague/api-core/protocol";
    export class DeltaConnection implements IDeltaConnection {
            objectId: string;
            protected events: EventEmitter;
            readonly minimumSequenceNumber: number;
            readonly referenceSequenceNumber: number;
            /**
                * The lowest sequence number tracked by this map. Will normally be the document minimum
                * sequence number but may be higher in the case of an attach after the MSN.
                */
            readonly baseSequenceNumber: number;
            constructor(objectId: string, document: IDocument);
            /**
                * Sets the base mapping from a local sequence number to the document sequence number that matches it
                */
            setBaseMapping(sequenceNumber: number, documentSequenceNumber: number): void;
            /**
                * Returns whether or not setBaseMapping has been called
                */
            baseMappingIsSet(): boolean;
            on(event: string, listener: (...args: any[]) => void): this;
            emit(message: IObjectMessage, clientId: string, documentSequenceNumber: number, documentMinimumSequenceNumber: number, traces: ITrace[]): void;
            transformDocumentSequenceNumber(value: number): number;
            updateMinSequenceNumber(value: number): void;
            /**
                * Send new messages to the server
                */
            submit(message: IObjectMessage): Promise<void>;
    }
}

declare module 'prague/api-core/deltaManager' {
    import * as protocol from "prague/api-core/protocol";
    import * as storage from "prague/api-core/storage";
    /**
        * Helper class that manages incoming delta messages. This class ensures that collaborative objects receive delta
        * messages in order regardless of possible network conditions or timings causing out of order delivery.
        */
    export class DeltaManager {
            readonly referenceSequenceNumber: number;
            readonly minimumSequenceNumber: number;
            constructor(documentId: string, baseSequenceNumber: number, deltaStorage: storage.IDocumentDeltaStorageService, deltaConnection: storage.IDocumentDeltaConnection);
            /**
                * Submits a new delta operation
                */
            submit(type: string, contents: any): Promise<void>;
            /**
                * Submits an acked roundtrip operation.
                */
            submitRoundtrip(type: string, contents: protocol.ILatencyMessage): Promise<void>;
            onDelta(listener: (message: protocol.ISequencedDocumentMessage) => void): void;
            handleOp(message: protocol.ISequencedDocumentMessage): void;
    }
}

declare module 'prague/api-core/document' {
    import { IEnvelope, ILatencyMessage, IObjectMessage } from "prague/api-core/protocol";
    import { ICollaborativeObject } from "prague/api-core/types";
    export interface IObjectStorageService {
            /**
                * Reads the object contained at the given path. Returns a base64 string representation for the object.
                */
            read(path: string): Promise<string>;
    }
    export interface IDistributedObjectServices {
            deltaConnection: IDeltaConnection;
            objectStorage: IObjectStorageService;
    }
    /**
        * Interface to represent a connection to a delta notification stream
        */
    export interface IDeltaConnection {
            minimumSequenceNumber: number;
            referenceSequenceNumber: number;
            /**
                * Subscribe to events emitted by the object
                */
            on(event: string, listener: Function): this;
            /**
                * Send new messages to the server
                */
            submit(message: IObjectMessage): Promise<void>;
    }
    export interface IDocument {
            clientId: string;
            options: Object;
            attach(object: ICollaborativeObject): IDistributedObjectServices;
            get(id: string): ICollaborativeObject;
            submitObjectMessage(envelope: IEnvelope): any;
            submitLatencyMessage(message: ILatencyMessage): any;
    }
}

declare module 'prague/api-core/extension' {
    import * as resources from "gitresources";
    import { IDistributedObjectServices, IDocument } from "prague/api-core/document";
    import * as types from "prague/api-core/types";
    /**
        * Definitions of a collaborative extensions. Extensions follow a common model but enable custom behavior.
        */
    export interface IExtension {
            type: string;
            /**
                * Loads the given distributed object. This call is only ever invoked internally as the only thing
                * that is ever directly loaded is the document itself. Load will then only be called on documents that
                * were created and added to a collaborative object.
                *
                * document: The document the object is part of
                * connection: Interface used to retrieve updates from remote clients
                * version: Document version being loaded
                * header: Base64 encoded stored header for a snapshot. Or null if a new data type.
                * storage: Access to the data store to retrieve more information.
                *
                * Thought: should the storage object include the version information and limit access to just files
                * for the given object? The latter seems good in general. But both are probably good things. We then just
                * need a way to allow the document to provide later storage for the object.
                */
            load(document: IDocument, id: string, sequenceNumber: number, services: IDistributedObjectServices, version: resources.ICommit, header: string): types.ICollaborativeObject;
            /**
                * Creates a local version of the distributive object.
                *
                * Calling attach on the object later will insert it into object stream.
                * NOTE here - When we attach we need to submit all the pending ops prior to actually doing the attach
                * for consistency.
                */
            create(document: IDocument, id: string): types.ICollaborativeObject;
    }
    /**
        * Class that contains a collection of collaboration extensions
        */
    export class Registry {
            extensions: IExtension[];
            /**
                * Registers a new extension
                * @param extension The extension to register
                */
            register(extension: IExtension): void;
            /**
                * Retrieves the extension with the given id
                * @param id ID for the extension to retrieve
                */
            getExtension(type: string): IExtension;
    }
}

declare module 'prague/api-core/protocol' {
    import * as storage from "prague/api-core/storage";
    export const OperationType = "op";
    export const NoOp = "noop";
    export const ObjectOperation = "objOp";
    export const AttachObject = "attach";
    export const ClientJoin = "join";
    export const ClientLeave = "leave";
    export const RoundTrip = "tripComplete";
    /**
        * An envelope wraps the contents with the intended target
        */
    export interface IEnvelope {
            address: string;
            contents: any;
    }
    /**
        * Messages to track latency trace
        */
    export interface ITrace {
            service: string;
            action: string;
            timestamp: number;
    }
    /**
        * Message related to a distributed data type
        */
    export interface IObjectMessage {
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            type: string;
            contents: any;
    }
    /**
        * Sequenced message for a distributed data type
        */
    export interface ISequencedObjectMessage {
            sequenceNumber: number;
            minimumSequenceNumber: number;
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            clientId: string;
            type: string;
            contents: any;
            traces: ITrace[];
    }
    export interface IAttachMessage {
            id: string;
            type: string;
            snapshot: storage.ITree;
    }
    export interface ILatencyMessage {
            traces: ITrace[];
    }
    export interface IPingMessage {
            acked: boolean;
            traces: ITrace[];
    }
    /**
        * Document specific message
        */
    export interface IDocumentMessage {
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            type: string;
            contents: any;
            encrypted: boolean;
            encryptedContents: string;
            traces: ITrace[];
    }
    /**
        * Sequenced message for a distribute document
        */
    export interface ISequencedDocumentMessage {
            userId: string;
            clientId: string;
            sequenceNumber: number;
            minimumSequenceNumber: number;
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            type: string;
            contents: any;
            encrypted: boolean;
            encryptedContents: string;
            traces: ITrace[];
    }
}

declare module 'prague/api-core/storage' {
    import * as resources from "gitresources";
    import { IDocumentMessage, ISequencedDocumentMessage } from "prague/api-core/protocol";
    export interface IDocumentAttributes {
            sequenceNumber: number;
            minimumSequenceNumber: number;
    }
    export interface IObjectAttributes {
            sequenceNumber: number;
            type: string;
    }
    /**
        * The worker service connects to work manager (TMZ) and registers itself to receive work.
        */
    export interface IWorkerService {
            /**
                * Connects to tmz and subscribes to start working.
                */
            connect(type: string): Promise<any>;
    }
    /**
        * Type of entries that can be stored in a tree
        */
    export enum TreeEntry {
            Blob = 0,
            Tree = 1,
    }
    /**
        * Tree storage
        */
    export interface ITree {
            entries: ITreeEntry[];
    }
    /**
        * A tree entry wraps a path with a type of node
        */
    export interface ITreeEntry {
            path: string;
            type: string;
            value: IBlob | ITree;
    }
    /**
        * Raw blob stored within the tree
        */
    export interface IBlob {
            contents: string;
            encoding: string;
    }
    /**
        * Interface to provide access to snapshots saved for a collaborative object
        */
    export interface IDocumentStorageService {
            /**
                * Reads the object with the given ID
                */
            read(path: string): Promise<string>;
            /**
                * Writes to the object with the given ID
                */
            write(root: ITree, message: string): Promise<resources.ICommit>;
    }
    /**
        * Interface to provide access to stored deltas for a collaborative object
        */
    export interface IDocumentDeltaStorageService {
            /**
                * Retrieves all the delta operations within the inclusive sequence number range
                */
            get(from?: number, to?: number): Promise<ISequencedDocumentMessage[]>;
    }
    /**
        * Interface to provide access to stored deltas for a collaborative object
        */
    export interface IDeltaStorageService {
            /**
                * Retrieves all the delta operations within the inclusive sequence number range
                */
            get(id: string, from?: number, to?: number): Promise<ISequencedDocumentMessage[]>;
    }
    export interface ISnapshotTree {
            blobs: {
                    [path: string]: string;
            };
            trees: {
                    [path: string]: ISnapshotTree;
            };
    }
    /**
        * Document header returned from the server
        */
    export interface IDocumentHeader {
            attributes: IDocumentAttributes;
            distributedObjects: IDistributedObject[];
            transformedMessages: ISequencedDocumentMessage[];
            tree: ISnapshotTree;
    }
    /**
        * A distributed object is enough information to fully load a distributed object. The object may then require
        * a server call to load in more state.
        */
    export interface IDistributedObject {
            id: string;
            type: string;
            header: string;
            sequenceNumber: number;
    }
    export interface IDocumentDeltaConnection {
            /**
                * ClientID for the connection
                */
            clientId: string;
            /**
                * DocumentId for the connection
                */
            documentId: string;
            /**
                * Flag indicating whether connection is encrypted
                */
            encrypted: boolean;
            /**
                * Private key for decrypting deltas from the server
                */
            privateKey: string;
            /**
                * Public key for sending deltas to the server
                */
            publicKey: string;
            /**
                * Subscribe to events emitted by the document
                */
            on(event: string, listener: Function): this;
            /**
                * Submit a new message to the server
                */
            submit(message: IDocumentMessage): Promise<void>;
            /**
                * Dispatches the given event to any registered listeners.
                */
            dispatchEvent(name: string, ...args: any[]): any;
    }
    export interface IDocumentResource {
            /**
                * Client identifier for this session
                */
            clientId: string;
            /**
                * Document identifier
                */
            documentId: string;
            /**
                * Whether or not the document existed prior to connection
                */
            existing: boolean;
            /**
                * The latest snapshot version of the document at the time of connect. Or null if no snapshots have been taken.
                */
            version: resources.ICommit;
            /**
                * Connection to receive delta notification
                */
            deltaConnection: IDocumentDeltaConnection;
            /**
                * Access to storage associated with the document
                */
            documentStorageService: IDocumentStorageService;
            /**
                * Access to delta storage associated with the document
                */
            deltaStorageService: IDocumentDeltaStorageService;
            /**
                * Distributed objects contained within the document
                */
            distributedObjects: IDistributedObject[];
            /**
                * Messages whose values are between the msn and sequenceNumber
                */
            transformedMessages: ISequencedDocumentMessage[];
            /**
                * Pending deltas that have not yet been included in a snapshot
                */
            pendingDeltas: ISequencedDocumentMessage[];
            /**
                * The smallest sequence number that can be used as a reference sequence number
                */
            minimumSequenceNumber: number;
            /**
                * The sequence number represented by this version of the document
                */
            sequenceNumber: number;
            /**
                * Directory information for objects contained in the snapshot
                */
            tree: ISnapshotTree;
    }
    export interface IDocumentService {
            connect(id: string, version: resources.ICommit, connect: boolean, encrypted: boolean): Promise<IDocumentResource>;
    }
    export interface IBlobStorageService {
            /**
                * Returns the header.
                */
            getHeader(id: string, version: resources.ICommit): Promise<IDocumentHeader>;
            /**
                * Reads the blob content.
                */
            read(sha: string): Promise<string>;
            /**
                * Writes the content to blob storage.
                */
            write(id: string, tree: ITree, message: string): Promise<resources.ICommit>;
    }
}

declare module 'prague/api-core/types' {
    import * as protocol from "prague/api-core/protocol";
    import * as storage from "prague/api-core/storage";
    /**
        * Helper interface to wrap a snapshot with the sequence number it was taken at
        */
    export interface ICollaborativeObjectSnapshot {
            sequenceNumber: number;
            snapshot: any;
    }
    export interface ICollaborativeObject {
            /**
                * A readonly identifier for the collaborative object
                */
            id: string;
            /**
                * The type of the collaborative object
                */
            type: string;
            /**
                * Marker to clearly identify the object as a collaborative object
                */
            __collaborativeObject__: boolean;
            /**
                * Attaches an event listener for the given event
                */
            on(event: string, listener: Function): this;
            /**
                * Removes the specified listenever
                */
            removeListener(event: string, listener: Function): this;
            /**
                * Removes all listeners, or those of the specified event name
                */
            removeAllListeners(event?: string): this;
            /**
                * Attaches the given collaborative object to its containing document
                */
            attach(): this;
            /**
                * Returns whether the given collaborative object is local
                */
            isLocal(): boolean;
            /**
                * Gets a form of the object that can be serialized.
                * TODO this is temporary to bootstrap the process. For performance/dynamic load/etc... we'll likely expose
                * access to the snapshot behind the storage objects.
                */
            snapshot(): storage.ITree;
            /**
                * Transforms the given message relative to the provided sequence number
                */
            transform(message: protocol.IObjectMessage, sequenceNumber: number): protocol.IObjectMessage;
    }
}

declare module 'prague/api-core/localObjectStorageService' {
    import { IObjectStorageService } from "prague/api-core/document";
    import * as storage from "prague/api-core/storage";
    export class LocalObjectStorageService implements IObjectStorageService {
        constructor(tree: storage.ITree);
        read(path: string): Promise<string>;
        /**
          * Provides a synchronous access point to locally stored data
          */
        readSync(path: string): string;
    }
}

declare module 'prague/api-core/objectStorageService' {
    import { IObjectStorageService } from "prague/api-core/document";
    import { IDocumentStorageService, ISnapshotTree } from "prague/api-core/storage";
    export class ObjectStorageService implements IObjectStorageService {
        constructor(tree: ISnapshotTree, storage: IDocumentStorageService);
        read(path: string): Promise<string>;
    }
}

declare module 'prague/core-utils/counters' {
    /**
        * Computes a histogram of data values
        */
    export class Histogram {
            increment: number;
            buckets: number[];
            /**
                * Constructs a new histogram. Increment is used to create buckets for the data
                */
            constructor(increment: number);
            /**
                * Adds a new value to the histogram
                */
            add(value: number): void;
    }
    /**
        * Helper class to monitor throughput
        */
    export class ThroughputCounter {
            constructor(log: (value: string) => void, prefix?: string, intervalTime?: number);
            produce(count?: number): void;
            acknolwedge(count?: number): void;
    }
    /**
        * Simple class to help sample rate based counters
        */
    export class RateCounter {
            constructor();
            increment(value: number): void;
            /**
                * Starts the counter
                */
            reset(): void;
            elapsed(): number;
            /**
                * Returns the total accumulated value
                */
            getValue(): number;
            /**
                * Minimum value seen
                */
            getMinimum(): number;
            /**
                * Maximum value seen
                */
            getMaximum(): number;
            /**
                * Total number of samples provided to the counter
                */
            getSamples(): number;
            /**
                * Returns the rate for the counter
                */
            getRate(): number;
    }
}

declare module 'prague/core-utils/promises' {
    /**
        * A deferred creates a promise and the ability to resolve or reject it
        */
    export class Deferred<T> {
            constructor();
            /**
                * Retrieves the underlying promise for the deferred
                */
            readonly promise: Promise<T>;
            /**
                * Resolves the promise
                */
            resolve(value?: T | PromiseLike<T>): void;
            /**
                * Rejects the promsie
                */
            reject(error: any): void;
    }
}

declare module 'prague/core-utils/rangeTracker' {
    /**
      * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary
      * is continuous and always maps to a single value in secondary above the base value. The range
      * defines an increasing step function.
      */
    export class RangeTracker {
        readonly base: number;
        readonly primaryHead: any;
        readonly secondaryHead: any;
        constructor(primary: number, secondary: number);
        add(primary: number, secondary: number): void;
        get(primary: number): number;
        updateBase(primary: number): void;
    }
}

declare module 'prague/core-utils/utils' {
    /**
      * Returns the value of an object or sets to default if undefined.
      */
    export function getOrDefault<T>(value: T, def: T): T;
}

declare module 'prague/data-types/cell' {
    import * as api from "prague/api-core";
    /**
        * Collaborative cell interface
        */
    export interface ICell extends api.ICollaborativeObject {
            /**
                * Retrieves the cell value.
                */
            get(): Promise<any>;
            /**
                * Sets the cell value.
                */
            set(value: any): Promise<void>;
            /**
                * Checks whether cell is empty or not.
                */
            empty(): Promise<boolean>;
            /**
                * Delete the value from the cell.
                */
            delete(): Promise<void>;
    }
}

declare module 'prague/data-types/map' {
    import { ICollaborativeObject } from "prague/api-core";
    /**
        * Type of "valueChanged" event parameter
        */
    export interface IValueChanged {
            key: string;
    }
    /**
        * Type of "KeyValueChanged" event parameter
        */
    export interface IKeyValueChanged {
            key: string;
            value: any;
    }
    export interface IMapView {
            /**
                * Retrieves the given key from the map
                */
            get(key: string): any;
            /**
                * A form of get except it will only resolve the promise once the key exists in the map.
                */
            wait<T>(key: string): Promise<T>;
            /**
                * Returns a boolean indicating whether or not the key exists in the map
                */
            has(key: string): boolean;
            /**
                * Sets the key to the provided value
                */
            set(key: string, value: any): void;
            /**
                * Deletes the specified key from the map and returns the value of the key at the time of deletion.
                */
            delete(key: string): void;
            /**
                * Retreives all the keys contained within the map
                */
            keys(): IterableIterator<string>;
            /**
                * Removes all entries from the map
                */
            clear(): void;
            /**
                * Executes the provided callback function once per each key/value pair
                */
            forEach(callbackFn: (value, key) => void): any;
    }
    /**
        * Collaborative map interface
        */
    export interface IMap extends ICollaborativeObject {
            /**
                * Retrieves the given key from the map
                */
            get(key: string): Promise<any>;
            /**
                * A form of get except it will only resolve the promise once the key exists in the map.
                */
            wait<T>(key: string): Promise<T>;
            /**
                * Returns a boolean indicating whether or not the key exists in the map
                */
            has(key: string): Promise<boolean>;
            /**
                * Sets the key to the provided value
                */
            set(key: string, value: any): Promise<void>;
            /**
                * Deletes the specified key from the map and returns the value of the key at the time of deletion.
                */
            delete(key: string): Promise<void>;
            /**
                * Retreives all the keys contained within the map
                */
            keys(): Promise<string[]>;
            /**
                * Removes all entries from the map
                */
            clear(): Promise<void>;
            /**
                * Retreives a synchronous view of the map
                */
            getView(): Promise<IMapView>;
            /**
                * Creates a counter inside the map.
                */
            createCounter(key: string, value?: number, min?: number, max?: number): Promise<ICounter>;
            /**
                * Creates a set inside the map.
                */
            createSet<T>(key: string, value?: T[]): Promise<ISet<T>>;
    }
    /**
        * Counter interface
        */
    export interface ICounter {
            /**
                * Increment/decrement the underlying value.
                */
            increment(value: number): Promise<void>;
            /**
                * Increment/decrement the underlying value.
                */
            get(): Promise<number>;
    }
    /**
        * Set interface
        */
    export interface ISet<T> {
            /**
                * Inserts element to the set.
                */
            add(value: T): Promise<T[]>;
            /**
                * delete element from the set.
                */
            delete(value: T): Promise<T[]>;
            /**
                * Returns elements of the set.
                */
            entries(): Promise<T[]>;
    }
}

declare module 'prague/data-types/stream' {
    import * as api from "prague/api-core";
    export interface IPoint {
            x: number;
            y: number;
    }
    export interface IColor {
            r: number;
            g: number;
            b: number;
            a: number;
    }
    /**
        * Fluent implementation of the IDelta interface to make creation the underlying operation easier.
        * Only one operation per delta is currently supported but it's expected this will expand to multiple in
        * the future
        */
    export class Delta implements IDelta {
            operations: IOperation[];
            constructor(operations?: IOperation[]);
            /**
                * Composes two ink delta streams together - which is as simple as appending their operation
                * logs
                */
            compose(delta: IDelta): void;
            push(operation: IOperation): void;
            clear(time?: number): Delta;
            stylusUp(point: IPoint, pressure: number, id?: string, time?: number): Delta;
            stylusDown(point: IPoint, pressure: number, pen: IPen, layer?: number, id?: string, time?: number): Delta;
            stylusMove(point: IPoint, pressure: number, id?: string, time?: number): Delta;
    }
    /**
        * Retrieves the type of action contained within the operation
        */
    export function getActionType(operation: IOperation): ActionType;
    /**
        * Extracts the IStylusAction contained in the operation
        */
    export function getStylusAction(operation: IOperation): IStylusAction;
    /**
        * Helper function to retrieve the ID of the stylus operation
        */
    export function getStylusId(operation: IOperation): string;
    export interface IInk extends api.ICollaborativeObject {
            getLayers(): IInkLayer[];
            getLayer(key: string): IInkLayer;
            submitOp(op: IDelta): any;
    }
    /**
        * Pen data for the current stroke
        */
    export interface IPen {
            color: IColor;
            thickness: number;
    }
    /**
        * Type of action
        */
    export enum ActionType {
            StylusDown = 0,
            StylusUp = 1,
            StylusMove = 2,
            Clear = 3,
    }
    export interface IClearAction {
    }
    export interface IStylusAction {
            point: IPoint;
            pressure: number;
            id: string;
    }
    export interface IStylusDownAction extends IStylusAction {
            pen: IPen;
            layer: number;
    }
    export interface IStylusUpAction extends IStylusAction {
    }
    export interface IStylusMoveAction extends IStylusAction {
    }
    export interface IOperation {
            time: number;
            clear?: IClearAction;
            stylusDown?: IStylusDownAction;
            stylusUp?: IStylusUpAction;
            stylusMove?: IStylusMoveAction;
    }
    export interface IInkLayer {
            id: string;
            operations: IOperation[];
    }
    export interface IDelta {
            operations: IOperation[];
    }
    export interface IInk extends api.ICollaborativeObject {
            getLayers(): IInkLayer[];
            getLayer(key: string): IInkLayer;
            submitOp(op: IDelta): any;
    }
}

declare module 'prague/ink/extension' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    export class InkExtension implements api.IExtension {
        static Type: string;
        type: string;
        load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, header: string): api.ICollaborativeObject;
        create(document: api.IDocument, id: string): api.ICollaborativeObject;
    }
}

declare module 'prague/ink/snapshot' {
    import { IDelta, IInkLayer, IOperation } from "prague/data-types";
    export interface ISnapshot {
        layers: IInkLayer[];
        layerIndex: {
            [key: string]: number;
        };
    }
    export class Snapshot implements ISnapshot {
        layers: IInkLayer[];
        layerIndex: {
            [key: string]: number;
        };
        static Clone(snapshot: ISnapshot): Snapshot;
        constructor(layers?: IInkLayer[], layerIndex?: {
            [key: string]: number;
        });
        apply(delta: IDelta): void;
        applyOperation(operation: IOperation): void;
    }
}

declare module 'prague/map/map' {
    import { EventEmitter } from "events";
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { ICounter, IMap, IMapView, ISet } from "prague/data-types";
    export enum ValueType {
            Collaborative = 0,
            Plain = 1,
            Counter = 2,
            Set = 3,
    }
    export interface ICollaborativeMapValue {
            type: string;
            id: string;
    }
    export interface IMapValue {
            type: string;
            value: any;
    }
    /**
        * Copies all values from the provided MapView to the given Map
        */
    export function copyMap(from: IMapView, to: Map<string, any>): void;
    export class MapView implements IMapView {
            constructor(document: api.IDocument, id: string, data: {
                    [key: string]: IMapValue;
            }, events: EventEmitter, submitLocalOperation: (op) => void);
            forEach(callbackFn: (value, key) => void): void;
            get(key: string): any;
            wait<T>(key: string): Promise<T>;
            has(key: string): boolean;
            set(key: string, value: any): void;
            delete(key: string): void;
            keys(): IterableIterator<string>;
            clear(): void;
            /**
                * Serializes the collaborative map to a JSON string
                */
            serialize(): string;
            getMapValue(key: string): IMapValue;
            setCore(key: string, value: IMapValue): void;
            clearCore(): void;
            deleteCore(key: string): void;
            initCounter(key: string, value: number): void;
            initCounterCore(key: string, value: IMapValue): void;
            incrementCounter(key: string, value: number, min: number, max: number): void;
            incrementCounterCore(key: string, value: IMapValue): void;
            initSet<T>(key: string, value: T[]): void;
            initSetCore(key: string, value: IMapValue): void;
            insertSet<T>(key: string, value: T): T[];
            insertSetCore(key: string, value: IMapValue): void;
            deleteSet<T>(key: string, value: T): T[];
            deleteSetCore(key: string, value: IMapValue): void;
    }
    /**
        * Implementation of a map collaborative object
        */
    export class CollaborativeMap extends api.CollaborativeObject implements IMap {
            /**
                * Constructs a new collaborative map. If the object is non-local an id and service interfaces will
                * be provided
                */
            constructor(document: api.IDocument, id: string, sequenceNumber: number, services?: api.IDistributedObjectServices, version?: resources.ICommit, header?: string);
            keys(): Promise<string[]>;
            /**
                * Retrieves the value with the given key from the map.
                */
            get(key: string): Promise<any>;
            wait<T>(key: string): Promise<T>;
            has(key: string): Promise<boolean>;
            set(key: string, value: any): Promise<void>;
            delete(key: string): Promise<void>;
            clear(): Promise<void>;
            createCounter(key: string, value?: number, min?: number, max?: number): Promise<ICounter>;
            incrementCounter(key: string, value: number, min: number, max: number): Promise<any>;
            getCounterValue(key: string): Promise<number>;
            createSet<T>(key: string, value?: T[]): Promise<ISet<T>>;
            insertSet<T>(key: string, value: T): Promise<T[]>;
            deleteSet<T>(key: string, value: T): Promise<T[]>;
            enumerateSet<T>(key: string): Promise<T[]>;
            snapshot(): api.ITree;
            /**
                * Returns a synchronous view of the map
                */
            getView(): Promise<IMapView>;
            protected submitCore(message: api.IObjectMessage): void;
            protected processMinSequenceNumberChanged(value: number): void;
            protected processCore(message: api.ISequencedObjectMessage): void;
    }
    /**
        * The extension that defines the map
        */
    export class MapExtension implements api.IExtension {
            static Type: string;
            type: string;
            load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, header: string): IMap;
            create(document: api.IDocument, id: string): IMap;
    }
}

declare module 'prague/merge-tree/collections' {
    import * as Base from "prague/merge-tree/base";
    export class Stack<T> {
        items: T[];
        push(val: T): void;
        empty(): boolean;
        top(): T | undefined;
        pop(): T | undefined;
    }
    export function ListRemoveEntry<U>(entry: List<U>): List<U>;
    export function ListMakeEntry<U>(data: U): List<U>;
    export function ListMakeHead<U>(): List<U>;
    export class List<T> {
        isHead: boolean;
        data: T;
        next: List<T>;
        prev: List<T>;
        constructor(isHead: boolean, data: T);
        clear(): void;
        add(data: T): List<T>;
        dequeue(): T;
        enqueue(data: T): List<T>;
        walk(fn: (data: T, l: List<T>) => void): void;
        some(fn: (data: T, l: List<T>) => boolean, rev?: boolean): T;
        count(): number;
        first(): T;
        last(): T;
        empty(): boolean;
        pushEntry(entry: List<T>): void;
        push(data: T): void;
        popEntry(head: List<T>): List<T>;
        insertEntry(entry: List<T>): List<T>;
        insertAfter(data: T): List<T>;
        insertBefore(data: T): List<T>;
        insertEntryBefore(entry: List<T>): List<T>;
    }
    export interface Comparer<T> {
        compare(a: T, b: T): number;
        min: T;
    }
    export var numberComparer: Comparer<number>;
    export class Heap<T> {
        comp: Comparer<T>;
        L: T[];
        count(): number;
        constructor(a: T[], comp: Comparer<T>);
        peek(): T;
        get(): T;
        add(x: T): void;
    }
    export function LinearDictionary<TKey, TData>(compareKeys: Base.KeyComparer<TKey>): Base.SortedDictionary<TKey, TData>;
    export const enum Color {
        RED = 0,
        BLACK = 1,
    }
    export interface Node<TKey, TData> {
        key: TKey;
        data: TData;
        left: Node<TKey, TData>;
        right: Node<TKey, TData>;
        color: Color;
        size: number;
    }
    export class RedBlackTree<TKey, TData> implements Base.SortedDictionary<TKey, TData> {
        compareKeys: Base.KeyComparer<TKey>;
        root: Node<TKey, TData>;
        constructor(compareKeys: Base.KeyComparer<TKey>);
        makeNode(key: TKey, data: TData, color: Color, size: number): Node<TKey, TData>;
        isRed(node: Node<TKey, TData>): boolean;
        nodeSize(node: Node<TKey, TData>): number;
        size(): number;
        isEmpty(): Node<TKey, TData>;
        get(key: TKey): Node<TKey, TData>;
        nodeGet(node: Node<TKey, TData>, key: TKey): Node<TKey, TData>;
        contains(key: TKey): Node<TKey, TData>;
        put(key: TKey, data: TData, conflict?: Base.ConflictAction<TKey, TData>): void;
        nodePut(node: Node<TKey, TData>, key: TKey, data: TData, conflict?: Base.ConflictAction<TKey, TData>): Node<TKey, TData>;
        removeMin(): void;
        nodeRemoveMin(node: Node<TKey, TData>): Node<TKey, TData>;
        removeMax(): void;
        nodeRemoveMax(node: Node<TKey, TData>): Node<TKey, TData>;
        remove(key: TKey): void;
        nodeRemove(node: Node<TKey, TData>, key: TKey): Node<TKey, TData>;
        height(): any;
        nodeHeight(node: Node<TKey, TData>): any;
        floor(key: TKey): any;
        nodeFloor(node: Node<TKey, TData>, key: TKey): any;
        min(): Node<TKey, TData>;
        nodeMin(node: Node<TKey, TData>): Node<TKey, TData>;
        max(): Node<TKey, TData>;
        nodeMax(node: Node<TKey, TData>): Node<TKey, TData>;
        rotateRight(node: Node<TKey, TData>): Node<TKey, TData>;
        rotateLeft(node: Node<TKey, TData>): Node<TKey, TData>;
        oppositeColor(c: Color): Color;
        flipColors(node: Node<TKey, TData>): void;
        moveRedLeft(node: Node<TKey, TData>): Node<TKey, TData>;
        moveRedRight(node: Node<TKey, TData>): Node<TKey, TData>;
        balance(node: Node<TKey, TData>): Node<TKey, TData>;
        mapRange<TAccum>(action: Base.PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): void;
        map<TAccum>(action: Base.PropertyAction<TKey, TData>, accum?: TAccum): void;
        nodeMap<TAccum>(node: Node<TKey, TData>, action: Base.PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): any;
        diag(): void;
    }
    export interface TSTNode<T> {
        c: string;
        left?: TSTNode<T>;
        mid?: TSTNode<T>;
        right?: TSTNode<T>;
        val?: T;
    }
    export interface TSTPrefix {
        text: string;
    }
    export interface ProxString<T> {
        text: string;
        invDistance: number;
        val: T;
    }
    export class TST<T> {
        constructor();
        size(): number;
        contains(key: string): T;
        get(key: string): T;
        nodeGet(x: TSTNode<T>, key: string, d: number): TSTNode<T>;
        put(key: string, val: T): void;
        nodePut(x: TSTNode<T>, key: string, val: T, d: number): TSTNode<T>;
        neighbors(text: string, distance?: number): ProxString<T>[];
        keysWithPrefix(text: string): string[];
        collect(x: TSTNode<T>, prefix: TSTPrefix, q: string[]): void;
        patternCollect(x: TSTNode<T>, prefix: TSTPrefix, d: number, pattern: string, q: string[]): void;
        nodeProximity(x: TSTNode<T>, prefix: TSTPrefix, d: number, pattern: string, distance: number, q: ProxString<T>[]): void;
        match(pattern: string): string[];
    }
}

declare module 'prague/merge-tree/mergeTree' {
    import * as Collections from "prague/merge-tree/collections";
    import * as ops from "prague/merge-tree/ops";
    import * as API from "prague/api-core";
    import { ISequencedObjectMessage } from "prague/api-core";
    import * as Properties from "prague/merge-tree/properties";
    export type RangeStackMap = Properties.MapLike<Collections.Stack<Marker>>;
    export interface IRange {
            start: number;
            end: number;
    }
    export interface IMergeNode {
            parent: IMergeBlock;
            cachedLength: number;
            isLeaf(): boolean;
    }
    export interface IMergeBlock extends IMergeNode {
            childCount: number;
            children: IMergeNode[];
            partialLengths?: PartialSequenceLengths;
            hierBlock(): IHierBlock;
    }
    export interface IHierBlock extends IMergeBlock {
            hierToString(indentCount: number): any;
            addNodeMarkers(mergeTree: MergeTree, node: IMergeNode): any;
            rightmostTiles: Properties.MapLike<Marker>;
            leftmostTiles: Properties.MapLike<Marker>;
            rangeStacks: RangeStackMap;
    }
    export interface LocalReference {
            segment: Segment;
            offset: number;
            slideOnRemove?: boolean;
    }
    export enum SegmentType {
            Base = 0,
            Text = 1,
            Marker = 2,
            External = 3,
    }
    export interface Segment extends IMergeNode {
            segmentGroup?: SegmentGroup;
            seq?: number;
            clientId?: number;
            removedSeq?: number;
            removedClientId?: number;
            removedClientOverlap?: number[];
            localRefs?: LocalReference[];
            splitAt(pos: number): Segment;
            netLength(): number;
            canAppend(segment: Segment): boolean;
            append(segment: Segment): any;
            getType(): SegmentType;
            removeRange(start: number, end: number): boolean;
    }
    export interface SegmentAction<TClientData> {
            (segment: Segment, pos: number, refSeq: number, clientId: number, start: number, end: number, accum?: TClientData): boolean;
    }
    export interface SegmentChanges {
            next?: Segment;
            replaceCurrent?: Segment;
    }
    export interface BlockAction<TClientData> {
            (block: IMergeBlock, pos: number, refSeq: number, clientId: number, start: number, end: number, accum?: TClientData): boolean;
    }
    export interface NodeAction<TClientData> {
            (node: IMergeNode, pos: number, refSeq: number, clientId: number, start: number, end: number, clientData?: TClientData): boolean;
    }
    export interface IncrementalSegmentAction<TContext> {
            (segment: Segment, state: IncrementalMapState<TContext>): any;
    }
    export interface IncrementalBlockAction<TContext> {
            (state: IncrementalMapState<TContext>): any;
    }
    export interface BlockUpdateActions {
            child: (block: IMergeBlock, index: number) => void;
    }
    export interface InsertContext {
            prepareEvents?: boolean;
            leaf: (segment: Segment, pos: number) => SegmentChanges;
            continuePredicate?: (continueFromBlock: IMergeBlock) => boolean;
    }
    export interface SegmentActions<TClientData> {
            leaf?: SegmentAction<TClientData>;
            shift?: NodeAction<TClientData>;
            contains?: NodeAction<TClientData>;
            pre?: BlockAction<TClientData>;
            post?: BlockAction<TClientData>;
    }
    export interface IncrementalSegmentActions<TContext> {
            leaf: IncrementalSegmentAction<TContext>;
            pre?: IncrementalBlockAction<TContext>;
            post?: IncrementalBlockAction<TContext>;
    }
    export interface SearchResult {
            text: string;
            pos: number;
    }
    export interface MergeTreeStats {
            maxHeight: number;
            nodeCount: number;
            leafCount: number;
            removedLeafCount: number;
            liveCount: number;
            histo: number[];
            windowTime?: number;
            packTime?: number;
    }
    export interface SegmentGroup {
            segments: Segment[];
    }
    export interface OverlapClient {
            clientId: number;
            seglen: number;
    }
    export class IMergeNode implements IMergeNode {
            parent: IMergeBlock;
            cachedLength: number;
    }
    export let MaxNodesInBlock: number;
    export class MergeBlock extends IMergeNode implements IMergeBlock {
            childCount: number;
            children: IMergeNode[];
            constructor(childCount: number);
            hierBlock(): any;
    }
    export abstract class BaseSegment extends IMergeNode implements Segment {
            seq: number;
            clientId: number;
            constructor(seq?: number, clientId?: number);
            removedSeq: number;
            removedClientId: number;
            removedClientOverlap: number[];
            segmentGroup: SegmentGroup;
            properties: Properties.PropertySet;
            localRefs: LocalReference[];
            addLocalRef(lref: LocalReference): void;
            removeLocalRef(lref: LocalReference): LocalReference;
            addProperties(newProps: Properties.PropertySet, op?: ops.ICombiningOp): void;
            isLeaf(): boolean;
            cloneInto(b: BaseSegment): void;
            netLength(): number;
            canAppend(segment: Segment): boolean;
            abstract clone(): BaseSegment;
            abstract append(segment: Segment): Segment;
            abstract getType(): SegmentType;
            abstract removeRange(start: number, end: number): boolean;
            abstract splitAt(pos: number): Segment;
    }
    /**
        * A non-collaborative placeholder for external content.
        */
    export class ExternalSegment extends BaseSegment {
            placeholderSeq: any;
            charLength: number;
            lengthBytes: number;
            binPosition: number;
            constructor(placeholderSeq: any, charLength: number, lengthBytes: number, binPosition: number);
            mergeTreeInsert(mergeTree: MergeTree, pos: number, refSeq: number, clientId: number, seq: number): void;
            clone(): BaseSegment;
            append(segment: Segment): Segment;
            getType(): SegmentType;
            removeRange(start: number, end: number): boolean;
            splitAt(pos: number): Segment;
    }
    export let reservedTileLabelsKey: string;
    export let reservedRangeLabelsKey: string;
    export let reservedMarkerIdKey: string;
    export class Marker extends BaseSegment {
            behaviors: ops.MarkerBehaviors;
            static make(behavior: ops.MarkerBehaviors, props?: Properties.PropertySet, seq?: number, clientId?: number): Marker;
            constructor(behaviors: ops.MarkerBehaviors, seq?: number, clientId?: number);
            clone(): Marker;
            hasTileLabels(): any;
            hasRangeLabels(): any;
            hasTileLabel(label: string): boolean;
            hasRangeLabel(label: string): boolean;
            getTileLabels(): string[];
            getRangeLabels(): string[];
            getId(): any;
            toString(): string;
            getType(): SegmentType;
            removeRange(start: number, end: number): boolean;
            splitAt(pos: number): any;
            canAppend(segment: Segment): boolean;
            append(segment: Segment): any;
    }
    export class TextSegment extends BaseSegment {
            text: string;
            static make(text: string, props?: Properties.PropertySet, seq?: number, clientId?: number): TextSegment;
            constructor(text: string, seq?: number, clientId?: number);
            splitLocalRefs(pos: number, leafSegment: TextSegment): void;
            splitAt(pos: number): TextSegment;
            clone(): TextSegment;
            getType(): SegmentType;
            matchProperties(b: TextSegment): boolean;
            canAppend(segment: Segment): boolean;
            toString(): string;
            append(segment: Segment): this;
            removeRange(start: number, end: number): boolean;
    }
    export enum IncrementalExecOp {
            Go = 0,
            Stop = 1,
            Yield = 2,
    }
    export class IncrementalMapState<TContext> {
            block: IMergeBlock;
            actions: IncrementalSegmentActions<TContext>;
            pos: number;
            refSeq: number;
            clientId: number;
            context: TContext;
            start: number;
            end: number;
            childIndex: number;
            op: IncrementalExecOp;
            constructor(block: IMergeBlock, actions: IncrementalSegmentActions<TContext>, pos: number, refSeq: number, clientId: number, context: TContext, start: number, end: number, childIndex?: number);
    }
    /**
        * Sequence numbers for collaborative segments start at 1 or greater.  Every segment marked
        * with sequence number zero will be counted as part of the requested string.
        */
    export const UniversalSequenceNumber = 0;
    export const UnassignedSequenceNumber = -1;
    export const TreeMaintainanceSequenceNumber = -2;
    export const LocalClientId = -1;
    export const NonCollabClient = -2;
    export interface PartialSequenceLength {
            seq: number;
            len: number;
            seglen: number;
            clientId?: number;
            overlapClients?: Collections.RedBlackTree<number, OverlapClient>;
    }
    export class CollaborationWindow {
            clientId: number;
            collaborating: boolean;
            localMinSeq?: number;
            globalMinSeq?: number;
            minSeq: number;
            currentSeq: number;
            loadFrom(a: CollaborationWindow): void;
    }
    export function compareNumbers(a: number, b: number): number;
    /**
        * Keep track of partial sums of segment lengths for all sequence numbers
        * in the current collaboration window (if any).  Only used during active
        * collaboration.
        */
    export class PartialSequenceLengths {
            minSeq: number;
            minLength: number;
            segmentCount: number;
            partialLengths: PartialSequenceLength[];
            clientSeqNumbers: PartialSequenceLength[][];
            static options: {
                    zamboni: boolean;
            };
            constructor(minSeq: number);
            cliLatestLEQ(clientId: number, refSeq: number): number;
            cliLatest(clientId: number): number;
            compare(b: PartialSequenceLengths): boolean;
            toString(glc?: (id: number) => string): string;
            getPartialLength(refSeq: number, clientId: number): number;
            zamboni(segmentWindow: CollaborationWindow): void;
            addClientSeqNumber(clientId: number, seq: number, seglen: number): void;
            addClientSeqNumberFromPartial(partialLength: PartialSequenceLength): void;
            update(node: IMergeBlock, seq: number, clientId: number, collabWindow: CollaborationWindow): void;
            static fromLeaves(combinedPartialLengths: PartialSequenceLengths, block: IMergeBlock, collabWindow: CollaborationWindow): void;
            /**
                * Combine the partial lengths of textSegmentBlock's children
                * @param {TextSegmentBlock} textSegmentBlock an interior node; it is assumed that each interior node child of this block
                * has its partials up to date
                * @param {SegmentWindow} segmentWindow segment window fo the segment tree containing textSegmentBlock
                */
            static combine(block: IMergeBlock, collabWindow: CollaborationWindow, recur?: boolean): PartialSequenceLengths;
    }
    /**
        * Used for in-memory testing.  This will queue a reference string for each client message.
        */
    export const useCheckQ: boolean;
    export function internedSpaces(n: number): string;
    export class Client {
            mergeTree: MergeTree;
            accumTime: number;
            localTime: number;
            localOps: number;
            accumWindowTime: number;
            maxWindowTime: number;
            accumWindow: number;
            accumOps: number;
            verboseOps: boolean;
            measureOps: boolean;
            q: Collections.List<API.ISequencedObjectMessage>;
            checkQ: Collections.List<string>;
            clientSequenceNumber: number;
            clientNameToId: Collections.RedBlackTree<string, number>;
            shortClientIdMap: string[];
            longClientId: string;
            constructor(initText: string, options?: Properties.PropertySet);
            getOrAddShortClientId(longClientId: string): number;
            getShortClientId(longClientId: string): number;
            getLongClientId(clientId: number): string;
            addLongClientId(longClientId: string): void;
            makeInsertMarkerMsg(markerType: string, behaviors: ops.MarkerBehaviors, pos: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            makeInsertMsg(text: string, pos: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            makeRemoveMsg(start: number, end: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            makeAnnotateMsg(props: Properties.PropertySet, start: number, end: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            hasMessages(): boolean;
            enqueueMsg(msg: API.ISequencedObjectMessage): void;
            dequeueMsg(): API.ISequencedObjectMessage;
            enqueueTestString(): void;
            transformOp(op: ops.IMergeTreeOp, msg: API.ISequencedObjectMessage, toSequenceNumber: number): ops.IMergeTreeOp;
            transform(msg: API.ISequencedObjectMessage, toSequenceNumber: number): ISequencedObjectMessage;
            checkContingentOps(groupOp: ops.IMergeTreeGroupMsg, msg: API.ISequencedObjectMessage): boolean;
            applyOp(op: ops.IMergeTreeOp, msg: API.ISequencedObjectMessage): void;
            coreApplyMsg(msg: API.ISequencedObjectMessage): void;
            applyMsg(msg: API.ISequencedObjectMessage): void;
            applyMessages(msgCount: number): void;
            getLocalSequenceNumber(): 0 | -1;
            localTransaction(groupOp: ops.IMergeTreeGroupMsg): void;
            annotateSegmentLocal(props: Properties.PropertySet, start: number, end: number, op: ops.ICombiningOp): void;
            annotateSegmentRemote(props: Properties.PropertySet, start: number, end: number, seq: number, refSeq: number, clientId: number, combiningOp: ops.ICombiningOp): void;
            removeSegmentLocal(start: number, end: number): void;
            removeSegmentRemote(start: number, end: number, seq: number, refSeq: number, clientId: number): void;
            insertTextLocal(text: string, pos: number, props?: Properties.PropertySet): void;
            insertMarkerLocal(pos: number, behaviors: ops.MarkerBehaviors, props?: Properties.PropertySet): void;
            insertMarkerRemote(marker: ops.IMarkerDef, pos: number, props: Properties.PropertySet, seq: number, refSeq: number, clientId: number): void;
            insertTextRemote(text: string, pos: number, props: Properties.PropertySet, seq: number, refSeq: number, clientId: number): void;
            ackPendingSegment(seq: number): void;
            updateMinSeq(minSeq: number): void;
            getCurrentSeq(): number;
            getClientId(): number;
            getText(start?: number, end?: number): string;
            /**
                * Adds spaces for markers and components, so that position calculations account for them
                */
            getTextWithPlaceholders(): string;
            getTextRangeWithPlaceholders(start: number, end: number): string;
            getLength(): number;
            relText(clientId: number, refSeq: number): string;
            startCollaboration(longClientId: string, minSeq?: number): void;
    }
    export interface ClientSeq {
            refSeq: number;
            clientId: string;
    }
    export var clientSeqComparer: Collections.Comparer<ClientSeq>;
    /**
        * Server for tests.  Simulates client communication by directing placing
        * messages in client queues.
        */
    export class TestServer extends Client {
            seq: number;
            clients: Client[];
            listeners: Client[];
            clientSeqNumbers: Collections.Heap<ClientSeq>;
            constructor(initText: string);
            addClients(clients: Client[]): void;
            addListeners(listeners: Client[]): void;
            applyMsg(msg: API.ISequencedObjectMessage): boolean;
            applyMessages(msgCount: number): boolean;
    }
    export interface LRUSegment {
            segment?: Segment;
            maxSeq: number;
    }
    export interface TextAccumulator {
            textSegment: TextSegment;
            placeholders?: boolean;
    }
    export class MergeTree {
            text: string;
            options: Properties.PropertySet;
            static TextSegmentGranularity: number;
            static zamboniSegmentsMaxCount: number;
            static options: {
                    incrementalUpdate: boolean;
                    zamboniSegments: boolean;
                    measureWindowTime: boolean;
            };
            static searchChunkSize: number;
            static traceGatherText: boolean;
            static diagInsertTie: boolean;
            static skipLeftShift: boolean;
            static diagOverlappingRemove: boolean;
            static traceTraversal: boolean;
            static traceIncrTraversal: boolean;
            static initBlockUpdateActions: BlockUpdateActions;
            static theUnfinishedNode: IMergeBlock;
            windowTime: number;
            packTime: number;
            root: IMergeBlock;
            blockUpdateMarkers: boolean;
            blockUpdateActions: BlockUpdateActions;
            collabWindow: CollaborationWindow;
            pendingSegments: Collections.List<SegmentGroup>;
            segmentsToScour: Collections.Heap<LRUSegment>;
            idToSegment: Properties.MapLike<Segment>;
            transactionSegmentGroup: SegmentGroup;
            getLongClientId: (id: number) => string;
            constructor(text: string, options?: Properties.PropertySet);
            clone(): void;
            blockClone(block: IMergeBlock): MergeBlock;
            segmentClone(segment: Segment): BaseSegment;
            startGroupOperation(): void;
            endGroupOperation(): void;
            mapIdToSegment(id: string, segment: Segment): void;
            addNode(block: IMergeBlock, node: IMergeNode): number;
            reloadFromSegments(segments: Segment[]): void;
            startCollaboration(localClientId: number, minSeq: number): void;
            addToLRUSet(segment: Segment, seq: number): void;
            underflow(node: IMergeBlock): boolean;
            scourNode(node: IMergeBlock, holdNodes: IMergeNode[]): void;
            pack(block: IMergeBlock): void;
            zamboniSegments(): void;
            getCollabWindow(): CollaborationWindow;
            getStats(): MergeTreeStats;
            tardisPosition(pos: number, fromSeq: number, toSeq: number, toClientId?: number): number;
            tardisPositionFromClient(pos: number, fromSeq: number, toSeq: number, fromClientId: number, toClientId?: number): number;
            tardisRange(rangeStart: number, rangeEnd: number, fromSeq: number, toSeq: number, toClientId?: number): IRange[];
            getLength(refSeq: number, clientId: number): number;
            getOffset(node: IMergeNode, refSeq: number, clientId: number): number;
            searchFromPos(pos: number, target: RegExp): {
                    text: string;
                    pos: number;
            };
            gatherText: (segment: Segment, pos: number, refSeq: number, clientId: number, start: number, end: number, accumText: TextAccumulator) => boolean;
            incrementalGetText(refSeq: number, clientId: number, start?: number, end?: number): string;
            getText(refSeq: number, clientId: number, placeholders?: boolean, start?: number, end?: number): string;
            getContainingSegment(pos: number, refSeq: number, clientId: number): {
                    segment: Segment;
                    offset: number;
            };
            blockLength(node: IMergeBlock, refSeq: number, clientId: number): number;
            nodeLength(node: IMergeNode, refSeq: number, clientId: number): number;
            updateLocalMinSeq(localMinSeq: number): void;
            setMinSeq(minSeq: number): void;
            commitGlobalMin(): void;
            updateGlobalMinSeq(globalMinSeq: number): void;
            refPosToLocalPos(pos: number, refSeq: number, clientId: number): number;
            getStackContext(startPos: number, clientId: number, rangeLabels: string[]): Properties.MapLike<Collections.Stack<Marker>>;
            localUndo(segment: Segment): void;
            findTile(startPos: number, clientId: number, tileLabel: string, preceding?: boolean): {
                    tile: Marker;
                    pos: number;
            };
            search<TClientData>(pos: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            searchBlock<TClientData>(block: IMergeBlock, pos: number, segpos: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            backwardSearch<TClientData>(pos: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            backwardSearchBlock<TClientData>(block: IMergeBlock, pos: number, segEnd: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            updateRoot(splitNode: IMergeBlock, refSeq: number, clientId: number, seq: number): void;
            /**
                * Assign sequence number to existing segment; update partial lengths to reflect the change
                * @param seq sequence number given by server to pending segment
                */
            ackPendingSegment(seq: number): void;
            addToPendingList(segment: Segment, segmentGroup?: SegmentGroup): SegmentGroup;
            appendSegment(segSpec: ops.IPropertyString): void;
            getSegmentFromId(id: string): Segment;
            insert<T>(pos: number, refSeq: number, clientId: number, seq: number, segData: T, traverse: (block: IMergeBlock, pos: number, refSeq: number, clientId: number, seq: number, segData: T) => IMergeBlock): void;
            insertMarker(pos: number, refSeq: number, clientId: number, seq: number, behaviors: ops.MarkerBehaviors, props?: Properties.PropertySet): void;
            insertText(pos: number, refSeq: number, clientId: number, seq: number, text: string, props?: Properties.PropertySet): void;
            blockInsert<T extends Segment>(block: IMergeBlock, pos: number, refSeq: number, clientId: number, seq: number, newSegment: T): MergeBlock;
            splitLeafSegment: (segment: Segment, pos: number) => SegmentChanges;
            ensureIntervalBoundary(pos: number, refSeq: number, clientId: number): void;
            breakTie(pos: number, len: number, seq: number, node: IMergeNode, refSeq: number, clientId: number, segType: SegmentType): boolean;
            leftExcursion<TClientData>(node: IMergeNode, leafAction: SegmentAction<TClientData>): void;
            rightExcursion<TClientData>(node: IMergeNode, leafAction: SegmentAction<TClientData>): void;
            addOverlappingClient(textSegment: Segment, clientId: number): void;
            annotateRange(props: Properties.PropertySet, start: number, end: number, refSeq: number, clientId: number, seq: number, combiningOp?: ops.ICombiningOp): void;
            markRangeRemoved(start: number, end: number, refSeq: number, clientId: number, seq: number): void;
            removeRange(start: number, end: number, refSeq: number, clientId: number): void;
            nodeRemoveRange(block: IMergeBlock, start: number, end: number, refSeq: number, clientId: number): void;
            nodeUpdateLengthNewStructure(node: IMergeBlock, recur?: boolean): void;
            blockUpdate(block: IMergeBlock): void;
            blockUpdatePathLengths(block: IMergeBlock, seq: number, clientId: number, newStructure?: boolean): void;
            nodeCompareUpdateLength(node: IMergeBlock, seq: number, clientId: number): void;
            blockUpdateLength(node: IMergeBlock, seq: number, clientId: number): void;
            map<TClientData>(actions: SegmentActions<TClientData>, refSeq: number, clientId: number, accum?: TClientData): void;
            mapRange<TClientData>(actions: SegmentActions<TClientData>, refSeq: number, clientId: number, accum?: TClientData, start?: number, end?: number): void;
            rangeToString(start: number, end: number): string;
            nodeToString(block: IMergeBlock, strbuf: string, indentCount?: number): string;
            toString(): string;
            incrementalBlockMap<TContext>(stateStack: Collections.Stack<IncrementalMapState<TContext>>): void;
            nodeMap<TClientData>(node: IMergeBlock, actions: SegmentActions<TClientData>, pos: number, refSeq: number, clientId: number, accum?: TClientData, start?: number, end?: number): boolean;
            nodeMapReverse<TClientData>(block: IMergeBlock, actions: SegmentActions<TClientData>, pos: number, refSeq: number, clientId: number, accum?: TClientData): any;
    }
}

declare module 'prague/merge-tree/ops' {
    export enum MarkerBehaviors {
        None = 0,
        Tile = 1,
        RangeBegin = 2,
        RangeEnd = 4,
        SlideOnRemove = 16,
    }
    export interface IMarkerDef {
        behaviors?: MarkerBehaviors;
    }
    export interface IComponentDef {
        url: string;
    }
    export const enum MergeTreeDeltaType {
        INSERT = 0,
        REMOVE = 1,
        ANNOTATE = 2,
        GROUP = 3,
    }
    export interface IMergeTreeDelta {
        /**
          * Type of this change.
          */
        type: MergeTreeDeltaType;
    }
    export interface IMarkerPosition {
        id: string;
    }
    export interface IMergeTreeInsertMsg extends IMergeTreeDelta {
        type: MergeTreeDeltaType.INSERT;
        pos1?: number;
        markerPos1?: IMarkerPosition;
        props?: Object;
        text?: string;
        marker?: IMarkerDef;
        component?: IComponentDef;
    }
    export interface IMergeTreeRemoveMsg extends IMergeTreeDelta {
        type: MergeTreeDeltaType.REMOVE;
        pos1?: number;
        markerPos1?: IMarkerPosition;
        pos2?: number;
        markerPos2?: IMarkerPosition;
    }
    export interface ICombiningOp {
        name: string;
        defaultValue?: any;
        minValue?: any;
        maxValue?: any;
    }
    export interface IContingencyCheck {
        props: Object;
    }
    export interface IMergeTreeAnnotateMsg extends IMergeTreeDelta {
        type: MergeTreeDeltaType.ANNOTATE;
        pos1?: number;
        markerPos1?: IMarkerPosition;
        pos2?: number;
        markerPos2?: IMarkerPosition;
        props: Object;
        combiningOp?: ICombiningOp;
        when?: IContingencyCheck;
    }
    export interface IMergeTreeGroupMsg extends IMergeTreeDelta {
        type: MergeTreeDeltaType.GROUP;
        hasContingentOps?: boolean;
        ops: IMergeTreeOp[];
    }
    export type IMergeTreeOp = IMergeTreeInsertMsg | IMergeTreeRemoveMsg | IMergeTreeAnnotateMsg | IMergeTreeGroupMsg;
    export interface IPropertyString {
        props?: Object;
        text?: string;
        marker?: IMarkerDef;
    }
    export interface MergeTreeChunk {
        chunkStartSegmentIndex: number;
        chunkSegmentCount: number;
        chunkLengthChars: number;
        totalLengthChars: number;
        totalSegmentCount: number;
        chunkSequenceNumber: number;
        segmentTexts: IPropertyString[];
    }
}

declare module 'prague/merge-tree/sharedString' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import * as MergeTree from "prague/merge-tree/mergeTree";
    import * as ops from "prague/merge-tree/ops";
    import * as Properties from "prague/merge-tree/properties";
    export class CollaboritiveStringExtension implements api.IExtension {
        static Type: string;
        type: string;
        load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, header: string): api.ICollaborativeObject;
        create(document: api.IDocument, id: string, options?: Object): api.ICollaborativeObject;
    }
    export class SharedString extends api.CollaborativeObject {
        id: string;
        client: MergeTree.Client;
        readonly loaded: Promise<void>;
        constructor(document: api.IDocument, id: string, sequenceNumber: number, services?: api.IDistributedObjectServices);
        load(sequenceNumber: number, header: string, collaborative: boolean): Promise<void>;
        insertMarker(pos: number, behaviors: ops.MarkerBehaviors, props?: Properties.PropertySet): void;
        insertText(text: string, pos: number, props?: Properties.PropertySet): void;
        removeText(start: number, end: number): void;
        annotateRangeFromPast(props: Properties.PropertySet, start: number, end: number, fromSeq: number): void;
        transaction(groupOp: ops.IMergeTreeGroupMsg): void;
        annotateRange(props: Properties.PropertySet, start: number, end: number, op?: ops.ICombiningOp): void;
        setLocalMinSeq(lmseq: number): void;
        snapshot(): api.ITree;
        transform(message: api.IObjectMessage, toSequenceNumber: number): api.IObjectMessage;
        protected processCore(message: api.ISequencedObjectMessage): void;
        protected processMinSequenceNumberChanged(value: number): void;
        protected attachCore(): void;
    }
}

declare module 'prague/merge-tree/properties' {
    import * as ops from "prague/merge-tree/ops";
    import * as Collections from "prague/merge-tree/collections";
    /**
      * For each contingent property, a list of contingent local changes,
      * in change order.
      */
    export type ContingentPropertySet = MapLike<Collections.List<any>>;
    export interface MapLike<T> {
        [index: string]: T;
    }
    export type PropertySet = MapLike<any>;
    export function combine(combiningInfo: ops.ICombiningOp, currentValue: any, newValue: any): any;
    export function matchProperties(a: PropertySet, b: PropertySet): boolean;
    export function readContingentProperty(name: string, props: PropertySet, contingentProps: ContingentPropertySet): any;
    export function contingentExtend<T>(contingentBase: ContingentPropertySet, base: MapLike<T>, extension: MapLike<T>, combiningOp?: ops.ICombiningOp): MapLike<T>;
    export function extend<T>(base: MapLike<T>, extension: MapLike<T>, combiningOp?: ops.ICombiningOp): MapLike<T>;
    export function extendIfUndefined<T>(base: MapLike<T>, extension: MapLike<T>): MapLike<T>;
    /** Create a MapLike with good performance. */
    export function createMap<T>(): MapLike<T>;
}

declare module 'prague/merge-tree/text' {
    import * as MergeTree from "prague/merge-tree/mergeTree";
    export function loadTextFromFile(filename: string, mergeTree: MergeTree.MergeTree, segLimit?: number): MergeTree.MergeTree;
    export function loadTextFromFileWithMarkers(filename: string, mergeTree: MergeTree.MergeTree, segLimit?: number): MergeTree.MergeTree;
    export function loadSegments(content: string, segLimit: number, markers?: boolean): MergeTree.Segment[];
    export function loadText(content: string, mergeTree: MergeTree.MergeTree, segLimit: number, markers?: boolean): MergeTree.MergeTree;
}

declare module 'prague/socket-storage/messages' {
    /**
        * Message sent to connect to the given object
        */
    export interface IConnect {
            id: string;
            privateKey: string;
            publicKey: string;
            encrypted: boolean;
    }
    /**
        * Message sent to indicate a client has connected to the server
        *
        * TODO Is the below a connection to the actual Kafka stream?
        */
    export interface IConnected {
            clientId: string;
            existing: boolean;
            privateKey: string;
            publicKey: string;
            encrypted: boolean;
    }
    /**
        * Message sent to indicate that a shadow client has connected to the server.
        */
    export interface IShadowConnected {
            clientId: string;
    }
    /**
        * Message sent to connect to the given object
        */
    export interface IWorker {
            clientId: string;
            type: string;
    }
}

declare module 'prague/socket-storage/deltaStorageService' {
    import * as api from "prague/api-core";
    /**
        * Storage service limited to only being able to fetch documents for a specific document
        */
    export class DocumentDeltaStorageService implements api.IDocumentDeltaStorageService {
            constructor(id: string, storageService: api.IDeltaStorageService);
            get(from?: number, to?: number): Promise<api.ISequencedDocumentMessage[]>;
    }
    /**
        * Provides access to the underlying delta storage on the server
        */
    export class DeltaStorageService implements api.IDeltaStorageService {
            constructor(url: string);
            get(id: string, from?: number, to?: number): Promise<api.ISequencedDocumentMessage[]>;
    }
}

declare module 'prague/socket-storage/documentService' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    export class DocumentResource implements api.IDocumentResource {
            documentId: string;
            clientId: string;
            existing: boolean;
            version: resources.ICommit;
            deltaConnection: api.IDocumentDeltaConnection;
            documentStorageService: api.IDocumentStorageService;
            deltaStorageService: api.IDocumentDeltaStorageService;
            distributedObjects: api.IDistributedObject[];
            pendingDeltas: api.ISequencedDocumentMessage[];
            transformedMessages: api.ISequencedDocumentMessage[];
            sequenceNumber: number;
            minimumSequenceNumber: number;
            tree: api.ISnapshotTree;
            constructor(documentId: string, clientId: string, existing: boolean, version: resources.ICommit, deltaConnection: api.IDocumentDeltaConnection, documentStorageService: api.IDocumentStorageService, deltaStorageService: api.IDocumentDeltaStorageService, distributedObjects: api.IDistributedObject[], pendingDeltas: api.ISequencedDocumentMessage[], transformedMessages: api.ISequencedDocumentMessage[], sequenceNumber: number, minimumSequenceNumber: number, tree: api.ISnapshotTree);
    }
    /**
        * The DocumentService manages the Socket.IO connection and manages routing requests to connected
        * clients
        */
    export class DocumentService implements api.IDocumentService {
            constructor(url: string, deltaStorage: api.IDeltaStorageService, blobStorge: api.IBlobStorageService);
            connect(id: string, version: resources.ICommit, connect: boolean, encrypted: boolean): Promise<api.IDocumentResource>;
            /**
                * Emits a message on the socket
                */
            emit(event: string, ...args: any[]): void;
            /**
                * Registers the given connection to receive events of the given type
                */
            registerForEvent(event: string, connection: api.IDocumentDeltaConnection): void;
    }
}

declare module 'prague/socket-storage/blobStorageService' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import * as gitStorage from "prague/git-storage";
    /**
        * Document access to underlying storage
        */
    export class DocumentStorageService implements api.IDocumentStorageService {
            constructor(id: string, version: resources.ICommit, storage: api.IBlobStorageService);
            read(sha: string): Promise<string>;
            write(tree: api.ITree, message: string): Promise<resources.ICommit>;
    }
    /**
        * Client side access to object storage.
        */
    export class BlobStorageService implements api.IBlobStorageService {
            constructor(manager: gitStorage.GitManager);
            getHeader(id: string, version: resources.ICommit): Promise<api.IDocumentHeader>;
            read(sha: string): Promise<string>;
            write(id: string, tree: api.ITree, message: string): Promise<resources.ICommit>;
    }
}

declare module 'prague/socket-storage/registration' {
    import * as apiCore from "prague/api-core";
    export function getDefaultService(deltaUrl: string, blobUrl: string, repository: string): apiCore.IDocumentService;
    export function registerAsDefault(deltaUrl: string, blobUrl: string, repository: string): void;
}

declare module 'prague/merge-tree/base' {
    export interface Property<TKey, TData> {
        key: TKey;
        data: TData;
    }
    export interface PropertyAction<TKey, TData> {
        <TAccum>(p: Property<TKey, TData>, accum: TAccum): boolean;
    }
    export interface ConflictAction<TKey, TData> {
        (key: TKey, current: TData, proposed: TData): TData;
    }
    export interface Dictionary<TKey, TData> {
        get(key: TKey): Property<TKey, TData>;
        put(key: TKey, data: TData, conflict?: ConflictAction<TKey, TData>): any;
        remove(key: TKey): any;
        map<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum): any;
        diag(): any;
    }
    export interface SortedDictionary<TKey, TData> extends Dictionary<TKey, TData> {
        max(): Property<TKey, TData>;
        min(): Property<TKey, TData>;
        mapRange<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): any;
    }
    export interface KeyComparer<TKey> {
        (a: TKey, b: TKey): number;
    }
}

declare module 'prague/git-storage' {
    export * from "prague/git-storage/gitManager";
}

declare module 'prague/git-storage/gitManager' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    export class GitManager {
            constructor(historian: resources.IHistorian, repository: string);
            getHeader(id: string, sha: string): Promise<api.IDocumentHeader>;
            getCommit(sha: string): Promise<resources.ICommit>;
            /**
                * Reads the object with the given ID. We defer to the client implementation to do the actual read.
                */
            getCommits(sha: string, count: number): Promise<resources.ICommit[]>;
            /**
                * Reads the object with the given ID. We defer to the client implementation to do the actual read.
                */
            getTree(root: string, recursive?: boolean): Promise<resources.ITree>;
            getBlob(sha: string): Promise<resources.IBlob>;
            /**
                * Retrieves the object at the given revision number
                */
            getObject(commit: string, path: string): Promise<any>;
            createBlob(content: string, encoding: string): Promise<resources.ICreateBlobResponse>;
            createTree(files: api.ITree): Promise<resources.ITree>;
            createCommit(commit: resources.ICreateCommitParams): Promise<resources.ICommit>;
            upsertRef(branch: string, commitSha: string): Promise<resources.IRef>;
            /**
                * Writes to the object with the given ID
                */
            write(branch: string, inputTree: api.ITree, message: string): Promise<resources.ICommit>;
    }
    export function getOrCreateRepository(historian: resources.IHistorian, repository: string): Promise<GitManager>;
}

