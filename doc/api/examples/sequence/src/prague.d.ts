// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../assert
//   ../debug
//   ../socket.io-client
//   ../events
//   ../gitresources

declare module 'prague' {
    import * as api from "prague/api";
    export { api };
    import * as core from "prague/api-core";
    export { core };
    import * as cell from "prague/cell";
    export { cell };
    import * as utils from "prague/core-utils";
    export { utils };
    import * as types from "prague/data-types";
    export { types };
    import * as stream from "prague/stream";
    export { stream };
    import * as map from "prague/map";
    export { map };
    import * as graph from "prague/graph";
    export { graph };
    import * as MergeTree from "prague/merge-tree";
    export { MergeTree };
    import * as socketStorage from "prague/socket-storage";
    export { socketStorage };
    import * as assert from "assert";
    export { assert };
    import * as debug from "debug";
    export { debug };
    import * as socketIoClient from "socket.io-client";
    export { socketIoClient };
}

declare module 'prague/api' {
    export * from "prague/api/document";
}

declare module 'prague/api-core' {
    export * from "prague/api-core/collaborativeObject";
    export * from "prague/api-core/deltaConnection";
    export * from "prague/api-core/deltaManager";
    export * from "prague/api-core/document";
    export * from "prague/api-core/extension";
    export * from "prague/api-core/protocol";
    export * from "prague/api-core/storage";
    export * from "prague/api-core/tenant";
    export * from "prague/api-core/types";
    export * from "prague/api-core/deltaManager";
    export * from "prague/api-core/localObjectStorageService";
    export * from "prague/api-core/objectStorageService";
}

declare module 'prague/cell' {
    export * from "prague/cell/extension";
    export * from "prague/cell/cell";
}

declare module 'prague/core-utils' {
    export * from "prague/core-utils/auth";
    export * from "prague/core-utils/batchManager";
    export * from "prague/core-utils/counters";
    export * from "prague/core-utils/messages";
    export * from "prague/core-utils/promises";
    export * from "prague/core-utils/rangeTracker";
    export * from "prague/core-utils/utils";
}

declare module 'prague/data-types' {
    export * from "prague/data-types/cell";
    export * from "prague/data-types/map";
    export * from "prague/data-types/set";
    export * from "prague/data-types/stream";
    export * from "prague/data-types/graph";
}

declare module 'prague/stream' {
    export * from "prague/stream/extension";
    export * from "prague/stream/snapshot";
}

declare module 'prague/map' {
    export * from "prague/map/array";
    export * from "prague/map/counter";
    export * from "prague/map/extension";
    export * from "prague/map/map";
    export * from "prague/map/set";
    export * from "prague/map/view";
}

declare module 'prague/graph' {
    export * from "prague/graph/graph";
}

declare module 'prague/merge-tree' {
    import * as Collections from "prague/merge-tree/collections";
    export { Collections };
    export * from "prague/merge-tree/extension";
    export * from "prague/merge-tree/mergeTree";
    export * from "prague/merge-tree/ops";
    export * from "prague/merge-tree/sharedString";
    export * from "prague/merge-tree/properties";
    export { loadSegments } from "prague/merge-tree/text";
}

declare module 'prague/socket-storage' {
    export * from "prague/socket-storage/messages";
    export * from "prague/socket-storage/deltaStorageService";
    export * from "prague/socket-storage/documentService";
    export * from "prague/socket-storage/blobStorageService";
    export * from "prague/socket-storage/registration";
}

declare module 'prague/api/document' {
    import { EventEmitter } from "events";
    import * as resources from "gitresources";
    import { ICollaborativeObject, ICollaborativeObjectSave, IDeltaConnection, IDistributedObjectServices, IDocumentService, IEnvelope, IExtension, ILatencyMessage, IObjectStorageService, Registry } from "prague/api-core";
    import { ICell, IMap, IStream } from "prague/data-types";
    import * as mergeTree from "prague/merge-tree";
    export const defaultRegistry: Registry;
    export const defaultDocumentOptions: any;
    export interface IAttachedServices {
            deltaConnection: IDeltaConnection;
            objectStorage: IObjectStorageService;
    }
    export function registerExtension(extension: IExtension): void;
    /**
        * Registers the default services to use for interacting with collaborative documents. To simplify the API it is
        * expected that the implementation provider of these will register themselves during startup prior to the user
        * requesting to load a collaborative object.
        */
    export function registerDocumentService(service: IDocumentService): void;
    export function getDefaultDocumentService(): IDocumentService;
    /**
        * A document is a collection of collaborative types.
        */
    export class Document extends EventEmitter {
            static Load(id: string, registry: Registry, service: IDocumentService, options: Object, version: resources.ICommit, connect: boolean): Promise<Document>;
            readonly clientId: string;
            readonly id: string;
            /**
                * Flag indicating whether the document already existed at the time of load
                */
            readonly existing: boolean;
            /**
                * Returns the parent branch for this document
                */
            readonly parentBranch: string;
            readonly options: Object;
            /**
                * Constructs a new collaborative object that can be attached to the document
                * @param type the identifier for the collaborative object type
                */
            create(type: string, id?: string): ICollaborativeObject;
            /**
                * Loads the specified distributed object. Returns null if it does not exist
                *
                * This method should not be called directly. Instead access should be obtained through the root map
                * or another distributed object.
                *
                * @param id Identifier of the object to load
                */
            get(id: string): Promise<ICollaborativeObject>;
            /**
                * Attaches the given object to the document which also makes it available to collaborators. The object is
                * expected to immediately submit delta messages for itself once being attached.
                *
                * @param object
                */
            attach(object: ICollaborativeObject): IDistributedObjectServices;
            /**
                * Creates a new collaborative map
                */
            createMap(): IMap;
            /**
                * Creates a new collaborative cell.
                * TODO (tanvir): replace this with type class.
                */
            createCell(): ICell;
            /**
                * Creates a new collaborative string
                */
            createString(): mergeTree.SharedString;
            /**
                * Creates a new ink collaborative object
                */
            createStream(): IStream;
            /**
                * Retrieves the root collaborative object that the document is based on
                */
            getRoot(): IMap;
            /**
                * Saves the document by performing a snapshot.
                */
            save(tag?: string): void;
            /**
                * Closes the document and detaches all listeners
                */
            close(): void;
            submitObjectMessage(envelope: IEnvelope): Promise<void>;
            submitSaveMessage(message: ICollaborativeObjectSave): Promise<void>;
            submitLatencyMessage(message: ILatencyMessage): void;
            branch(): Promise<string>;
            /**
                * Called to snapshot the given document
                */
            snapshot(tagMessage?: string): Promise<void>;
            /**
                * Returns the user id connected to the document.
                */
            getUser(): any;
    }
    /**
        * Loads a specific version (commit) of the collaborative object
        */
    export function load(id: string, options?: Object, version?: resources.ICommit, connect?: boolean, registry?: Registry, service?: IDocumentService): Promise<Document>;
}

declare module 'prague/api-core/collaborativeObject' {
    import { EventEmitter } from "events";
    import { ICommit } from "gitresources";
    import { IDistributedObjectServices, IDocument, IObjectStorageService } from "prague/api-core/document";
    import { IObjectMessage, ISequencedObjectMessage } from "prague/api-core/protocol";
    import { ITree } from "prague/api-core/storage";
    import { ICollaborativeObject } from "prague/api-core/types";
    export abstract class CollaborativeObject extends EventEmitter implements ICollaborativeObject {
            id: string;
            protected document: IDocument;
            type: string;
            __collaborativeObject__: boolean;
            readonly sequenceNumber: number;
            constructor(id: string, document: IDocument, type: string);
            /**
                * A collaborative object, after construction, can either be loaded in the case that it is already part of
                * a collaborative document. Or later attached if it is being newly added.
                */
            load(sequenceNumber: number, version: ICommit, headerOrigin: string, services: IDistributedObjectServices): Promise<void>;
            /**
                * Initializes the object as a local, non-collaborative object. This object can become collaborative after
                * it is attached to the document.
                */
            initializeLocal(): void;
            /**
                * Attaches the given collaborative object to its containing document
                */
            attach(): this;
            /**
                * Returns whether the given collaborative object is local
                */
            isLocal(): boolean;
            /**
                * Gets a form of the object that can be serialized.
                */
            abstract snapshot(): ITree;
            /**
                * Creates a new message from the provided message that is relative to the given sequenceNumber. It is valid
                * to modify the passed in object in place.
                */
            abstract transform(message: IObjectMessage, sequenceNumber: number): IObjectMessage;
            /**
                * Allows the distributed data type to perform custom loading
                */
            protected abstract loadCore(version: ICommit, headerOrigin: string, services: IObjectStorageService): Promise<void>;
            /**
                * Allows the distributed data type to perform custom local loading
                */
            protected abstract initializeLocalCore(): any;
            /**
                * Allows the distributive data type the ability to perform custom processing once an attach has happened
                */
            protected abstract attachCore(): any;
            /**
                * Prepares the given message for processing
                */
            protected abstract prepareCore(message: ISequencedObjectMessage): Promise<void>;
            /**
                * Derived classes must override this to do custom processing on a remote message
                */
            protected abstract processCore(message: ISequencedObjectMessage, context: any): any;
            /**
                * Method called when the minimum sequence number for the object has changed
                */
            protected abstract processMinSequenceNumberChanged(value: number): any;
            /**
                * Processes a message by the local client
                */
            protected submitLocalMessage(contents: any): void;
    }
}

declare module 'prague/api-core/deltaConnection' {
    import { IDeltaConnection, IDeltaHandler, IDocument } from "prague/api-core/document";
    import { IObjectMessage, ISequencedDocumentMessage, ISequencedObjectMessage } from "prague/api-core/protocol";
    export interface IMessageContext {
            objectMessage: ISequencedObjectMessage;
            handlerContext: any;
    }
    export class DeltaConnection implements IDeltaConnection {
            objectId: string;
            readonly minimumSequenceNumber: number;
            /**
                * The lowest sequence number tracked by this map. Will normally be the document minimum
                * sequence number but may be higher in the case of an attach after the MSN.
                */
            readonly baseSequenceNumber: number;
            constructor(objectId: string, document: IDocument);
            /**
                * Sets the base mapping from a local sequence number to the document sequence number that matches it
                */
            setBaseMapping(sequenceNumber: number, documentSequenceNumber: number): void;
            attach(handler: IDeltaHandler): void;
            /**
                * Returns whether or not setBaseMapping has been called
                */
            baseMappingIsSet(): boolean;
            prepare(message: ISequencedDocumentMessage): Promise<IMessageContext>;
            process(message: ISequencedDocumentMessage, context: IMessageContext): void;
            transformDocumentSequenceNumber(value: number): number;
            updateMinSequenceNumber(value: number): void;
            /**
                * Send new messages to the server
                */
            submit(message: IObjectMessage): Promise<void>;
    }
}

declare module 'prague/api-core/deltaManager' {
    import * as protocol from "prague/api-core/protocol";
    import * as storage from "prague/api-core/storage";
    /**
        * Interface used to define a strategy for handling incoming delta messages
        */
    export interface IDeltaHandlerStrategy {
            /**
                * Preparess data necessary to process the message. The return value of the method will be passed to the process
                * function.
                */
            prepare: (message: protocol.ISequencedDocumentMessage) => Promise<any>;
            /**
                * Processes the message. The return value from prepare is passed in the context parameter.
                */
            process: (message: protocol.ISequencedDocumentMessage, context: any) => void;
    }
    /**
        * Helper class that manages incoming delta messages. This class ensures that collaborative objects receive delta
        * messages in order regardless of possible network conditions or timings causing out of order delivery.
        */
    export class DeltaManager {
            readonly referenceSequenceNumber: number;
            readonly minimumSequenceNumber: number;
            constructor(baseSequenceNumber: number, pendingMessages: protocol.ISequencedDocumentMessage[], deltaStorage: storage.IDocumentDeltaStorageService, deltaConnection: storage.IDocumentDeltaConnection, handler: IDeltaHandlerStrategy);
            /**
                * Flushes all pending tasks and returns a promise for when they are completed. The queue is marked as paused
                * upon return.
                */
            flushAndPause(): Promise<void>;
            start(): void;
            /**
                * Submits a new delta operation
                */
            submit(type: string, contents: any): Promise<void>;
            /**
                * Submits an acked roundtrip operation.
                */
            submitRoundtrip(type: string, contents: protocol.ILatencyMessage): Promise<void>;
    }
}

declare module 'prague/api-core/document' {
    import { IEnvelope, ILatencyMessage, IObjectMessage, ISequencedObjectMessage } from "prague/api-core/protocol";
    import { ICollaborativeObject, ICollaborativeObjectSave } from "prague/api-core/types";
    export interface IObjectStorageService {
            /**
                * Reads the object contained at the given path. Returns a base64 string representation for the object.
                */
            read(path: string): Promise<string>;
    }
    export interface IDistributedObjectServices {
            deltaConnection: IDeltaConnection;
            objectStorage: IObjectStorageService;
    }
    export interface IDeltaHandler {
            prepare: (message: ISequencedObjectMessage) => Promise<any>;
            process: (message: ISequencedObjectMessage, context: any) => void;
            minSequenceNumberChanged: (value: number) => void;
    }
    /**
        * Interface to represent a connection to a delta notification stream.
        */
    export interface IDeltaConnection {
            /**
                * Send new messages to the server
                */
            submit(message: IObjectMessage): Promise<void>;
            /**
                * Attaches a message handler to the delta connection
                */
            attach(handler: IDeltaHandler): void;
    }
    export interface IDocument {
            id: string;
            clientId: string;
            options: Object;
            create(type: string, id?: string): ICollaborativeObject;
            attach(object: ICollaborativeObject): IDistributedObjectServices;
            get(id: string): Promise<ICollaborativeObject>;
            submitObjectMessage(envelope: IEnvelope): any;
            submitLatencyMessage(message: ILatencyMessage): any;
            submitSaveMessage(message: ICollaborativeObjectSave): any;
    }
}

declare module 'prague/api-core/extension' {
    import * as resources from "gitresources";
    import { IDistributedObjectServices, IDocument } from "prague/api-core/document";
    import * as types from "prague/api-core/types";
    /**
        * Definitions of a collaborative extensions. Extensions follow a common model but enable custom behavior.
        */
    export interface IExtension {
            type: string;
            /**
                * Loads the given distributed object. This call is only ever invoked internally as the only thing
                * that is ever directly loaded is the document itself. Load will then only be called on documents that
                * were created and added to a collaborative object.
                *
                * document: The document the object is part of
                * connection: Interface used to retrieve updates from remote clients
                * version: Document version being loaded
                * header: Base64 encoded stored header for a snapshot. Or null if a new data type.
                * storage: Access to the data store to retrieve more information.
                *
                * Thought: should the storage object include the version information and limit access to just files
                * for the given object? The latter seems good in general. But both are probably good things. We then just
                * need a way to allow the document to provide later storage for the object.
                */
            load(document: IDocument, id: string, sequenceNumber: number, services: IDistributedObjectServices, version: resources.ICommit, headerOrigin: string): Promise<types.ICollaborativeObject>;
            /**
                * Creates a local version of the distributive object.
                *
                * Calling attach on the object later will insert it into object stream.
                * NOTE here - When we attach we need to submit all the pending ops prior to actually doing the attach
                * for consistency.
                */
            create(document: IDocument, id: string): types.ICollaborativeObject;
    }
    /**
        * Class that contains a collection of collaboration extensions
        */
    export class Registry {
            extensions: IExtension[];
            /**
                * Registers a new extension
                * @param extension The extension to register
                */
            register(extension: IExtension): void;
            /**
                * Retrieves the extension with the given id
                * @param id ID for the extension to retrieve
                */
            getExtension(type: string): IExtension;
    }
}

declare module 'prague/api-core/protocol' {
    import * as storage from "prague/api-core/storage";
    export const OperationType = "op";
    export const NoOp = "noop";
    export const ObjectOperation = "objOp";
    export const SaveOperation = "saveOp";
    export const AttachObject = "attach";
    export const ClientJoin = "join";
    export const ClientLeave = "leave";
    export const Fork = "fork";
    export const Integrate = "integrate";
    export const RoundTrip = "tripComplete";
    /**
        * An envelope wraps the contents with the intended target
        */
    export interface IEnvelope {
            address: string;
            contents: any;
    }
    /**
        * Branch origin information
        */
    export interface IBranchOrigin {
            id: string;
            sequenceNumber: number;
            minimumSequenceNumber: number;
    }
    /**
        * Messages to track latency trace
        */
    export interface ITrace {
            service: string;
            action: string;
            timestamp: number;
    }
    /**
        * Message related to a distributed data type
        */
    export interface IObjectMessage {
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            type: string;
            contents: any;
    }
    /**
        * Sequenced message for a distributed data type
        */
    export interface ISequencedObjectMessage {
            sequenceNumber: number;
            minimumSequenceNumber: number;
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            clientId: string;
            type: string;
            contents: any;
            origin: IBranchOrigin;
            traces: ITrace[];
    }
    export interface IAttachMessage {
            id: string;
            type: string;
            snapshot: storage.ITree;
    }
    export interface ILatencyMessage {
            traces: ITrace[];
    }
    export interface IPingMessage {
            acked: boolean;
            traces: ITrace[];
    }
    /**
        * Document specific message
        */
    export interface IDocumentMessage {
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            type: string;
            contents: any;
            encrypted: boolean;
            encryptedContents: string;
            traces: ITrace[];
    }
    /**
        * Sequenced message for a distribute document
        */
    export interface ISequencedDocumentMessage {
            userId: string;
            clientId: string;
            sequenceNumber: number;
            minimumSequenceNumber: number;
            clientSequenceNumber: number;
            referenceSequenceNumber: number;
            type: string;
            contents: any;
            encrypted: boolean;
            encryptedContents: string;
            origin: IBranchOrigin;
            traces: ITrace[];
    }
}

declare module 'prague/api-core/storage' {
    import * as resources from "gitresources";
    import { IAuthenticatedUser } from "prague/core-utils";
    import { IDocumentMessage, ISequencedDocumentMessage } from "prague/api-core/protocol";
    export interface IDocumentAttributes {
            /**
                * Name of the branch that created the snapshot
                */
            branch: string;
            /**
                * Sequence number at which the snapshot was taken
                */
            sequenceNumber: number;
            /**
                * Minimum sequence number when the snapshot was taken
                */
            minimumSequenceNumber: number;
    }
    export interface IObjectAttributes {
            sequenceNumber: number;
            type: string;
    }
    /**
        * The worker service connects to work manager (TMZ) and registers itself to receive work.
        */
    export interface IWorkerService {
            /**
                * Connects to tmz and subscribes to start working.
                */
            connect(type: string): Promise<any>;
    }
    /**
        * Type of entries that can be stored in a tree
        */
    export enum TreeEntry {
            Blob = 0,
            Tree = 1,
    }
    /**
        * Tree storage
        */
    export interface ITree {
            entries: ITreeEntry[];
    }
    /**
        * A tree entry wraps a path with a type of node
        */
    export interface ITreeEntry {
            path: string;
            type: string;
            value: IBlob | ITree;
    }
    /**
        * Raw blob stored within the tree
        */
    export interface IBlob {
            contents: string;
            encoding: string;
    }
    /**
        * Interface to provide access to snapshots saved for a collaborative object
        */
    export interface IDocumentStorageService {
            /**
                * Reads the object with the given ID
                */
            read(path: string): Promise<string>;
            /**
                * Writes to the object with the given ID
                */
            write(root: ITree, message: string): Promise<resources.ICommit>;
    }
    /**
        * Interface to provide access to stored deltas for a collaborative object
        */
    export interface IDocumentDeltaStorageService {
            /**
                * Retrieves all the delta operations within the inclusive sequence number range
                */
            get(from?: number, to?: number): Promise<ISequencedDocumentMessage[]>;
    }
    /**
        * Interface to provide access to stored deltas for a collaborative object
        */
    export interface IDeltaStorageService {
            /**
                * Retrieves all the delta operations within the inclusive sequence number range
                */
            get(id: string, from?: number, to?: number): Promise<ISequencedDocumentMessage[]>;
    }
    export interface ISnapshotTree {
            blobs: {
                    [path: string]: string;
            };
            trees: {
                    [path: string]: ISnapshotTree;
            };
    }
    /**
        * A distributed object is enough information to fully load a distributed object. The object may then require
        * a server call to load in more state.
        */
    export interface IDistributedObject {
            id: string;
            type: string;
            sequenceNumber: number;
    }
    export interface IDocumentDeltaConnection {
            /**
                * ClientID for the connection
                */
            clientId: string;
            /**
                * DocumentId for the connection
                */
            documentId: string;
            /**
                * Flag indicating whether connection is encrypted
                */
            encrypted: boolean;
            /**
                * Private key for decrypting deltas from the server
                */
            privateKey: string;
            /**
                * Public key for sending deltas to the server
                */
            publicKey: string;
            /**
                * Subscribe to events emitted by the document
                */
            on(event: string, listener: Function): this;
            /**
                * Submit a new message to the server
                */
            submit(message: IDocumentMessage): Promise<void>;
            /**
                * Dispatches the given event to any registered listeners.
                */
            dispatchEvent(name: string, ...args: any[]): any;
    }
    export interface IDocumentResource {
            /**
                * User connecting to the document.
                */
            user: IAuthenticatedUser;
            /**
                * Client identifier for this session
                */
            clientId: string;
            /**
                * Document identifier
                */
            documentId: string;
            /**
                * Whether or not the document existed prior to connection
                */
            existing: boolean;
            /**
                * The latest snapshot version of the document at the time of connect. Or null if no snapshots have been taken.
                */
            version: resources.ICommit;
            /**
                * Connection to receive delta notification
                */
            deltaConnection: IDocumentDeltaConnection;
            /**
                * Access to storage associated with the document
                */
            documentStorageService: IDocumentStorageService;
            /**
                * Access to delta storage associated with the document
                */
            deltaStorageService: IDocumentDeltaStorageService;
            /**
                * Distributed objects contained within the document
                */
            distributedObjects: IDistributedObject[];
            /**
                * Messages whose values are between the msn and sequenceNumber
                */
            transformedMessages: ISequencedDocumentMessage[];
            /**
                * Pending deltas that have not yet been included in a snapshot
                */
            pendingDeltas: ISequencedDocumentMessage[];
            /**
                * Branch identifier where snapshots originated
                */
            snapshotOriginBranch: string;
            /**
                * The smallest sequence number that can be used as a reference sequence number
                */
            minimumSequenceNumber: number;
            /**
                * The sequence number represented by this version of the document
                */
            sequenceNumber: number;
            /**
                * Directory information for objects contained in the snapshot
                */
            tree: ISnapshotTree;
            /**
                * Parent branch
                */
            parentBranch: string;
    }
    export interface IDocumentService {
            connect(id: string, version: resources.ICommit, connect: boolean, encrypted: boolean, token?: string): Promise<IDocumentResource>;
            /**
                * Creates a branch of the document with the given ID. Returns the new ID.
                */
            branch(id: string): Promise<string>;
    }
    export interface IBlobStorageService {
            /**
                * Returns the snapshot tree.
                */
            getSnapshotTree(id: string, version: resources.ICommit): Promise<ISnapshotTree>;
            /**
                * Reads the blob content.
                */
            read(sha: string): Promise<string>;
            /**
                * Writes the content to blob storage.
                */
            write(id: string, tree: ITree, message: string): Promise<resources.ICommit>;
    }
}

declare module 'prague/api-core/tenant' {
    import { GitManager } from "prague/git-storage";
    export interface ITenantStorage {
        url: string;
        publicUrl: string;
        owner: string;
        repository: string;
        /**
          * (optional) Direct access to storage historian is providing cached access to
          */
        direct?: string;
        credentials?: {
            user: string;
            password: string;
        };
    }
    export interface ITenantConfig {
        name: string;
        storage: ITenantStorage;
        isDefault?: boolean;
    }
    export interface ITenant {
        gitManager: GitManager;
        storage: ITenantStorage;
    }
    export interface ITenantManager {
        getTenant(tenantid: string): ITenant;
    }
}

declare module 'prague/api-core/types' {
    import * as protocol from "prague/api-core/protocol";
    import * as storage from "prague/api-core/storage";
    export const SAVE = "save";
    /**
        * Helper interface to wrap a snapshot with the sequence number it was taken at
        */
    export interface ICollaborativeObjectSnapshot {
            sequenceNumber: number;
            snapshot: any;
    }
    export interface ICollaborativeObjectSave {
            type: string;
            message: string;
    }
    export interface ICollaborativeObject {
            /**
                * A readonly identifier for the collaborative object
                */
            id: string;
            /**
                * The type of the collaborative object
                */
            type: string;
            /**
                * Marker to clearly identify the object as a collaborative object
                */
            __collaborativeObject__: boolean;
            /**
                * Attaches an event listener for the given event
                */
            on(event: string | symbol, listener: (...args: any[]) => void): this;
            /**
                * Removes the specified listenever
                */
            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
            /**
                * Attaches the given collaborative object to its containing document
                */
            attach(): this;
            /**
                * Returns whether the given collaborative object is local
                */
            isLocal(): boolean;
            /**
                * Snapshots the object
                */
            snapshot(): storage.ITree;
            /**
                * Transforms the given message relative to the provided sequence number
                */
            transform(message: protocol.IObjectMessage, sequenceNumber: number): protocol.IObjectMessage;
    }
}

declare module 'prague/api-core/localObjectStorageService' {
    import { IObjectStorageService } from "prague/api-core/document";
    import * as storage from "prague/api-core/storage";
    export class LocalObjectStorageService implements IObjectStorageService {
        constructor(tree: storage.ITree);
        read(path: string): Promise<string>;
        /**
          * Provides a synchronous access point to locally stored data
          */
        readSync(path: string): string;
    }
}

declare module 'prague/api-core/objectStorageService' {
    import { IObjectStorageService } from "prague/api-core/document";
    import { IDocumentStorageService, ISnapshotTree } from "prague/api-core/storage";
    export class ObjectStorageService implements IObjectStorageService {
        constructor(tree: ISnapshotTree, storage: IDocumentStorageService);
        read(path: string): Promise<string>;
    }
}

declare module 'prague/cell/extension' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { ICell } from "prague/data-types";
    /**
      * The extension that defines the map
      */
    export class CellExtension implements api.IExtension {
        static Type: string;
        type: string;
        load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, headerOrigin: string): Promise<ICell>;
        create(document: api.IDocument, id: string): ICell;
    }
}

declare module 'prague/cell/cell' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { ICell } from "prague/data-types";
    /**
        * Cell snapshot definition
        */
    export interface ICellSnapshot {
            minimumSequenceNumber: number;
            offset: number;
            sequenceNumber: number;
            snapshot: any;
    }
    export enum CellValueType {
            Collaborative = 0,
            Plain = 1,
    }
    export interface ICellValue {
            type: string;
            value: any;
    }
    /**
        * Implementation of a cell collaborative object
        */
    export class Cell extends api.CollaborativeObject implements ICell {
            /**
                * Constructs a new collaborative cell. If the object is non-local an id and service interfaces will
                * be provided
                */
            constructor(id: string, document: api.IDocument);
            /**
                * Retrieves the value of the cell.
                */
            get(): Promise<any>;
            /**
                * Sets the value of the cell.
                */
            set(value: any): Promise<void>;
            delete(): Promise<void>;
            /**
                * Returns whether cell is empty or not.
                */
            empty(): Promise<boolean>;
            snapshot(): api.ITree;
            transform(message: api.IObjectMessage, sequenceNumber: number): api.IObjectMessage;
            protected loadCore(version: resources.ICommit, headerOrigin: string, storage: api.IObjectStorageService): Promise<void>;
            protected initializeLocalCore(): void;
            protected attachCore(): void;
            protected prepareCore(message: api.ISequencedObjectMessage): Promise<any>;
            protected processCore(message: api.ISequencedObjectMessage, context: any): void;
            protected processMinSequenceNumberChanged(value: number): void;
    }
}

declare module 'prague/core-utils/auth' {
    import { IAuthenticatedUser } from "prague/core-utils/messages";
    export function verifyAuthToken(service: string, authToken: any): Promise<IAuthenticatedUser>;
}

declare module 'prague/core-utils/batchManager' {
    export class BatchManager<T> {
        constructor(process: (id: string, work: T[]) => void, batchSize?: number);
        add(id: string, work: T): void;
        /**
          * Resolves once all pending work is complete
          */
        drain(): Promise<void>;
    }
}

declare module 'prague/core-utils/counters' {
    /**
        * Computes a histogram of data values
        */
    export class Histogram {
            increment: number;
            buckets: number[];
            /**
                * Constructs a new histogram. Increment is used to create buckets for the data
                */
            constructor(increment: number);
            /**
                * Adds a new value to the histogram
                */
            add(value: number): void;
    }
    /**
        * Helper class to monitor throughput
        */
    export class ThroughputCounter {
            constructor(log: (value: string) => void, prefix?: string, intervalTime?: number);
            produce(count?: number): void;
            acknolwedge(count?: number): void;
    }
    /**
        * Simple class to help sample rate based counters
        */
    export class RateCounter {
            constructor();
            increment(value: number): void;
            /**
                * Starts the counter
                */
            reset(): void;
            elapsed(): number;
            /**
                * Returns the total accumulated value
                */
            getValue(): number;
            /**
                * Minimum value seen
                */
            getMinimum(): number;
            /**
                * Maximum value seen
                */
            getMaximum(): number;
            /**
                * Total number of samples provided to the counter
                */
            getSamples(): number;
            /**
                * Returns the rate for the counter
                */
            getRate(): number;
    }
}

declare module 'prague/core-utils/messages' {
    export interface IAuthenticatedUser {
        user: any;
        tenantid: string;
        permission: string;
    }
}

declare module 'prague/core-utils/promises' {
    /**
        * A deferred creates a promise and the ability to resolve or reject it
        */
    export class Deferred<T> {
            constructor();
            /**
                * Retrieves the underlying promise for the deferred
                */
            readonly promise: Promise<T>;
            /**
                * Resolves the promise
                */
            resolve(value?: T | PromiseLike<T>): void;
            /**
                * Rejects the promsie
                */
            reject(error: any): void;
    }
    /**
        * Helper function that asserts that the given promise only resolves
        */
    export function assertNotRejected<T>(promise: Promise<T>): Promise<T>;
}

declare module 'prague/core-utils/rangeTracker' {
    export interface IRange {
            primary: number;
            secondary: number;
            length: number;
    }
    export interface IRangeTrackerSnapshot {
            ranges: IRange[];
            lastPrimary: number;
            lastSecondary: number;
    }
    /**
        * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary
        * is continuous and always maps to a single value in secondary above the base value. The range
        * defines an increasing step function.
        */
    export class RangeTracker {
            readonly base: number;
            readonly primaryHead: number;
            readonly secondaryHead: number;
            constructor(primary: IRangeTrackerSnapshot);
            constructor(primary: number, secondary: number);
            /**
                * Returns a serialized form of the RangeTracker
                */
            serialize(): IRangeTrackerSnapshot;
            add(primary: number, secondary: number): void;
            get(primary: number): number;
            updateBase(primary: number): void;
    }
}

declare module 'prague/core-utils/utils' {
    /**
      * Returns the value of an object or sets to default if undefined.
      */
    export function getOrDefault<T>(value: T, def: T): T;
}

declare module 'prague/data-types/cell' {
    import * as api from "prague/api-core";
    /**
        * Collaborative cell interface
        */
    export interface ICell extends api.ICollaborativeObject {
            /**
                * Retrieves the cell value.
                */
            get(): Promise<any>;
            /**
                * Sets the cell value.
                */
            set(value: any): Promise<void>;
            /**
                * Checks whether cell is empty or not.
                */
            empty(): Promise<boolean>;
            /**
                * Delete the value from the cell.
                */
            delete(): Promise<void>;
    }
}

declare module 'prague/data-types/map' {
    import { ICollaborativeObject } from "prague/api-core";
    export type SerializeFilter = (key: string, serializedValue: any, type: string) => any;
    /**
        * Type of "valueChanged" event parameter
        */
    export interface IValueChanged {
            key: string;
    }
    /**
        * Type of "KeyValueChanged" event parameter
        */
    export interface IKeyValueChanged {
            key: string;
            value: any;
    }
    export interface IValueOpEmitter {
            emit(name: string, params: any): any;
    }
    /**
        * A value factory is used to serialize/deserialize values to a map
        */
    export interface IValueFactory<T> {
            load(emitter: IValueOpEmitter, raw: any): T;
            store(value: T): any;
    }
    export interface IValueOperation<T> {
            /**
                * Allows the handler to prepare for the operation
                */
            prepare(old: T, params: any): Promise<any>;
            /**
                * Performs the actual processing on the operation
                */
            process(old: T, params: any, context: any): T;
    }
    /**
        * Used to register a new value type on a map
        */
    export interface IValueType<T> {
            /**
                * Name of the value type
                */
            name: string;
            /**
                * Factory method used to convert to/from a JSON form of the type
                */
            factory: IValueFactory<T>;
            /**
                * Operations that can be applied to the value
                */
            ops: Map<string, IValueOperation<T>>;
    }
    export interface IMapView {
            /**
                * Retrieves the given key from the map
                */
            get<T = any>(key: string): T;
            /**
                * A form of get except it will only resolve the promise once the key exists in the map.
                */
            wait<T>(key: string): Promise<T>;
            /**
                * Returns a boolean indicating whether or not the key exists in the map
                */
            has(key: string): boolean;
            /**
                * Sets the key to the provided value
                */
            set<T = any>(key: string, value: T | any, type?: string): T;
            /**
                * Deletes the specified key from the map and returns the value of the key at the time of deletion.
                */
            delete(key: string): void;
            /**
                * Retreives all the keys contained within the map
                */
            keys(): IterableIterator<string>;
            /**
                * Removes all entries from the map
                */
            clear(): void;
            /**
                * Executes the provided callback function once per each key/value pair
                */
            forEach(callbackFn: (value, key) => void): any;
    }
    /**
        * Collaborative map interface
        */
    export interface IMap extends ICollaborativeObject {
            /**
                * Retrieves the given key from the map
                */
            get<T = any>(key: string): Promise<T>;
            /**
                * A form of get except it will only resolve the promise once the key exists in the map.
                */
            wait<T>(key: string): Promise<T>;
            /**
                * Returns a boolean indicating whether or not the key exists in the map
                */
            has(key: string): Promise<boolean>;
            /**
                * Sets the key to the provided value. An optional type can be specified to initialize the key
                * to one of the registered value types.
                */
            set<T = any>(key: string, value: T | any, type?: string): T;
            /**
                * Deletes the specified key from the map and returns the value of the key at the time of deletion.
                */
            delete(key: string): Promise<void>;
            /**
                * Retreives all the keys contained within the map
                */
            keys(): Promise<string[]>;
            /**
                * Removes all entries from the map
                */
            clear(): Promise<void>;
            /**
                * Retreives a synchronous view of the map
                */
            getView(): Promise<IMapView>;
            /**
                * Registers a new operation on the map
                */
            registerValueType<T>(type: IValueType<T>): any;
            /**
                * Registers a custom filter to provide extra processing on the condensed log.
                * This is a very advanced feature and should be used with extreme caution.
                */
            registerSerializeFilter(filter: SerializeFilter): any;
    }
}

declare module 'prague/data-types/set' {
    export interface ISet<T> {
        add(value: T): ISet<T>;
        delete(value: T): ISet<T>;
        entries(): T[];
    }
}

declare module 'prague/data-types/stream' {
    import * as api from "prague/api-core";
    export interface IPoint {
            x: number;
            y: number;
    }
    export interface IColor {
            r: number;
            g: number;
            b: number;
            a: number;
    }
    /**
        * Fluent implementation of the IDelta interface to make creation the underlying operation easier.
        * Only one operation per delta is currently supported but it's expected this will expand to multiple in
        * the future
        */
    export class Delta implements IDelta {
            operations: IOperation[];
            constructor(operations?: IOperation[]);
            /**
                * Composes two ink delta streams together - which is as simple as appending their operation
                * logs
                */
            compose(delta: IDelta): void;
            push(operation: IOperation): void;
            clear(time?: number): Delta;
            stylusUp(point: IPoint, pressure: number, id?: string, time?: number): Delta;
            stylusDown(point: IPoint, pressure: number, pen: IPen, layer?: number, id?: string, time?: number): Delta;
            stylusMove(point: IPoint, pressure: number, id?: string, time?: number): Delta;
    }
    /**
        * Retrieves the type of action contained within the operation
        */
    export function getActionType(operation: IOperation): ActionType;
    /**
        * Extracts the IStylusAction contained in the operation
        */
    export function getStylusAction(operation: IOperation): IStylusAction;
    /**
        * Helper function to retrieve the ID of the stylus operation
        */
    export function getStylusId(operation: IOperation): string;
    export interface IStream extends api.ICollaborativeObject {
            getLayers(): IInkLayer[];
            getLayer(key: string): IInkLayer;
            submitOp(op: IDelta): any;
    }
    /**
        * Pen data for the current stroke
        */
    export interface IPen {
            color: IColor;
            thickness: number;
    }
    /**
        * Type of action
        */
    export enum ActionType {
            StylusDown = 0,
            StylusUp = 1,
            StylusMove = 2,
            Clear = 3,
    }
    export interface IClearAction {
    }
    export interface IStylusAction {
            point: IPoint;
            pressure: number;
            id: string;
    }
    export interface IStylusDownAction extends IStylusAction {
            pen: IPen;
            layer: number;
    }
    export interface IStylusUpAction extends IStylusAction {
    }
    export interface IStylusMoveAction extends IStylusAction {
    }
    export interface IOperation {
            time: number;
            clear?: IClearAction;
            stylusDown?: IStylusDownAction;
            stylusUp?: IStylusUpAction;
            stylusMove?: IStylusMoveAction;
    }
    export interface IInkLayer {
            id: string;
            operations: IOperation[];
    }
    export interface IDelta {
            operations: IOperation[];
    }
    export interface IStream extends api.ICollaborativeObject {
            getLayers(): IInkLayer[];
            getLayer(key: string): IInkLayer;
            submitOp(op: IDelta): any;
    }
}

declare module 'prague/data-types/graph' {
    import { ISet } from "prague/data-types";
    /**
      * Collaborative graph interface
      */
    export interface IGraph {
        getVertices(): ISet<any>;
        getEdges(): ISet<any>;
        addVertex(id: number, label: string): any;
        addEdge(nodeId1: number, nodeId2: number, label: string): any;
    }
    export interface IVertex {
        id: number;
        label: string;
    }
    export interface IEdge {
        nodeId1: number;
        nodeId2: number;
        label: string;
    }
}

declare module 'prague/stream/extension' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    export class StreamExtension implements api.IExtension {
        static Type: string;
        type: string;
        load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, headerOrigin: string): Promise<api.ICollaborativeObject>;
        create(document: api.IDocument, id: string): api.ICollaborativeObject;
    }
}

declare module 'prague/stream/snapshot' {
    import { IDelta, IInkLayer, IOperation } from "prague/data-types";
    export interface ISnapshot {
        layers: IInkLayer[];
        layerIndex: {
            [key: string]: number;
        };
    }
    export class Snapshot implements ISnapshot {
        layers: IInkLayer[];
        layerIndex: {
            [key: string]: number;
        };
        static Clone(snapshot: ISnapshot): Snapshot;
        constructor(layers?: IInkLayer[], layerIndex?: {
            [key: string]: number;
        });
        apply(delta: IDelta): void;
        applyOperation(operation: IOperation): void;
    }
}

declare module 'prague/map/array' {
    import { IValueFactory, IValueOpEmitter, IValueOperation, IValueType } from "prague/data-types";
    export class DistributedArrayFactory<T> implements IValueFactory<DistributedArray<T>> {
        load(emitter: IValueOpEmitter, raw: any[]): DistributedArray<T>;
        store(value: DistributedArray<T>): any[];
    }
    export class DistributedArray<T> {
        readonly value: T[];
        constructor(emitter: IValueOpEmitter, value: T[]);
        insertAt(index: number, value: T, submitEvent?: boolean): DistributedArray<T>;
    }
    export class DistributedArrayValueType implements IValueType<DistributedArray<any>> {
        static Name: string;
        readonly name: string;
        readonly factory: IValueFactory<DistributedArray<any>>;
        readonly ops: Map<string, IValueOperation<DistributedArray<any>>>;
        constructor();
    }
}

declare module 'prague/map/counter' {
    import { IValueFactory, IValueOpEmitter, IValueOperation, IValueType } from "prague/data-types";
    export class CounterFactory implements IValueFactory<Counter> {
        load(emitter: IValueOpEmitter, raw: number): Counter;
        store(value: Counter): number;
    }
    export class Counter {
        readonly value: number;
        constructor(emitter: IValueOpEmitter, _value: number);
        increment(value: number, submit?: boolean): this;
    }
    export class CounterValueType implements IValueType<Counter> {
        static Name: string;
        readonly name: string;
        readonly factory: IValueFactory<Counter>;
        readonly ops: Map<string, IValueOperation<Counter>>;
        constructor();
    }
}

declare module 'prague/map/extension' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { IMap } from "prague/data-types";
    /**
      * The extension that defines the map
      */
    export class MapExtension implements api.IExtension {
        static Type: string;
        type: string;
        load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, headerOrigin: string): Promise<IMap>;
        create(document: api.IDocument, id: string): IMap;
    }
}

declare module 'prague/map/map' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { IMap, IMapView, IValueType, SerializeFilter } from "prague/data-types";
    import { IMapOperation } from "prague/map/definitions";
    /**
        * Copies all values from the provided MapView to the given Map
        */
    export function copyMap(from: IMapView, to: Map<string, any>): void;
    export interface IMapMessageHandler {
            prepare(op: IMapOperation): Promise<any>;
            process(op: IMapOperation, context: any): void;
    }
    /**
        * Implementation of a map collaborative object
        */
    export class CollaborativeMap extends api.CollaborativeObject implements IMap {
            /**
                * Constructs a new collaborative map. If the object is non-local an id and service interfaces will
                * be provided
                */
            constructor(id: string, document: api.IDocument, type?: string);
            keys(): Promise<string[]>;
            /**
                * Retrieves the value with the given key from the map.
                */
            get(key: string): Promise<any>;
            wait<T>(key: string): Promise<T>;
            has(key: string): Promise<boolean>;
            set<T>(key: string, value: any, type?: string): T;
            delete(key: string): Promise<void>;
            clear(): Promise<void>;
            snapshot(): api.ITree;
            transform(message: api.IObjectMessage, sequenceNumber: number): api.IObjectMessage;
            submitMapMessage(op: any): void;
            /**
                * Returns a synchronous view of the map
                */
            getView(): Promise<IMapView>;
            /**
                * Registers a new value type on the map
                */
            registerValueType<T>(type: IValueType<T>): void;
            registerSerializeFilter(filter: SerializeFilter): void;
            protected loadCore(version: resources.ICommit, headerOrigin: string, storage: api.IObjectStorageService): Promise<void>;
            protected initializeLocalCore(): void;
            protected processMinSequenceNumberChanged(value: number): void;
            protected loadContent(version: resources.ICommit, headerOrigin: string, services: api.IObjectStorageService): Promise<void>;
            protected initializeContent(): void;
            protected prepareCore(message: api.ISequencedObjectMessage): Promise<any>;
            protected processCore(message: api.ISequencedObjectMessage, context: any): void;
            protected attachCore(): void;
            protected attachContent(): void;
            protected prepareContent(message: api.ISequencedObjectMessage): Promise<any>;
            /**
                * Processes a content message
                */
            protected processContent(message: api.ISequencedObjectMessage, context: any): void;
            /**
                * Snapshots the content
                */
            protected snapshotContent(): api.ITree;
            /**
                * Notifies the content that the minimum sequence number has changed
                */
            protected processMinSequenceNumberChangedContent(value: number): void;
            /**
                * Allows derived classes to transform the given message
                */
            protected transformContent(message: api.IObjectMessage, sequenceNumber: number): api.IObjectMessage;
    }
}

declare module 'prague/map/set' {
    import { IValueFactory, IValueOpEmitter, IValueOperation, IValueType } from "prague/data-types";
    export class DistributedSetFactory<T> implements IValueFactory<DistributedSet<T>> {
        load(emitter: IValueOpEmitter, raw: any[]): DistributedSet<T>;
        store(value: DistributedSet<T>): any[];
    }
    export class DistributedSet<T> {
        constructor(emitter: IValueOpEmitter, value: T[]);
        add(value: T, submitEvent?: boolean): DistributedSet<T>;
        delete(value: T, submitEvent?: boolean): DistributedSet<T>;
        entries(): any[];
    }
    export class DistributedSetValueType implements IValueType<DistributedSet<any>> {
        static Name: string;
        readonly name: string;
        readonly factory: IValueFactory<DistributedSet<any>>;
        readonly ops: Map<string, IValueOperation<DistributedSet<any>>>;
        constructor();
    }
}

declare module 'prague/map/view' {
    import * as api from "prague/api-core";
    import { IMapView, IValueType, SerializeFilter } from "prague/data-types";
    import { IMapValue } from "prague/map/definitions";
    import { CollaborativeMap, IMapMessageHandler } from "prague/map/map";
    export interface ILocalViewElement {
        localType: string;
        localValue: any;
    }
    export class MapView implements IMapView {
        constructor(map: CollaborativeMap, document: api.IDocument, id: string);
        populate(data: {
            [key: string]: IMapValue;
        }): Promise<void>;
        forEach(callbackFn: (value, key) => void): void;
        get(key: string): any;
        wait<T>(key: string): Promise<T>;
        has(key: string): boolean;
        attachAll(): void;
        set<T = any>(key: string, value: any, type?: string): T;
        delete(key: string): void;
        keys(): IterableIterator<string>;
        clear(): void;
        /**
          * Serializes the collaborative map to a JSON string
          */
        serialize(filter: SerializeFilter): string;
        setCore(key: string, value: ILocalViewElement): void;
        prepareSetCore(key: string, value: IMapValue): Promise<ILocalViewElement>;
        clearCore(): void;
        deleteCore(key: string): void;
        registerValueType<T>(type: IValueType<T>): IMapMessageHandler;
    }
}

declare module 'prague/graph/graph' {
    import { IEdge, IGraph, ISet, IVertex } from "prague/data-types";
    /**
      * Implementation of a map collaborative object
      */
    export class CollaborativeGraph implements IGraph {
        constructor(edges?: ISet<IEdge>, vertices?: ISet<IVertex>);
        addVertex(id: number, label: string): void;
        addEdge(nodeId1: number, nodeId2: number, label: string): void;
        getVertices(): ISet<any>;
        getEdges(): ISet<any>;
    }
    export class Edge implements IEdge {
        nodeId1: number;
        nodeId2: number;
        label: string;
        constructor(nodeId1: number, nodeId2: number, label: string);
    }
    export class Vertex implements IVertex {
        id: number;
        label: string;
        constructor(id: number, label: string);
    }
}

declare module 'prague/merge-tree/collections' {
    import * as Base from "prague/merge-tree/base";
    export class Stack<T> {
            items: T[];
            push(val: T): void;
            empty(): boolean;
            top(): T | undefined;
            pop(): T | undefined;
    }
    export function ListRemoveEntry<U>(entry: List<U>): List<U>;
    export function ListMakeEntry<U>(data: U): List<U>;
    export function ListMakeHead<U>(): List<U>;
    export class List<T> {
            isHead: boolean;
            data: T;
            next: List<T>;
            prev: List<T>;
            constructor(isHead: boolean, data: T);
            clear(): void;
            add(data: T): List<T>;
            dequeue(): T;
            enqueue(data: T): List<T>;
            walk(fn: (data: T, l: List<T>) => void): void;
            some(fn: (data: T, l: List<T>) => boolean, rev?: boolean): T;
            count(): number;
            first(): T;
            last(): T;
            empty(): boolean;
            pushEntry(entry: List<T>): void;
            push(data: T): void;
            popEntry(head: List<T>): List<T>;
            insertEntry(entry: List<T>): List<T>;
            insertAfter(data: T): List<T>;
            insertBefore(data: T): List<T>;
            insertEntryBefore(entry: List<T>): List<T>;
    }
    export interface Comparer<T> {
            compare(a: T, b: T): number;
            min: T;
    }
    export var numberComparer: Comparer<number>;
    export class Heap<T> {
            comp: Comparer<T>;
            L: T[];
            count(): number;
            constructor(a: T[], comp: Comparer<T>);
            peek(): T;
            get(): T;
            add(x: T): void;
    }
    export function LinearDictionary<TKey, TData>(compareKeys: Base.KeyComparer<TKey>): Base.SortedDictionary<TKey, TData>;
    export const enum RBColor {
            RED = 0,
            BLACK = 1,
    }
    export interface Node<TKey, TData> {
            key: TKey;
            data: TData;
            left: Node<TKey, TData>;
            right: Node<TKey, TData>;
            color: RBColor;
            size: number;
    }
    export interface IRBAugmentation<TKey, TData> {
            update(node: Node<TKey, TData>): any;
            init?(node: Node<TKey, TData>): any;
    }
    export interface IRBMatcher<TKey, TData> {
            continueSubtree(node: Node<TKey, TData>, key: TKey): boolean;
            matchNode(node: Node<TKey, TData>, key: TKey): boolean;
    }
    export interface NodeActions<TKey, TData> {
            infix?(node: Node<TKey, TData>): boolean;
            pre?(node: Node<TKey, TData>): boolean;
            post?(node: Node<TKey, TData>): boolean;
            showStructure?: boolean;
    }
    export class RedBlackTree<TKey, TData> implements Base.SortedDictionary<TKey, TData> {
            compareKeys: Base.KeyComparer<TKey>;
            aug: IRBAugmentation<TKey, TData>;
            root: Node<TKey, TData>;
            constructor(compareKeys: Base.KeyComparer<TKey>, aug?: IRBAugmentation<TKey, TData>);
            makeNode(key: TKey, data: TData, color: RBColor, size: number): Node<TKey, TData>;
            isRed(node: Node<TKey, TData>): boolean;
            nodeSize(node: Node<TKey, TData>): number;
            size(): number;
            isEmpty(): Node<TKey, TData>;
            get(key: TKey): Node<TKey, TData>;
            nodeGet(node: Node<TKey, TData>, key: TKey): Node<TKey, TData>;
            contains(key: TKey): Node<TKey, TData>;
            gather(key: TKey, matcher: IRBMatcher<TKey, TData>): Node<TKey, TData>[];
            nodeGather(node: Node<TKey, TData>, results: Node<TKey, TData>[], key: TKey, matcher: IRBMatcher<TKey, TData>): void;
            put(key: TKey, data: TData, conflict?: Base.ConflictAction<TKey, TData>): void;
            nodePut(node: Node<TKey, TData>, key: TKey, data: TData, conflict?: Base.ConflictAction<TKey, TData>): Node<TKey, TData>;
            updateLocal(node: Node<TKey, TData>): void;
            removeMin(): void;
            nodeRemoveMin(node: Node<TKey, TData>): Node<TKey, TData>;
            removeMax(): void;
            nodeRemoveMax(node: Node<TKey, TData>): Node<TKey, TData>;
            remove(key: TKey): void;
            nodeRemove(node: Node<TKey, TData>, key: TKey): Node<TKey, TData>;
            height(): any;
            nodeHeight(node: Node<TKey, TData>): any;
            floor(key: TKey): any;
            nodeFloor(node: Node<TKey, TData>, key: TKey): any;
            min(): Node<TKey, TData>;
            nodeMin(node: Node<TKey, TData>): Node<TKey, TData>;
            max(): Node<TKey, TData>;
            nodeMax(node: Node<TKey, TData>): Node<TKey, TData>;
            rotateRight(node: Node<TKey, TData>): Node<TKey, TData>;
            rotateLeft(node: Node<TKey, TData>): Node<TKey, TData>;
            oppositeColor(c: RBColor): RBColor;
            flipColors(node: Node<TKey, TData>): void;
            moveRedLeft(node: Node<TKey, TData>): Node<TKey, TData>;
            moveRedRight(node: Node<TKey, TData>): Node<TKey, TData>;
            balance(node: Node<TKey, TData>): Node<TKey, TData>;
            mapRange<TAccum>(action: Base.PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): void;
            map<TAccum>(action: Base.PropertyAction<TKey, TData>, accum?: TAccum): void;
            /**
                * Depth-first traversal with custom action; if action returns
                * false, traversal is halted.
                * @param action action to apply to each node
                */
            walk(actions: NodeActions<TKey, TData>): void;
            nodeWalk(node: Node<TKey, TData>, actions: NodeActions<TKey, TData>): boolean;
            nodeMap<TAccum>(node: Node<TKey, TData>, action: Base.PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): any;
            diag(): void;
    }
    export interface AugRangeNode {
            minmax: Base.IRange;
    }
    /**
        * Union of two ranges; assumes for both ranges start <= end.
        * @param a A range
        * @param b A range
        */
    export function rangeUnion(a: Base.IRange, b: Base.IRange): Base.IRange;
    export function rangeOverlaps(a: Base.IRange, b: Base.IRange): boolean;
    export function rangeComparer(a: Base.IRange, b: Base.IRange): number;
    export function rangeCopy(r: Base.IRange): Base.IRange;
    export function rangeToString(range: Base.IRange): string;
    export type RangeNode = Node<Base.IRange, AugRangeNode>;
    export class RangeTree implements IRBAugmentation<Base.IRange, AugRangeNode>, IRBMatcher<Base.IRange, AugRangeNode> {
            ranges: RedBlackTree<Base.IRange, AugRangeNode>;
            diag: boolean;
            remove(r: Base.IRange): void;
            put(r: Base.IRange): void;
            toString(): string;
            nodeToString(node: RangeNode): string;
            matchPos(pos: number): Node<Base.IRange, AugRangeNode>[];
            match(r: Base.IRange): Node<Base.IRange, AugRangeNode>[];
            matchNode(node: RangeNode, key: Base.IRange): boolean;
            continueSubtree(node: RangeNode, key: Base.IRange): boolean;
            update(node: RangeNode): void;
    }
    export interface TSTNode<T> {
            c: string;
            left?: TSTNode<T>;
            mid?: TSTNode<T>;
            right?: TSTNode<T>;
            val?: T;
    }
    export interface TSTPrefix {
            text: string;
    }
    export interface ProxString<T> {
            text: string;
            invDistance: number;
            val: T;
    }
    export class TST<T> {
            constructor();
            size(): number;
            contains(key: string): T;
            get(key: string): T;
            nodeGet(x: TSTNode<T>, key: string, d: number): TSTNode<T>;
            put(key: string, val: T): void;
            nodePut(x: TSTNode<T>, key: string, val: T, d: number): TSTNode<T>;
            neighbors(text: string, distance?: number): ProxString<T>[];
            keysWithPrefix(text: string): string[];
            collect(x: TSTNode<T>, prefix: TSTPrefix, q: string[]): void;
            patternCollect(x: TSTNode<T>, prefix: TSTPrefix, d: number, pattern: string, q: string[]): void;
            nodeProximity(x: TSTNode<T>, prefix: TSTPrefix, d: number, pattern: string, distance: number, q: ProxString<T>[]): void;
            match(pattern: string): string[];
    }
}

declare module 'prague/merge-tree/extension' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    export class CollaboritiveStringExtension implements api.IExtension {
        static Type: string;
        type: string;
        load(document: api.IDocument, id: string, sequenceNumber: number, services: api.IDistributedObjectServices, version: resources.ICommit, headerOrigin: string): Promise<api.ICollaborativeObject>;
        create(document: api.IDocument, id: string, options?: Object): api.ICollaborativeObject;
    }
}

declare module 'prague/merge-tree/mergeTree' {
    import * as Base from "prague/merge-tree/base";
    import * as Collections from "prague/merge-tree/collections";
    import * as ops from "prague/merge-tree/ops";
    import * as API from "prague/api-core";
    import { ISequencedObjectMessage } from "prague/api-core";
    import * as Properties from "prague/merge-tree/properties";
    import { IRelativePosition } from "prague/merge-tree/index";
    export interface ReferencePosition {
            properties: Properties.PropertySet;
            refType: ops.ReferenceType;
            /** True if this reference is a segment. */
            isLeaf(): boolean;
            getId(): string;
            getSegment(): BaseSegment;
            getOffset(): number;
            addProperties(newProps: Properties.PropertySet, op?: ops.ICombiningOp): any;
            hasTileLabels(): any;
            hasRangeLabels(): any;
            hasTileLabel(label: string): any;
            hasRangeLabel(label: string): any;
            getTileLabels(): any;
            getRangeLabels(): any;
            matchEnd(refPos: ReferencePosition): boolean;
    }
    export type RangeStackMap = Properties.MapLike<Collections.Stack<ReferencePosition>>;
    export interface IMergeNode {
            parent: IMergeBlock;
            cachedLength: number;
            index: number;
            ordinal: string;
            isLeaf(): boolean;
    }
    export interface IMergeBlock extends IMergeNode {
            childCount: number;
            children: IMergeNode[];
            partialLengths?: PartialSequenceLengths;
            hierBlock(): IHierBlock;
            assignChild(child: IMergeNode, index: number, updateOrdinal?: boolean): any;
            setOrdinal(child: IMergeNode, index: number): any;
    }
    export interface IHierBlock extends IMergeBlock {
            hierToString(indentCount: number): any;
            addNodeReferences(mergeTree: MergeTree, node: IMergeNode): any;
            rightmostTiles: Properties.MapLike<ReferencePosition>;
            leftmostTiles: Properties.MapLike<ReferencePosition>;
            rangeStacks: RangeStackMap;
            startsInterval: Properties.MapLike<boolean>;
    }
    export class LocalRangeReference {
            start: LocalReference;
            end: LocalReference;
            constructor(start: LocalReference, end: LocalReference);
    }
    export class LocalReference implements ReferencePosition {
            segment: BaseSegment;
            offset: number;
            refType: ops.ReferenceType;
            properties: Properties.PropertySet;
            cachedEnd?: LocalReference;
            constructor(segment: BaseSegment, offset?: number, refType?: ops.ReferenceType);
            toPosition(mergeTree: MergeTree, refSeq: number, clientId: number): number;
            matchEnd(refPos: ReferencePosition): any;
            getId(): any;
            hasTileLabels(): any;
            hasRangeLabels(): any;
            hasTileLabel(label: string): any;
            hasRangeLabel(label: string): any;
            getTileLabels(): any;
            getRangeLabels(): any;
            isLeaf(): boolean;
            addProperties(newProps: Properties.PropertySet, op?: ops.ICombiningOp): void;
            getSegment(): BaseSegment;
            getOffset(): number;
            getProperties(): Properties.MapLike<any>;
    }
    export enum SegmentType {
            Base = 0,
            Text = 1,
            Marker = 2,
            External = 3,
    }
    export interface IRemovalInfo {
            removedSeq?: number;
            removedClientId?: number;
            removedClientOverlap?: number[];
    }
    export interface Segment extends IMergeNode, IRemovalInfo {
            segmentGroup?: SegmentGroup;
            seq?: number;
            clientId?: number;
            localRefs?: LocalReference[];
            removalsByBranch?: IRemovalInfo[];
            splitAt(pos: number): Segment;
            canAppend(segment: Segment, mergeTree: MergeTree): boolean;
            append(segment: Segment): any;
            getType(): SegmentType;
            removeRange(start: number, end: number): boolean;
    }
    export interface SegmentAction<TClientData> {
            (segment: Segment, pos: number, refSeq: number, clientId: number, start: number, end: number, accum?: TClientData): boolean;
    }
    export interface SegmentChanges {
            next?: Segment;
            replaceCurrent?: Segment;
    }
    export interface BlockAction<TClientData> {
            (block: IMergeBlock, pos: number, refSeq: number, clientId: number, start: number, end: number, accum?: TClientData): boolean;
    }
    export interface NodeAction<TClientData> {
            (node: MergeNode, pos: number, refSeq: number, clientId: number, start: number, end: number, clientData?: TClientData): boolean;
    }
    export interface IncrementalSegmentAction<TContext> {
            (segment: Segment, state: IncrementalMapState<TContext>): any;
    }
    export interface IncrementalBlockAction<TContext> {
            (state: IncrementalMapState<TContext>): any;
    }
    export interface BlockUpdateActions {
            child: (block: IMergeBlock, index: number) => void;
    }
    export interface InsertContext {
            prepareEvents?: boolean;
            leaf: (segment: Segment, pos: number) => SegmentChanges;
            continuePredicate?: (continueFromBlock: IMergeBlock) => boolean;
    }
    export interface SegmentActions<TClientData> {
            leaf?: SegmentAction<TClientData>;
            shift?: NodeAction<TClientData>;
            contains?: NodeAction<TClientData>;
            pre?: BlockAction<TClientData>;
            post?: BlockAction<TClientData>;
    }
    export interface IncrementalSegmentActions<TContext> {
            leaf: IncrementalSegmentAction<TContext>;
            pre?: IncrementalBlockAction<TContext>;
            post?: IncrementalBlockAction<TContext>;
    }
    export interface SearchResult {
            text: string;
            pos: number;
    }
    export interface MergeTreeStats {
            maxHeight: number;
            nodeCount: number;
            leafCount: number;
            removedLeafCount: number;
            liveCount: number;
            histo: number[];
            windowTime?: number;
            packTime?: number;
            ordTime?: number;
            maxOrdTime?: number;
    }
    export interface SegmentGroup {
            segments: Segment[];
    }
    export interface OverlapClient {
            clientId: number;
            seglen: number;
    }
    export class MergeNode implements IMergeNode {
            index: number;
            ordinal: string;
            parent: IMergeBlock;
            cachedLength: number;
            isLeaf(): boolean;
    }
    export function ordinalToArray(ord: string): number[];
    export const MaxNodesInBlock = 8;
    export class MergeBlock extends MergeNode implements IMergeBlock {
            childCount: number;
            static traceOrdinals: boolean;
            children: MergeNode[];
            constructor(childCount: number);
            hierBlock(): any;
            setOrdinal(child: IMergeNode, index: number): void;
            assignChild(child: MergeNode, index: number, updateOrdinal?: boolean): void;
    }
    export abstract class BaseSegment extends MergeNode implements Segment {
            seq: number;
            clientId: number;
            constructor(seq?: number, clientId?: number);
            index: number;
            ordinal: string;
            removedSeq: number;
            removedClientId: number;
            removedClientOverlap: number[];
            segmentGroup: SegmentGroup;
            properties: Properties.PropertySet;
            localRefs: LocalReference[];
            hierRefCount?: number;
            addLocalRef(lref: LocalReference): void;
            removeLocalRef(lref: LocalReference): LocalReference;
            addProperties(newProps: Properties.PropertySet, op?: ops.ICombiningOp): void;
            isLeaf(): boolean;
            cloneInto(b: BaseSegment): void;
            canAppend(segment: Segment, mergeTree: MergeTree): boolean;
            abstract clone(): BaseSegment;
            abstract append(segment: Segment): Segment;
            abstract getType(): SegmentType;
            abstract removeRange(start: number, end: number): boolean;
            abstract splitAt(pos: number): Segment;
    }
    /**
        * A non-collaborative placeholder for external content.
        */
    export class ExternalSegment extends BaseSegment {
            placeholderSeq: any;
            charLength: number;
            lengthBytes: number;
            binPosition: number;
            constructor(placeholderSeq: any, charLength: number, lengthBytes: number, binPosition: number);
            mergeTreeInsert(mergeTree: MergeTree, pos: number, refSeq: number, clientId: number, seq: number): void;
            clone(): BaseSegment;
            append(segment: Segment): Segment;
            getType(): SegmentType;
            removeRange(start: number, end: number): boolean;
            splitAt(pos: number): Segment;
    }
    export let reservedTileLabelsKey: string;
    export let reservedRangeLabelsKey: string;
    export let reservedReferenceIdKey: string;
    export class Marker extends BaseSegment implements ReferencePosition {
            refType: ops.ReferenceType;
            static make(refType: ops.ReferenceType, props?: Properties.PropertySet, seq?: number, clientId?: number): Marker;
            constructor(refType: ops.ReferenceType, seq?: number, clientId?: number);
            clone(): Marker;
            matchEnd(refPos: ReferencePosition): boolean;
            getSegment(): this;
            getOffset(): number;
            getProperties(): Properties.MapLike<any>;
            getId(): any;
            hasTileLabels(): any;
            hasRangeLabels(): any;
            hasTileLabel(label: string): any;
            hasRangeLabel(label: string): any;
            getTileLabels(): any;
            getRangeLabels(): any;
            toString(): string;
            getType(): SegmentType;
            removeRange(start: number, end: number): boolean;
            splitAt(pos: number): any;
            canAppend(segment: Segment): boolean;
            append(segment: Segment): any;
    }
    export class TextSegment extends BaseSegment {
            text: string;
            static make(text: string, props?: Properties.PropertySet, seq?: number, clientId?: number): TextSegment;
            constructor(text: string, seq?: number, clientId?: number);
            splitLocalRefs(pos: number, leafSegment: TextSegment): void;
            splitAt(pos: number): TextSegment;
            clone(): TextSegment;
            getType(): SegmentType;
            matchProperties(b: TextSegment): boolean;
            canAppend(segment: Segment, mergeTree: MergeTree): boolean;
            toString(): string;
            append(segment: Segment): this;
            removeRange(start: number, end: number): boolean;
    }
    export enum IncrementalExecOp {
            Go = 0,
            Stop = 1,
            Yield = 2,
    }
    export class IncrementalMapState<TContext> {
            block: IMergeBlock;
            actions: IncrementalSegmentActions<TContext>;
            pos: number;
            refSeq: number;
            clientId: number;
            context: TContext;
            start: number;
            end: number;
            childIndex: number;
            op: IncrementalExecOp;
            constructor(block: IMergeBlock, actions: IncrementalSegmentActions<TContext>, pos: number, refSeq: number, clientId: number, context: TContext, start: number, end: number, childIndex?: number);
    }
    /**
        * Sequence numbers for collaborative segments start at 1 or greater.  Every segment marked
        * with sequence number zero will be counted as part of the requested string.
        */
    export const UniversalSequenceNumber = 0;
    export const UnassignedSequenceNumber = -1;
    export const TreeMaintainanceSequenceNumber = -2;
    export const LocalClientId = -1;
    export const NonCollabClient = -2;
    export interface PartialSequenceLength {
            seq: number;
            len: number;
            seglen: number;
            clientId?: number;
            overlapClients?: Collections.RedBlackTree<number, OverlapClient>;
    }
    export class CollaborationWindow {
            clientId: number;
            collaborating: boolean;
            localMinSeq?: number;
            globalMinSeq?: number;
            minSeq: number;
            currentSeq: number;
            loadFrom(a: CollaborationWindow): void;
    }
    export function compareNumbers(a: number, b: number): number;
    /**
        * Keep track of partial sums of segment lengths for all sequence numbers
        * in the current collaboration window (if any).  Only used during active
        * collaboration.
        */
    export class PartialSequenceLengths {
            minSeq: number;
            minLength: number;
            segmentCount: number;
            partialLengths: PartialSequenceLength[];
            clientSeqNumbers: PartialSequenceLength[][];
            downstreamPartialLengths: PartialSequenceLengths[];
            static options: {
                    zamboni: boolean;
            };
            constructor(minSeq: number);
            cliLatestLEQ(clientId: number, refSeq: number): number;
            cliLatest(clientId: number): number;
            compare(b: PartialSequenceLengths): boolean;
            branchToString(glc?: (id: number) => string, branchId?: number): string;
            toString(glc?: (id: number) => string, indentCount?: number): string;
            getPartialLength(mergeTree: MergeTree, refSeq: number, clientId: number): number;
            getBranchPartialLength(refSeq: number, clientId: number): number;
            zamboni(segmentWindow: CollaborationWindow): void;
            addClientSeqNumber(clientId: number, seq: number, seglen: number): void;
            addClientSeqNumberFromPartial(partialLength: PartialSequenceLength): void;
            update(mergeTree: MergeTree, block: IMergeBlock, seq: number, clientId: number, collabWindow: CollaborationWindow): void;
            updateBranch(mergeTree: MergeTree, branchId: number, node: IMergeBlock, seq: number, clientId: number, collabWindow: CollaborationWindow): void;
            static fromLeaves(mergeTree: MergeTree, branchId: number, combinedPartialLengths: PartialSequenceLengths, block: IMergeBlock, collabWindow: CollaborationWindow): void;
            static combine(mergeTree: MergeTree, block: IMergeBlock, collabWindow: CollaborationWindow, recur?: boolean): PartialSequenceLengths;
            partialLengthsForBranch(branchId: number): PartialSequenceLengths;
            /**
                * Combine the partial lengths of block's children
                * @param {IMergeBlock} block an interior node; it is assumed that each interior node child of this block
                * has its partials up to date
                * @param {CollaborationWindow} collabWindow segment window fo the segment tree containing textSegmentBlock
                */
            static combineBranch(mergeTree: MergeTree, block: IMergeBlock, collabWindow: CollaborationWindow, branchId: number, recur?: boolean): PartialSequenceLengths;
    }
    /**
        * Used for in-memory testing.  This will queue a reference string for each client message.
        */
    export const useCheckQ: boolean;
    export function internedSpaces(n: number): string;
    export interface ClientIds {
            clientId: number;
            branchId: number;
    }
    export interface IUndoInfo {
            seq: number;
            seg: Segment;
            op: ops.MergeTreeDeltaType;
    }
    export class Client {
            mergeTree: MergeTree;
            accumTime: number;
            localTime: number;
            localOps: number;
            accumWindowTime: number;
            maxWindowTime: number;
            accumWindow: number;
            accumOps: number;
            verboseOps: boolean;
            measureOps: boolean;
            q: Collections.List<API.ISequencedObjectMessage>;
            checkQ: Collections.List<string>;
            clientSequenceNumber: number;
            clientNameToIds: Collections.RedBlackTree<string, ClientIds>;
            shortClientIdMap: string[];
            shortClientBranchIdMap: number[];
            longClientId: string;
            undoSegments: IUndoInfo[];
            redoSegments: IUndoInfo[];
            constructor(initText: string, options?: Properties.PropertySet);
            undoSingleSequenceNumber(undoSegments: IUndoInfo[], redoSegments: IUndoInfo[]): number;
            historyToPct(pct: number): number;
            undo(): number;
            redo(): number;
            cloneFromSegments(): Client;
            getOrAddShortClientId(longClientId: string, branchId?: number): number;
            getShortClientId(longClientId: string): number;
            getLongClientId(clientId: number): string;
            addLongClientId(longClientId: string, branchId?: number): void;
            getBranchId(clientId: number): number;
            makeInsertMarkerMsg(markerType: string, behaviors: ops.ReferenceType, pos: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            makeInsertMsg(text: string, pos: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            makeRemoveMsg(start: number, end: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            makeAnnotateMsg(props: Properties.PropertySet, start: number, end: number, seq: number, refSeq: number, objectId: string): ISequencedObjectMessage;
            hasMessages(): boolean;
            enqueueMsg(msg: API.ISequencedObjectMessage): void;
            dequeueMsg(): API.ISequencedObjectMessage;
            enqueueTestString(): void;
            transformOp(op: ops.IMergeTreeOp, msg: API.ISequencedObjectMessage, toSequenceNumber: number): ops.IMergeTreeOp;
            transform(msg: API.ISequencedObjectMessage, toSequenceNumber: number): ISequencedObjectMessage;
            checkContingentOps(groupOp: ops.IMergeTreeGroupMsg, msg: API.ISequencedObjectMessage): boolean;
            applyOp(op: ops.IMergeTreeOp, msg: API.ISequencedObjectMessage): void;
            coreApplyMsg(msg: API.ISequencedObjectMessage): void;
            applyMsg(msg: API.ISequencedObjectMessage): void;
            applyMessages(msgCount: number): void;
            getLocalSequenceNumber(): 0 | -1;
            localTransaction(groupOp: ops.IMergeTreeGroupMsg): void;
            annotateSegmentLocal(props: Properties.PropertySet, start: number, end: number, op: ops.ICombiningOp): void;
            annotateSegmentRemote(props: Properties.PropertySet, start: number, end: number, seq: number, refSeq: number, clientId: number, combiningOp: ops.ICombiningOp): void;
            removeSegmentLocal(start: number, end: number): void;
            removeSegmentRemote(start: number, end: number, seq: number, refSeq: number, clientId: number): void;
            insertTextLocal(text: string, pos: number, props?: Properties.PropertySet): void;
            insertTextMarkerRelative(text: string, markerPos: IRelativePosition, props?: Properties.PropertySet): void;
            insertMarkerLocal(pos: number, behaviors: ops.ReferenceType, props?: Properties.PropertySet): void;
            insertMarkerRemote(marker: ops.IMarkerDef, pos: number, props: Properties.PropertySet, seq: number, refSeq: number, clientId: number): void;
            insertTextRemote(text: string, pos: number, props: Properties.PropertySet, seq: number, refSeq: number, clientId: number): void;
            ackPendingSegment(seq: number): void;
            updateMinSeq(minSeq: number): void;
            getCurrentSeq(): number;
            getClientId(): number;
            getText(start?: number, end?: number): string;
            /**
                * Adds spaces for markers and components, so that position calculations account for them
                */
            getTextWithPlaceholders(): string;
            getTextRangeWithPlaceholders(start: number, end: number): string;
            getLength(): number;
            relText(clientId: number, refSeq: number): string;
            startCollaboration(longClientId: string, minSeq?: number, branchId?: number): void;
    }
    export interface ClientSeq {
            refSeq: number;
            clientId: string;
    }
    export var clientSeqComparer: Collections.Comparer<ClientSeq>;
    /**
        * Server for tests.  Simulates client communication by directing placing
        * messages in client queues.
        */
    export class TestServer extends Client {
            seq: number;
            clients: Client[];
            listeners: Client[];
            clientSeqNumbers: Collections.Heap<ClientSeq>;
            upstreamMap: Collections.RedBlackTree<number, number>;
            constructor(initText: string, options?: Properties.PropertySet);
            addUpstreamClients(upstreamClients: Client[]): void;
            addClients(clients: Client[]): void;
            addListeners(listeners: Client[]): void;
            applyMsg(msg: API.ISequencedObjectMessage): boolean;
            transformUpstreamMessage(msg: ISequencedObjectMessage): void;
            copyMsg(msg: ISequencedObjectMessage): ISequencedObjectMessage;
            applyMessages(msgCount: number): boolean;
    }
    export interface LRUSegment {
            segment?: Segment;
            maxSeq: number;
    }
    export interface TextAccumulator {
            textSegment: TextSegment;
            placeholders?: boolean;
    }
    export interface RemoveRangeInfo {
            highestBlockRemovingChildren: IMergeBlock;
    }
    export class MergeTree {
            text: string;
            options: Properties.PropertySet;
            static TextSegmentGranularity: number;
            static zamboniSegmentsMaxCount: number;
            static options: {
                    incrementalUpdate: boolean;
                    zamboniSegments: boolean;
                    measureWindowTime: boolean;
                    measureOrdinalTime: boolean;
            };
            static searchChunkSize: number;
            static traceAppend: boolean;
            static traceZRemove: boolean;
            static traceOrdinals: boolean;
            static traceGatherText: boolean;
            static diagInsertTie: boolean;
            static skipLeftShift: boolean;
            static diagOverlappingRemove: boolean;
            static traceTraversal: boolean;
            static traceIncrTraversal: boolean;
            static initBlockUpdateActions: BlockUpdateActions;
            static theUnfinishedNode: IMergeBlock;
            windowTime: number;
            packTime: number;
            ordTime: number;
            maxOrdTime: number;
            root: IMergeBlock;
            blockUpdateMarkers: boolean;
            blockUpdateActions: BlockUpdateActions;
            collabWindow: CollaborationWindow;
            pendingSegments: Collections.List<SegmentGroup>;
            segmentsToScour: Collections.Heap<LRUSegment>;
            idToSegment: Properties.MapLike<Segment>;
            idToLref: Properties.MapLike<LocalReference>;
            clientIdToBranchId: number[];
            localBranchId: number;
            transactionSegmentGroup: SegmentGroup;
            getLongClientId: (id: number) => string;
            constructor(text: string, options?: Properties.PropertySet);
            blockCloneFromSegments(block: IMergeBlock, segments: Segment[]): void;
            clone(): void;
            blockClone(block: IMergeBlock): MergeBlock;
            segmentClone(segment: Segment): BaseSegment;
            startGroupOperation(): void;
            endGroupOperation(): void;
            localNetLength(segment: Segment): number;
            getBranchId(clientId: number): number;
            mapIdToSegment(id: string, segment: Segment): void;
            mapIdToLref(id: string, lref: LocalReference): void;
            addNode(block: IMergeBlock, node: MergeNode): number;
            reloadFromSegments(segments: Segment[]): void;
            startCollaboration(localClientId: number, minSeq: number, branchId: number): void;
            addToLRUSet(segment: Segment, seq: number): void;
            underflow(node: IMergeBlock): boolean;
            scourNode(node: IMergeBlock, holdNodes: MergeNode[]): void;
            pack(block: IMergeBlock): void;
            zamboniSegments(): void;
            getCollabWindow(): CollaborationWindow;
            getStats(): MergeTreeStats;
            tardisPosition(pos: number, fromSeq: number, toSeq: number, toClientId?: number): number;
            tardisPositionFromClient(pos: number, fromSeq: number, toSeq: number, fromClientId: number, toClientId?: number): number;
            tardisRange(rangeStart: number, rangeEnd: number, fromSeq: number, toSeq: number, toClientId?: number): Base.IRange[];
            getLength(refSeq: number, clientId: number): number;
            getOffset(node: MergeNode, refSeq: number, clientId: number): number;
            searchFromPos(pos: number, target: RegExp): {
                    text: string;
                    pos: number;
            };
            ogatherText: (segment: Segment, pos: number, refSeq: number, clientId: number, start: number, end: number, accumText: TextAccumulator) => boolean;
            gatherText: (segment: Segment, pos: number, refSeq: number, clientId: number, start: number, end: number, accumText: TextAccumulator) => boolean;
            incrementalGetText(refSeq: number, clientId: number, start?: number, end?: number): string;
            getText(refSeq: number, clientId: number, placeholders?: boolean, start?: number, end?: number): string;
            getContainingSegment(pos: number, refSeq: number, clientId: number): {
                    segment: Segment;
                    offset: number;
            };
            blockLength(node: IMergeBlock, refSeq: number, clientId: number): number;
            getRemovalInfo(branchId: number, segBranchId: number, segment: Segment): IRemovalInfo;
            nodeLength(node: MergeNode, refSeq: number, clientId: number): number;
            updateLocalMinSeq(localMinSeq: number): void;
            setMinSeq(minSeq: number): void;
            commitGlobalMin(): void;
            updateGlobalMinSeq(globalMinSeq: number): void;
            referencePositionToLocalPosition(refPos: ReferencePosition): number;
            findOverlappingIntervals(startPos: number, endPos: number, rangeLabels: string[]): ReferencePosition[];
            getStackContext(startPos: number, clientId: number, rangeLabels: string[]): Properties.MapLike<Collections.Stack<ReferencePosition>>;
            cherryPickedUndo(undoInfo: IUndoInfo): void;
            findTile(startPos: number, clientId: number, tileLabel: string, preceding?: boolean): {
                    tile: ReferencePosition;
                    pos: number;
            };
            search<TClientData>(pos: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            searchBlock<TClientData>(block: IMergeBlock, pos: number, segpos: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            backwardSearch<TClientData>(pos: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            backwardSearchBlock<TClientData>(block: IMergeBlock, pos: number, segEnd: number, refSeq: number, clientId: number, actions?: SegmentActions<TClientData>, clientData?: TClientData): Segment;
            updateRoot(splitNode: IMergeBlock, refSeq: number, clientId: number, seq: number): void;
            /**
                * Assign sequence number to existing segment; update partial lengths to reflect the change
                * @param seq sequence number given by server to pending segment
                */
            ackPendingSegment(seq: number): void;
            addToPendingList(segment: Segment, segmentGroup?: SegmentGroup): SegmentGroup;
            appendSegment(segSpec: ops.IPropertyString, seq?: number): void;
            getSegmentFromId(id: string): Segment;
            getLrefFromId(id: string): LocalReference;
            /**
                * Given a position specified relative to a marker id, lookup the marker
                * and convert the position to a character position.
                * @param relativePos Id of marker (may be indirect) and whether position is before or after marker.
                * @param refseq The reference sequence number at which to compute the position.
                * @param clientId The client id with which to compute the position.
                */
            posFromRelativePos(relativePos: IRelativePosition, refseq: number, clientId: number): number;
            insert<T>(pos: number, refSeq: number, clientId: number, seq: number, segData: T, traverse: (block: IMergeBlock, pos: number, refSeq: number, clientId: number, seq: number, segData: T) => IMergeBlock): void;
            insertMarker(pos: number, refSeq: number, clientId: number, seq: number, behaviors: ops.ReferenceType, props?: Properties.PropertySet): void;
            insertTextMarkerRelative(markerPos: IRelativePosition, refSeq: number, clientId: number, seq: number, text: string, props?: Properties.PropertySet): void;
            insertText(pos: number, refSeq: number, clientId: number, seq: number, text: string, props?: Properties.PropertySet): void;
            blockInsert<T extends Segment>(block: IMergeBlock, pos: number, refSeq: number, clientId: number, seq: number, newSegment: T): MergeBlock;
            splitLeafSegment: (segment: Segment, pos: number) => SegmentChanges;
            ensureIntervalBoundary(pos: number, refSeq: number, clientId: number): void;
            breakTie(pos: number, len: number, seq: number, node: MergeNode, refSeq: number, clientId: number, segType: SegmentType): boolean;
            leftExcursion<TClientData>(node: MergeNode, leafAction: SegmentAction<TClientData>): void;
            rightExcursion<TClientData>(node: MergeNode, leafAction: SegmentAction<TClientData>): void;
            ordinalIntegrity(): void;
            nodeOrdinalIntegrity(block: IMergeBlock): void;
            nodeUpdateOrdinals(block: IMergeBlock): void;
            addOverlappingClient(removalInfo: IRemovalInfo, clientId: number): void;
            annotateRange(props: Properties.PropertySet, start: number, end: number, refSeq: number, clientId: number, seq: number, combiningOp?: ops.ICombiningOp): void;
            markRangeRemoved(start: number, end: number, refSeq: number, clientId: number, seq: number): void;
            removeRange(start: number, end: number, refSeq: number, clientId: number): void;
            nodeRemoveRange(block: IMergeBlock, start: number, end: number, refSeq: number, clientId: number, removeInfo: RemoveRangeInfo): void;
            nodeUpdateLengthNewStructure(node: IMergeBlock, recur?: boolean): void;
            removeLocalReference(segment: BaseSegment, lref: LocalReference): void;
            addLocalReference(segment: BaseSegment, lref: LocalReference): void;
            blockUpdate(block: IMergeBlock): void;
            blockUpdatePathLengths(block: IMergeBlock, seq: number, clientId: number, newStructure?: boolean): void;
            nodeCompareUpdateLength(node: IMergeBlock, seq: number, clientId: number): void;
            blockUpdateLength(node: IMergeBlock, seq: number, clientId: number): void;
            map<TClientData>(actions: SegmentActions<TClientData>, refSeq: number, clientId: number, accum?: TClientData): void;
            mapRange<TClientData>(actions: SegmentActions<TClientData>, refSeq: number, clientId: number, accum?: TClientData, start?: number, end?: number): void;
            rangeToString(start: number, end: number): string;
            nodeToString(block: IMergeBlock, strbuf: string, indentCount?: number): string;
            toString(): string;
            incrementalBlockMap<TContext>(stateStack: Collections.Stack<IncrementalMapState<TContext>>): void;
            nodeMap<TClientData>(node: IMergeBlock, actions: SegmentActions<TClientData>, pos: number, refSeq: number, clientId: number, accum?: TClientData, start?: number, end?: number): boolean;
            nodeMapReverse<TClientData>(block: IMergeBlock, actions: SegmentActions<TClientData>, pos: number, refSeq: number, clientId: number, accum?: TClientData): any;
    }
}

declare module 'prague/merge-tree/ops' {
    export enum ReferenceType {
            Simple = 0,
            Tile = 1,
            NestBegin = 2,
            NestEnd = 4,
            RangeBegin = 16,
            RangeEnd = 32,
            SlideOnRemove = 64,
    }
    export interface IMarkerDef {
            refType?: ReferenceType;
    }
    export interface IComponentDef {
            url: string;
    }
    export const enum MergeTreeDeltaType {
            INSERT = 0,
            REMOVE = 1,
            ANNOTATE = 2,
            GROUP = 3,
    }
    export interface IMergeTreeDelta {
            /**
                * Type of this change.
                */
            type: MergeTreeDeltaType;
    }
    /**
        * A segment-relative position.
        */
    export interface IRelativePosition {
            /**
                * String identifier specifying a segment or reference collection.
                */
            id: string;
            /**
                * True if the id refers to the segment indirectly.
                */
            indirect?: boolean;
            /**
                * If true, insert before the specified segment.  If false or not defined,
                * insert after the specified segment.
                */
            before?: boolean;
            /**
                * A positive number >= 1.  If before is false, offset is added to the position.
                * If before is true, offset is subtracted from the position.
                */
            offset?: number;
    }
    export interface IMergeTreeInsertMsg extends IMergeTreeDelta {
            type: MergeTreeDeltaType.INSERT;
            pos1?: number;
            relativePos1?: IRelativePosition;
            props?: Object;
            text?: string;
            marker?: IMarkerDef;
    }
    export interface IMergeTreeRemoveMsg extends IMergeTreeDelta {
            type: MergeTreeDeltaType.REMOVE;
            pos1?: number;
            relativePos1?: IRelativePosition;
            pos2?: number;
            relativePos2?: IRelativePosition;
    }
    export interface ICombiningOp {
            name: string;
            defaultValue?: any;
            minValue?: any;
            maxValue?: any;
    }
    export interface IContingencyCheck {
            props: Object;
    }
    export interface IMergeTreeAnnotateMsg extends IMergeTreeDelta {
            type: MergeTreeDeltaType.ANNOTATE;
            pos1?: number;
            markerPos1?: IRelativePosition;
            pos2?: number;
            markerPos2?: IRelativePosition;
            props: Object;
            combiningOp?: ICombiningOp;
            when?: IContingencyCheck;
    }
    export interface IMergeTreeGroupMsg extends IMergeTreeDelta {
            type: MergeTreeDeltaType.GROUP;
            hasContingentOps?: boolean;
            ops: IMergeTreeOp[];
    }
    export type IMergeTreeOp = IMergeTreeInsertMsg | IMergeTreeRemoveMsg | IMergeTreeAnnotateMsg | IMergeTreeGroupMsg;
    export interface IPropertyString {
            props?: Object;
            text?: string;
            marker?: IMarkerDef;
    }
    export interface MergeTreeChunk {
            chunkStartSegmentIndex: number;
            chunkSegmentCount: number;
            chunkLengthChars: number;
            totalLengthChars: number;
            totalSegmentCount: number;
            chunkSequenceNumber: number;
            segmentTexts: IPropertyString[];
    }
}

declare module 'prague/merge-tree/sharedString' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { IMapView } from "prague/data-types";
    import { CollaborativeMap } from "prague/map";
    import * as MergeTree from "prague/merge-tree/mergeTree";
    import * as ops from "prague/merge-tree/ops";
    import * as Properties from "prague/merge-tree/properties";
    export class SharedString extends CollaborativeMap {
        id: string;
        client: MergeTree.Client;
        readonly loaded: Promise<void>;
        constructor(document: api.IDocument, id: string, sequenceNumber: number, services?: api.IDistributedObjectServices);
        insertMarker(pos: number, refType: ops.ReferenceType, props?: Properties.PropertySet): void;
        insertText(text: string, pos: number, props?: Properties.PropertySet): void;
        removeText(start: number, end: number): void;
        annotateRangeFromPast(props: Properties.PropertySet, start: number, end: number, fromSeq: number): void;
        transaction(groupOp: ops.IMergeTreeGroupMsg): void;
        annotateRange(props: Properties.PropertySet, start: number, end: number, op?: ops.ICombiningOp): void;
        setLocalMinSeq(lmseq: number): void;
        createRangeReference(start: number, end: number): MergeTree.LocalRangeReference;
        createPositionReference(pos: number, slideOnRemove?: boolean): MergeTree.LocalReference;
        localRefToPos(localRef: MergeTree.LocalReference): number;
        addBookmark(clientId: string, bookmark: any): void;
        getBookmarks(): IMapView;
        protected transformContent(message: api.IObjectMessage, toSequenceNumber: number): api.IObjectMessage;
        protected loadContent(version: resources.ICommit, headerOrigin: string, storage: api.IObjectStorageService): Promise<void>;
        protected initializeContent(): void;
        protected snapshotContent(): api.ITree;
        protected processContent(message: api.ISequencedObjectMessage): void;
        protected processMinSequenceNumberChangedContent(value: number): void;
        protected attachContent(): void;
    }
}

declare module 'prague/merge-tree/properties' {
    import * as ops from "prague/merge-tree/ops";
    import * as Collections from "prague/merge-tree/collections";
    /**
      * For each contingent property, a list of contingent local changes,
      * in change order.
      */
    export type ContingentPropertySet = MapLike<Collections.List<any>>;
    export interface MapLike<T> {
        [index: string]: T;
    }
    export type PropertySet = MapLike<any>;
    export function combine(combiningInfo: ops.ICombiningOp, currentValue: any, newValue: any): any;
    export function matchProperties(a: PropertySet, b: PropertySet): boolean;
    export function readContingentProperty(name: string, props: PropertySet, contingentProps: ContingentPropertySet): any;
    export function contingentExtend<T>(contingentBase: ContingentPropertySet, base: MapLike<T>, extension: MapLike<T>, combiningOp?: ops.ICombiningOp): MapLike<T>;
    export function extend<T>(base: MapLike<T>, extension: MapLike<T>, combiningOp?: ops.ICombiningOp): MapLike<T>;
    export function addProperties(oldProps: PropertySet, newProps: PropertySet, op?: ops.ICombiningOp): MapLike<any>;
    export function extendIfUndefined<T>(base: MapLike<T>, extension: MapLike<T>): MapLike<T>;
    /** Create a MapLike with good performance. */
    export function createMap<T>(): MapLike<T>;
}

declare module 'prague/merge-tree/text' {
    import * as MergeTree from "prague/merge-tree/mergeTree";
    export function loadTextFromFile(filename: string, mergeTree: MergeTree.MergeTree, segLimit?: number): MergeTree.MergeTree;
    export function loadTextFromFileWithMarkers(filename: string, mergeTree: MergeTree.MergeTree, segLimit?: number): MergeTree.MergeTree;
    export function loadSegments(content: string, segLimit: number, markers?: boolean): MergeTree.Segment[];
    export function loadText(content: string, mergeTree: MergeTree.MergeTree, segLimit: number, markers?: boolean): MergeTree.MergeTree;
}

declare module 'prague/socket-storage/messages' {
    import { IAuthenticatedUser } from "prague/core-utils";
    /**
        * Message sent to connect to the given object
        */
    export interface IConnect {
            id: string;
            privateKey: string;
            publicKey: string;
            encrypted: boolean;
            token?: string;
    }
    /**
        * Message sent to indicate a client has connected to the server
        *
        * TODO Is the below a connection to the actual Kafka stream?
        */
    export interface IConnected {
            user: IAuthenticatedUser;
            clientId: string;
            existing: boolean;
            parentBranch: string;
            privateKey: string;
            publicKey: string;
            encrypted: boolean;
    }
    /**
        * Message sent to indicate that a shadow client has connected to the server.
        */
    export interface IShadowConnected {
            clientId: string;
    }
    /**
        * Message sent to connect to the given object
        */
    export interface IWorker {
            clientId: string;
            type: string;
    }
}

declare module 'prague/socket-storage/deltaStorageService' {
    import * as api from "prague/api-core";
    /**
        * Storage service limited to only being able to fetch documents for a specific document
        */
    export class DocumentDeltaStorageService implements api.IDocumentDeltaStorageService {
            constructor(id: string, storageService: api.IDeltaStorageService);
            get(from?: number, to?: number): Promise<api.ISequencedDocumentMessage[]>;
    }
    /**
        * Provides access to the underlying delta storage on the server
        */
    export class DeltaStorageService implements api.IDeltaStorageService {
            constructor(url: string);
            get(id: string, from?: number, to?: number): Promise<api.ISequencedDocumentMessage[]>;
    }
}

declare module 'prague/socket-storage/documentService' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import { IAuthenticatedUser } from "prague/core-utils";
    import { GitManager } from "prague/git-storage";
    export class DocumentResource implements api.IDocumentResource {
            documentId: string;
            user: IAuthenticatedUser;
            clientId: string;
            existing: boolean;
            version: resources.ICommit;
            parentBranch: string;
            deltaConnection: api.IDocumentDeltaConnection;
            documentStorageService: api.IDocumentStorageService;
            deltaStorageService: api.IDocumentDeltaStorageService;
            distributedObjects: api.IDistributedObject[];
            pendingDeltas: api.ISequencedDocumentMessage[];
            transformedMessages: api.ISequencedDocumentMessage[];
            snapshotOriginBranch: string;
            sequenceNumber: number;
            minimumSequenceNumber: number;
            tree: api.ISnapshotTree;
            constructor(documentId: string, user: IAuthenticatedUser, clientId: string, existing: boolean, version: resources.ICommit, parentBranch: string, deltaConnection: api.IDocumentDeltaConnection, documentStorageService: api.IDocumentStorageService, deltaStorageService: api.IDocumentDeltaStorageService, distributedObjects: api.IDistributedObject[], pendingDeltas: api.ISequencedDocumentMessage[], transformedMessages: api.ISequencedDocumentMessage[], snapshotOriginBranch: string, sequenceNumber: number, minimumSequenceNumber: number, tree: api.ISnapshotTree);
    }
    /**
        * The DocumentService manages the Socket.IO connection and manages routing requests to connected
        * clients
        */
    export class DocumentService implements api.IDocumentService {
            constructor(url: string, deltaStorage: api.IDeltaStorageService, blobStorge: api.IBlobStorageService, gitManager: GitManager);
            connect(id: string, version: resources.ICommit, connect: boolean, encrypted: boolean, token?: string): Promise<api.IDocumentResource>;
            branch(id: string): Promise<string>;
            /**
                * Emits a message on the socket
                */
            emit(event: string, ...args: any[]): void;
            /**
                * Registers the given connection to receive events of the given type
                */
            registerForEvent(event: string, connection: api.IDocumentDeltaConnection): void;
    }
}

declare module 'prague/socket-storage/blobStorageService' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    import * as gitStorage from "prague/git-storage";
    /**
        * Document access to underlying storage
        */
    export class DocumentStorageService implements api.IDocumentStorageService {
            constructor(id: string, version: resources.ICommit, storage: api.IBlobStorageService);
            read(sha: string): Promise<string>;
            write(tree: api.ITree, message: string): Promise<resources.ICommit>;
    }
    /**
        * Client side access to object storage.
        */
    export class BlobStorageService implements api.IBlobStorageService {
            constructor(manager: gitStorage.GitManager);
            getSnapshotTree(id: string, version: resources.ICommit): Promise<api.ISnapshotTree>;
            read(sha: string): Promise<string>;
            write(id: string, tree: api.ITree, message: string): Promise<resources.ICommit>;
    }
}

declare module 'prague/socket-storage/registration' {
    import { IDocumentService } from "prague/api-core";
    export function createDocumentService(deltaUrl: string, gitUrl: string, owner: string, repository: string, disableCache?: boolean, historianApi?: boolean, credentials?: any): IDocumentService;
    export function registerAsDefault(deltaUrl: string, gitUrl: string, owner: string, repository: string, disableCache?: boolean, historianApi?: boolean, credentials?: any): void;
}

declare module 'prague/git-storage' {
    export * from "prague/git-storage/gitManager";
}

declare module 'prague/map/definitions' {
    /**
      * Description of a map delta operation
      */
    export interface IMapOperation {
        type: string;
        key?: string;
        value?: IMapValue;
    }
    export enum ValueType {
        Collaborative = 0,
        Plain = 1,
        Counter = 2,
        Set = 3,
    }
    export interface IMapValue {
        type: string;
        value: any;
    }
    export interface IMapDataCompatibility {
        data: IMapValue;
        reject: Promise<any>;
    }
}

declare module 'prague/merge-tree/base' {
    export interface Property<TKey, TData> {
        key: TKey;
        data: TData;
    }
    export interface PropertyAction<TKey, TData> {
        <TAccum>(p: Property<TKey, TData>, accum?: TAccum): boolean;
    }
    export interface ConflictAction<TKey, TData> {
        (key: TKey, current: TData, proposed: TData): TData;
    }
    export interface Dictionary<TKey, TData> {
        get(key: TKey): Property<TKey, TData>;
        put(key: TKey, data: TData, conflict?: ConflictAction<TKey, TData>): any;
        remove(key: TKey): any;
        map<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum): any;
        diag(): any;
    }
    export interface SortedDictionary<TKey, TData> extends Dictionary<TKey, TData> {
        max(): Property<TKey, TData>;
        min(): Property<TKey, TData>;
        mapRange<TAccum>(action: PropertyAction<TKey, TData>, accum?: TAccum, start?: TKey, end?: TKey): any;
    }
    export interface KeyComparer<TKey> {
        (a: TKey, b: TKey): number;
    }
    /**
      * A range [start, end)
      */
    export interface IRange {
        start: number;
        end: number;
    }
}

declare module 'prague/merge-tree/index' {
    import * as Collections from "prague/merge-tree/collections";
    export { Collections };
    export * from "prague/merge-tree/extension";
    export * from "prague/merge-tree/mergeTree";
    export * from "prague/merge-tree/ops";
    export * from "prague/merge-tree/sharedString";
    export * from "prague/merge-tree/properties";
    export { loadSegments } from "prague/merge-tree/text";
}

declare module 'prague/git-storage/gitManager' {
    import * as resources from "gitresources";
    import * as api from "prague/api-core";
    export function buildHierarchy(flatTree: resources.ITree): api.ISnapshotTree;
    export class GitManager {
            endpoint: string;
            constructor(historian: resources.IHistorian, endpoint: string, owner: string, repository: string);
            getHeader(id: string, sha: string): Promise<api.ISnapshotTree>;
            getCommit(sha: string): Promise<resources.ICommit>;
            /**
                * Reads the object with the given ID. We defer to the client implementation to do the actual read.
                */
            getCommits(sha: string, count: number): Promise<resources.ICommitDetails[]>;
            /**
                * Reads the object with the given ID. We defer to the client implementation to do the actual read.
                */
            getTree(root: string, recursive?: boolean): Promise<resources.ITree>;
            getBlob(sha: string): Promise<resources.IBlob>;
            /**
                * Retrieves the object at the given revision number
                */
            getContent(commit: string, path: string): Promise<resources.IBlob>;
            createBlob(content: string, encoding: string): Promise<resources.ICreateBlobResponse>;
            createTree(files: api.ITree): Promise<resources.ITree>;
            createCommit(commit: resources.ICreateCommitParams): Promise<resources.ICommit>;
            getRef(ref: string): Promise<resources.IRef>;
            createRef(branch: string, sha: string): Promise<resources.IRef>;
            upsertRef(branch: string, commitSha: string): Promise<resources.IRef>;
            /**
                * Writes to the object with the given ID
                */
            write(branch: string, inputTree: api.ITree, message: string): Promise<resources.ICommit>;
    }
    export function getOrCreateRepository(historian: resources.IHistorian, endpoint: string, owner: string, repository: string): Promise<GitManager>;
}

