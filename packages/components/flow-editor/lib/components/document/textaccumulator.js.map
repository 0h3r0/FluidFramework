{"version":3,"file":"textaccumulator.js","sourceRoot":"","sources":["../../../src/components/document/textaccumulator.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAC;AACpD,OAAO,EAAY,WAAW,EAAE,MAAM,oBAAoB,CAAC;AAE3D;;;GAGG;AACH,MAAM,OAAO,eAAe;IAWxB,YAAY,QAAgB,EAAE,KAAkB,EAAE,WAAmB,EAAE,iBAAyB;QAThF,aAAQ,GAAkB,EAAE,CAAC;QAG7C,yCAAyC;QACjC,UAAK,GAAG,EAAE,CAAC;QAEnB,yCAAyC;QACjC,kBAAa,GAAG,GAAG,CAAC;QASZ,cAAS,GAAG,CAAC,QAAgB,EAAE,OAAiB,EAAE,mBAA2B,EAAE,iBAAyB,EAAE,EAAE;YACxH,OAAO,CAAC,MAAM,CAAC,QAAQ,KAAK,IAAI,CAAC,aAAa,CAAC,CAAC;YAEhD,uDAAuD;YACvD,IAAI,CAAC,CAAC,OAAO,YAAY,WAAW,CAAC,EAAE;gBACnC,OAAO,KAAK,CAAC;aAChB;YAED,6FAA6F;YAC7F,IAAI,QAAQ,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;gBAClC,OAAO,KAAK,CAAC;aAChB;YAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAE5B,oGAAoG;YACpG,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,mBAAmB,CAAC,CAAC;YACrD,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACnE,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;YACzD,IAAI,CAAC,aAAa,GAAG,QAAQ,GAAG,SAAS,CAAC;YAC1C,OAAO,IAAI,CAAC;QAChB,CAAC,CAAA;QA3BG,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC7B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAQ,GAAG,WAAW,CAAC,CAAC;QAChE,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC9B,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,iBAAiB,CAAC,CAAC;IACpE,CAAC;IAyBD,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACxC,IAAW,YAAY,KAAK,OAAO,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;CAC3D","sourcesContent":["import { getStyle } from \"@chaincode/flow-document\";\r\nimport { ISegment, TextSegment } from \"@prague/merge-tree\";\r\n\r\n/**\r\n * Used by the DocumentView to concatenate adjacent text segments that share the same style.  These should be\r\n * rendered using a single <span> element to preserve kerning & ligatures.\r\n */\r\nexport class TextAccumulator {\r\n    public readonly style: CSSStyleDeclaration;\r\n    public readonly segments: TextSegment[] = [];\r\n    public readonly startPosition: number;\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    private _text = \"\";\r\n\r\n    // tslint:disable-next-line:variable-name\r\n    private _nextPosition = NaN;\r\n\r\n    constructor(position: number, first: TextSegment, startOffset: number, relativeEndOffset: number) {\r\n        this.style = getStyle(first);\r\n        this.startPosition = Math.max(position, position + startOffset);\r\n        this._nextPosition = position;\r\n        this.tryConcat(position, first, startOffset, relativeEndOffset);\r\n    }\r\n\r\n    public readonly tryConcat = (position: number, segment: ISegment, relativeStartOffset: number, relativeEndOffset: number) => {\r\n        console.assert(position === this._nextPosition);\r\n\r\n        // Terminate if the next segment is not a text segment.\r\n        if (!(segment instanceof TextSegment)) {\r\n            return false;\r\n        }\r\n\r\n        // Terminate if the next text segment uses a different style (i.e., needs a separate <span>.)\r\n        if (getStyle(segment) !== this.style) {\r\n            return false;\r\n        }\r\n\r\n        this.segments.push(segment);\r\n\r\n        // Clamp the relative start/end offsets to the range of offsets included in the current TextSegment.\r\n        const startOffset = Math.max(0, relativeStartOffset);\r\n        const endOffset = Math.min(relativeEndOffset, segment.text.length);\r\n        this._text += segment.text.slice(startOffset, endOffset);\r\n        this._nextPosition = position + endOffset;\r\n        return true;\r\n    }\r\n\r\n    public get text() { return this._text; }\r\n    public get nextPosition() { return this._nextPosition; }\r\n}\r\n"]}