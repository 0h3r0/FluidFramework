{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/components/document/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocSegmentKind, FlowDocument, getDocSegmentKind, getInclusionHtml, getInclusionKind, InclusionKind } from \"@chaincode/flow-document\";\r\nimport { Dom, Template } from \"@prague/flow-util\";\r\nimport {\r\n    ISegment,\r\n    Marker,\r\n    TextSegment,\r\n} from \"@prague/merge-tree\";\r\nimport { IFlowViewComponent, IViewState, View } from \"../\";\r\nimport { debug } from \"../../debug\";\r\nimport { InclusionView } from \"../inclusion\";\r\nimport { LineBreakView } from \"../linebreak\";\r\nimport { ParagraphView } from \"../paragraph\";\r\nimport { TextView } from \"../text\";\r\nimport * as styles from \"./index.css\";\r\nimport { Paginator } from \"./paginator\";\r\nimport { TextAccumulator } from \"./textaccumulator\";\r\n\r\nconst template = new Template({\r\n    tag: \"span\",\r\n    props: { tabIndex: 0, className: styles.document },\r\n    children: [\r\n        { tag: \"span\", ref: \"leadingSpan\", props: { className: styles.leadingSpan }},\r\n        { tag: \"span\", ref: \"slot\", props: { className: styles.documentContent }},\r\n        { tag: \"span\", ref: \"trailingSpan\", props: { className: styles.trailingSpan }},\r\n        { tag: \"span\", ref: \"overlay\", props: { className: styles.documentOverlay }},\r\n    ],\r\n});\r\n\r\n/**\r\n * A position in the FlowDocument and a callback to be invoked with the DOM node\r\n * and offset within the dom node where that position is rendered.\r\n */\r\nexport interface ITrackedPosition {\r\n    position: number;\r\n    callback: (node: Node, nodeOffset: number) => void;\r\n}\r\n\r\n/**\r\n * The state to be visualized/edited by the DocumentView.\r\n */\r\nexport interface IDocumentProps {\r\n    doc: FlowDocument;\r\n    trackedPositions: ITrackedPosition[];\r\n    paginator?: Paginator;\r\n}\r\n\r\n/**\r\n * The state that is calculated/cached for each segment within the currently rendered\r\n * window.\r\n */\r\nexport interface IViewInfo<TProps, TView extends IFlowViewComponent<TProps>> {\r\n    /**\r\n     * The document-ordered list of segments visualized by the cached 'view' instance.\r\n     * (Currently, only TextSegments are combined into a single view/element.  Other segment\r\n     * types are 1:1.)\r\n     */\r\n    segments: ISegment[];\r\n\r\n    // The IView instance that rendered this set of segments.\r\n    view: TView;\r\n\r\n    // Cached ClientRects that bound this view.\r\n    clientRects?: ClientRectList | DOMRectList;\r\n}\r\n\r\ninterface IRect { top: number; bottom: number; left: number; right: number; }\r\ntype FindVerticalPredicate = (top: number, bottom: number, best: IRect, candidate: IRect) => boolean;\r\n\r\n/**\r\n * The state maintained by the DocumentView instance.\r\n */\r\ninterface IDocumentViewState extends IViewState {\r\n    // The root element into which segments are rendered.\r\n    slot: HTMLElement;\r\n\r\n    // The root element into which overlays are attached.\r\n    overlay: Element;\r\n\r\n    // Leading span\r\n    leadingSpan: Element;\r\n    trailingSpan: Element;\r\n\r\n    /**\r\n     * Mapping from segments to their IViewInfo, if the segment is currently within the rendered window.\r\n     * Note that when a range of segments are rendered by a single view (as is the case with TextSegments\r\n     * that share the same style), only the first segment in the range appears in this map.\r\n     */\r\n    segmentToViewInfo: Map<ISegment, IViewInfo<any, IFlowViewComponent<any>>>;\r\n\r\n    /**\r\n     * Mapping from the root element produced by an IView to it's IViewInfo.\r\n     */\r\n    elementToViewInfo: Map<Element, IViewInfo<any, IFlowViewComponent<any>>>;\r\n}\r\n\r\n// IView that renders a FlowDocument.\r\nexport class DocumentView extends View<IDocumentProps, IDocumentViewState> {\r\n\r\n    public  get root()       { return this.state.root; }\r\n    public  get overlay()    { return this.state.overlay; }\r\n\r\n    private static readonly findBelowPredicate: FindVerticalPredicate =\r\n        (top, bottom, best, candidate) => {\r\n            return candidate.top > top              // disqualify rects higher/same original height\r\n                && candidate.top <= best.top;       // disqualify rects lower than best match\r\n        }\r\n\r\n    private static readonly findAbovePredicate: FindVerticalPredicate =\r\n        (top, bottom, best, candidate) => {\r\n            return candidate.bottom < bottom        // disqualify rects lower/same as starting point\r\n                && candidate.bottom >= best.bottom; // disqualify rects higher than best match\r\n        }\r\n\r\n    // Returns the { segment, offset } currently visible at the given x/y coordinates (if any).\r\n    public hitTest(x: number, y: number) {\r\n        const range = document.caretRangeFromPoint(x, y);\r\n        const segmentAndOffset = this.nodeOffsetToSegmentOffset(range.startContainer, range.startOffset);\r\n        debug(`  (${x},${y}) -> \"${range.startContainer.textContent}\":${range.startOffset} -> ${\r\n            segmentAndOffset\r\n                ? `${(segmentAndOffset.segment as TextSegment).text}:${segmentAndOffset.offset}`\r\n                : `undefined`}`);\r\n        return segmentAndOffset;\r\n    }\r\n\r\n    /**\r\n     * Returns the closest { segment, offset } below the text cursor occupying the 0-width rect\r\n     * described by x/top/bottom.\r\n     */\r\n    public readonly findBelow = (x: number, top: number, bottom: number) => {\r\n        return this.findVertical(x, top, bottom, DocumentView.findBelowPredicate);\r\n    }\r\n\r\n    /**\r\n     * Returns the closest { segment, offset } below the text cursor occupying the 0-width rect\r\n     * described by x/top/bottom.\r\n     */\r\n    public readonly findAbove = (x: number, top: number, bottom: number) => {\r\n        return this.findVertical(x, top, bottom, DocumentView.findAbovePredicate);\r\n    }\r\n    protected mounting(props: IDocumentProps) {\r\n        const root = template.clone();\r\n        const leadingSpan = template.get(root, \"leadingSpan\");\r\n        const slot = template.get(root, \"slot\") as HTMLElement;\r\n        const overlay = template.get(root, \"overlay\");\r\n        const trailingSpan = template.get(root, \"trailingSpan\");\r\n\r\n        return this.updating(props, {\r\n            root,\r\n            slot,\r\n            leadingSpan,\r\n            trailingSpan,\r\n            overlay,\r\n            segmentToViewInfo: new Map<ISegment, IViewInfo<any, IFlowViewComponent<any>>>(),\r\n            elementToViewInfo: new Map<Element, IViewInfo<any, IFlowViewComponent<any>>>(),\r\n        });\r\n    }\r\n\r\n    protected updating(props: Readonly<IDocumentProps>, state: Readonly<IDocumentViewState>) {\r\n        const originalTrackedPositions = props.trackedPositions;\r\n        const trackedPositions = originalTrackedPositions.slice(0).concat(\r\n            (props.paginator && props.paginator.trackedPositions) || []);\r\n\r\n        Object.assign(props, { trackedPositions: [] });\r\n        DocumentLayout.sync(props, state);\r\n\r\n        // 2nd pass does not mutate DOM.\r\n        Object.assign(props, { trackedPositions });\r\n        DocumentLayout.sync(props, state);\r\n\r\n        Object.assign(props, { trackedPositions: originalTrackedPositions });\r\n\r\n        return state;\r\n    }\r\n\r\n    protected unmounting() { /* do nothing */ }\r\n\r\n    // Map a node/nodeOffset to the corresponding segment/segmentOffset that rendered it.\r\n    private nodeOffsetToSegmentOffset(node: Node | null, nodeOffset: number) {\r\n        const state = this.state;\r\n        let viewInfo: IViewInfo<any, IFlowViewComponent<any>> | undefined;\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        while (node && !(viewInfo = state.elementToViewInfo.get(node as Element))) {\r\n            node = node.parentElement;\r\n        }\r\n\r\n        if (!viewInfo) {\r\n            return undefined;\r\n        }\r\n\r\n        let segment: ISegment | undefined;\r\n        for (segment of viewInfo.segments) {\r\n            if (nodeOffset < segment.cachedLength) {\r\n                return { segment, offset: nodeOffset };\r\n            }\r\n            nodeOffset -= segment.cachedLength;\r\n        }\r\n\r\n        return segment && { segment, offset: segment.cachedLength };\r\n    }\r\n\r\n    // Returns the closest { segment, offset } to the 0-width rect described by x/top/bottom.\r\n    private findDomPosition(node: Node, x: number, yMin: number, yMax: number) {\r\n        // Note: Attempting to hit test using 'caretRangeFromPoint()' against a reported client rect's top/bottom\r\n        //       produced inconsistent results, presumably due to internal fixed-point -> Float32 rounding discrepancies.\r\n        //\r\n        // Reported edge: 487.99713134765625\r\n        //\r\n        // Boundary case: 487.999999999999971578290569595992 (miss)\r\n        //                487.999999999999971578290569595993 (hit)\r\n\r\n        // Note: Caller must pass a 'node' that was previously rendered for a TextSegment.\r\n        const domRange = document.createRange();\r\n        let left = 0;\r\n        let right = node.textContent!.length;\r\n\r\n        while (left < right) {\r\n            // tslint:disable-next-line:no-bitwise\r\n            const m = (left + right) >>> 1;\r\n            domRange.setStart(node, m);\r\n            domRange.setEnd(node, m);\r\n\r\n            // Note: On Safari 12, 'domRange.getBoundingClientRect()' returns an empty rectangle when domRange start === end.\r\n            //       However, 'getClientRects()' for the same range returns the expected 0-width rect.\r\n            const bounds = domRange.getClientRects()[0];\r\n            const cy = (bounds.top + bounds.bottom) / 2;\r\n            if ((cy < yMin)                                     // Current position is above our target rect.\r\n                || (cy < yMax && bounds.left < x)) {            // Current position is within our desired y range.\r\n                left = m + 1;\r\n            } else {\r\n                right = m;\r\n            }\r\n        }\r\n\r\n        return this.nodeOffsetToSegmentOffset(node, left);\r\n    }\r\n\r\n    // Get the ClientRects that define the boundary of the given 'element', using cached information if we have it.\r\n    private getClientRects(element: Element) {\r\n        // Note: Caller must only request clientRects for elements we've previously rendered.\r\n        const state = this.state;\r\n        const viewInfo = state.elementToViewInfo.get(element)!;\r\n        if (!viewInfo.clientRects) {\r\n            viewInfo.clientRects = element.getClientRects();\r\n        }\r\n        return viewInfo.clientRects;\r\n    }\r\n\r\n    /**\r\n     * Returns the closest { segment, offset } below the text cursor occupying the 0-width rect\r\n     * described by x/top/bottom.\r\n     */\r\n    private findVertical(x: number, top: number, bottom: number, predicate: FindVerticalPredicate) {\r\n        debug(`looking below: ${bottom}`);\r\n\r\n        const state = this.state;\r\n        let bestRect = { top: +Infinity, bottom: -Infinity, left: +Infinity, right: -Infinity };\r\n        let bestDx = +Infinity;\r\n        let bestViewInfo: IViewInfo<any, IFlowViewComponent<any>> | undefined;\r\n\r\n        for (const viewInfo of state.elementToViewInfo.values()) {\r\n            // TODO: Better filter for potential cursor targets?\r\n            if (!(viewInfo.view instanceof TextView)) {\r\n                continue;\r\n            }\r\n\r\n            const view = viewInfo.view;\r\n            const node = view.root;\r\n            const rects = this.getClientRects(node);\r\n            debug(`rects: ${rects.length} for ${node.textContent}`);\r\n\r\n            for (const rect of rects) {\r\n                debug(`    ${JSON.stringify(rect)}`);\r\n                if (!predicate(top, bottom, bestRect, rect)) {\r\n                    continue;\r\n                }\r\n\r\n                // Disqualify the new rect if its horizontal distance is greater than the best match\r\n                const dx = Math.max(rect.left - x, 0, x - rect.right);\r\n                if (dx > bestDx) {\r\n                    debug(`        Rejected dx (${dx} > ${bestDx})`);\r\n                    continue;\r\n                }\r\n\r\n                bestRect = rect;\r\n                bestDx = dx;\r\n                bestViewInfo = viewInfo;\r\n                debug(`    ==> Best candidate: ${bestViewInfo.view.root.id}: ${bestViewInfo.view.root.textContent}`);\r\n            }\r\n        }\r\n\r\n        if (!bestViewInfo) {\r\n            debug(`No best candidate found.`);\r\n            return undefined;\r\n        }\r\n\r\n        debug(`Best candidate: ${bestViewInfo.view.root.id}: ${bestViewInfo.view.root.textContent}`);\r\n        debug(`    rect: ${JSON.stringify(bestRect)}`);\r\n\r\n        return this.findDomPosition(\r\n            LayoutContext.getCursorTarget(bestViewInfo.view),\r\n            Math.min(Math.max(x, bestRect.left), bestRect.right),\r\n            bestRect.top, bestRect.bottom);\r\n    }\r\n}\r\n\r\n// Holds ephemeral state used during layout calculations.\r\nclass LayoutContext {\r\n\r\n    // The next tracked position we're looking for.\r\n    private get nextTrackedPosition() {\r\n        return this.pendingTrackedPositions[this.pendingTrackedPositions.length - 1];\r\n    }\r\n\r\n    public get currentInline() { return this._currentInline; }\r\n\r\n    /**\r\n     * Returns the given view's designated cursor target, if any.  This is the node within the view that\r\n     * should receive the text caret.\r\n     */\r\n    public static getCursorTarget<TProps>(view: IFlowViewComponent<TProps>): Node {\r\n        return (view as any).cursorTarget;\r\n    }\r\n    /**\r\n     * Sorted stack of tracked position we're still looking for.  Positions are popped from\r\n     * the stack as the consumers are notified.\r\n     */\r\n    private readonly pendingTrackedPositions: ITrackedPosition[];\r\n\r\n    /**\r\n     * Set of Elements that were previously rendered that have not yet been encountered by\r\n     * this layout pass.  At the end of the layout pass, any remaining elements are unmounted\r\n     * as they are no longer within the rendered window.\r\n     */\r\n    private readonly pendingLayout: Set<Element>;\r\n\r\n    // The IViewInfo for the last rendered inline view.\r\n    // tslint:disable-next-line:variable-name\r\n    private _currentInline: IViewInfo<any, IFlowViewComponent<any>> | null = null;\r\n\r\n    constructor(readonly doc: FlowDocument, readonly state: IDocumentViewState, public root: Element, trackedPositions: ITrackedPosition[]) {\r\n        // Initialize 'pendingTrackedPositions' by copying and sorting the tracked positions.\r\n        this.pendingTrackedPositions = trackedPositions\r\n            .slice(0)\r\n            .sort((left, right) => right.position - left.position);\r\n\r\n        // Initialize 'pendingLayout' with the set of root elements rendered in the last layout pass.\r\n        this.pendingLayout = new Set<Element>(state.elementToViewInfo.keys());\r\n    }\r\n\r\n    /**\r\n     * Invoked for each DOM node we emit.  Position is the starting position rendered by the current IView.\r\n     */\r\n    public notifyTrackedPositionListeners(node: Node, position: number, segments: Array<{ cachedLength: number }>) {\r\n        const trackedPositions = this.pendingTrackedPositions;\r\n        let topTracked: ITrackedPosition;\r\n\r\n        // Notify listeners if we've advanced past a tracked position without intersecting it (e.g., the\r\n        // tracked position is above the rendered window.)  In this case, the calculated position will be\r\n        // negative.\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        while ((topTracked = this.nextTrackedPosition) && topTracked.position < position) {\r\n            trackedPositions.pop()!.callback(node, topTracked.position - position);\r\n        }\r\n\r\n        // Notify listeners if any of the consumed segments intersected a tracked position.\r\n        let end = position;\r\n        for (const segment of segments) {\r\n            end += segment.cachedLength;\r\n            // tslint:disable-next-line:no-conditional-assignment\r\n            while ((topTracked = this.nextTrackedPosition) && position <= topTracked.position && topTracked.position < end) {\r\n                // Note: Pop() cannot return 'undefined' per the condition 'topTracked !== undefined' above.\r\n                trackedPositions.pop()!.callback(node, topTracked.position - position);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Invoked at completion of the layout pass to unmount all IViews that are no longer in the rendered window.\r\n    public unmount() {\r\n        for (const toUnmount of this.pendingLayout) {\r\n            const toUnmountInfo = this.elementToViewInfo(toUnmount)!;\r\n            this.state.elementToViewInfo.delete(toUnmount);\r\n            toUnmount.remove();\r\n            toUnmountInfo.view.unmount();\r\n        }\r\n\r\n        this.pendingLayout.clear();\r\n\r\n        // Rebuild the segment -> ViewInfo map from the remaining visible elements.\r\n        this.state.segmentToViewInfo = new Map<ISegment, IViewInfo<any, IFlowViewComponent<any>>>(\r\n            [...this.state.elementToViewInfo.values()].map<[ISegment, IViewInfo<any, IFlowViewComponent<any>>]>(\r\n                (viewInfo) => [viewInfo.segments[0], viewInfo]));\r\n    }\r\n\r\n    public elementToViewInfo(element: Element) { return this.state.elementToViewInfo.get(element); }\r\n\r\n    /**\r\n     * If the given 'segment' is at the head of a list of previously rendered segments, return it's\r\n     * cached ViewInfo and remove that IView from the pendingLayout list.\r\n     */\r\n    public maybeReuseViewInfo<TProps, TView extends IFlowViewComponent<TProps>>(segment: ISegment) {\r\n        const viewInfo = this.state.segmentToViewInfo.get(segment);\r\n        if (viewInfo) {\r\n            this.pendingLayout.delete(viewInfo.view.root);\r\n        }\r\n        return viewInfo as IViewInfo<TProps, TView>;\r\n    }\r\n\r\n    public setCurrentInline<TProps>(viewInfo: IViewInfo<TProps, IFlowViewComponent<TProps>>) {\r\n        this._currentInline = viewInfo;\r\n        return viewInfo;\r\n    }\r\n\r\n    public setViewInfo<TProps, TView extends IFlowViewComponent<TProps>>(viewInfo: IViewInfo<TProps, TView>) {\r\n        this.state.segmentToViewInfo.set(viewInfo.segments[0], viewInfo);\r\n        this.state.elementToViewInfo.set(viewInfo.view.root, viewInfo);\r\n        return viewInfo;\r\n    }\r\n}\r\n\r\n// State machine that synchronizes the DOM with the visible portion of the FlowDocument.\r\nexport class DocumentLayout {\r\n\r\n    // Runs state machine, starting with the paragraph at 'start'.\r\n    public static sync(props: IDocumentProps, state: IDocumentViewState) {\r\n        const paginator = props.paginator;\r\n        const desiredStart = paginator ? paginator.startPosition : 0;\r\n        let start = paginator ? paginator.startingBlockPosition : 0;\r\n\r\n        debug(`Sync(${desiredStart}): [${start}..?)`);\r\n\r\n        const context = new LayoutContext(\r\n            props.doc,\r\n            state,\r\n            state.slot,\r\n            props.trackedPositions);\r\n\r\n        do {\r\n            // Ensure that we exit the outer do..while loop if there are no remaining segments.\r\n            let nextStart = -1;\r\n\r\n            context.doc.visitRange((position, segment, startOffset, endOffset) => {\r\n                nextStart = this.syncSegment(context, position, segment, startOffset, endOffset);\r\n\r\n                // TODO: Halt synchronization once we're off-screen.\r\n\r\n                // If the 'syncSegment' returned '-1', proceed to the next segment (if any).\r\n                // Otherwise break to the outer 'do..while' loop and we'll restart at the returned\r\n                // 'next' position.\r\n                return nextStart < 0;\r\n            }, start);\r\n\r\n            start = nextStart;\r\n        } while (start >= 0);\r\n\r\n        // Notify listeners whose tracked positions were after our rendered window.\r\n        context.notifyTrackedPositionListeners(LayoutContext.getCursorTarget(context.currentInline!.view)!, +Infinity, []);\r\n\r\n        // Any nodes not re-used from the previous layout are unmounted and removed.\r\n        context.unmount();\r\n    }\r\n\r\n    private static readonly inclusionRootSym = Symbol(\"Flow.Editor.Marker.InclusionRoot\");\r\n    private static mountView<TProps, TView extends IFlowViewComponent<TProps>>(\r\n        context: LayoutContext,\r\n        segments: ISegment[],\r\n        factory: () => TView,\r\n        props: TProps): IViewInfo<TProps, TView> {\r\n        const view = factory();\r\n        view.mount(props);\r\n\r\n        return context.setViewInfo({\r\n            view,\r\n            segments,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Ensure that the IView for the given set of Segments has been created and that it's root DOM node\r\n     * is at the correct position within the current parent.\r\n     */\r\n    private static syncNode<TProps, TView extends IFlowViewComponent<TProps>>(\r\n        context: LayoutContext,\r\n        previous: Node | null,\r\n        segments: ISegment[],\r\n        factory: () => TView,\r\n        props: TProps): IViewInfo<TProps, TView> {\r\n        const parent = context.root;\r\n\r\n        // TODO: Check all non-head segments to look for best match?\r\n        let viewInfo = context.maybeReuseViewInfo<TProps, TView>(segments[0]);\r\n        if (!viewInfo) {\r\n            // Segment was not previously in the rendered window.  Create it.\r\n            viewInfo = this.mountView(context, segments, factory, props);\r\n\r\n            // Insert the node for the new segment after the previous block.\r\n            Dom.insertAfter(parent, viewInfo.view.root, previous);\r\n        } else {\r\n            viewInfo.segments = segments;\r\n            const view = viewInfo.view;\r\n            view.update(props);\r\n\r\n            const node = viewInfo.view.root;\r\n\r\n            // The node was previously inside the rendered window.  See if it is already in the correct location.\r\n            if (!Dom.isAfterNode(parent, node, previous)) {\r\n                // The node is not in the correct position.  Move it.\r\n                //\r\n                // TODO: Sometimes we have a choice if we move the cached node or the one already residing in the\r\n                //       expected position.  We should prefer to move nodes known not to have side effects (i.e.,\r\n                //       do not move inclusion if possible, and never move the node containing focus.)\r\n                Dom.insertAfter(parent, node, previous);\r\n            }\r\n\r\n            // Client bounds have possibly changed.  Clear cached client rects (if any).\r\n            viewInfo.clientRects = undefined;\r\n        }\r\n\r\n        return viewInfo;\r\n    }\r\n\r\n    // Ensures that the given inline 'view' is mounted and up to date.\r\n    private static syncInline<TProps, TView extends IFlowViewComponent<TProps>>(context: LayoutContext, position: number, segments: ISegment[], factory: () => TView, props: TProps) {\r\n        const viewInfo = context.setCurrentInline(\r\n            this.syncNode<TProps, TView>(\r\n                context,\r\n                context.currentInline && context.currentInline.view.root!,\r\n                segments,\r\n                factory,\r\n                props));\r\n\r\n        const maybeCursorTarget = LayoutContext.getCursorTarget(viewInfo.view);\r\n        context.notifyTrackedPositionListeners(maybeCursorTarget || viewInfo.view.root, position, segments);\r\n    }\r\n\r\n    // Ensures that the paragraph's view is mounted and up to date.\r\n    private static syncParagraph(context: LayoutContext, position: number, marker: Marker) {\r\n        this.syncInline(context, position, [ marker ], ParagraphView.factory, {});\r\n    }\r\n\r\n    // Ensures that the lineBreak's view is mounted and up to date.\r\n    private static syncLineBreak(context: LayoutContext, position: number, marker: Marker) {\r\n        this.syncInline(context, position, [ marker ], LineBreakView.factory, {});\r\n    }\r\n\r\n    // Ensures that the text's view is mounted and up to date.\r\n    private static syncText(context: LayoutContext, position: number, segments: ISegment[], text: string) {\r\n       this.syncInline(context, position, segments, TextView.factory, { text });\r\n    }\r\n\r\n    // Ensures that a foreign inclusion's view is mounted and up to date.\r\n    private static syncInclusion(context: LayoutContext, position: number, marker: Marker) {\r\n        let child: HTMLElement;\r\n        const kind = getInclusionKind(marker);\r\n\r\n        child = (marker.properties as any)[this.inclusionRootSym];\r\n        if (!child) {\r\n            switch (kind) {\r\n                case InclusionKind.HTML:\r\n                    child = getInclusionHtml(marker);\r\n                    break;\r\n\r\n                case InclusionKind.Component:\r\n                    child = document.createElement(\"span\");\r\n                    context.doc.getInclusionContainerComponent(marker, [[\"div\", Promise.resolve(child)]]);\r\n                    break;\r\n\r\n                default:\r\n                    console.assert(kind === InclusionKind.Chaincode);\r\n                    child = document.createElement(\"span\");\r\n                    context.doc.getInclusionComponent(marker, [[\"div\", Promise.resolve(child)]]);\r\n            }\r\n            (marker.properties as any)[this.inclusionRootSym] = child;\r\n        }\r\n\r\n        this.syncInline(context, position, [ marker ], InclusionView.factory, { child });\r\n    }\r\n\r\n    /**\r\n     * Finds the largest contiguous run of TextSegments that share the same style as 'first', starting at\r\n     * the given 'start' position and returns the concatenated text.\r\n     */\r\n    private static concatTextSegments(context: LayoutContext, position: number, first: TextSegment, relativeStartOffset: number, relativeEndOffset: number)\r\n        : { text: string, style: CSSStyleDeclaration, segments: TextSegment[], nextPosition: number, startPosition: number } {\r\n        const accumulator = new TextAccumulator(position, first, relativeStartOffset, relativeEndOffset);\r\n        context.doc.visitRange(accumulator.tryConcat, accumulator.nextPosition, position + relativeEndOffset);\r\n        return accumulator;\r\n    }\r\n\r\n    private static syncSegment(context: LayoutContext, position: number, segment: ISegment, start: number, end: number) {\r\n        const kind = getDocSegmentKind(segment);\r\n        switch (kind) {\r\n            case DocSegmentKind.Text:\r\n                const textInfo = this.concatTextSegments(context, position, segment as TextSegment, start, end);\r\n                this.syncText(context, textInfo.startPosition, textInfo.segments, textInfo.text);\r\n\r\n                // Note: We early exit here with the 'end' of the concatenated range of TextSegments.\r\n                //       This will cause the outer loop to skip to the next TextSegment we haven't yet\r\n                //       processed.  (TODO: Consider pushing/popping processors in the outer loop instead?)\r\n                return textInfo.nextPosition;\r\n\r\n            case DocSegmentKind.Paragraph:\r\n                this.syncParagraph(context, position, segment as Marker);\r\n                break;\r\n\r\n            case DocSegmentKind.LineBreak:\r\n                this.syncLineBreak(context, position, segment as Marker);\r\n                break;\r\n\r\n            case DocSegmentKind.Inclusion:\r\n                this.syncInclusion(context, position, segment as Marker);\r\n                break;\r\n\r\n            case DocSegmentKind.EOF:\r\n                this.syncText(context, position, [segment], \"\\u200B\");\r\n                break;\r\n\r\n            default:\r\n                throw new Error(`Unknown DocSegmentKind '${kind}'.`);\r\n        }\r\n\r\n        // By default, continue continue with the next segment.\r\n        return -1;\r\n    }\r\n}\r\n"]}